declare class BlockPos extends Vec3i {
    getClass(): Internal.Class<any>;
    wait(arg0: number, arg1: number): void;
    wait(): void;
    wait(arg0: number): void;
    getX(): number;
    getY(): number;
    getZ(): number;
    hashCode(): number;
    notifyAll(): void;
    equals(arg0: any): boolean;
    toString(): string;
    compareTo(arg0: Vec3i_): number;
    notify(): void;
    get x(): number;
    get y(): number;
    get z(): number;
    get class(): Internal.Class<any>;
    constructor(arg0: Vec3i);
    constructor(arg0: net.minecraft.core.Position);
    constructor(arg0: Vec3);
    constructor(arg0: number, arg1: number, arg2: number);
    constructor(arg0: number, arg1: number, arg2: number);
}
type BlockPos_ = BlockPos;
declare class Text {
    getClass(): Internal.Class<any>;
    wait(arg0: number, arg1: number): void;
    wait(): void;
    wait(arg0: number): void;
    static string(text: any): Internal.Text;
    notifyAll(): void;
    static yellow(text: any): Internal.Text;
    static darkBlue(text: any): Internal.Text;
    notify(): void;
    static translate(key: string, objects: any[]): Internal.Text;
    static translate(key: string): Internal.Text;
    static gold(text: any): Internal.Text;
    static red(text: any): Internal.Text;
    static aqua(text: any): Internal.Text;
    static gray(text: any): Internal.Text;
    static white(text: any): Internal.Text;
    hashCode(): number;
    static darkRed(text: any): Internal.Text;
    static of(object: any): Internal.Text;
    static darkPurple(text: any): Internal.Text;
    static join(separator: Internal.Text_, texts: Internal.Iterable_<Internal.Text_>): Internal.Text;
    static green(text: any): Internal.Text;
    static darkGreen(text: any): Internal.Text;
    static lightPurple(text: any): Internal.Text;
    static black(text: any): Internal.Text;
    static darkAqua(text: any): Internal.Text;
    static blue(text: any): Internal.Text;
    equals(arg0: any): boolean;
    static keybind(keybind: string): Internal.Text;
    static darkGray(text: any): Internal.Text;
    toString(): string;
    get class(): Internal.Class<any>;
    constructor();
}
type Text_ = Text;
declare interface Utils {
    static getSystemTime(): number;
    static listOrSelf(o: any): Internal.ListJS;
    static getStat(id: ResourceLocation_): Internal.Stat<ResourceLocation>;
    static parseDouble(object: any, def: number): number;
    static emptyList<T>(): Internal.List<T>;
    static getRandom(): Internal.Random;
    static randomOf(random: Internal.Random_, objects: Internal.Collection_<any>): any;
    static emptyMap<K, V>(): Internal.Map<K, V>;
    static copy(o: any): any;
    static id(namespace: string, path: string): ResourceLocation;
    static id(id: ResourceLocation_): ResourceLocation;
    static listOf(o: any): Internal.ListJS;
    static rollChestLoot(id: ResourceLocation_, entity: Internal.EntityJS_): Internal.ListJS;
    static rollChestLoot(id: ResourceLocation_): Internal.ListJS;
    static getServer(): Internal.ServerJS;
    static newCountingMap(): Internal.CountingMap;
    static createConsole(name: string): Internal.ConsoleJS;
    static newMap(): Internal.MapJS;
    static newList(): Internal.ListJS;
    static getClientLevel(): Internal.LevelJS;
    static parseInt(object: any, def: number): number;
    static getLevel(level: Internal.Level_): Internal.LevelJS;
    static isWrapped(o: any): boolean;
    static regex(s: any): Internal.Pattern;
    static regex(pattern: string, flags: number): Internal.Pattern;
    static newRandom(seed: number): Internal.Random;
    static queueIO(runnable: Internal.Runnable_): void;
    static toTitleCase(s: string): string;
    static mapOf(o: any): Internal.MapJS;
    static getSound(id: ResourceLocation_): Internal.SoundEvent;
}
type Utils_ = Utils;
declare const Utils: Utils;
declare interface AABB {
    static ofBlock(pos: BlockPos_): Internal.AABB;
    static ofSize(x: number, y: number, z: number): Internal.AABB;
    static ofSize(vec3: Vec3_, x: number, y: number, z: number): Internal.AABB;
    static of(x0: number, y0: number, z0: number, x1: number, y1: number, z1: number): Internal.AABB;
    static wrap(o: any): Internal.AABB;
    static ofBlocks(pos1: BlockPos_, pos2: BlockPos_): Internal.AABB;
    readonly CUBE : Internal.AABB;
    readonly EMPTY : Internal.AABB;
}
type AABB_ = AABB;
declare const AABB: AABB;
declare class Hand extends Internal.Enum<Hand> {
    getClass(): Internal.Class<any>;
    wait(arg0: number, arg1: number): void;
    wait(): void;
    wait(arg0: number): void;
    static valueOf(arg0: string): Hand;
    static valueOf<T_>(arg0: Internal.Class_<T_>, arg1: string): T_;
    notifyAll(): void;
    static values(): Hand[];
    compareTo(arg0: Hand_): number;
    describeConstable(): Internal.Optional<Internal.Enum$EnumDesc<Hand>>;
    notify(): void;
    getDeclaringClass(): Internal.Class<Hand>;
    hashCode(): number;
    equals(arg0: any): boolean;
    name(): string;
    toString(): string;
    ordinal(): number;
    static readonly MAIN_HAND : Hand;
    static readonly OFF_HAND : Hand;
    get class(): Internal.Class<any>;
    get declaringClass(): Internal.Class<Hand>;
}
type Hand_ = "main_hand" | "off_hand" | Hand;
declare class Vec3i implements Internal.Comparable<Vec3i> {
    getClass(): Internal.Class<any>;
    wait(arg0: number, arg1: number): void;
    wait(): void;
    wait(arg0: number): void;
    getX(): number;
    getY(): number;
    getZ(): number;
    hashCode(): number;
    notifyAll(): void;
    equals(arg0: any): boolean;
    toString(): string;
    compareTo(arg0: Vec3i_): number;
    notify(): void;
    get x(): number;
    get y(): number;
    get z(): number;
    get class(): Internal.Class<any>;
    constructor(arg0: number, arg1: number, arg2: number);
    constructor(arg0: number, arg1: number, arg2: number);
}
type Vec3i_ = Vec3i;
declare class MbdRecipeMap {
    getClass(): Internal.Class<any>;
    wait(arg0: number, arg1: number): void;
    wait(): void;
    wait(arg0: number): void;
    notifyAll(): void;
    start(): Internal.RecipeBuilder;
    searchRecipe(arg0: Internal.ICapabilityProxyHolder_): Internal.List<com.lowdragmc.multiblocked.api.recipe.Recipe>;
    allRecipes(): Internal.List<com.lowdragmc.multiblocked.api.recipe.Recipe>;
    getUnlocalizedName(): string;
    notify(): void;
    hasCapability(arg0: Internal.IO_, arg1: Internal.MultiblockCapability_<any>): boolean;
    addRecipe(arg0: com.lowdragmc.multiblocked.api.recipe.Recipe_): void;
    hashCode(): number;
    equals(arg0: any): boolean;
    getRecipe(arg0: string): com.lowdragmc.multiblocked.api.recipe.Recipe;
    toString(): string;
    copy(): MbdRecipeMap;
    static registerRecipeFromFile(arg0: Internal.Gson_, arg1: Internal.File_): void;
    static register(arg0: MbdRecipeMap_): void;
    outputCapabilities : Internal.Set<Internal.MultiblockCapability<any>>;
    recipes : Internal.HashMap<string, com.lowdragmc.multiblocked.api.recipe.Recipe>;
    static readonly RECIPE_MAP_REGISTRY : {"329943bb-1ecf-4ade-ba92-89804d846bd4":MbdRecipeMap,"5a0d35c6-d8ac-4e28-8771-f3ca4010b360":MbdRecipeMap,"8e0bd440-e2eb-4353-84b4-0231af413ee9":MbdRecipeMap,"457f91cb-2402-4b1b-a90d-47f6a8301b65":MbdRecipeMap,"empty":MbdRecipeMap};
    inputCapabilities : Internal.Set<Internal.MultiblockCapability<any>>;
    progressTexture : Internal.ResourceTexture;
    name : string;
    static readonly EMPTY : MbdRecipeMap;
    recipeBuilder : Internal.RecipeBuilder;
    categoryTexture : Internal.IGuiTexture;
    get unlocalizedName(): string;
    get class(): Internal.Class<any>;
    constructor(arg0: string);
}
type MbdRecipeMap_ = MbdRecipeMap;
declare class Rarity extends Internal.Enum<Rarity> implements Internal.IExtensibleEnum {
    init(): void;
    getClass(): Internal.Class<any>;
    wait(arg0: number, arg1: number): void;
    wait(): void;
    wait(arg0: number): void;
    static valueOf(arg0: string): Rarity;
    static valueOf<T_>(arg0: Internal.Class_<T_>, arg1: string): T_;
    notifyAll(): void;
    static values(): Rarity[];
    compareTo(arg0: Rarity_): number;
    describeConstable(): Internal.Optional<Internal.Enum$EnumDesc<Rarity>>;
    notify(): void;
    getDeclaringClass(): Internal.Class<Rarity>;
    hashCode(): number;
    equals(arg0: any): boolean;
    name(): string;
    static create(arg0: string, arg1: Internal.ChatFormatting_): Rarity;
    toString(): string;
    ordinal(): number;
    static readonly RARE : Rarity;
    static readonly EPIC : Rarity;
    static readonly UNCOMMON : Rarity;
    static readonly COMMON : Rarity;
    get class(): Internal.Class<any>;
    get declaringClass(): Internal.Class<Rarity>;
}
type Rarity_ = "uncommon" | "common" | "legendary" | "rare" | "forgotten" | "epic" | "twilight" | Rarity;
declare class Vec3 implements net.minecraft.core.Position {
    getClass(): Internal.Class<any>;
    wait(arg0: number, arg1: number): void;
    wait(): void;
    wait(arg0: number): void;
    hashCode(): number;
    notifyAll(): void;
    equals(arg0: any): boolean;
    toString(): string;
    notify(): void;
    readonly x : number;
    readonly y : number;
    readonly z : number;
    get class(): Internal.Class<any>;
    constructor(arg0: number, arg1: number, arg2: number);
    constructor(arg0: Internal.Vector3f);
}
type Vec3_ = Vec3;
declare class JsonIO {
    static writeJsonHash(stream: Internal.DataOutputStream_, element: Internal.JsonElement_): void;
    getClass(): Internal.Class<any>;
    wait(arg0: number, arg1: number): void;
    wait(): void;
    wait(arg0: number): void;
    static toPrimitive(element: Internal.JsonElement_): any;
    static read(path: Internal.Path_): Internal.MapJS;
    notifyAll(): void;
    static getJsonHashBytes(json: Internal.JsonElement_): number[];
    static parse(string: string): any;
    static primitiveOf(o: any): Internal.JsonPrimitive;
    notify(): void;
    hashCode(): number;
    equals(arg0: any): boolean;
    static of(o: any): Internal.JsonElement;
    static toArray(element: Internal.JsonElement_): Internal.JsonArray;
    static parseRaw(string: string): Internal.JsonElement;
    static toPrettyString(json: Internal.JsonElement_): string;
    static toString(json: Internal.JsonElement_): string;
    toString(): string;
    static toObject(json: Internal.JsonElement_): any;
    static copy(element: Internal.JsonElement_): Internal.JsonElement;
    static write(path: Internal.Path_, json: Internal.JsonElement_): void;
    get class(): Internal.Class<any>;
    constructor();
}
type JsonIO_ = JsonIO;
declare class Fluid {
    getClass(): Internal.Class<any>;
    wait(arg0: number, arg1: number): void;
    wait(): void;
    wait(arg0: number): void;
    notifyAll(): void;
    static water(amount: number): Internal.FluidStackJS;
    static water(): Internal.FluidStackJS;
    notify(): void;
    static lava(): Internal.FluidStackJS;
    static lava(amount: number): Internal.FluidStackJS;
    static getType(id: ResourceLocation_): Internal.Fluid;
    hashCode(): number;
    equals(arg0: any): boolean;
    static getEmpty(): Internal.FluidStackJS;
    static of(o: Internal.FluidStackJS_): Internal.FluidStackJS;
    static of(o: Internal.FluidStackJS_, amount: number, nbt: Internal.CompoundTag_): Internal.FluidStackJS;
    static of(o: Internal.FluidStackJS_, nbt: Internal.CompoundTag_): Internal.FluidStackJS;
    static of(o: Internal.FluidStackJS_, amount: number): Internal.FluidStackJS;
    static exists(id: ResourceLocation_): boolean;
    toString(): string;
    static getTypes(): Internal.List<string>;
    static readonly LAVA_ID : ResourceLocation;
    static readonly WATER_ID : ResourceLocation;
    get types(): Internal.List<string>;
    get class(): Internal.Class<any>;
    get empty(): Internal.FluidStackJS;
    constructor();
}
type Fluid_ = Fluid;
declare interface ItemFilter extends Internal.Predicate<Internal.ItemStack> {
    static not(arg0: ItemFilter_): ItemFilter;
    or(arg0: ItemFilter_): ItemFilter;
    static or(arg0: ItemFilter_[]): ItemFilter;
    or(arg0: Internal.Predicate_<Internal.ItemStack_>): Internal.Predicate<Internal.ItemStack>;
    test(arg0: Internal.ItemStack_): boolean;
    static and(arg0: ItemFilter_[]): ItemFilter;
    and(arg0: ItemFilter_): ItemFilter;
    and(arg0: Internal.Predicate_<Internal.ItemStack_>): Internal.Predicate<Internal.ItemStack>;
    negate(): ItemFilter;
    static equipmentSlot(arg0: EquipmentSlot_): ItemFilter;
    static hasEnchantment(arg0: Internal.Enchantment_, arg1: number, arg2: number): ItemFilter;
    static hasEnchantment(arg0: Internal.Enchantment_): ItemFilter;
    readonly ALWAYS_TRUE : ItemFilter;
    readonly HEAD_ARMOR : ItemFilter;
    readonly ARMOR : ItemFilter;
    readonly SWORD : ItemFilter;
    readonly BLOCK : ItemFilter;
    readonly ALWAYS_FALSE : ItemFilter;
    readonly HAS_TIER : ItemFilter;
    readonly LEGS_ARMOR : ItemFilter;
    readonly PROJECTILE_WEAPON : ItemFilter;
    readonly DAMAGEABLE : ItemFilter;
    readonly AXE : ItemFilter;
    readonly FEET_ARMOR : ItemFilter;
    readonly POTION : ItemFilter;
    readonly CHEST_ARMOR : ItemFilter;
    readonly PICKAXE : ItemFilter;
    readonly DAMAGED : ItemFilter;
    readonly WEAPON : ItemFilter;
    readonly ENCHANTABLE : ItemFilter;
    readonly ENCHANTED : ItemFilter;
    readonly SHOVEL : ItemFilter;
    readonly HOE : ItemFilter;
    readonly TOOL : ItemFilter;
    readonly FOOD : ItemFilter;
}
type ItemFilter_ = ItemFilter;
declare const ItemFilter: ItemFilter;
declare class Item {
    getClass(): Internal.Class<any>;
    wait(arg0: number, arg1: number): void;
    wait(): void;
    wait(arg0: number): void;
    notifyAll(): void;
    static getTypeList(): Internal.ListJS;
    static findGroup(id: string): Internal.CreativeModeTab;
    static getItem(id: ResourceLocation_): Internal.Item;
    static fireworks(properties: Internal.Map_<string, any>): Internal.FireworksJS;
    notify(): void;
    static clearListCache(): void;
    hashCode(): number;
    static getList(): Internal.ListJS;
    equals(arg0: any): boolean;
    static getEmpty(): Internal.ItemStackJS;
    static of(in_: Internal.ItemStackJS_, count: number, nbt: Internal.CompoundTag_): Internal.ItemStackJS;
    static of(in_: Internal.ItemStackJS_, tag: Internal.CompoundTag_): Internal.ItemStackJS;
    static of(in_: Internal.ItemStackJS_, count: number): Internal.ItemStackJS;
    static of(in_: Internal.ItemStackJS_): Internal.ItemStackJS;
    static isItem(o: any): boolean;
    static exists(id: ResourceLocation_): boolean;
    toString(): string;
    static withChance(in_: Internal.ItemStackJS_, c: number): Internal.ItemStackJS;
    static withNBT(in_: Internal.ItemStackJS_, nbt: Internal.CompoundTag_): Internal.ItemStackJS;
    get typeList(): Internal.ListJS;
    get list(): Internal.ListJS;
    get class(): Internal.Class<any>;
    get empty(): Internal.ItemStackJS;
    constructor();
}
type Item_ = Item;
declare class DecorationGenerationStep extends Internal.Enum<DecorationGenerationStep> {
    getClass(): Internal.Class<any>;
    wait(arg0: number, arg1: number): void;
    wait(): void;
    wait(arg0: number): void;
    static valueOf(arg0: string): DecorationGenerationStep;
    static valueOf<T_>(arg0: Internal.Class_<T_>, arg1: string): T_;
    notifyAll(): void;
    static values(): DecorationGenerationStep[];
    compareTo(arg0: DecorationGenerationStep_): number;
    describeConstable(): Internal.Optional<Internal.Enum$EnumDesc<DecorationGenerationStep>>;
    notify(): void;
    getDeclaringClass(): Internal.Class<DecorationGenerationStep>;
    hashCode(): number;
    equals(arg0: any): boolean;
    name(): string;
    toString(): string;
    ordinal(): number;
    static readonly RAW_GENERATION : DecorationGenerationStep;
    static readonly UNDERGROUND_STRUCTURES : DecorationGenerationStep;
    static readonly LOCAL_MODIFICATIONS : DecorationGenerationStep;
    static readonly TOP_LAYER_MODIFICATION : DecorationGenerationStep;
    static readonly UNDERGROUND_DECORATION : DecorationGenerationStep;
    static readonly LAKES : DecorationGenerationStep;
    static readonly SURFACE_STRUCTURES : DecorationGenerationStep;
    static readonly STRONGHOLDS : DecorationGenerationStep;
    static readonly FLUID_SPRINGS : DecorationGenerationStep;
    static readonly VEGETAL_DECORATION : DecorationGenerationStep;
    static readonly UNDERGROUND_ORES : DecorationGenerationStep;
    get class(): Internal.Class<any>;
    get declaringClass(): Internal.Class<DecorationGenerationStep>;
}
type DecorationGenerationStep_ = "strongholds" | "underground_ores" | "underground_structures" | "top_layer_modification" | "fluid_springs" | "underground_decoration" | "raw_generation" | "lakes" | "vegetal_decoration" | "local_modifications" | "surface_structures" | DecorationGenerationStep;
declare class LootType extends Internal.Enum<LootType> {
    getClass(): Internal.Class<any>;
    wait(arg0: number, arg1: number): void;
    wait(): void;
    wait(arg0: number): void;
    static valueOf(arg0: string): LootType;
    static valueOf<T_>(arg0: Internal.Class_<T_>, arg1: string): T_;
    notifyAll(): void;
    static values(): LootType[];
    compareTo(arg0: LootType_): number;
    describeConstable(): Internal.Optional<Internal.Enum$EnumDesc<LootType>>;
    notify(): void;
    getDeclaringClass(): Internal.Class<LootType>;
    hashCode(): number;
    equals(arg0: any): boolean;
    name(): string;
    toString(): string;
    ordinal(): number;
    static readonly CHEST : LootType;
    static readonly ADVANCEMENT_ENTITY : LootType;
    static readonly GIFT : LootType;
    static readonly ENTITY : LootType;
    static readonly FISHING : LootType;
    static readonly PIGLIN_BARTER : LootType;
    static readonly BLOCK : LootType;
    static readonly UNKNOWN : LootType;
    static readonly ADVANCEMENT_REWARD : LootType;
    get class(): Internal.Class<any>;
    get declaringClass(): Internal.Class<LootType>;
}
type LootType_ = "gift" | "chest" | "piglin_barter" | "advancement_entity" | "advancement_reward" | "fishing" | "block" | "entity" | "unknown" | LootType;
declare class MbdRegistry {
    static getDefinition(arg0: string): Internal.ComponentDefinition;
    getClass(): Internal.Class<any>;
    wait(arg0: number, arg1: number): void;
    wait(): void;
    wait(arg0: number): void;
    static getRecipeMap(arg0: string): MbdRecipeMap;
    static getCapability(arg0: string): Internal.MultiblockCapability<any>;
    hashCode(): number;
    notifyAll(): void;
    equals(arg0: any): boolean;
    toString(): string;
    notify(): void;
    get class(): Internal.Class<any>;
    constructor();
}
type MbdRegistry_ = MbdRegistry;
declare class MbdRelativeDirection extends Internal.Enum<MbdRelativeDirection> {
    getClass(): Internal.Class<any>;
    wait(arg0: number, arg1: number): void;
    wait(): void;
    wait(arg0: number): void;
    static valueOf(arg0: string): MbdRelativeDirection;
    static valueOf<T_>(arg0: Internal.Class_<T_>, arg1: string): T_;
    notifyAll(): void;
    static values(): MbdRelativeDirection[];
    compareTo(arg0: MbdRelativeDirection_): number;
    describeConstable(): Internal.Optional<Internal.Enum$EnumDesc<MbdRelativeDirection>>;
    notify(): void;
    getDeclaringClass(): Internal.Class<MbdRelativeDirection>;
    getActualFacing(arg0: Internal.Direction_): Internal.Direction;
    hashCode(): number;
    equals(arg0: any): boolean;
    name(): string;
    toString(): string;
    isSameAxis(arg0: MbdRelativeDirection_): boolean;
    ordinal(): number;
    static readonly DOWN : MbdRelativeDirection;
    static readonly LEFT : MbdRelativeDirection;
    static readonly RIGHT : MbdRelativeDirection;
    static readonly FRONT : MbdRelativeDirection;
    static readonly BACK : MbdRelativeDirection;
    static readonly UP : MbdRelativeDirection;
    readonly axis : Internal.Direction$Axis;
    get class(): Internal.Class<any>;
    get declaringClass(): Internal.Class<MbdRelativeDirection>;
}
type MbdRelativeDirection_ = "left" | "back" | "up" | "right" | "front" | "down" | MbdRelativeDirection;
declare class BiomeDictionary {
    getClass(): Internal.Class<any>;
    wait(arg0: number, arg1: number): void;
    wait(): void;
    wait(arg0: number): void;
    static printTags(biome: ResourceLocation_): void;
    static getBiomeType(o: any): Internal.BiomeDictionary$Type;
    static printBiomes(type: Internal.BiomeDictionary$Type_): void;
    hashCode(): number;
    static addTypes(biomes: ResourceLocation_[], tags: Internal.BiomeDictionary$Type_[]): void;
    notifyAll(): void;
    equals(arg0: any): boolean;
    toString(): string;
    notify(): void;
    get class(): Internal.Class<any>;
    constructor();
}
type BiomeDictionary_ = BiomeDictionary;
declare interface NBTIO {
    static read(path: Internal.Path_): Internal.CompoundTag;
    static write(path: Internal.Path_, nbt: Internal.CompoundTag_): void;
}
type NBTIO_ = NBTIO;
declare const NBTIO: NBTIO;
declare interface Color {
    static rgba(r: number, g: number, b: number, a: number): Internal.Color;
    static of(o: any): Internal.Color;
    static createMapped(o: any, names: string[]): Internal.Color;
    readonly BLUE_DYE : Internal.Color;
    readonly GOLD : Internal.Color;
    readonly GRAY : Internal.Color;
    readonly MAGENTA_DYE : Internal.Color;
    readonly BLUE : Internal.Color;
    readonly DARK_AQUA : Internal.Color;
    readonly TEXT : {"dark_red":Internal.ChatFormatting,"green":Internal.ChatFormatting,"underline":Internal.ChatFormatting,"dark_green":Internal.ChatFormatting,"black":Internal.ChatFormatting,"yellow":Internal.ChatFormatting,"bold":Internal.ChatFormatting,"italic":Internal.ChatFormatting,"dark_blue":Internal.ChatFormatting,"dark_purple":Internal.ChatFormatting,"gold":Internal.ChatFormatting,"red":Internal.ChatFormatting,"aqua":Internal.ChatFormatting,"gray":Internal.ChatFormatting,"light_purple":Internal.ChatFormatting,"blue":Internal.ChatFormatting,"white":Internal.ChatFormatting,"dark_aqua":Internal.ChatFormatting,"dark_gray":Internal.ChatFormatting,"reset":Internal.ChatFormatting,"strikethrough":Internal.ChatFormatting,"obfuscated":Internal.ChatFormatting};
    readonly DYE : {"magenta":Internal.DyeColor,"pink":Internal.DyeColor,"green":Internal.DyeColor,"lime":Internal.DyeColor,"light_gray":Internal.DyeColor,"yellow":Internal.DyeColor,"black":Internal.DyeColor,"light_blue":Internal.DyeColor,"brown":Internal.DyeColor,"cyan":Internal.DyeColor,"orange":Internal.DyeColor,"red":Internal.DyeColor,"gray":Internal.DyeColor,"white":Internal.DyeColor,"blue":Internal.DyeColor,"purple":Internal.DyeColor};
    readonly WHITE_DYE : Internal.Color;
    readonly DARK_RED : Internal.Color;
    readonly LIGHT_PURPLE : Internal.Color;
    readonly BROWN_DYE : Internal.Color;
    readonly BLACK : Internal.Color;
    readonly GRAY_DYE : Internal.Color;
    readonly NONE : Internal.Color;
    readonly LIGHT_BLUE_DYE : Internal.Color;
    readonly AQUA : Internal.Color;
    readonly WHITE : Internal.Color;
    readonly LIGHT_GRAY_DYE : Internal.Color;
    readonly BLACK_DYE : Internal.Color;
    readonly RED_DYE : Internal.Color;
    readonly PURPLE_DYE : Internal.Color;
    readonly GREEN_DYE : Internal.Color;
    readonly PINK_DYE : Internal.Color;
    readonly DARK_BLUE : Internal.Color;
    readonly GREEN : Internal.Color;
    readonly CYAN_DYE : Internal.Color;
    readonly RED : Internal.Color;
    readonly DARK_PURPLE : Internal.Color;
    readonly ORANGE_DYE : Internal.Color;
    readonly YELLOW_DYE : Internal.Color;
    readonly DARK_GREEN : Internal.Color;
    readonly YELLOW : Internal.Color;
    readonly LIME_DYE : Internal.Color;
    readonly DARK_GRAY : Internal.Color;
    readonly MAP : {"":any,"light_blue_dye":Internal.DyeColor,"BLUE_DYE":Internal.DyeColor,"purple_dye":Internal.DyeColor,"dark_red":Internal.ChatFormatting,"lightGrayDye":Internal.DyeColor,"DARK_AQUA":Internal.ChatFormatting,"none":any,"green_dye":Internal.DyeColor,"blackDye":Internal.DyeColor,"dark_blue":Internal.ChatFormatting,"red":Internal.ChatFormatting,"pink_dye":Internal.DyeColor,"aqua":Internal.ChatFormatting,"white":Internal.ChatFormatting,"WHITE_DYE":Internal.DyeColor,"dark_gray":Internal.ChatFormatting,"LIGHT_PURPLE":Internal.ChatFormatting,"BROWN_DYE":Internal.DyeColor,"BLACK":Internal.ChatFormatting,"darkPurple":Internal.ChatFormatting,"NONE":any,"LIGHT_BLUE_DYE":Internal.DyeColor,"AQUA":Internal.ChatFormatting,"lightBlueDye":Internal.DyeColor,"limeDye":Internal.DyeColor,"PURPLE_DYE":Internal.DyeColor,"GREEN_DYE":Internal.DyeColor,"magenta_dye":Internal.DyeColor,"-":any,"lime_dye":Internal.DyeColor,"yellowDye":Internal.DyeColor,"grayDye":Internal.DyeColor,"purpleDye":Internal.DyeColor,"DARK_PURPLE":Internal.ChatFormatting,"ORANGE_DYE":Internal.DyeColor,"darkGray":Internal.ChatFormatting,"brownDye":Internal.DyeColor,"YELLOW":Internal.ChatFormatting,"LIME_DYE":Internal.DyeColor,"blueDye":Internal.DyeColor,"white_dye":Internal.DyeColor,"pinkDye":Internal.DyeColor,"blue_dye":Internal.DyeColor,"cyanDye":Internal.DyeColor,"GOLD":Internal.ChatFormatting,"GRAY":Internal.ChatFormatting,"MAGENTA_DYE":Internal.DyeColor,"BLUE":Internal.ChatFormatting,"yellow":Internal.ChatFormatting,"darkBlue":Internal.ChatFormatting,"transparent":any,"orange_dye":Internal.DyeColor,"red_dye":Internal.DyeColor,"dark_purple":Internal.ChatFormatting,"gold":Internal.ChatFormatting,"gray":Internal.ChatFormatting,"light_purple":Internal.ChatFormatting,"darkRed":Internal.ChatFormatting,"greenDye":Internal.DyeColor,"DARK_RED":Internal.ChatFormatting,"redDye":Internal.DyeColor,"GRAY_DYE":Internal.DyeColor,"orangeDye":Internal.DyeColor,"yellow_dye":Internal.DyeColor,"black_dye":Internal.DyeColor,"magentaDye":Internal.DyeColor,"WHITE":Internal.ChatFormatting,"green":Internal.ChatFormatting,"LIGHT_GRAY_DYE":Internal.DyeColor,"BLACK_DYE":Internal.DyeColor,"darkGreen":Internal.ChatFormatting,"RED_DYE":Internal.DyeColor,"dark_green":Internal.ChatFormatting,"black":Internal.ChatFormatting,"lightPurple":Internal.ChatFormatting,"PINK_DYE":Internal.DyeColor,"DARK_BLUE":Internal.ChatFormatting,"GREEN":Internal.ChatFormatting,"darkAqua":Internal.ChatFormatting,"gray_dye":Internal.DyeColor,"CYAN_DYE":Internal.DyeColor,"RED":Internal.ChatFormatting,"brown_dye":Internal.DyeColor,"cyan_dye":Internal.DyeColor,"blue":Internal.ChatFormatting,"whiteDye":Internal.DyeColor,"dark_aqua":Internal.ChatFormatting,"YELLOW_DYE":Internal.DyeColor,"DARK_GREEN":Internal.ChatFormatting,"DARK_GRAY":Internal.ChatFormatting};
}
type Color_ = Color;
declare const Color: Color;
declare class Ingredient {
    getClass(): Internal.Class<any>;
    static customNBT(in_: Internal.IngredientJS_, predicate: Internal.Predicate_<Internal.CompoundTag_>): Internal.IngredientJS;
    wait(arg0: number, arg1: number): void;
    wait(): void;
    wait(arg0: number): void;
    static getAll(): Internal.IngredientJS;
    static isIngredient(o: any): boolean;
    notifyAll(): void;
    static custom(in_: Internal.IngredientJS_, predicate: Internal.Predicate_<Internal.ItemStackJS_>): Internal.IngredientJS;
    static custom(predicate: Internal.Predicate_<Internal.ItemStackJS_>): Internal.IngredientJS;
    static getNone(): Internal.IngredientJS;
    notify(): void;
    static matchAny(objects: any): Internal.IngredientJS;
    hashCode(): number;
    equals(arg0: any): boolean;
    static of(object: any, count: number): Internal.IngredientJS;
    static of(object: any): Internal.IngredientJS;
    toString(): string;
    static registerCustomIngredientAction(id: string, callback: Internal.CustomIngredientActionCallback_): void;
    get all(): Internal.IngredientJS;
    get none(): Internal.IngredientJS;
    get class(): Internal.Class<any>;
    constructor();
}
type Ingredient_ = Ingredient;
/**
*/
declare interface BlockStatePredicate {
    test(arg0: Internal.BlockState_): boolean;
    getBlockStates(): Internal.Collection<Internal.BlockState>;
    static of(o: any): BlockStatePredicate;
    getBlocks(): Internal.Collection<Internal.Block>;
    static fromString(s: string): BlockStatePredicate;
    check(targetStates: Internal.List_<Internal.OreConfiguration$TargetBlockState_>): boolean;
    getBlockIds(): Internal.Set<ResourceLocation>;
    asRuleTest(): Internal.RuleTest;
    static ruleTestOf(o: any): Internal.RuleTest;
    readonly AIR_ID : ResourceLocation;
}
/**
*/
type BlockStatePredicate_ = string | BlockStatePredicate_[] | {or?: Internal.BlockStatePredicate_[], not?: Internal.BlockStatePredicate_} | Internal.Block_ | Internal.BlockState_ | RegExp | BlockStatePredicate;
declare const BlockStatePredicate: BlockStatePredicate;
declare interface NBT {
    static byteArrayTag(v: number[]): net.minecraft.nbt.Tag;
    static fromTag(t: net.minecraft.nbt.Tag_): any;
    static toTagCompound(v: any): Internal.CompoundTag;
    static listTag(): net.minecraft.nbt.Tag;
    static listTag(list: Internal.List_<any>): net.minecraft.nbt.Tag;
    static isTagCompound(o: any): boolean;
    static compoundTag(): net.minecraft.nbt.Tag;
    static compoundTag(map: Internal.Map_<any, any>): net.minecraft.nbt.Tag;
    static toTag(v: any): net.minecraft.nbt.Tag;
    static floatTag(v: number): net.minecraft.nbt.Tag;
    static quoteAndEscapeForJS(stringBuilder: Internal.StringBuilder_, string: string): void;
    static toTagList(list: any): Internal.ListTag;
    static ia(v: number[]): net.minecraft.nbt.Tag;
    static intTag(v: number): net.minecraft.nbt.Tag;
    static byteTag(v: number): net.minecraft.nbt.Tag;
    static longArrayTag(v: number[]): net.minecraft.nbt.Tag;
    static b(v: number): net.minecraft.nbt.Tag;
    static read(buf: Internal.FriendlyByteBuf_): Internal.OrderedCompoundTag;
    static d(v: number): net.minecraft.nbt.Tag;
    static f(v: number): net.minecraft.nbt.Tag;
    static convertType(tagType: Internal.TagType_<any>): Internal.TagType<any>;
    static i(v: number): net.minecraft.nbt.Tag;
    static shortTag(v: number): net.minecraft.nbt.Tag;
    static l(v: number): net.minecraft.nbt.Tag;
    static toTagCollection(c: Internal.Collection_<any>): Internal.CollectionTag<any>;
    static toTagCollection(v: any): Internal.CollectionTag<any>;
    static s(v: number): net.minecraft.nbt.Tag;
    static la(v: number[]): net.minecraft.nbt.Tag;
    static isTagCollection(o: any): boolean;
    static longTag(v: number): net.minecraft.nbt.Tag;
    static intArrayTag(v: number[]): net.minecraft.nbt.Tag;
    static doubleTag(v: number): net.minecraft.nbt.Tag;
    static stringTag(v: string): net.minecraft.nbt.Tag;
    static accessTagMap(tag: Internal.CompoundTag_): Internal.Map<string, net.minecraft.nbt.Tag>;
    static ba(v: number[]): net.minecraft.nbt.Tag;
    readonly COMPOUND_TYPE : Internal.TagType<Internal.OrderedCompoundTag>;
    readonly VALUE_UNWRAPPER : ((arg0: Internal.Scriptable, arg1: any) => any);
    readonly LIST_TYPE : Internal.TagType<Internal.ListTag>;
}
type NBT_ = NBT;
declare const NBT: NBT;
/**
*/
declare class ResourceLocation implements Internal.Comparable<ResourceLocation>, Internal.SpecialEquality {
    getClass(): Internal.Class<any>;
    wait(arg0: number, arg1: number): void;
    wait(): void;
    wait(arg0: number): void;
    getNamespace(): string;
    hashCode(): number;
    notifyAll(): void;
    compareNamespaced(arg0: ResourceLocation_): number;
    equals(arg0: any): boolean;
    getPath(): string;
    toString(): string;
    compareTo(arg0: ResourceLocation_): number;
    notify(): void;
    specialEquals(o: any, shallow: boolean): boolean;
    get path(): string;
    get namespace(): string;
    get class(): Internal.Class<any>;
    constructor(arg0: string, arg1: string);
    constructor(arg0: string);
}
/**
*/
type ResourceLocation_ = string | ResourceLocation;
declare class CarvingGenerationStep extends Internal.Enum<CarvingGenerationStep> implements Internal.StringRepresentable {
    getClass(): Internal.Class<any>;
    wait(arg0: number, arg1: number): void;
    wait(): void;
    wait(arg0: number): void;
    static valueOf(arg0: string): CarvingGenerationStep;
    static valueOf<T_>(arg0: Internal.Class_<T_>, arg1: string): T_;
    notifyAll(): void;
    static values(): CarvingGenerationStep[];
    compareTo(arg0: CarvingGenerationStep_): number;
    describeConstable(): Internal.Optional<Internal.Enum$EnumDesc<CarvingGenerationStep>>;
    notify(): void;
    getDeclaringClass(): Internal.Class<CarvingGenerationStep>;
    hashCode(): number;
    equals(arg0: any): boolean;
    name(): string;
    toString(): string;
    ordinal(): number;
    static readonly LIQUID : CarvingGenerationStep;
    static readonly AIR : CarvingGenerationStep;
    get class(): Internal.Class<any>;
    get declaringClass(): Internal.Class<CarvingGenerationStep>;
}
type CarvingGenerationStep_ = "liquid" | "air" | CarvingGenerationStep;
declare class Block {
    getClass(): Internal.Class<any>;
    wait(arg0: number, arg1: number): void;
    wait(): void;
    wait(arg0: number): void;
    static getBlock(id: ResourceLocation_): Internal.Block;
    notifyAll(): void;
    static custom(predicate: Internal.BlockPredicate_): Internal.BlockPredicate;
    static getTypeList(): Internal.List<string>;
    notify(): void;
    static getMaterial(): Internal.Map<string, Internal.MaterialJS>;
    static getTaggedIds(tag: ResourceLocation_): Internal.List<ResourceLocation>;
    hashCode(): number;
    equals(arg0: any): boolean;
    toString(): string;
    static getFacing(): Internal.Map<string, Internal.Direction>;
    static id(id: ResourceLocation_, properties: Internal.Map_<string, any>): Internal.BlockIDPredicate;
    static id(id: ResourceLocation_): Internal.BlockIDPredicate;
    static entity(id: ResourceLocation_): Internal.BlockEntityPredicate;
    get typeList(): Internal.List<string>;
    get material(): Internal.Map<string, Internal.MaterialJS>;
    get facing(): Internal.Map<string, Internal.Direction>;
    get class(): Internal.Class<any>;
    constructor();
}
type Block_ = Block;
declare class MbdFactoryBlockPattern {
    getClass(): Internal.Class<any>;
    aisleRepeatable(arg0: number, arg1: number, arg2: string[]): MbdFactoryBlockPattern;
    wait(arg0: number, arg1: number): void;
    wait(): void;
    wait(arg0: number): void;
    build(): Internal.BlockPattern;
    hashCode(): number;
    notifyAll(): void;
    equals(arg0: any): boolean;
    static start(): MbdFactoryBlockPattern;
    static start(arg0: MbdRelativeDirection_, arg1: MbdRelativeDirection_, arg2: MbdRelativeDirection_): MbdFactoryBlockPattern;
    toString(): string;
    where(arg0: string, arg1: Internal.TraceabilityPredicate_): MbdFactoryBlockPattern;
    aisle(arg0: string[]): MbdFactoryBlockPattern;
    notify(): void;
    setRepeatable(arg0: number, arg1: number): MbdFactoryBlockPattern;
    setRepeatable(arg0: number): MbdFactoryBlockPattern;
    get class(): Internal.Class<any>;
    set repeatable(arg0: number);
}
type MbdFactoryBlockPattern_ = MbdFactoryBlockPattern;
declare class EquipmentSlot extends Internal.Enum<EquipmentSlot> {
    getClass(): Internal.Class<any>;
    wait(arg0: number, arg1: number): void;
    wait(): void;
    wait(arg0: number): void;
    static valueOf(arg0: string): EquipmentSlot;
    static valueOf<T_>(arg0: Internal.Class_<T_>, arg1: string): T_;
    notifyAll(): void;
    static values(): EquipmentSlot[];
    compareTo(arg0: EquipmentSlot_): number;
    describeConstable(): Internal.Optional<Internal.Enum$EnumDesc<EquipmentSlot>>;
    notify(): void;
    getDeclaringClass(): Internal.Class<EquipmentSlot>;
    hashCode(): number;
    equals(arg0: any): boolean;
    name(): string;
    toString(): string;
    ordinal(): number;
    static readonly CHEST : EquipmentSlot;
    static readonly HEAD : EquipmentSlot;
    static readonly OFFHAND : EquipmentSlot;
    static readonly MAINHAND : EquipmentSlot;
    static readonly LEGS : EquipmentSlot;
    static readonly FEET : EquipmentSlot;
    get class(): Internal.Class<any>;
    get declaringClass(): Internal.Class<EquipmentSlot>;
}
type EquipmentSlot_ = "mainhand" | "head" | "feet" | "chest" | "legs" | "offhand" | EquipmentSlot;
declare interface UUID {
    static digits(sb: Internal.StringBuilder_, val: number, digits: number): void;
    static toString(id: Internal.UUID_): string;
    static fromString(o: any): Internal.UUID;
}
type UUID_ = UUID;
declare const UUID: UUID;
declare interface Facing {
    readonly ALL : {"east":Internal.Direction,"south":Internal.Direction,"north":Internal.Direction,"west":Internal.Direction,"up":Internal.Direction,"down":Internal.Direction};
    readonly DOWN : Internal.Direction;
    readonly south : Internal.Direction;
    readonly north : Internal.Direction;
    readonly WEST : Internal.Direction;
    readonly down : Internal.Direction;
    readonly east : Internal.Direction;
    readonly NORTH : Internal.Direction;
    readonly west : Internal.Direction;
    readonly up : Internal.Direction;
    readonly UP : Internal.Direction;
    readonly SOUTH : Internal.Direction;
    readonly EAST : Internal.Direction;
}
type Facing_ = Facing;
declare const Facing: Facing;
declare class Platform {
    static isDevelopmentEnvironment(): boolean;
    getClass(): Internal.Class<any>;
    static isClientEnvironment(): boolean;
    wait(arg0: number, arg1: number): void;
    wait(): void;
    wait(arg0: number): void;
    static getName(): string;
    static getInfo(modID: string): Internal.PlatformWrapper$ModInfo;
    static getMods(): Internal.Map<string, Internal.PlatformWrapper$ModInfo>;
    notifyAll(): void;
    static isForge(): boolean;
    static isLoaded(modId: string): boolean;
    notify(): void;
    static isFabric(): boolean;
    hashCode(): number;
    static getList(): Internal.Set<string>;
    equals(arg0: any): boolean;
    static getModVersion(): string;
    toString(): string;
    static getMcVersion(): string;
    get mods(): Internal.Map<string, Internal.PlatformWrapper$ModInfo>;
    get modVersion(): string;
    get developmentEnvironment(): boolean;
    get forge(): boolean;
    get fabric(): boolean;
    get mcVersion(): string;
    get clientEnvironment(): boolean;
    get name(): string;
    get list(): Internal.Set<string>;
    get class(): Internal.Class<any>;
    constructor();
}
type Platform_ = Platform;
declare class JavaMath {
    getClass(): Internal.Class<any>;
    static multiplyFull(arg0: number, arg1: number): number;
    static copySign(arg0: number, arg1: number): number;
    static log1p(arg0: number): number;
    static expm1(arg0: number): number;
    static cos(arg0: number): number;
    static rint(arg0: number): number;
    static atan(arg0: number): number;
    static ceilDiv(arg0: number, arg1: number): number;
    static nextUp(arg0: number): number;
    static sqrt(arg0: number): number;
    static ceilDivExact(arg0: number, arg1: number): number;
    static decrementExact(arg0: number): number;
    static absExact(arg0: number): number;
    static exp(arg0: number): number;
    static atan2(arg0: number, arg1: number): number;
    static signum(arg0: number): number;
    static tan(arg0: number): number;
    static floorDivExact(arg0: number, arg1: number): number;
    static sinh(arg0: number): number;
    static toDegrees(arg0: number): number;
    static acos(arg0: number): number;
    static ceil(arg0: number): number;
    static divideExact(arg0: number, arg1: number): number;
    static getExponent(arg0: number): number;
    static addExact(arg0: number, arg1: number): number;
    static multiplyHigh(arg0: number, arg1: number): number;
    static ulp(arg0: number): number;
    wait(arg0: number, arg1: number): void;
    wait(): void;
    wait(arg0: number): void;
    static scalb(arg0: number, arg1: number): number;
    static floorMod(arg0: number, arg1: number): number;
    static log(arg0: number): number;
    static log10(arg0: number): number;
    notifyAll(): void;
    static nextAfter(arg0: number, arg1: number): number;
    static multiplyExact(arg0: number, arg1: number): number;
    notify(): void;
    static cbrt(arg0: number): number;
    static random(): number;
    static tanh(arg0: number): number;
    static min(arg0: number, arg1: number): number;
    static negateExact(arg0: number): number;
    hashCode(): number;
    static hypot(arg0: number, arg1: number): number;
    static pow(arg0: number, arg1: number): number;
    static sin(arg0: number): number;
    static unsignedMultiplyHigh(arg0: number, arg1: number): number;
    static floor(arg0: number): number;
    static subtractExact(arg0: number, arg1: number): number;
    static ceilMod(arg0: number, arg1: number): number;
    static max(arg0: number, arg1: number): number;
    static toIntExact(arg0: number): number;
    static nextDown(arg0: number): number;
    static toRadians(arg0: number): number;
    static cosh(arg0: number): number;
    static IEEEremainder(arg0: number, arg1: number): number;
    static abs(arg0: number): number;
    static round(arg0: number): number;
    static floorDiv(arg0: number, arg1: number): number;
    static incrementExact(arg0: number): number;
    equals(arg0: any): boolean;
    toString(): string;
    static asin(arg0: number): number;
    static fma(arg0: number, arg1: number, arg2: number): number;
    static readonly E : 2.718281828459045;
    static readonly PI : 3.141592653589793;
    get class(): Internal.Class<any>;
}
type JavaMath_ = JavaMath;
declare namespace dev.architectury.event {
    interface Event <T> {
        unregister(arg0: T): void;
        isRegistered(arg0: T): boolean;
        invoker(): T;
        clearListeners(): void;
        register(arg0: T): void;
    }
    type Event_<T> = Event<T>;
}
declare namespace vazkii.botania.mixin {
    interface AccessorEntity {
        callUnsetRemoved(): void;
    }
    type AccessorEntity_ = AccessorEntity;
    interface AccessorMob {
        getGoalSelector(): Internal.GoalSelector;
        setLootTable(arg0: ResourceLocation_): void;
        botania_getAmbientSound(): Internal.SoundEvent;
        getTargetSelector(): Internal.GoalSelector;
    }
    type AccessorMob_ = AccessorMob;
}
declare namespace Internal {
    interface IIngredients {
        setInputs<T>(arg0: Internal.IIngredientType_<T>, arg1: Internal.List_<T>): void;
        setOutputs<T>(arg0: Internal.IIngredientType_<T>, arg1: Internal.List_<T>): void;
        getOutputs<T>(arg0: Internal.IIngredientType_<T>): Internal.List<Internal.List<T>>;
        setInputIngredients(arg0: Internal.List_<Internal.Ingredient_>): void;
        setOutputLists<T>(arg0: Internal.IIngredientType_<T>, arg1: Internal.List_<Internal.List_<T>>): void;
        setInputLists<T>(arg0: Internal.IIngredientType_<T>, arg1: Internal.List_<Internal.List_<T>>): void;
        getInputs<T>(arg0: Internal.IIngredientType_<T>): Internal.List<Internal.List<T>>;
        setOutput<T>(arg0: Internal.IIngredientType_<T>, arg1: T): void;
        setInput<T>(arg0: Internal.IIngredientType_<T>, arg1: T): void;
    }
    type IIngredients_ = IIngredients;
    interface DoubleBinaryOperator {
        applyAsDouble(arg0: number, arg1: number): number;
    }
    type DoubleBinaryOperator_ = ((arg0: number, arg1: number) => number) | DoubleBinaryOperator;
    interface IIngredientType <T> {
        getIngredientClass(): Internal.Class<T>;
    }
    type IIngredientType_<T> = (() => Internal.Class<T>) | IIngredientType<T>;
    interface DynamicOps <T> {
        createIntList(arg0: Internal.IntStream_): T;
        updateGeneric(arg0: T, arg1: T, arg2: java_.util.function_.Function_<T, T>): T;
        listBuilder(): Internal.ListBuilder<T>;
        createLong(arg0: number): T;
        createDouble(arg0: number): T;
        createLongList(arg0: Internal.LongStream_): T;
        createShort(arg0: number): T;
        mergeToList(arg0: T, arg1: Internal.List_<T>): Internal.DataResult<T>;
        mergeToList(arg0: T, arg1: T): Internal.DataResult<T>;
        update(arg0: T, arg1: string, arg2: java_.util.function_.Function_<T, T>): T;
        createByteList(arg0: Internal.ByteBuffer_): T;
        getByteBuffer(arg0: T): Internal.DataResult<Internal.ByteBuffer>;
        withDecoder<E>(arg0: Internal.Decoder_<E>): java_.util.function_.Function<T, Internal.DataResult<Internal.Pair<E, T>>>;
        createBoolean(arg0: boolean): T;
        remove(arg0: T, arg1: string): T;
        getMapValues(arg0: T): Internal.DataResult<Internal.Stream<Internal.Pair<T, T>>>;
        empty(): T;
        mergeToMap(arg0: T, arg1: Internal.Map_<T, T>): Internal.DataResult<T>;
        mergeToMap(arg0: T, arg1: Internal.MapLike_<T>): Internal.DataResult<T>;
        mergeToMap(arg0: T, arg1: T, arg2: T): Internal.DataResult<T>;
        withParser<E>(arg0: Internal.Decoder_<E>): java_.util.function_.Function<T, Internal.DataResult<E>>;
        convertList<U>(arg0: Internal.DynamicOps_<U>, arg1: T): U;
        emptyList(): T;
        getIntStream(arg0: T): Internal.DataResult<Internal.IntStream>;
        getList(arg0: T): Internal.DataResult<Internal.Consumer<Internal.Consumer<T>>>;
        getLongStream(arg0: T): Internal.DataResult<Internal.LongStream>;
        get(arg0: T, arg1: string): Internal.DataResult<T>;
        getMapEntries(arg0: T): Internal.DataResult<Internal.Consumer<Internal.BiConsumer<T, T>>>;
        emptyMap(): T;
        getBooleanValue(arg0: T): Internal.DataResult<boolean>;
        createNumeric(arg0: Internal.Number_): T;
        getStream(arg0: T): Internal.DataResult<Internal.Stream<T>>;
        convertMap<U>(arg0: Internal.DynamicOps_<U>, arg1: T): U;
        mergeToPrimitive(arg0: T, arg1: T): Internal.DataResult<T>;
        createList(arg0: Internal.Stream_<T>): T;
        getStringValue(arg0: T): Internal.DataResult<string>;
        withEncoder<E>(arg0: Internal.Encoder_<E>): java_.util.function_.Function<E, Internal.DataResult<T>>;
        set(arg0: T, arg1: string, arg2: T): T;
        getGeneric(arg0: T, arg1: T): Internal.DataResult<T>;
        createString(arg0: string): T;
        convertTo<U>(arg0: Internal.DynamicOps_<U>, arg1: T): U;
        createMap(arg0: Internal.Stream_<Internal.Pair_<T, T>>): T;
        createMap(arg0: Internal.Map_<T, T>): T;
        mapBuilder(): Internal.RecordBuilder<T>;
        getMap(arg0: T): Internal.DataResult<Internal.MapLike<T>>;
        createByte(arg0: number): T;
        createFloat(arg0: number): T;
        createInt(arg0: number): T;
        compressMaps(): boolean;
        getNumberValue(arg0: T): Internal.DataResult<Internal.Number>;
        getNumberValue(arg0: T, arg1: Internal.Number_): Internal.Number;
    }
    type DynamicOps_<T> = DynamicOps<T>;
    class IsoChronology extends Internal.AbstractChronology implements Internal.Serializable {
        localDateTime(arg0: Internal.TemporalAccessor_): Internal.LocalDateTime;
        date(arg0: Internal.Era_, arg1: number, arg2: number, arg3: number): Internal.LocalDate;
        date(arg0: Internal.TemporalAccessor_): Internal.LocalDate;
        date(arg0: number, arg1: number, arg2: number): Internal.LocalDate;
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        notifyAll(): void;
        range(arg0: Internal.ChronoField_): Internal.ValueRange;
        getId(): string;
        compareTo(arg0: Internal.Chronology_): number;
        notify(): void;
        dateNow(arg0: Internal.Clock_): Internal.LocalDate;
        dateNow(): Internal.LocalDate;
        dateNow(arg0: Internal.ZoneId_): Internal.LocalDate;
        eraOf(arg0: number): Internal.IsoEra;
        prolepticYear(arg0: Internal.Era_, arg1: number): number;
        zonedDateTime(arg0: Internal.Instant_, arg1: Internal.ZoneId_): Internal.ZonedDateTime;
        zonedDateTime(arg0: Internal.TemporalAccessor_): Internal.ZonedDateTime;
        hashCode(): number;
        epochSecond(arg0: number, arg1: number, arg2: number, arg3: number, arg4: number, arg5: number, arg6: Internal.ZoneOffset_): number;
        epochSecond(arg0: Internal.Era_, arg1: number, arg2: number, arg3: number, arg4: number, arg5: number, arg6: number, arg7: Internal.ZoneOffset_): number;
        period(arg0: number, arg1: number, arg2: number): Internal.Period;
        dateYearDay(arg0: number, arg1: number): Internal.LocalDate;
        dateYearDay(arg0: Internal.Era_, arg1: number, arg2: number): Internal.LocalDate;
        getCalendarType(): string;
        resolveDate(arg0: Internal.Map_<Internal.TemporalField_, number>, arg1: Internal.ResolverStyle_): Internal.LocalDate;
        isLeapYear(arg0: number): boolean;
        dateEpochDay(arg0: number): Internal.LocalDate;
        eras(): Internal.List<Internal.Era>;
        getDisplayName(arg0: Internal.TextStyle_, arg1: Internal.Locale_): string;
        equals(arg0: any): boolean;
        toString(): string;
        static readonly INSTANCE : Internal.IsoChronology;
        get calendarType(): string;
        get id(): string;
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    type IsoChronology_ = IsoChronology;
    interface AccessorIngredient {
    }
    type AccessorIngredient_ = AccessorIngredient;
    interface Accessible {
        getAccessibleContext(): Internal.AccessibleContext;
    }
    type Accessible_ = Accessible;
    class PanelScrollBar extends Internal.ScrollBar {
        static isMouseButtonDown(button: Internal.MouseButton_): boolean;
        closeGui(openPrevScreen: boolean): void;
        closeGui(): void;
        getClass(): Internal.Class<any>;
        setY(v: number): void;
        setCanAlwaysScrollPlane(v: boolean): void;
        collidesWith(x: number, y: number, w: number, h: number): boolean;
        setX(v: number): void;
        shouldDraw(): boolean;
        acceptGhostIngredient(ingredient: any): void;
        isGhostIngredientTarget(ingredient: any): boolean;
        run(): void;
        getGui(): Internal.BaseScreen;
        canMouseScroll(): boolean;
        mousePressed(button: Internal.MouseButton_): boolean;
        setPos(x: number, y: number): void;
        getTitle(): Internal.Component;
        static getClipboardString(): string;
        drawBackground(matrixStack: Internal.PoseStack_, theme: Internal.Theme_, x: number, y: number, w: number, h: number): void;
        static isCtrlKeyDown(): boolean;
        updateMouseOver(mouseX: number, mouseY: number): void;
        getScrollStep(): number;
        getScreen(): Internal.Window;
        getMouseY(): number;
        onClosed(): void;
        isMouseOver(): boolean;
        keyPressed(key: dev.ftb.mods.ftblibrary.ui.input.Key_): boolean;
        getMouseX(): number;
        openGui(): void;
        setPosAndSize(x: number, y: number, w: number, h: number): dev.ftb.mods.ftblibrary.ui.Widget;
        getMappedValue(max: number): number;
        tick(): void;
        setHeight(v: number): void;
        addMouseOverText(list: Internal.TooltipList_): void;
        setMaxValue(max: number): void;
        showValueOnMouseOver(): boolean;
        canMouseScrollPlane(): boolean;
        playClickSound(): void;
        handleClick(click: string): boolean;
        handleClick(scheme: string, path: string): boolean;
        isEnabled(): boolean;
        charTyped(c: string, modifiers: Internal.KeyModifiers_): boolean;
        getScrollBarSize(): number;
        setMinValue(min: number): void;
        mouseDoubleClicked(button: Internal.MouseButton_): boolean;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        mouseScrolled(scroll: number): boolean;
        getMaxValue(): number;
        notifyAll(): void;
        shouldAddMouseOverText(): boolean;
        openAfter(runnable: Internal.Runnable_): Internal.Runnable;
        drawScrollBar(matrixStack: Internal.PoseStack_, theme: Internal.Theme_, x: number, y: number, w: number, h: number): void;
        closeContextMenu(): void;
        notify(): void;
        mouseReleased(button: Internal.MouseButton_): void;
        setSize(w: number, h: number): void;
        hashCode(): number;
        getPartialTicks(): number;
        openGuiLater(): void;
        static isKeyDown(key: number): boolean;
        keyReleased(key: dev.ftb.mods.ftblibrary.ui.input.Key_): void;
        setCanAlwaysScroll(v: boolean): void;
        static setClipboardString(string: string): void;
        static isShiftKeyDown(): boolean;
        getCursor(): Internal.CursorType;
        setScrollStep(s: number): void;
        getWidgetType(): Internal.WidgetType;
        draw(matrixStack: Internal.PoseStack_, theme: Internal.Theme_, x: number, y: number, w: number, h: number): void;
        checkMouseOver(mouseX: number, mouseY: number): boolean;
        setWidth(v: number): void;
        onMoved(): void;
        getValue(): number;
        openContextMenu(panel: Internal.Panel_): void;
        getX(): number;
        getMinValue(): number;
        getY(): number;
        equals(arg0: any): boolean;
        setValue(v: number): void;
        toString(): string;
        getIngredientUnderMouse(): any;
        readonly plane : Internal.ScrollBar$Plane;
        posX : number;
        parent : Internal.Panel;
        posY : number;
        width : number;
        readonly panel : Internal.Panel;
        height : number;
        get mouseX(): number;
        get cursor(): Internal.CursorType;
        get ingredientUnderMouse(): any;
        get clipboardString(): string;
        get maxValue(): number;
        get mouseY(): number;
        get shiftKeyDown(): boolean;
        get mouseOver(): boolean;
        get screen(): Internal.Window;
        get scrollStep(): number;
        get title(): Internal.Component;
        get scrollBarSize(): number;
        get enabled(): boolean;
        get widgetType(): Internal.WidgetType;
        get ctrlKeyDown(): boolean;
        get minValue(): number;
        get x(): number;
        get y(): number;
        get gui(): Internal.BaseScreen;
        get class(): Internal.Class<any>;
        get value(): number;
        get partialTicks(): number;
        set canAlwaysScroll(v: boolean);
        set canAlwaysScrollPlane(v: boolean);
        set minValue(min: number);
        set clipboardString(string: string);
        set maxValue(max: number);
        set x(v: number);
        set y(v: number);
        set scrollStep(s: number);
        set value(v: number);
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    type PanelScrollBar_ = PanelScrollBar;
    abstract class Image {
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        getProperty(arg0: string, arg1: Internal.ImageObserver_): any;
        notifyAll(): void;
        getCapabilities(arg0: Internal.GraphicsConfiguration_): Internal.ImageCapabilities;
        getWidth(arg0: Internal.ImageObserver_): number;
        notify(): void;
        getScaledInstance(arg0: number, arg1: number, arg2: number): Internal.Image;
        setAccelerationPriority(arg0: number): void;
        getHeight(arg0: Internal.ImageObserver_): number;
        flush(): void;
        hashCode(): number;
        getSource(): Internal.ImageProducer;
        equals(arg0: any): boolean;
        getAccelerationPriority(): number;
        toString(): string;
        getGraphics(): Internal.Graphics;
        static readonly SCALE_DEFAULT : 1;
        static readonly UndefinedProperty : any;
        static readonly SCALE_FAST : 2;
        static readonly SCALE_AREA_AVERAGING : 16;
        static readonly SCALE_SMOOTH : 4;
        static readonly SCALE_REPLICATE : 8;
        get accelerationPriority(): number;
        get source(): Internal.ImageProducer;
        get graphics(): Internal.Graphics;
        get class(): Internal.Class<any>;
        set accelerationPriority(arg0: number);
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    type Image_ = Image;
    abstract class EffectRenderingInventoryScreen <T> extends Internal.AbstractContainerScreen<T> {
        renderComponentTooltip(arg0: Internal.PoseStack_, arg1: Internal.List_<Internal.FormattedText_>, arg2: number, arg3: number, arg4: net.minecraft.client.gui.Font_): void;
        renderComponentTooltip(arg0: Internal.PoseStack_, arg1: Internal.List_<Internal.FormattedText_>, arg2: number, arg3: number, arg4: Internal.ItemStack_): void;
        renderComponentTooltip(arg0: Internal.PoseStack_, arg1: Internal.List_<Internal.FormattedText_>, arg2: number, arg3: number, arg4: net.minecraft.client.gui.Font_, arg5: Internal.ItemStack_): void;
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        renderTooltip(arg0: Internal.PoseStack_, arg1: Internal.List_<Internal.Component_>, arg2: Internal.Optional_<Internal.TooltipComponent_>, arg3: number, arg4: number, arg5: Internal.ItemStack_): void;
        renderTooltip(arg0: Internal.PoseStack_, arg1: Internal.List_<Internal.Component_>, arg2: Internal.Optional_<Internal.TooltipComponent_>, arg3: number, arg4: number, arg5: net.minecraft.client.gui.Font_): void;
        renderTooltip(arg0: Internal.PoseStack_, arg1: Internal.List_<Internal.Component_>, arg2: Internal.Optional_<Internal.TooltipComponent_>, arg3: number, arg4: number, arg5: net.minecraft.client.gui.Font_, arg6: Internal.ItemStack_): void;
        renderTooltip(arg0: Internal.PoseStack_, arg1: Internal.List_<Internal.FormattedCharSequence_>, arg2: number, arg3: number, arg4: net.minecraft.client.gui.Font_): void;
        notifyAll(): void;
        handler$bmc000$renderSlot(arg0: Internal.PoseStack_, arg1: Internal.Slot_, arg2: Internal.CallbackInfo_): void;
        getYSize(): number;
        getMinecraft(): Internal.Minecraft;
        getGuiTop(): number;
        getGuiLeft(): number;
        notify(): void;
        static renderSlotHighlight(arg0: Internal.PoseStack_, arg1: number, arg2: number, arg3: number, arg4: number): void;
        hashCode(): number;
        equals(arg0: any): boolean;
        getSlotUnderMouse(): Internal.Slot;
        toString(): string;
        getSlotColor(arg0: number): number;
        getXSize(): number;
        tooltipFont : net.minecraft.client.gui.Font;
        get minecraft(): Internal.Minecraft;
        get slotUnderMouse(): Internal.Slot;
        get guiLeft(): number;
        get ySize(): number;
        get xSize(): number;
        get class(): Internal.Class<any>;
        get guiTop(): number;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    type EffectRenderingInventoryScreen_<T> = EffectRenderingInventoryScreen<T>;
    interface IRecipeSlotsView {
        findSlotByName(arg0: string): Internal.Optional<Internal.IRecipeSlotView>;
        getSlotViews(arg0: Internal.RecipeIngredientRole_): Internal.List<Internal.IRecipeSlotView>;
        getSlotViews(): Internal.List<Internal.IRecipeSlotView>;
    }
    type IRecipeSlotsView_ = IRecipeSlotsView;
    class ForgeConfigSpec$Range <V> implements Internal.Predicate<any> {
        getClass(): Internal.Class<any>;
        getClazz(): Internal.Class<V>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        or(arg0: Internal.Predicate_<any>): Internal.Predicate<any>;
        correct(arg0: any, arg1: any): any;
        test(arg0: any): boolean;
        getMax(): V;
        notifyAll(): void;
        notify(): void;
        getMin(): V;
        and(arg0: Internal.Predicate_<any>): Internal.Predicate<any>;
        negate(): Internal.Predicate<any>;
        hashCode(): number;
        equals(arg0: any): boolean;
        toString(): string;
        get min(): V;
        get max(): V;
        get class(): Internal.Class<any>;
        get clazz(): Internal.Class<V>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    type ForgeConfigSpec$Range_<V> = ForgeConfigSpec$Range<V>;
    class SoundEventBuilder extends Internal.BuilderBase<Internal.SoundEvent> {
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        clientRegistry(minecraft: Internal.Minecraft_): void;
        generateAssetJsons(generator: Internal.AssetJsonGenerator_): void;
        transformObject(obj: Internal.SoundEvent_): Internal.SoundEvent;
        translationKey(key: string): Internal.BuilderBase<Internal.SoundEvent>;
        getTranslationKeyGroup(): string;
        newID(pre: string, post: string): ResourceLocation;
        displayName(name: string): Internal.BuilderBase<Internal.SoundEvent>;
        notifyAll(): void;
        generateLang(lang: Internal.Map_<string, string>): void;
        type(type: string): Internal.BuilderBase<Internal.SoundEvent>;
        notify(): void;
        createAdditionalObjects(): void;
        createObject(): Internal.SoundEvent;
        addResourcePackLocations(path: string, list: Internal.List_<ResourceLocation_>, packType: Internal.PackType_): void;
        hashCode(): number;
        equals(arg0: any): boolean;
        get(): Internal.SoundEvent;
        getRegistryType(): Internal.RegistryObjectBuilderTypes<Internal.SoundEvent>;
        toString(): string;
        tag(tag: ResourceLocation_): Internal.BuilderBase<Internal.SoundEvent>;
        generateDataJsons(generator: Internal.DataJsonGenerator_): void;
        readonly id : ResourceLocation;
        get registryType(): Internal.RegistryObjectBuilderTypes<Internal.SoundEvent>;
        get class(): Internal.Class<any>;
        get translationKeyGroup(): string;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    type SoundEventBuilder_ = SoundEventBuilder;
    class Quest extends Internal.QuestObject implements Internal.Movable {
        getClass(): Internal.Class<any>;
        hasDependency(object: Internal.QuestObject_): boolean;
        isProgressionIgnored(): boolean;
        getMutableTitle(): Internal.MutableComponent;
        getSubtitle(): Internal.Component;
        moved(nx: number, ny: number, nc: number): void;
        getTags(): Internal.Set<string>;
        static getCodeString(object: Internal.QuestObjectBase_): string;
        getCodeString(): string;
        static getCodeString(id: number): string;
        writeData(nbt: Internal.CompoundTag_): void;
        createSubGroup(group: Internal.ConfigGroup_): Internal.ConfigGroup;
        editedFromGUIOnServer(): void;
        forceProgress(teamData: Internal.TeamData_, progressChange: Internal.ProgressChange_): void;
        isCompletedRaw(data: Internal.TeamData_): boolean;
        getTitle(): Internal.Component;
        verifyDependencies(autofix: boolean): boolean;
        getPath(): string;
        clearCachedData(): void;
        static parseCodeString(id: string): number;
        readData(nbt: Internal.CompoundTag_): void;
        editedFromGUI(): void;
        hasTag(tag: string): boolean;
        onCompleted(data: Internal.QuestProgressEventData_<any>): void;
        static getID(object: Internal.QuestObjectBase_): number;
        isVisible(data: Internal.TeamData_): boolean;
        onEditButtonClicked(gui: Internal.Runnable_): void;
        getChildren(): Internal.Collection<Internal.QuestObject>;
        onStarted(data: Internal.QuestProgressEventData_<any>): void;
        getAltTitle(): Internal.Component;
        deleteSelf(): void;
        cacheProgress(): boolean;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        deleteChildren(): void;
        readNetData(buffer: Internal.FriendlyByteBuf_): void;
        notifyAll(): void;
        getShape(): string;
        getWidth(): number;
        getDescription(): Internal.Component[];
        notify(): void;
        getChapter(): Internal.Chapter;
        getHeight(): number;
        getRelativeProgressFromChildren(data: Internal.TeamData_): number;
        static getRelativeProgressFromChildren(progressSum: number, count: number): number;
        hashCode(): number;
        getAltIcon(): Internal.Icon;
        getObjectType(): Internal.QuestObjectType;
        hasUnclaimedRewardsRaw(teamData: Internal.TeamData_, player: Internal.UUID_): boolean;
        getParentID(): number;
        getProgressColor(data: Internal.TeamData_, dim: boolean): Internal.Color4I;
        getProgressColor(data: Internal.TeamData_): Internal.Color4I;
        move(to: Internal.Chapter_, x: number, y: number): void;
        getDependants(): Internal.List<Internal.QuestObject>;
        refreshJEI(): number;
        getQuestChapter(): Internal.Chapter;
        removeInvalidDependencies(): void;
        getQuestFile(): Internal.QuestFile;
        getHideDependencyLines(): boolean;
        writeNetData(buffer: Internal.FriendlyByteBuf_): void;
        getConfig(config: Internal.ConfigGroup_): void;
        getIcon(): Internal.Icon;
        drawMoved(matrixStack: Internal.PoseStack_): void;
        forceProgressRaw(teamData: Internal.TeamData_, progressChange: Internal.ProgressChange_): void;
        getX(): number;
        getY(): number;
        static isNull(object: Internal.QuestObjectBase_): boolean;
        equals(object: any): boolean;
        toString(): string;
        static titleToID(s: string): Internal.Optional<string>;
        onCreated(): void;
        disableToast : boolean;
        chapter : Internal.Chapter;
        dependencyRequirement : Internal.DependencyRequirement;
        disableJEI : Internal.Tristate;
        minRequiredDependencies : number;
        icon : Internal.ItemStack;
        readonly description : Internal.List<string>;
        title : string;
        guidePage : string;
        hideDependencyLines : Internal.Tristate;
        id : number;
        readonly tasks : Internal.List<Internal.Task>;
        shape : string;
        optional : boolean;
        minWidth : number;
        readonly dependencies : Internal.List<Internal.QuestObject>;
        hideTextUntilComplete : Internal.Tristate;
        hide : Internal.Tristate;
        size : number;
        subtitle : string;
        x : number;
        invalid : boolean;
        y : number;
        static sendNotifications : Internal.Tristate;
        readonly rewards : Internal.List<Internal.Reward>;
        get progressionIgnored(): boolean;
        get codeString(): string;
        get questFile(): Internal.QuestFile;
        get parentID(): number;
        get mutableTitle(): Internal.MutableComponent;
        get tags(): Internal.Set<string>;
        get altIcon(): Internal.Icon;
        get objectType(): Internal.QuestObjectType;
        get path(): string;
        get children(): Internal.Collection<Internal.QuestObject>;
        get dependants(): Internal.List<Internal.QuestObject>;
        get width(): number;
        get altTitle(): Internal.Component;
        get class(): Internal.Class<any>;
        get height(): number;
        get questChapter(): Internal.Chapter;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    type Quest_ = Quest;
    interface Table <R, C, V> {
        cellSet(): Internal.Set<Internal.Table$Cell<R, C, V>>;
        values(): Internal.Collection<V>;
        column(arg0: C): Internal.Map<R, V>;
        isEmpty(): boolean;
        clear(): void;
        containsValue(arg0: any): boolean;
        put(arg0: R, arg1: C, arg2: V): V;
        remove(arg0: any, arg1: any): V;
        columnMap(): Internal.Map<C, Internal.Map<R, V>>;
        contains(arg0: any, arg1: any): boolean;
        containsColumn(arg0: any): boolean;
        size(): number;
        columnKeySet(): Internal.Set<C>;
        hashCode(): number;
        putAll(arg0: Internal.Table_<R, C, V>): void;
        equals(arg0: any): boolean;
        get(arg0: any, arg1: any): V;
        rowKeySet(): Internal.Set<R>;
        rowMap(): Internal.Map<R, Internal.Map<C, V>>;
        row(arg0: R): Internal.Map<C, V>;
        containsRow(arg0: any): boolean;
    }
    type Table_<R, C, V> = Table<R, C, V>;
    interface Movable {
        drawMoved(matrixStack: Internal.PoseStack_): void;
        getHeight(): number;
        getX(): number;
        move(arg0: Internal.Chapter_, arg1: number, arg2: number): void;
        getY(): number;
        getShape(): string;
        getWidth(): number;
        getChapter(): Internal.Chapter;
    }
    type Movable_ = Movable;
    interface Collection <E> extends Internal.Iterable<E> {
        add(arg0: E): boolean;
        spliterator(): Internal.Spliterator<E>;
        forEach(arg0: Internal.Consumer_<E>): void;
        containsAll(arg0: Internal.Collection_<any>): boolean;
        isEmpty(): boolean;
        clear(): void;
        remove(arg0: any): boolean;
        removeIf(arg0: Internal.Predicate_<E>): boolean;
        removeAll(arg0: Internal.Collection_<any>): boolean;
        contains(arg0: any): boolean;
        iterator(): Internal.Iterator<E>;
        size(): number;
        addAll(arg0: Internal.Collection_<E>): boolean;
        stream(): Internal.Stream<E>;
        hashCode(): number;
        equals(arg0: any): boolean;
        toArray<T_>(arg0: T_[]): T_[];
        toArray<T_>(arg0: Internal.IntFunction_<T_[]>): T_[];
        toArray(): any[];
        parallelStream(): Internal.Stream<E>;
        retainAll(arg0: Internal.Collection_<any>): boolean;
    }
    type Collection_<E> = Collection<E>;
    class ClassWrapper <T> extends Internal.Record implements Internal.CustomJavaToJsWrapper {
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        wrappedClass(): Internal.Class<T>;
        hashCode(): number;
        notifyAll(): void;
        equals(o: any): boolean;
        toString(): string;
        convertJavaToJs(cx: Internal.Context_, scope: Internal.Scriptable_, staticType: Internal.Class_<any>): Internal.Scriptable;
        notify(): void;
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    type ClassWrapper_<T> = ClassWrapper<T>;
    abstract class EntityEventJS extends Internal.LevelEventJS {
        cancel(): void;
        getServer(): Internal.ServerJS;
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        isCancelled(): boolean;
        notifyAll(): void;
        getEntity(): Internal.EntityJS;
        notify(): void;
        getLevel(): Internal.LevelJS;
        post(id: string): boolean;
        post(id: string, sub: string): boolean;
        post(t: Internal.ScriptType_, id: string, sub: string): boolean;
        post(t: Internal.ScriptType_, id: string): boolean;
        hashCode(): number;
        equals(arg0: any): boolean;
        toString(): string;
        canCancel(): boolean;
        get server(): Internal.ServerJS;
        get level(): Internal.LevelJS;
        get cancelled(): boolean;
        get class(): Internal.Class<any>;
        get entity(): Internal.EntityJS;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    type EntityEventJS_ = EntityEventJS;
    interface IForgeBlockState {
        rotate(arg0: Internal.LevelAccessor_, arg1: BlockPos_, arg2: Internal.Rotation_): Internal.BlockState;
        getStateAtViewpoint(arg0: Internal.BlockGetter_, arg1: BlockPos_, arg2: Vec3_): Internal.BlockState;
        onBlockExploded(arg0: Internal.Level_, arg1: BlockPos_, arg2: Internal.Explosion_): void;
        getBedDirection(arg0: Internal.LevelReader_, arg1: BlockPos_): Internal.Direction;
        getExpDrop(arg0: Internal.LevelReader_, arg1: BlockPos_, arg2: number, arg3: number): number;
        isConduitFrame(arg0: Internal.LevelReader_, arg1: BlockPos_, arg2: BlockPos_): boolean;
        getLightEmission(arg0: Internal.BlockGetter_, arg1: BlockPos_): number;
        onDestroyedByPlayer(arg0: Internal.Level_, arg1: BlockPos_, arg2: Internal.Player_, arg3: boolean, arg4: Internal.FluidState_): boolean;
        isBed(arg0: Internal.BlockGetter_, arg1: BlockPos_, arg2: Internal.LivingEntity_): boolean;
        canHarvestBlock(arg0: Internal.BlockGetter_, arg1: BlockPos_, arg2: Internal.Player_): boolean;
        shouldCheckWeakPower(arg0: Internal.LevelReader_, arg1: BlockPos_, arg2: Internal.Direction_): boolean;
        collisionExtendsVertically(arg0: Internal.BlockGetter_, arg1: BlockPos_, arg2: Internal.Entity_): boolean;
        supportsExternalFaceHiding(): boolean;
        isLadder(arg0: Internal.LevelReader_, arg1: BlockPos_, arg2: Internal.LivingEntity_): boolean;
        addLandingEffects(arg0: Internal.ServerLevel_, arg1: BlockPos_, arg2: Internal.BlockState_, arg3: Internal.LivingEntity_, arg4: number): boolean;
        shouldDisplayFluidOverlay(arg0: Internal.BlockAndTintGetter_, arg1: BlockPos_, arg2: Internal.FluidState_): boolean;
        getSoundType(arg0: Internal.LevelReader_, arg1: BlockPos_, arg2: Internal.Entity_): Internal.SoundType;
        canStickTo(arg0: Internal.BlockState_): boolean;
        addRunningEffects(arg0: Internal.Level_, arg1: BlockPos_, arg2: Internal.Entity_): boolean;
        onNeighborChange(arg0: Internal.LevelReader_, arg1: BlockPos_, arg2: BlockPos_): void;
        hidesNeighborFace(arg0: Internal.BlockGetter_, arg1: BlockPos_, arg2: Internal.BlockState_, arg3: Internal.Direction_): boolean;
        getWeakChanges(arg0: Internal.LevelReader_, arg1: BlockPos_): boolean;
        canEntityDestroy(arg0: Internal.BlockGetter_, arg1: BlockPos_, arg2: Internal.Entity_): boolean;
        isBurning(arg0: Internal.BlockGetter_, arg1: BlockPos_): boolean;
        getCloneItemStack(arg0: Internal.HitResult_, arg1: Internal.BlockGetter_, arg2: BlockPos_, arg3: Internal.Player_): Internal.ItemStack;
        getFriction(arg0: Internal.LevelReader_, arg1: BlockPos_, arg2: Internal.Entity_): number;
        isFlammable(arg0: Internal.BlockGetter_, arg1: BlockPos_, arg2: Internal.Direction_): boolean;
        isValidSpawn(arg0: Internal.LevelReader_, arg1: BlockPos_, arg2: Internal.SpawnPlacements$Type_, arg3: Internal.EntityType_<any>): boolean;
        isPortalFrame(arg0: Internal.BlockGetter_, arg1: BlockPos_): boolean;
        getBlockPathType(arg0: Internal.BlockGetter_, arg1: BlockPos_): Internal.BlockPathTypes;
        getBlockPathType(arg0: Internal.BlockGetter_, arg1: BlockPos_, arg2: Internal.Mob_): Internal.BlockPathTypes;
        getExplosionResistance(arg0: Internal.BlockGetter_, arg1: BlockPos_, arg2: Internal.Explosion_): number;
        canSustainPlant(arg0: Internal.BlockGetter_, arg1: BlockPos_, arg2: Internal.Direction_, arg3: Internal.IPlantable_): boolean;
        isScaffolding(arg0: Internal.LivingEntity_): boolean;
        onCaughtFire(arg0: Internal.Level_, arg1: BlockPos_, arg2: Internal.Direction_, arg3: Internal.LivingEntity_): void;
        getEnchantPowerBonus(arg0: Internal.LevelReader_, arg1: BlockPos_): number;
        setBedOccupied(arg0: Internal.Level_, arg1: BlockPos_, arg2: Internal.LivingEntity_, arg3: boolean): void;
        isFireSource(arg0: Internal.LevelReader_, arg1: BlockPos_, arg2: Internal.Direction_): boolean;
        canDropFromExplosion(arg0: Internal.BlockGetter_, arg1: BlockPos_, arg2: Internal.Explosion_): boolean;
        getRespawnPosition(arg0: Internal.EntityType_<any>, arg1: Internal.LevelReader_, arg2: BlockPos_, arg3: number, arg4: Internal.LivingEntity_): Internal.Optional<Vec3>;
        canRedstoneConnectTo(arg0: Internal.BlockGetter_, arg1: BlockPos_, arg2: Internal.Direction_): boolean;
        isStickyBlock(): boolean;
        isFertile(arg0: Internal.BlockGetter_, arg1: BlockPos_): boolean;
        isSlimeBlock(): boolean;
        getFireSpreadSpeed(arg0: Internal.BlockGetter_, arg1: BlockPos_, arg2: Internal.Direction_): number;
        getFlammability(arg0: Internal.BlockGetter_, arg1: BlockPos_, arg2: Internal.Direction_): number;
        getToolModifiedState(arg0: Internal.UseOnContext_, arg1: Internal.ToolAction_, arg2: boolean): Internal.BlockState;
        getToolModifiedState(arg0: Internal.Level_, arg1: BlockPos_, arg2: Internal.Player_, arg3: Internal.ItemStack_, arg4: Internal.ToolAction_): Internal.BlockState;
        getBeaconColorMultiplier(arg0: Internal.LevelReader_, arg1: BlockPos_, arg2: BlockPos_): number[];
    }
    type IForgeBlockState_ = IForgeBlockState;
    abstract class ImmutableCollection$Builder <E> {
        add(arg0: E): Internal.ImmutableCollection$Builder<E>;
        add(arg0: E[]): Internal.ImmutableCollection$Builder<E>;
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        build(): Internal.ImmutableCollection<E>;
        addAll(arg0: Internal.Iterator_<E>): Internal.ImmutableCollection$Builder<E>;
        addAll(arg0: Internal.Iterable_<E>): Internal.ImmutableCollection$Builder<E>;
        hashCode(): number;
        notifyAll(): void;
        equals(arg0: any): boolean;
        toString(): string;
        notify(): void;
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    type ImmutableCollection$Builder_<E> = ImmutableCollection$Builder<E>;
    abstract class VoxelShape {
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        hashCode(): number;
        notifyAll(): void;
        equals(arg0: any): boolean;
        toString(): string;
        notify(): void;
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    type VoxelShape_ = VoxelShape;
    interface AccessorLivingEntity {
        setUseItemRemaining(arg0: number): void;
        callCreateLootContext(arg0: boolean, arg1: Internal.DamageSource_): Internal.LootContext$Builder;
    }
    type AccessorLivingEntity_ = AccessorLivingEntity;
    interface Iterable <T> {
        iterator(): Internal.Iterator<T>;
        spliterator(): Internal.Spliterator<T>;
        forEach(arg0: Internal.Consumer_<T>): void;
    }
    type Iterable_<T> = Iterable<T>;
    abstract class ShortBuffer extends Internal.Buffer implements Internal.Comparable<Internal.ShortBuffer> {
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        compact(): Internal.ShortBuffer;
        notifyAll(): void;
        compareTo(arg0: Internal.ShortBuffer_): number;
        notify(): void;
        asReadOnlyBuffer(): Internal.ShortBuffer;
        put(arg0: number[]): Internal.ShortBuffer;
        put(arg0: number, arg1: number[], arg2: number, arg3: number): Internal.ShortBuffer;
        put(arg0: number, arg1: number[]): Internal.ShortBuffer;
        put(arg0: number[], arg1: number, arg2: number): Internal.ShortBuffer;
        put(arg0: number, arg1: Internal.ShortBuffer_, arg2: number, arg3: number): Internal.ShortBuffer;
        put(arg0: Internal.ShortBuffer_): Internal.ShortBuffer;
        put(arg0: number, arg1: number): Internal.ShortBuffer;
        put(arg0: number): Internal.ShortBuffer;
        capacity(): number;
        isReadOnly(): boolean;
        slice(arg0: number, arg1: number): Internal.ShortBuffer;
        slice(): Internal.ShortBuffer;
        array(): number[];
        hashCode(): number;
        get(): number;
        get(arg0: number, arg1: number[]): Internal.ShortBuffer;
        get(arg0: number): number;
        get(arg0: number, arg1: number[], arg2: number, arg3: number): Internal.ShortBuffer;
        get(arg0: number[], arg1: number, arg2: number): Internal.ShortBuffer;
        get(arg0: number[]): Internal.ShortBuffer;
        limit(arg0: number): Internal.ShortBuffer;
        limit(): number;
        arrayOffset(): number;
        flip(): Internal.ShortBuffer;
        order(): Internal.ByteOrder;
        hasArray(): boolean;
        hasRemaining(): boolean;
        clear(): Internal.ShortBuffer;
        duplicate(): Internal.ShortBuffer;
        remaining(): number;
        static allocate(arg0: number): Internal.ShortBuffer;
        rewind(): Internal.ShortBuffer;
        mismatch(arg0: Internal.ShortBuffer_): number;
        equals(arg0: any): boolean;
        reset(): Internal.ShortBuffer;
        toString(): string;
        position(arg0: number): Internal.ShortBuffer;
        position(): number;
        isDirect(): boolean;
        static wrap(arg0: number[]): Internal.ShortBuffer;
        static wrap(arg0: number[], arg1: number, arg2: number): Internal.ShortBuffer;
        mark(): Internal.ShortBuffer;
        get direct(): boolean;
        get readOnly(): boolean;
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    type ShortBuffer_ = ShortBuffer;
    class EventPriority extends Internal.Enum<Internal.EventPriority> implements Internal.IEventListener {
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        static valueOf(arg0: string): Internal.EventPriority;
        static valueOf<T_>(arg0: Internal.Class_<T_>, arg1: string): T_;
        notifyAll(): void;
        static values(): Internal.EventPriority[];
        invoke(arg0: Internal.Event_): void;
        compareTo(arg0: Internal.EventPriority_): number;
        describeConstable(): Internal.Optional<Internal.Enum$EnumDesc<Internal.EventPriority>>;
        notify(): void;
        getDeclaringClass(): Internal.Class<Internal.EventPriority>;
        hashCode(): number;
        listenerName(): string;
        equals(arg0: any): boolean;
        name(): string;
        toString(): string;
        ordinal(): number;
        static readonly LOWEST : Internal.EventPriority;
        static readonly HIGH : Internal.EventPriority;
        static readonly LOW : Internal.EventPriority;
        static readonly HIGHEST : Internal.EventPriority;
        static readonly NORMAL : Internal.EventPriority;
        get class(): Internal.Class<any>;
        get declaringClass(): Internal.Class<Internal.EventPriority>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    type EventPriority_ = "normal" | "high" | "highest" | "low" | "lowest" | EventPriority;
    class BiomeSpecialEffects$GrassColorModifier extends Internal.Enum<Internal.BiomeSpecialEffects$GrassColorModifier> implements Internal.StringRepresentable, Internal.IExtensibleEnum {
        getClass(): Internal.Class<any>;
        init(): void;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        static valueOf(arg0: string): Internal.BiomeSpecialEffects$GrassColorModifier;
        static valueOf<T_>(arg0: Internal.Class_<T_>, arg1: string): T_;
        notifyAll(): void;
        static values(): Internal.BiomeSpecialEffects$GrassColorModifier[];
        compareTo(arg0: Internal.BiomeSpecialEffects$GrassColorModifier_): number;
        describeConstable(): Internal.Optional<Internal.Enum$EnumDesc<Internal.BiomeSpecialEffects$GrassColorModifier>>;
        notify(): void;
        getDeclaringClass(): Internal.Class<Internal.BiomeSpecialEffects$GrassColorModifier>;
        hashCode(): number;
        equals(arg0: any): boolean;
        name(): string;
        static create(arg0: string, arg1: string, arg2: Internal.BiomeSpecialEffects$GrassColorModifier$ColorModifier_): Internal.BiomeSpecialEffects$GrassColorModifier;
        toString(): string;
        ordinal(): number;
        static readonly SWAMP : Internal.BiomeSpecialEffects$GrassColorModifier;
        static readonly NONE : Internal.BiomeSpecialEffects$GrassColorModifier;
        static readonly DARK_FOREST : Internal.BiomeSpecialEffects$GrassColorModifier;
        get class(): Internal.Class<any>;
        get declaringClass(): Internal.Class<Internal.BiomeSpecialEffects$GrassColorModifier>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    type BiomeSpecialEffects$GrassColorModifier_ = "twilightforest:enchanted_forest" | "twilightforest:swamp" | "twilightforest:dark_forest_center" | "dark_forest" | "twilightforest:spooky_forest" | "twilightforest:dark_forest" | "none" | "swamp" | BiomeSpecialEffects$GrassColorModifier;
    interface ICustomPacket <T> {
        setName(arg0: ResourceLocation_): void;
        getThis(): T;
        getName(): ResourceLocation;
        getDirection(): Internal.NetworkDirection;
        getIndex(): number;
        setData(arg0: Internal.FriendlyByteBuf_): void;
        setIndex(arg0: number): void;
        getInternalData(): Internal.FriendlyByteBuf;
    }
    type ICustomPacket_<T> = ICustomPacket<T>;
    interface ExclusionStrategy {
        shouldSkipClass(arg0: Internal.Class_<any>): boolean;
        shouldSkipField(arg0: Internal.FieldAttributes_): boolean;
    }
    type ExclusionStrategy_ = ExclusionStrategy;
    interface Short2ReferenceFunction <V> extends Internal.Function<number, V>, Internal.IntFunction<V> {
        getOrDefault(arg0: number, arg1: V): V;
        getOrDefault(arg0: any, arg1: V): V;
        andThenShort(arg0: Internal.Reference2ShortFunction_<V>): Internal.Short2ShortFunction;
        composeByte(arg0: Internal.Byte2ShortFunction_): Internal.Byte2ReferenceFunction<V>;
        andThenInt(arg0: Internal.Reference2IntFunction_<V>): Internal.Short2IntFunction;
        andThen<V_>(arg0: java_.util.function_.Function_<V, V_>): java_.util.function_.Function<number, V_>;
        composeReference<T_>(arg0: Internal.Reference2ShortFunction_<T_>): Internal.Reference2ReferenceFunction<T_, V>;
        put(arg0: number, arg1: V): V;
        remove(arg0: any): V;
        remove(arg0: number): V;
        defaultReturnValue(arg0: V): void;
        defaultReturnValue(): V;
        andThenDouble(arg0: Internal.Reference2DoubleFunction_<V>): Internal.Short2DoubleFunction;
        andThenObject<T_>(arg0: Internal.Reference2ObjectFunction_<V, T_>): Internal.Short2ObjectFunction<T_>;
        get(arg0: any): V;
        get(arg0: number): V;
        andThenLong(arg0: Internal.Reference2LongFunction_<V>): Internal.Short2LongFunction;
        composeLong(arg0: Internal.Long2ShortFunction_): Internal.Long2ReferenceFunction<V>;
        andThenByte(arg0: Internal.Reference2ByteFunction_<V>): Internal.Short2ByteFunction;
        andThenFloat(arg0: Internal.Reference2FloatFunction_<V>): Internal.Short2FloatFunction;
        apply(arg0: number): V;
        containsKey(arg0: any): boolean;
        containsKey(arg0: number): boolean;
        composeInt(arg0: Internal.Int2ShortFunction_): Internal.Int2ReferenceFunction<V>;
        clear(): void;
        composeFloat(arg0: Internal.Float2ShortFunction_): Internal.Float2ReferenceFunction<V>;
        andThenChar(arg0: Internal.Reference2CharFunction_<V>): Internal.Short2CharFunction;
        composeObject<T_>(arg0: Internal.Object2ShortFunction_<T_>): Internal.Object2ReferenceFunction<T_, V>;
        size(): number;
        compose<T_>(arg0: java_.util.function_.Function_<T_, number>): java_.util.function_.Function<T_, V>;
        composeShort(arg0: Internal.Short2ShortFunction_): Internal.Short2ReferenceFunction<V>;
        andThenReference<T_>(arg0: Internal.Reference2ReferenceFunction_<V, T_>): Internal.Short2ReferenceFunction<T_>;
        composeChar(arg0: Internal.Char2ShortFunction_): Internal.Char2ReferenceFunction<V>;
        composeDouble(arg0: Internal.Double2ShortFunction_): Internal.Double2ReferenceFunction<V>;
    }
    type Short2ReferenceFunction_<V> = ((arg0: number) => V) | Short2ReferenceFunction<V>;
    class Byte2ObjectOpenHashMap <V> extends Internal.AbstractByte2ObjectMap<V> implements Internal.Serializable, Internal.Cloneable, Internal.Hash {
        getClass(): Internal.Class<any>;
        getOrDefault(arg0: number, arg1: V): V;
        getOrDefault(arg0: any, arg1: V): V;
        replace(arg0: number, arg1: V, arg2: V): boolean;
        replace(arg0: number, arg1: V): V;
        composeByte(arg0: Internal.Byte2ByteFunction_): Internal.Byte2ObjectFunction<V>;
        andThen<V_>(arg0: java_.util.function_.Function_<V, V_>): java_.util.function_.Function<number, V_>;
        composeReference<T_>(arg0: Internal.Reference2ByteFunction_<T_>): Internal.Reference2ObjectFunction<T_, V>;
        containsValue(arg0: any): boolean;
        put(arg0: number, arg1: V): V;
        compute(arg0: number, arg1: Internal.BiFunction_<number, V, V>): V;
        defaultReturnValue(arg0: V): void;
        defaultReturnValue(): V;
        andThenObject<T_>(arg0: Internal.Object2ObjectFunction_<V, T_>): Internal.Byte2ObjectFunction<T_>;
        trim(arg0: number): boolean;
        trim(): boolean;
        merge(arg0: number, arg1: V, arg2: Internal.BiFunction_<V, V, V>): V;
        composeLong(arg0: Internal.Long2ByteFunction_): Internal.Long2ObjectFunction<V>;
        entrySet(): Internal.ObjectSet<Internal.Map$Entry<number, V>>;
        containsKey(arg0: number): boolean;
        containsKey(arg0: any): boolean;
        composeObject<T_>(arg0: Internal.Object2ByteFunction_<T_>): Internal.Object2ObjectFunction<T_, V>;
        size(): number;
        compose<T_>(arg0: java_.util.function_.Function_<T_, number>): java_.util.function_.Function<T_, V>;
        composeShort(arg0: Internal.Short2ByteFunction_): Internal.Short2ObjectFunction<V>;
        composeChar(arg0: Internal.Char2ByteFunction_): Internal.Char2ObjectFunction<V>;
        composeDouble(arg0: Internal.Double2ByteFunction_): Internal.Double2ObjectFunction<V>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        notifyAll(): void;
        computeIfAbsent(arg0: number, arg1: Internal.IntFunction_<V>): V;
        computeIfAbsent(arg0: number, arg1: Internal.Byte2ObjectFunction_<V>): V;
        computeIfAbsent(arg0: number, arg1: java_.util.function_.Function_<number, V>): V;
        values(): Internal.ObjectCollection<V>;
        andThenShort(arg0: Internal.Object2ShortFunction_<V>): Internal.Byte2ShortFunction;
        computeIfAbsentPartial(arg0: number, arg1: Internal.Byte2ObjectFunction_<V>): V;
        replaceAll(arg0: Internal.BiFunction_<number, V, V>): void;
        andThenInt(arg0: Internal.Object2IntFunction_<V>): Internal.Byte2IntFunction;
        notify(): void;
        remove(arg0: number, arg1: any): boolean;
        remove(arg0: number): V;
        remove(arg0: any): V;
        remove(arg0: any, arg1: any): boolean;
        byte2ObjectEntrySet(): Internal.Byte2ObjectMap$FastEntrySet<V>;
        andThenDouble(arg0: Internal.Object2DoubleFunction_<V>): Internal.Byte2DoubleFunction;
        hashCode(): number;
        putAll(arg0: Internal.Map_<number, V>): void;
        get(arg0: number): V;
        get(arg0: any): V;
        andThenLong(arg0: Internal.Object2LongFunction_<V>): Internal.Byte2LongFunction;
        keySet(): Internal.ByteSet;
        andThenByte(arg0: Internal.Object2ByteFunction_<V>): Internal.Byte2ByteFunction;
        andThenFloat(arg0: Internal.Object2FloatFunction_<V>): Internal.Byte2FloatFunction;
        apply(arg0: number): V;
        forEach(arg0: Internal.BiConsumer_<number, V>): void;
        composeInt(arg0: Internal.Int2ByteFunction_): Internal.Int2ObjectFunction<V>;
        isEmpty(): boolean;
        clear(): void;
        composeFloat(arg0: Internal.Float2ByteFunction_): Internal.Float2ObjectFunction<V>;
        andThenChar(arg0: Internal.Object2CharFunction_<V>): Internal.Byte2CharFunction;
        computeIfPresent(arg0: number, arg1: Internal.BiFunction_<number, V, V>): V;
        equals(arg0: any): boolean;
        andThenReference<T_>(arg0: Internal.Object2ReferenceFunction_<V, T_>): Internal.Byte2ReferenceFunction<T_>;
        clone(): Internal.Byte2ObjectOpenHashMap<V>;
        toString(): string;
        putIfAbsent(arg0: number, arg1: V): V;
        static readonly DEFAULT_GROWTH_FACTOR : 16;
        static readonly FAST_LOAD_FACTOR : 0.5;
        static readonly DEFAULT_INITIAL_SIZE : 16;
        static readonly DEFAULT_LOAD_FACTOR : 0.75;
        static readonly OCCUPIED : -1;
        static readonly VERY_FAST_LOAD_FACTOR : 0.25;
        static readonly FREE : 0;
        static readonly PRIMES : number[];
        static readonly REMOVED : 1;
        get class(): Internal.Class<any>;
        get empty(): boolean;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    type Byte2ObjectOpenHashMap_<V> = Byte2ObjectOpenHashMap<V>;
    interface DoubleSpliterator extends Internal.Spliterator$OfDouble {
        trySplit(): Internal.DoubleSpliterator;
        characteristics(): number;
        tryAdvance(arg0: Internal.Consumer_<number>): boolean;
        tryAdvance(arg0: Internal.DoubleConsumer_): boolean;
        tryAdvance(arg0: java_.util.function_.DoubleConsumer_): boolean;
        getComparator(): Internal.DoubleComparator;
        getExactSizeIfKnown(): number;
        estimateSize(): number;
        skip(arg0: number): number;
        hasCharacteristics(arg0: number): boolean;
        forEachRemaining(arg0: Internal.Consumer_<number>): void;
        forEachRemaining(arg0: Internal.DoubleConsumer_): void;
        forEachRemaining(arg0: java_.util.function_.DoubleConsumer_): void;
    }
    type DoubleSpliterator_ = DoubleSpliterator;
    interface TemporalAdjuster {
        adjustInto(arg0: Internal.Temporal_): Internal.Temporal;
    }
    type TemporalAdjuster_ = ((arg0: Internal.Temporal) => Internal.Temporal) | TemporalAdjuster;
    interface IRecipeLayoutBuilder {
        moveRecipeTransferButton(arg0: number, arg1: number): void;
        addSlot(arg0: Internal.RecipeIngredientRole_, arg1: number, arg2: number): Internal.IRecipeSlotBuilder;
        addInvisibleIngredients(arg0: Internal.RecipeIngredientRole_): Internal.IIngredientAcceptor<any>;
        createFocusLink(arg0: Internal.IRecipeSlotBuilder_[]): void;
        createFocusLink(arg0: Internal.IIngredientAcceptor_<any>[]): void;
        setShapeless(arg0: number, arg1: number): void;
        setShapeless(): void;
    }
    type IRecipeLayoutBuilder_ = IRecipeLayoutBuilder;
    class Material {
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        hashCode(): number;
        notifyAll(): void;
        equals(arg0: any): boolean;
        toString(): string;
        notify(): void;
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    type Material_ = Material;
    class WoodenButtonBlockBuilder extends Internal.ShapedBlockBuilder {
        noItem(): Internal.BlockBuilder;
        suffocating(b: boolean): Internal.BlockBuilder;
        getClass(): Internal.Class<any>;
        translationKey(key: string): Internal.BuilderBase<Internal.Block>;
        newID(pre: string, post: string): ResourceLocation;
        type(type: string): Internal.BuilderBase<Internal.Block>;
        unbreakable(): Internal.BlockBuilder;
        model(m: string): Internal.BlockBuilder;
        tag(tag: ResourceLocation_): Internal.BlockBuilder;
        generateDataJsons(generator: Internal.DataJsonGenerator_): void;
        tagBoth(tag: ResourceLocation_): Internal.BlockBuilder;
        defaultCutout(): Internal.BlockBuilder;
        item(i: Internal.Consumer_<Internal.BlockItemBuilder_>): Internal.BlockBuilder;
        resistance(r: number): Internal.BlockBuilder;
        hardness(h: number): Internal.BlockBuilder;
        slipperiness(f: number): Internal.BlockBuilder;
        getRegistryType(): Internal.RegistryObjectBuilderTypes<Internal.Block>;
        textureSide(direction: Internal.Direction_, tex: string): Internal.BlockBuilder;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        clientRegistry(minecraft: Internal.Minecraft_): void;
        waterlogged(): Internal.BlockBuilder;
        transformObject(obj: Internal.Block_): Internal.Block;
        color(index: number, c: Internal.Color_): Internal.BlockBuilder;
        textureAll(tex: string): Internal.BlockBuilder;
        displayName(name: string): Internal.BuilderBase<Internal.Block>;
        notifyAll(): void;
        box(x0: number, y0: number, z0: number, x1: number, y1: number, z1: number): Internal.BlockBuilder;
        box(x0: number, y0: number, z0: number, x1: number, y1: number, z1: number, scale16: boolean): Internal.BlockBuilder;
        viewBlocking(b: boolean): Internal.BlockBuilder;
        notify(): void;
        transparent(b: boolean): Internal.BlockBuilder;
        createAdditionalObjects(): void;
        tagBlock(tag: ResourceLocation_): Internal.BlockBuilder;
        fullBlock(f: boolean): Internal.BlockBuilder;
        createProperties(): Internal.BlockBehaviour$Properties;
        notSolid(): Internal.BlockBuilder;
        generateBlockModels(builder: Internal.BlockBuilder_): Internal.Map<ResourceLocation, Internal.JsonObject>;
        hashCode(): number;
        noCollission(): Internal.BlockBuilder;
        get(): Internal.Block;
        requiresTool(f: boolean): Internal.BlockBuilder;
        renderType(l: string): Internal.BlockBuilder;
        jumpFactor(f: number): Internal.BlockBuilder;
        createShape(): Internal.VoxelShape;
        generateAssetJsons(generator: Internal.AssetJsonGenerator_): void;
        noCollision(): Internal.BlockBuilder;
        opaque(o: boolean): Internal.BlockBuilder;
        randomTick(randomTickCallback: Internal.Consumer_<Internal.RandomTickCallbackJS_>): Internal.BlockBuilder;
        getTranslationKeyGroup(): string;
        texture(id: string, tex: string): Internal.BlockBuilder;
        noDrops(): Internal.BlockBuilder;
        generateLang(lang: Internal.Map_<string, string>): void;
        tagItem(tag: ResourceLocation_): Internal.BlockBuilder;
        speedFactor(f: number): Internal.BlockBuilder;
        noValidSpawns(b: boolean): Internal.BlockBuilder;
        createObject(): Internal.Block;
        lightLevel(light: number): Internal.BlockBuilder;
        addResourcePackLocations(path: string, list: Internal.List_<ResourceLocation_>, packType: Internal.PackType_): void;
        defaultTranslucent(): Internal.BlockBuilder;
        material(m: Internal.MaterialJS_): Internal.BlockBuilder;
        equals(arg0: any): boolean;
        toString(): string;
        redstoneConductor(b: boolean): Internal.BlockBuilder;
        lootTable : ((arg0: Internal.LootBuilder) => void);
        modelJson : Internal.JsonObject;
        blockstateJson : Internal.JsonObject;
        readonly id : ResourceLocation;
        randomTickCallback : ((arg0: Internal.RandomTickCallbackJS) => void);
        get registryType(): Internal.RegistryObjectBuilderTypes<Internal.Block>;
        get class(): Internal.Class<any>;
        get translationKeyGroup(): string;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    type WoodenButtonBlockBuilder_ = WoodenButtonBlockBuilder;
    abstract class LevelEventJS extends Internal.EventJS {
        cancel(): void;
        getServer(): Internal.ServerJS;
        getClass(): Internal.Class<any>;
        getLevel(): Internal.LevelJS;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        isCancelled(): boolean;
        post(id: string): boolean;
        post(id: string, sub: string): boolean;
        post(t: Internal.ScriptType_, id: string, sub: string): boolean;
        post(t: Internal.ScriptType_, id: string): boolean;
        hashCode(): number;
        notifyAll(): void;
        equals(arg0: any): boolean;
        toString(): string;
        notify(): void;
        canCancel(): boolean;
        get server(): Internal.ServerJS;
        get level(): Internal.LevelJS;
        get cancelled(): boolean;
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    type LevelEventJS_ = LevelEventJS;
    abstract class Player extends Internal.LivingEntity implements Internal.BYGPlayerTrackedData$Access, Internal.BYGAdditionalData, Internal.PlayerData, Internal.PlayerAccess, Internal.AccessorPlayer, Internal.PlayerKJS {
        getClass(): Internal.Class<any>;
        setItemSwapAnimationTimer(count: number): void;
        resetDynamicLight(): void;
        getCapability<T_>(arg0: Internal.Capability_<T_>, arg1: Internal.Direction_): Internal.LazyOptional<T_>;
        getCapability<T_>(arg0: Internal.Capability_<T_>): Internal.LazyOptional<T_>;
        captureDrops(arg0: Internal.Collection_<Internal.ItemEntity_>): Internal.Collection<Internal.ItemEntity>;
        captureDrops(): Internal.Collection<Internal.ItemEntity>;
        botania$setCritTarget(arg0: Internal.LivingEntity_): void;
        canBeRiddenInWater(arg0: Internal.Entity_): boolean;
        setCitadelEntityData(arg0: Internal.CompoundTag_): void;
        isDynamicLightEnabled(): boolean;
        changeDimension(arg0: Internal.ServerLevel_, arg1: Internal.ITeleporter_): Internal.Entity;
        serializeNBT(): Internal.CompoundTag;
        invalidateCaps(): void;
        setDynamicLightEnabled(arg0: boolean): void;
        shouldUpdateDynamicLight(): boolean;
        foodEatenKJS(is: Internal.ItemStack_): void;
        redirect$bid001$elytraOverride(arg0: Internal.ItemStack_, arg1: Internal.LivingEntity_): boolean;
        revive(): void;
        setVisualScale(arg0: number): void;
        getDigSpeed(arg0: Internal.BlockState_, arg1: BlockPos_): number;
        write(): net.minecraft.nbt.Tag;
        dynamicLightTick(): void;
        readBYG(arg0: Internal.CompoundTag_): void;
        getPersistentDataKJS(): Internal.CompoundTag;
        canUpdate(): boolean;
        canUpdate(arg0: boolean): void;
        getDynamicLightY(): number;
        getSuffixes(): Internal.Collection<Internal.MutableComponent>;
        getDynamicLightZ(): number;
        handler$zbj000$curio$canFreeze(arg0: Internal.CallbackInfoReturnable_<any>): void;
        read(arg0: Internal.CompoundTag_): void;
        getDynamicLightX(): number;
        areCapsCompatible(arg0: Internal.CapabilityProvider_<Internal.Entity_>): boolean;
        areCapsCompatible(arg0: Internal.CapabilityDispatcher_): boolean;
        getSideSword(): Internal.ItemStack;
        redirect$bie002$elytraOverride(arg0: Internal.ItemStack_, arg1: Internal.LivingEntity_): boolean;
        getEyeHeightAccess(arg0: Internal.Pose_, arg1: Internal.EntityDimensions_): number;
        reviveCaps(): void;
        lambdynlights$updateDynamicLight(arg0: Internal.LevelRenderer_): boolean;
        handler$bih000$removed(arg0: Internal.CallbackInfo_): void;
        setForcedPose(arg0: Internal.Pose_): void;
        canRiderInteract(): boolean;
        lambdynlights$scheduleTrackedChunksRebuild(arg0: Internal.LevelRenderer_): void;
        handler$bih001$onTick(arg0: Internal.CallbackInfo_): void;
        setLastAnimationSwapTick(count: number): void;
        onAddedToWorld(): void;
        lastUpdate(): number;
        getItemSwapAnimationTimer(): number;
        getPrefixes(): Internal.Collection<Internal.MutableComponent>;
        canTrample(arg0: Internal.BlockState_, arg1: BlockPos_, arg2: number): boolean;
        getCitadelEntityData(): Internal.CompoundTag;
        getPoseOverwrite(): Internal.Pose;
        setUpdated(frameId: number): void;
        getClassification(arg0: boolean): Internal.MobCategory;
        handler$bih000$onRemove(arg0: Internal.CallbackInfo_): void;
        getLastAnimationSwapTick(): number;
        shouldRiderSit(): boolean;
        getPickedResult(arg0: Internal.HitResult_): Internal.ItemStack;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        notifyAll(): void;
        isActuallyReallyBlocking(): boolean;
        setSideSword(item: Internal.ItemStack_): void;
        isUpdated(frameId: number): boolean;
        getPersistentData(): Internal.CompoundTag;
        getStagesRawKJS(): Internal.Stages;
        handler$bjh000$tick(info: Internal.CallbackInfo_): void;
        notify(): void;
        redirect$bie000$eytraValidOverride(arg0: Internal.ItemStack_, arg1: Internal.LivingEntity_, arg2: number): boolean;
        getStages(): Internal.Stages;
        getLastHeldItems(): Internal.ItemStack[];
        hashCode(): number;
        getPlayerTrackedData(): Internal.BYGPlayerTrackedData;
        setDimension(arg0: Internal.EntityDimensions_): void;
        isBodyRotationDisabled(): boolean;
        isAddedToWorld(): boolean;
        getData(holder: Internal.DataHolder_<any>, builder: Internal.Supplier_<any>): any;
        getParts(): any[];
        getDynamicLightWorld(): Internal.Level;
        writeBYG(arg0: Internal.CompoundTag_): void;
        disableBodyRotation(val: boolean): void;
        onRemovedFromWorld(): void;
        getLuminance(): number;
        isMultipartEntity(): boolean;
        deserializeNBT(arg0: Internal.CompoundTag_): void;
        curePotionEffects(arg0: Internal.ItemStack_): boolean;
        asKJS(): any;
        setPlayerTrackedData(arg0: Internal.BYGPlayerTrackedData_): Internal.BYGPlayerTrackedData;
        handler$cfc000$getPortalWaitTime(arg0: Internal.CallbackInfoReturnable_<any>): void;
        shouldRiderFaceForward(arg0: Internal.Player_): boolean;
        setPoseOverwrite(state: Internal.Pose_): void;
        equals(arg0: any): boolean;
        toString(): string;
        getVisualScale(): number;
        getLastRotations(): number[];
        refreshDisplayName(): void;
        getForcedPose(): Internal.Pose;
        static readonly PERSISTED_NBT_TAG : "PlayerPersisted";
        get luminance(): number;
        get suffixes(): Internal.Collection<Internal.MutableComponent>;
        get citadelEntityData(): Internal.CompoundTag;
        get playerTrackedData(): Internal.BYGPlayerTrackedData;
        get stagesRawKJS(): Internal.Stages;
        get addedToWorld(): boolean;
        get dynamicLightY(): number;
        get dynamicLightZ(): number;
        get sideSword(): Internal.ItemStack;
        get dynamicLightX(): number;
        get visualScale(): number;
        get persistentDataKJS(): Internal.CompoundTag;
        get class(): Internal.Class<any>;
        get dynamicLightWorld(): Internal.Level;
        get dynamicLightEnabled(): boolean;
        get poseOverwrite(): Internal.Pose;
        get persistentData(): Internal.CompoundTag;
        get lastHeldItems(): Internal.ItemStack[];
        get multipartEntity(): boolean;
        get lastRotations(): number[];
        get prefixes(): Internal.Collection<Internal.MutableComponent>;
        get lastAnimationSwapTick(): number;
        get bodyRotationDisabled(): boolean;
        get forcedPose(): Internal.Pose;
        get actuallyReallyBlocking(): boolean;
        get stages(): Internal.Stages;
        get parts(): any[];
        get itemSwapAnimationTimer(): number;
        set poseOverwrite(state: Internal.Pose_);
        set dynamicLightEnabled(arg0: boolean);
        set visualScale(arg0: number);
        set lastAnimationSwapTick(count: number);
        set forcedPose(arg0: Internal.Pose_);
        set playerTrackedData(arg0: Internal.BYGPlayerTrackedData_);
        set citadelEntityData(arg0: Internal.CompoundTag_);
        set dimension(arg0: Internal.EntityDimensions_);
        set sideSword(item: Internal.ItemStack_);
        set updated(frameId: number);
        set itemSwapAnimationTimer(count: number);
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    type Player_ = Player;
    class ForgeConfigSpec extends Internal.UnmodifiableConfigWrapper<Internal.UnmodifiableConfig> implements Internal.IConfigSpec<Internal.ForgeConfigSpec> {
        getShortOrElse(arg0: string, arg1: number): number;
        getShortOrElse(arg0: Internal.List_<string>, arg1: number): number;
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        getByte(arg0: Internal.List_<string>): number;
        getByte(arg0: string): number;
        correct(arg0: Internal.CommentedConfig_, arg1: Internal.ConfigSpec$CorrectionListener_, arg2: Internal.ConfigSpec$CorrectionListener_): number;
        correct(arg0: Internal.CommentedConfig_): number;
        correct(arg0: Internal.CommentedConfig_, arg1: Internal.ConfigSpec$CorrectionListener_): number;
        notifyAll(): void;
        acceptConfig(arg0: Internal.CommentedConfig_): void;
        save(): void;
        getEnum<T_>(arg0: string, arg1: Internal.Class_<T_>, arg2: Internal.EnumGetMethod_): T_;
        getEnum<T_>(arg0: Internal.List_<string>, arg1: Internal.Class_<T_>): T_;
        getEnum<T_>(arg0: Internal.List_<string>, arg1: Internal.Class_<T_>, arg2: Internal.EnumGetMethod_): T_;
        getEnum<T_>(arg0: string, arg1: Internal.Class_<T_>): T_;
        getLongOrElse(arg0: string, arg1: Internal.LongSupplier_): number;
        getLongOrElse(arg0: Internal.List_<string>, arg1: Internal.LongSupplier_): number;
        getLongOrElse(arg0: Internal.List_<string>, arg1: number): number;
        getLongOrElse(arg0: string, arg1: number): number;
        isLoaded(): boolean;
        notify(): void;
        isCorrecting(): boolean;
        setConfig(arg0: Internal.CommentedConfig_): void;
        getByteOrElse(arg0: Internal.List_<string>, arg1: number): number;
        getByteOrElse(arg0: string, arg1: number): number;
        hashCode(): number;
        get<T_>(arg0: string): T_;
        get<T_>(arg0: Internal.List_<string>): T_;
        valueMap(): Internal.Map<string, any>;
        getOrElse<T_>(arg0: Internal.List_<string>, arg1: T_): T_;
        getOrElse<T_>(arg0: string, arg1: Internal.Supplier_<T_>): T_;
        getOrElse<T_>(arg0: string, arg1: T_): T_;
        getOrElse<T_>(arg0: Internal.List_<string>, arg1: Internal.Supplier_<T_>): T_;
        getEnumOrElse<T_>(arg0: string, arg1: Internal.Class_<T_>, arg2: Internal.EnumGetMethod_, arg3: Internal.Supplier_<T_>): T_;
        getEnumOrElse<T_>(arg0: Internal.List_<string>, arg1: T_): T_;
        getEnumOrElse<T_>(arg0: Internal.List_<string>, arg1: T_, arg2: Internal.EnumGetMethod_): T_;
        getEnumOrElse<T_>(arg0: string, arg1: T_): T_;
        getEnumOrElse<T_>(arg0: string, arg1: T_, arg2: Internal.EnumGetMethod_): T_;
        getEnumOrElse<T_>(arg0: Internal.List_<string>, arg1: Internal.Class_<T_>, arg2: Internal.EnumGetMethod_, arg3: Internal.Supplier_<T_>): T_;
        getEnumOrElse<T_>(arg0: Internal.List_<string>, arg1: Internal.Class_<T_>, arg2: Internal.Supplier_<T_>): T_;
        getEnumOrElse<T_>(arg0: string, arg1: Internal.Class_<T_>, arg2: Internal.Supplier_<T_>): T_;
        getIntOrElse(arg0: string, arg1: Internal.IntSupplier_): number;
        getIntOrElse(arg0: string, arg1: number): number;
        getIntOrElse(arg0: Internal.List_<string>, arg1: number): number;
        getIntOrElse(arg0: Internal.List_<string>, arg1: Internal.IntSupplier_): number;
        getValues(): Internal.UnmodifiableConfig;
        apply<T_>(arg0: string): T_;
        apply<T_>(arg0: Internal.List_<string>): T_;
        getShort(arg0: string): number;
        getShort(arg0: Internal.List_<string>): number;
        entrySet(): Internal.Set<Internal.UnmodifiableConfig$Entry>;
        configFormat(): Internal.ConfigFormat<any>;
        isEmpty(): boolean;
        getOptionalInt(arg0: string): Internal.OptionalInt;
        getOptionalInt(arg0: Internal.List_<string>): Internal.OptionalInt;
        getCharOrElse(arg0: Internal.List_<string>, arg1: string): string;
        getCharOrElse(arg0: string, arg1: string): string;
        afterReload(): void;
        getLong(arg0: string): number;
        getLong(arg0: Internal.List_<string>): number;
        getInt(arg0: string): number;
        getInt(arg0: Internal.List_<string>): number;
        getChar(arg0: string): string;
        getChar(arg0: Internal.List_<string>): string;
        getOptional<T_>(arg0: string): Internal.Optional<T_>;
        getOptional<T_>(arg0: Internal.List_<string>): Internal.Optional<T_>;
        contains(arg0: Internal.List_<string>): boolean;
        contains(arg0: string): boolean;
        size(): number;
        getSpec(): Internal.UnmodifiableConfig;
        isNull(arg0: string): boolean;
        isNull(arg0: Internal.List_<string>): boolean;
        equals(arg0: any): boolean;
        self(): Internal.ForgeConfigSpec;
        toString(): string;
        getRaw<T_>(arg0: Internal.List_<string>): T_;
        getRaw<T_>(arg0: string): T_;
        getOptionalLong(arg0: string): Internal.OptionalLong;
        getOptionalLong(arg0: Internal.List_<string>): Internal.OptionalLong;
        getOptionalEnum<T_>(arg0: string, arg1: Internal.Class_<T_>): Internal.Optional<T_>;
        getOptionalEnum<T_>(arg0: Internal.List_<string>, arg1: Internal.Class_<T_>): Internal.Optional<T_>;
        getOptionalEnum<T_>(arg0: string, arg1: Internal.Class_<T_>, arg2: Internal.EnumGetMethod_): Internal.Optional<T_>;
        getOptionalEnum<T_>(arg0: Internal.List_<string>, arg1: Internal.Class_<T_>, arg2: Internal.EnumGetMethod_): Internal.Optional<T_>;
        isCorrect(arg0: Internal.CommentedConfig_): boolean;
        get loaded(): boolean;
        get values(): Internal.UnmodifiableConfig;
        get correcting(): boolean;
        get class(): Internal.Class<any>;
        get spec(): Internal.UnmodifiableConfig;
        get empty(): boolean;
        set config(arg0: Internal.CommentedConfig_);
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    type ForgeConfigSpec_ = ForgeConfigSpec;
    interface LootItemFunction$Builder {
    }
    type LootItemFunction$Builder_ = LootItemFunction$Builder;
    abstract class OutputStream implements Internal.Closeable, Internal.Flushable {
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        flush(): void;
        hashCode(): number;
        notifyAll(): void;
        equals(arg0: any): boolean;
        toString(): string;
        static nullOutputStream(): Internal.OutputStream;
        close(): void;
        write(arg0: number[]): void;
        write(arg0: number[], arg1: number, arg2: number): void;
        write(arg0: number): void;
        notify(): void;
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    type OutputStream_ = OutputStream;
    interface SymbolScriptable {
        get(arg0: Internal.Symbol_, arg1: Internal.Scriptable_): any;
        has(arg0: Internal.Symbol_, arg1: Internal.Scriptable_): boolean;
        delete(arg0: Internal.Symbol_): void;
        put(arg0: Internal.Symbol_, arg1: Internal.Scriptable_, arg2: any): void;
    }
    type SymbolScriptable_ = SymbolScriptable;
    interface SpawnProperties {
        getSpawners(): Internal.Map<Internal.MobCategory, Internal.List<Internal.MobSpawnSettings$SpawnerData>>;
        getMobSpawnCosts(): Internal.Map<Internal.EntityType<any>, Internal.MobSpawnSettings$MobSpawnCost>;
        getCreatureProbability(): number;
    }
    type SpawnProperties_ = SpawnProperties;
    interface IOpenableScreen extends Internal.Runnable {
        closeGui(): void;
        closeGui(openPrevScreen: boolean): void;
        openContextMenu(panel: Internal.Panel_): void;
        openGui(): void;
        openGuiLater(): void;
        run(): void;
        openAfter(runnable: Internal.Runnable_): Internal.Runnable;
        closeContextMenu(): void;
    }
    type IOpenableScreen_ = IOpenableScreen;
    class RecipeIngredientRole extends Internal.Enum<Internal.RecipeIngredientRole> {
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        static valueOf(arg0: string): Internal.RecipeIngredientRole;
        static valueOf<T_>(arg0: Internal.Class_<T_>, arg1: string): T_;
        notifyAll(): void;
        static values(): Internal.RecipeIngredientRole[];
        compareTo(arg0: Internal.RecipeIngredientRole_): number;
        describeConstable(): Internal.Optional<Internal.Enum$EnumDesc<Internal.RecipeIngredientRole>>;
        notify(): void;
        getDeclaringClass(): Internal.Class<Internal.RecipeIngredientRole>;
        hashCode(): number;
        equals(arg0: any): boolean;
        name(): string;
        toString(): string;
        ordinal(): number;
        static readonly INPUT : Internal.RecipeIngredientRole;
        static readonly RENDER_ONLY : Internal.RecipeIngredientRole;
        static readonly OUTPUT : Internal.RecipeIngredientRole;
        static readonly CATALYST : Internal.RecipeIngredientRole;
        get class(): Internal.Class<any>;
        get declaringClass(): Internal.Class<Internal.RecipeIngredientRole>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    type RecipeIngredientRole_ = "output" | "input" | "catalyst" | "render_only" | RecipeIngredientRole;
    interface ItemColorsExtended {
        getColorProvider(arg0: Internal.ItemStack_): Internal.ItemColor;
    }
    type ItemColorsExtended_ = ItemColorsExtended;
    class EventObject implements Internal.Serializable {
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        hashCode(): number;
        getSource(): any;
        notifyAll(): void;
        equals(arg0: any): boolean;
        toString(): string;
        notify(): void;
        get source(): any;
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    type EventObject_ = EventObject;
    interface Constable {
        describeConstable(): Internal.Optional<Internal.ConstantDesc>;
    }
    type Constable_ = Constable;
    class Month extends Internal.Enum<Internal.Month> implements Internal.TemporalAccessor, Internal.TemporalAdjuster {
        getClass(): Internal.Class<any>;
        firstMonthOfQuarter(): Internal.Month;
        minus(arg0: number): Internal.Month;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        firstDayOfYear(arg0: boolean): number;
        notifyAll(): void;
        minLength(): number;
        static values(): Internal.Month[];
        adjustInto(arg0: Internal.Temporal_): Internal.Temporal;
        range(arg0: Internal.TemporalField_): Internal.ValueRange;
        compareTo(arg0: Internal.Month_): number;
        describeConstable(): Internal.Optional<Internal.Enum$EnumDesc<Internal.Month>>;
        notify(): void;
        getDeclaringClass(): Internal.Class<Internal.Month>;
        hashCode(): number;
        static of(arg0: number): Internal.Month;
        get(arg0: Internal.TemporalField_): number;
        static from(arg0: Internal.TemporalAccessor_): Internal.Month;
        static valueOf(arg0: string): Internal.Month;
        static valueOf<T_>(arg0: Internal.Class_<T_>, arg1: string): T_;
        query<R_>(arg0: Internal.TemporalQuery_<R_>): R_;
        length(arg0: boolean): number;
        isSupported(arg0: Internal.TemporalField_): boolean;
        plus(arg0: number): Internal.Month;
        getLong(arg0: Internal.TemporalField_): number;
        getValue(): number;
        getDisplayName(arg0: Internal.TextStyle_, arg1: Internal.Locale_): string;
        equals(arg0: any): boolean;
        name(): string;
        toString(): string;
        maxLength(): number;
        ordinal(): number;
        static readonly JANUARY : Internal.Month;
        static readonly JUNE : Internal.Month;
        static readonly MAY : Internal.Month;
        static readonly OCTOBER : Internal.Month;
        static readonly DECEMBER : Internal.Month;
        static readonly MARCH : Internal.Month;
        static readonly FEBRUARY : Internal.Month;
        static readonly AUGUST : Internal.Month;
        static readonly JULY : Internal.Month;
        static readonly SEPTEMBER : Internal.Month;
        static readonly NOVEMBER : Internal.Month;
        static readonly APRIL : Internal.Month;
        get class(): Internal.Class<any>;
        get value(): number;
        get declaringClass(): Internal.Class<Internal.Month>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    type Month_ = "november" | "june" | "september" | "may" | "august" | "january" | "february" | "july" | "december" | "october" | "april" | "march" | Month;
    class CraftingContainer implements net.minecraft.world.Container, Internal.StackedContentsCompatible, Internal.AccessorCraftingContainer {
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        hashCode(): number;
        notifyAll(): void;
        equals(arg0: any): boolean;
        toString(): string;
        notify(): void;
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    type CraftingContainer_ = CraftingContainer;
    class VisibilitySet {
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        hashCode(): number;
        notifyAll(): void;
        equals(arg0: any): boolean;
        toString(): string;
        notify(): void;
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    type VisibilitySet_ = VisibilitySet;
    class Advancement {
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        hashCode(): number;
        notifyAll(): void;
        equals(arg0: any): boolean;
        toString(): string;
        notify(): void;
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    type Advancement_ = Advancement;
    interface ResultConsumer <S> {
        onCommandComplete(arg0: Internal.CommandContext_<S>, arg1: boolean, arg2: number): void;
    }
    type ResultConsumer_<S> = ((arg0: Internal.CommandContext<S>, arg1: boolean, arg2: number) => void) | ResultConsumer<S>;
    /**
    */
    class ArmorItemBuilder$Helmet extends Internal.ArmorItemBuilder {
        barWidth(barWidth: Internal.ToIntFunction_<Internal.ItemStackJS_>): Internal.ItemBuilder;
        getClass(): Internal.Class<any>;
        maxStackSize(v: number): Internal.ItemBuilder;
        translationKey(key: string): Internal.BuilderBase<Internal.Item>;
        newID(pre: string, post: string): ResourceLocation;
        use(use: Internal.ItemBuilder$UseCallback_): Internal.ItemBuilder;
        maxDamage(v: number): Internal.ItemBuilder;
        textureJson(json: Internal.JsonObject_): Internal.ItemBuilder;
        tooltip(text: Internal.Component_): Internal.ItemBuilder;
        modifyTier(callback: Internal.Consumer_<Internal.MutableArmorTier_>): Internal.ArmorItemBuilder;
        type(type: string): Internal.BuilderBase<Internal.Item>;
        containerItem(id: string): Internal.ItemBuilder;
        subtypes(fn: java_.util.function_.Function_<Internal.ItemStackJS_, Internal.Collection_<Internal.ItemStackJS_>>): Internal.ItemBuilder;
        modelJson(json: Internal.JsonObject_): Internal.ItemBuilder;
        burnTime(v: number): Internal.ItemBuilder;
        useDuration(useDuration: Internal.ToIntFunction_<Internal.ItemStackJS_>): Internal.ItemBuilder;
        tag(tag: ResourceLocation_): Internal.BuilderBase<Internal.Item>;
        parentModel(m: string): Internal.ItemBuilder;
        generateDataJsons(generator: Internal.DataJsonGenerator_): void;
        group(g: string): Internal.ItemBuilder;
        static ofArmorMaterial(o: any): Internal.ArmorMaterial;
        /**
        */
        modifyAttribute(attribute: net.minecraft.world.entity.ai.attributes.Attribute_, identifier: string, d: number, operation: Internal.AttributeModifier$Operation_): Internal.ItemBuilder;
        getRegistryType(): Internal.RegistryObjectBuilderTypes<Internal.Item>;
        glow(v: boolean): Internal.ItemBuilder;
        useAnimation(animation: Internal.UseAnim_): Internal.ItemBuilder;
        rarity(v: Rarity_): Internal.ItemBuilder;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        clientRegistry(minecraft: Internal.Minecraft_): void;
        transformObject(obj: Internal.Item_): Internal.Item;
        color(callback: Internal.ItemBuilder$ItemColorJS_): Internal.ItemBuilder;
        color(index: number, c: Internal.Color_): Internal.ItemBuilder;
        displayName(name: string): Internal.BuilderBase<Internal.Item>;
        notifyAll(): void;
        barColor(barColor: java_.util.function_.Function_<Internal.ItemStackJS_, Internal.Color_>): Internal.ItemBuilder;
        notify(): void;
        createAdditionalObjects(): void;
        tier(t: Internal.ArmorMaterial_): Internal.ArmorItemBuilder;
        hashCode(): number;
        get(): Internal.Item;
        generateAssetJsons(generator: Internal.AssetJsonGenerator_): void;
        getTranslationKeyGroup(): string;
        texture(key: string, tex: string): Internal.ItemBuilder;
        texture(tex: string): Internal.ItemBuilder;
        generateLang(lang: Internal.Map_<string, string>): void;
        food(b: Internal.Consumer_<Internal.FoodBuilder_>): Internal.ItemBuilder;
        createObject(): Internal.Item;
        releaseUsing(releaseUsing: Internal.ItemBuilder$ReleaseUsingCallback_): Internal.ItemBuilder;
        unstackable(): Internal.ItemBuilder;
        addResourcePackLocations(path: string, list: Internal.List_<ResourceLocation_>, packType: Internal.PackType_): void;
        equals(arg0: any): boolean;
        toString(): string;
        finishUsing(finishUsing: Internal.ItemBuilder$FinishUsingCallback_): Internal.ItemBuilder;
        createItemProperties(): Internal.Item$Properties;
        armorTier : Internal.MutableArmorTier;
        static readonly TOOL_TIERS : {"gold":any,"diamond":any,"iron":any,"wood":any,"stone":any,"netherite":any};
        static readonly ARMOR_TIERS : {"gold":any,"chain":any,"diamond":any,"turtle":any,"iron":any,"leather":any,"netherite":any};
        readonly equipmentSlot : EquipmentSlot;
        readonly id : ResourceLocation;
        get registryType(): Internal.RegistryObjectBuilderTypes<Internal.Item>;
        get class(): Internal.Class<any>;
        get translationKeyGroup(): string;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    /**
    */
    type ArmorItemBuilder$Helmet_ = ArmorItemBuilder$Helmet;
    interface DrawCallTrackingRenderBuffers {
        getDrawCalls(): number;
        resetDrawCounts(): void;
        getRenderTypes(): number;
    }
    type DrawCallTrackingRenderBuffers_ = DrawCallTrackingRenderBuffers;
    class FileChannel$MapMode {
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        hashCode(): number;
        notifyAll(): void;
        equals(arg0: any): boolean;
        toString(): string;
        notify(): void;
        static readonly READ_ONLY : Internal.FileChannel$MapMode;
        static readonly READ_WRITE : Internal.FileChannel$MapMode;
        static readonly PRIVATE : Internal.FileChannel$MapMode;
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    type FileChannel$MapMode_ = FileChannel$MapMode;
    interface ItemModelPropertiesEventJS$ItemPropertiesCallback {
        accept(arg0: Internal.ItemStackJS_, arg1: Internal.LevelJS_, arg2: Internal.EntityJS_, arg3: number): number;
    }
    type ItemModelPropertiesEventJS$ItemPropertiesCallback_ = ((arg0: Internal.ItemStackJS, arg1: Internal.LevelJS, arg2: Internal.EntityJS, arg3: number) => number) | ItemModelPropertiesEventJS$ItemPropertiesCallback;
    class StringRange {
        getClass(): Internal.Class<any>;
        static encompassing(arg0: Internal.StringRange_, arg1: Internal.StringRange_): Internal.StringRange;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        getStart(): number;
        notifyAll(): void;
        isEmpty(): boolean;
        getEnd(): number;
        notify(): void;
        static at(arg0: number): Internal.StringRange;
        hashCode(): number;
        equals(arg0: any): boolean;
        get(arg0: string): string;
        get(arg0: Internal.ImmutableStringReader_): string;
        getLength(): number;
        toString(): string;
        static between(arg0: number, arg1: number): Internal.StringRange;
        get start(): number;
        get length(): number;
        get end(): number;
        get class(): Internal.Class<any>;
        get empty(): boolean;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    type StringRange_ = StringRange;
    interface Functor <F, Mu> extends Internal.Kind1<F, Mu> {
        map<T_, R_>(arg0: java_.util.function_.Function_<T_, R_>, arg1: Internal.App_<Mu, T_>): Internal.App<Mu, R_>;
        group<T1_, T2_, T3_, T4_, T5_, T6_, T7_, T8_, T9_, T10_, T11_>(arg0: Internal.App_<Mu, T1_>, arg1: Internal.App_<Mu, T2_>, arg2: Internal.App_<Mu, T3_>, arg3: Internal.App_<Mu, T4_>, arg4: Internal.App_<Mu, T5_>, arg5: Internal.App_<Mu, T6_>, arg6: Internal.App_<Mu, T7_>, arg7: Internal.App_<Mu, T8_>, arg8: Internal.App_<Mu, T9_>, arg9: Internal.App_<Mu, T10_>, arg10: Internal.App_<Mu, T11_>): Internal.Products$P11<Mu, T1_, T2_, T3_, T4_, T5_, T6_, T7_, T8_, T9_, T10_, T11_>;
        group<T1_, T2_, T3_, T4_, T5_, T6_, T7_, T8_, T9_, T10_>(arg0: Internal.App_<Mu, T1_>, arg1: Internal.App_<Mu, T2_>, arg2: Internal.App_<Mu, T3_>, arg3: Internal.App_<Mu, T4_>, arg4: Internal.App_<Mu, T5_>, arg5: Internal.App_<Mu, T6_>, arg6: Internal.App_<Mu, T7_>, arg7: Internal.App_<Mu, T8_>, arg8: Internal.App_<Mu, T9_>, arg9: Internal.App_<Mu, T10_>): Internal.Products$P10<Mu, T1_, T2_, T3_, T4_, T5_, T6_, T7_, T8_, T9_, T10_>;
        group<T1_, T2_, T3_, T4_, T5_, T6_, T7_, T8_, T9_>(arg0: Internal.App_<Mu, T1_>, arg1: Internal.App_<Mu, T2_>, arg2: Internal.App_<Mu, T3_>, arg3: Internal.App_<Mu, T4_>, arg4: Internal.App_<Mu, T5_>, arg5: Internal.App_<Mu, T6_>, arg6: Internal.App_<Mu, T7_>, arg7: Internal.App_<Mu, T8_>, arg8: Internal.App_<Mu, T9_>): Internal.Products$P9<Mu, T1_, T2_, T3_, T4_, T5_, T6_, T7_, T8_, T9_>;
        group<T1_, T2_, T3_, T4_, T5_, T6_, T7_, T8_, T9_, T10_, T11_, T12_, T13_, T14_, T15_, T16_>(arg0: Internal.App_<Mu, T1_>, arg1: Internal.App_<Mu, T2_>, arg2: Internal.App_<Mu, T3_>, arg3: Internal.App_<Mu, T4_>, arg4: Internal.App_<Mu, T5_>, arg5: Internal.App_<Mu, T6_>, arg6: Internal.App_<Mu, T7_>, arg7: Internal.App_<Mu, T8_>, arg8: Internal.App_<Mu, T9_>, arg9: Internal.App_<Mu, T10_>, arg10: Internal.App_<Mu, T11_>, arg11: Internal.App_<Mu, T12_>, arg12: Internal.App_<Mu, T13_>, arg13: Internal.App_<Mu, T14_>, arg14: Internal.App_<Mu, T15_>, arg15: Internal.App_<Mu, T16_>): Internal.Products$P16<Mu, T1_, T2_, T3_, T4_, T5_, T6_, T7_, T8_, T9_, T10_, T11_, T12_, T13_, T14_, T15_, T16_>;
        group<T1_, T2_, T3_, T4_, T5_, T6_, T7_, T8_, T9_, T10_, T11_, T12_, T13_, T14_, T15_>(arg0: Internal.App_<Mu, T1_>, arg1: Internal.App_<Mu, T2_>, arg2: Internal.App_<Mu, T3_>, arg3: Internal.App_<Mu, T4_>, arg4: Internal.App_<Mu, T5_>, arg5: Internal.App_<Mu, T6_>, arg6: Internal.App_<Mu, T7_>, arg7: Internal.App_<Mu, T8_>, arg8: Internal.App_<Mu, T9_>, arg9: Internal.App_<Mu, T10_>, arg10: Internal.App_<Mu, T11_>, arg11: Internal.App_<Mu, T12_>, arg12: Internal.App_<Mu, T13_>, arg13: Internal.App_<Mu, T14_>, arg14: Internal.App_<Mu, T15_>): Internal.Products$P15<Mu, T1_, T2_, T3_, T4_, T5_, T6_, T7_, T8_, T9_, T10_, T11_, T12_, T13_, T14_, T15_>;
        group<T1_, T2_, T3_, T4_, T5_, T6_, T7_, T8_, T9_, T10_, T11_, T12_, T13_, T14_>(arg0: Internal.App_<Mu, T1_>, arg1: Internal.App_<Mu, T2_>, arg2: Internal.App_<Mu, T3_>, arg3: Internal.App_<Mu, T4_>, arg4: Internal.App_<Mu, T5_>, arg5: Internal.App_<Mu, T6_>, arg6: Internal.App_<Mu, T7_>, arg7: Internal.App_<Mu, T8_>, arg8: Internal.App_<Mu, T9_>, arg9: Internal.App_<Mu, T10_>, arg10: Internal.App_<Mu, T11_>, arg11: Internal.App_<Mu, T12_>, arg12: Internal.App_<Mu, T13_>, arg13: Internal.App_<Mu, T14_>): Internal.Products$P14<Mu, T1_, T2_, T3_, T4_, T5_, T6_, T7_, T8_, T9_, T10_, T11_, T12_, T13_, T14_>;
        group<T1_, T2_, T3_, T4_, T5_, T6_, T7_, T8_, T9_, T10_, T11_, T12_, T13_>(arg0: Internal.App_<Mu, T1_>, arg1: Internal.App_<Mu, T2_>, arg2: Internal.App_<Mu, T3_>, arg3: Internal.App_<Mu, T4_>, arg4: Internal.App_<Mu, T5_>, arg5: Internal.App_<Mu, T6_>, arg6: Internal.App_<Mu, T7_>, arg7: Internal.App_<Mu, T8_>, arg8: Internal.App_<Mu, T9_>, arg9: Internal.App_<Mu, T10_>, arg10: Internal.App_<Mu, T11_>, arg11: Internal.App_<Mu, T12_>, arg12: Internal.App_<Mu, T13_>): Internal.Products$P13<Mu, T1_, T2_, T3_, T4_, T5_, T6_, T7_, T8_, T9_, T10_, T11_, T12_, T13_>;
        group<T1_, T2_, T3_, T4_, T5_, T6_, T7_, T8_, T9_, T10_, T11_, T12_>(arg0: Internal.App_<Mu, T1_>, arg1: Internal.App_<Mu, T2_>, arg2: Internal.App_<Mu, T3_>, arg3: Internal.App_<Mu, T4_>, arg4: Internal.App_<Mu, T5_>, arg5: Internal.App_<Mu, T6_>, arg6: Internal.App_<Mu, T7_>, arg7: Internal.App_<Mu, T8_>, arg8: Internal.App_<Mu, T9_>, arg9: Internal.App_<Mu, T10_>, arg10: Internal.App_<Mu, T11_>, arg11: Internal.App_<Mu, T12_>): Internal.Products$P12<Mu, T1_, T2_, T3_, T4_, T5_, T6_, T7_, T8_, T9_, T10_, T11_, T12_>;
        group<T1_, T2_, T3_>(arg0: Internal.App_<Mu, T1_>, arg1: Internal.App_<Mu, T2_>, arg2: Internal.App_<Mu, T3_>): Internal.Products$P3<Mu, T1_, T2_, T3_>;
        group<T1_, T2_>(arg0: Internal.App_<Mu, T1_>, arg1: Internal.App_<Mu, T2_>): Internal.Products$P2<Mu, T1_, T2_>;
        group<T1_>(arg0: Internal.App_<Mu, T1_>): Internal.Products$P1<Mu, T1_>;
        group<T1_, T2_, T3_, T4_, T5_, T6_, T7_, T8_>(arg0: Internal.App_<Mu, T1_>, arg1: Internal.App_<Mu, T2_>, arg2: Internal.App_<Mu, T3_>, arg3: Internal.App_<Mu, T4_>, arg4: Internal.App_<Mu, T5_>, arg5: Internal.App_<Mu, T6_>, arg6: Internal.App_<Mu, T7_>, arg7: Internal.App_<Mu, T8_>): Internal.Products$P8<Mu, T1_, T2_, T3_, T4_, T5_, T6_, T7_, T8_>;
        group<T1_, T2_, T3_, T4_, T5_, T6_, T7_>(arg0: Internal.App_<Mu, T1_>, arg1: Internal.App_<Mu, T2_>, arg2: Internal.App_<Mu, T3_>, arg3: Internal.App_<Mu, T4_>, arg4: Internal.App_<Mu, T5_>, arg5: Internal.App_<Mu, T6_>, arg6: Internal.App_<Mu, T7_>): Internal.Products$P7<Mu, T1_, T2_, T3_, T4_, T5_, T6_, T7_>;
        group<T1_, T2_, T3_, T4_, T5_, T6_>(arg0: Internal.App_<Mu, T1_>, arg1: Internal.App_<Mu, T2_>, arg2: Internal.App_<Mu, T3_>, arg3: Internal.App_<Mu, T4_>, arg4: Internal.App_<Mu, T5_>, arg5: Internal.App_<Mu, T6_>): Internal.Products$P6<Mu, T1_, T2_, T3_, T4_, T5_, T6_>;
        group<T1_, T2_, T3_, T4_, T5_>(arg0: Internal.App_<Mu, T1_>, arg1: Internal.App_<Mu, T2_>, arg2: Internal.App_<Mu, T3_>, arg3: Internal.App_<Mu, T4_>, arg4: Internal.App_<Mu, T5_>): Internal.Products$P5<Mu, T1_, T2_, T3_, T4_, T5_>;
        group<T1_, T2_, T3_, T4_>(arg0: Internal.App_<Mu, T1_>, arg1: Internal.App_<Mu, T2_>, arg2: Internal.App_<Mu, T3_>, arg3: Internal.App_<Mu, T4_>): Internal.Products$P4<Mu, T1_, T2_, T3_, T4_>;
    }
    type Functor_<F, Mu> = Functor<F, Mu>;
    interface JsonSerializationContext {
        serialize(arg0: any): Internal.JsonElement;
        serialize(arg0: any, arg1: java_.lang.reflect.Type_): Internal.JsonElement;
    }
    type JsonSerializationContext_ = JsonSerializationContext;
    interface ConfigWriter {
        writeToString(arg0: Internal.UnmodifiableConfig_): string;
        write(arg0: Internal.UnmodifiableConfig_, arg1: Internal.Path_, arg2: Internal.WritingMode_, arg3: Internal.Charset_): void;
        write(arg0: Internal.UnmodifiableConfig_, arg1: Internal.File_, arg2: Internal.WritingMode_): void;
        write(arg0: Internal.UnmodifiableConfig_, arg1: Internal.File_, arg2: Internal.WritingMode_, arg3: Internal.Charset_): void;
        write(arg0: Internal.UnmodifiableConfig_, arg1: Internal.URL_): void;
        write(arg0: Internal.UnmodifiableConfig_, arg1: Internal.Writer_): void;
        write(arg0: Internal.UnmodifiableConfig_, arg1: Internal.OutputStream_, arg2: Internal.Charset_): void;
        write(arg0: Internal.UnmodifiableConfig_, arg1: Internal.OutputStream_): void;
        write(arg0: Internal.UnmodifiableConfig_, arg1: Internal.Path_, arg2: Internal.WritingMode_): void;
    }
    type ConfigWriter_ = ConfigWriter;
    abstract class ForwardingMultimap <K, V> extends Internal.ForwardingObject implements Internal.Multimap<K, V> {
        getClass(): Internal.Class<any>;
        containsEntry(arg0: any, arg1: any): boolean;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        forEach(arg0: Internal.BiConsumer_<K, V>): void;
        asMap(): Internal.Map<K, Internal.Collection<V>>;
        keys(): Internal.Multiset<K>;
        containsKey(arg0: any): boolean;
        notifyAll(): void;
        values(): Internal.Collection<V>;
        isEmpty(): boolean;
        clear(): void;
        replaceValues(arg0: K, arg1: Internal.Iterable_<V>): Internal.Collection<V>;
        notify(): void;
        containsValue(arg0: any): boolean;
        put(arg0: K, arg1: V): boolean;
        remove(arg0: any, arg1: any): boolean;
        removeAll(arg0: any): Internal.Collection<V>;
        entries(): Internal.Collection<Internal.Map$Entry<K, V>>;
        size(): number;
        hashCode(): number;
        putAll(arg0: Internal.Multimap_<K, V>): boolean;
        putAll(arg0: K, arg1: Internal.Iterable_<V>): boolean;
        equals(arg0: any): boolean;
        get(arg0: K): Internal.Collection<V>;
        toString(): string;
        keySet(): Internal.Set<K>;
        get class(): Internal.Class<any>;
        get empty(): boolean;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    type ForwardingMultimap_<K, V> = ForwardingMultimap<K, V>;
    class ComponentOrientation implements Internal.Serializable {
        isLeftToRight(): boolean;
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        static getOrientation(arg0: Internal.Locale_): Internal.ComponentOrientation;
        static getOrientation(arg0: Internal.ResourceBundle_): Internal.ComponentOrientation;
        hashCode(): number;
        notifyAll(): void;
        equals(arg0: any): boolean;
        toString(): string;
        notify(): void;
        isHorizontal(): boolean;
        static readonly RIGHT_TO_LEFT : Internal.ComponentOrientation;
        static readonly UNKNOWN : Internal.ComponentOrientation;
        static readonly LEFT_TO_RIGHT : Internal.ComponentOrientation;
        get leftToRight(): boolean;
        get horizontal(): boolean;
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    type ComponentOrientation_ = ComponentOrientation;
    class Format$Field extends Internal.AttributedCharacterIterator$Attribute {
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        hashCode(): number;
        notifyAll(): void;
        equals(arg0: any): boolean;
        toString(): string;
        notify(): void;
        static readonly LANGUAGE : Internal.AttributedCharacterIterator$Attribute;
        static readonly INPUT_METHOD_SEGMENT : Internal.AttributedCharacterIterator$Attribute;
        static readonly READING : Internal.AttributedCharacterIterator$Attribute;
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    type Format$Field_ = Format$Field;
    class Pair <F, S> implements Internal.App<Internal.Pair$Mu<S>, F> {
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        swap(): Internal.Pair<S, Internal.Pair$Mu<S>>;
        notifyAll(): void;
        notify(): void;
        mapFirst<F2_>(arg0: java_.util.function_.Function_<Internal.Pair$Mu_<S>, F2_>): Internal.Pair<F2_, S>;
        static unbox<F_, S_>(arg0: Internal.App_<Internal.Pair$Mu_<S_>, F_>): Internal.Pair<F_, S_>;
        getFirst(): Internal.Pair$Mu<S>;
        hashCode(): number;
        static toMap<F_, S_>(): Internal.Collector<Internal.Pair<F_, S_>, any, Internal.Map<F_, S_>>;
        static of<F_, S_>(arg0: F_, arg1: S_): Internal.Pair<F_, S_>;
        equals(arg0: any): boolean;
        getSecond(): S;
        toString(): string;
        mapSecond<S2_>(arg0: java_.util.function_.Function_<S, S2_>): Internal.Pair<Internal.Pair$Mu<S>, S2_>;
        get class(): Internal.Class<any>;
        get first(): Internal.Pair$Mu<S>;
        get second(): S;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    type Pair_<F, S> = Pair<F, S>;
    interface HierarchyBoundsListener extends Internal.EventListener {
        ancestorResized(arg0: Internal.HierarchyEvent_): void;
        ancestorMoved(arg0: Internal.HierarchyEvent_): void;
    }
    type HierarchyBoundsListener_ = HierarchyBoundsListener;
    abstract class AbstractContainerEventHandler extends Internal.GuiComponent implements Internal.ContainerEventHandler {
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        hashCode(): number;
        notifyAll(): void;
        equals(arg0: any): boolean;
        toString(): string;
        notify(): void;
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    type AbstractContainerEventHandler_ = AbstractContainerEventHandler;
    abstract class Projectile extends Internal.Entity implements Internal.IOnProjectileHit {
        getClass(): Internal.Class<any>;
        resetDynamicLight(): void;
        getCapability<T_>(arg0: Internal.Capability_<T_>, arg1: Internal.Direction_): Internal.LazyOptional<T_>;
        getCapability<T_>(arg0: Internal.Capability_<T_>): Internal.LazyOptional<T_>;
        captureDrops(arg0: Internal.Collection_<Internal.ItemEntity_>): Internal.Collection<Internal.ItemEntity>;
        captureDrops(): Internal.Collection<Internal.ItemEntity>;
        canBeRiddenInWater(arg0: Internal.Entity_): boolean;
        setAddDamage(arg0: number): void;
        isDynamicLightEnabled(): boolean;
        changeDimension(arg0: Internal.ServerLevel_, arg1: Internal.ITeleporter_): Internal.Entity;
        serializeNBT(): Internal.CompoundTag;
        invalidateCaps(): void;
        setDynamicLightEnabled(arg0: boolean): void;
        shouldUpdateDynamicLight(): boolean;
        revive(): void;
        setVisualScale(arg0: number): void;
        dynamicLightTick(): void;
        getPersistentDataKJS(): Internal.CompoundTag;
        canUpdate(): boolean;
        canUpdate(arg0: boolean): void;
        getDynamicLightY(): number;
        getDynamicLightZ(): number;
        getDynamicLightX(): number;
        areCapsCompatible(arg0: Internal.CapabilityProvider_<Internal.Entity_>): boolean;
        areCapsCompatible(arg0: Internal.CapabilityDispatcher_): boolean;
        getEyeHeightAccess(arg0: Internal.Pose_, arg1: Internal.EntityDimensions_): number;
        reviveCaps(): void;
        lambdynlights$updateDynamicLight(arg0: Internal.LevelRenderer_): boolean;
        handler$bih000$removed(arg0: Internal.CallbackInfo_): void;
        canRiderInteract(): boolean;
        lambdynlights$scheduleTrackedChunksRebuild(arg0: Internal.LevelRenderer_): void;
        handler$bih001$onTick(arg0: Internal.CallbackInfo_): void;
        onAddedToWorld(): void;
        canTrample(arg0: Internal.BlockState_, arg1: BlockPos_, arg2: number): boolean;
        setMaxLifeTime(arg0: number): void;
        setOnHitAction(arg0: Internal.Consumer_<any>): void;
        getClassification(arg0: boolean): Internal.MobCategory;
        handler$bih000$onRemove(arg0: Internal.CallbackInfo_): void;
        shouldRiderSit(): boolean;
        getPickedResult(arg0: Internal.HitResult_): Internal.ItemStack;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        notifyAll(): void;
        getPersistentData(): Internal.CompoundTag;
        notify(): void;
        hashCode(): number;
        setDimension(arg0: Internal.EntityDimensions_): void;
        isAddedToWorld(): boolean;
        getParts(): any[];
        getDynamicLightWorld(): Internal.Level;
        onRemovedFromWorld(): void;
        getLuminance(): number;
        isMultipartEntity(): boolean;
        deserializeNBT(arg0: Internal.CompoundTag_): void;
        getAddDamage(): number;
        asKJS(): any;
        handler$bhf000$onHitCallback(arg0: Internal.HitResult_, arg1: Internal.CallbackInfo_): void;
        equals(arg0: any): boolean;
        toString(): string;
        getVisualScale(): number;
        get luminance(): number;
        get dynamicLightEnabled(): boolean;
        get persistentData(): Internal.CompoundTag;
        get multipartEntity(): boolean;
        get addedToWorld(): boolean;
        get dynamicLightY(): number;
        get dynamicLightZ(): number;
        get dynamicLightX(): number;
        get visualScale(): number;
        get persistentDataKJS(): Internal.CompoundTag;
        get addDamage(): number;
        get parts(): any[];
        get class(): Internal.Class<any>;
        get dynamicLightWorld(): Internal.Level;
        set onHitAction(arg0: Internal.Consumer_<any>);
        set dynamicLightEnabled(arg0: boolean);
        set visualScale(arg0: number);
        set addDamage(arg0: number);
        set maxLifeTime(arg0: number);
        set dimension(arg0: Internal.EntityDimensions_);
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    type Projectile_ = Projectile;
    abstract class FieldNamingPolicy extends Internal.Enum<Internal.FieldNamingPolicy> implements Internal.FieldNamingStrategy {
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        static valueOf(arg0: string): Internal.FieldNamingPolicy;
        static valueOf<T_>(arg0: Internal.Class_<T_>, arg1: string): T_;
        notifyAll(): void;
        static values(): Internal.FieldNamingPolicy[];
        translateName(arg0: Internal.Field_): string;
        compareTo(arg0: Internal.FieldNamingPolicy_): number;
        describeConstable(): Internal.Optional<Internal.Enum$EnumDesc<Internal.FieldNamingPolicy>>;
        notify(): void;
        getDeclaringClass(): Internal.Class<Internal.FieldNamingPolicy>;
        hashCode(): number;
        equals(arg0: any): boolean;
        name(): string;
        toString(): string;
        ordinal(): number;
        static readonly IDENTITY : Internal.FieldNamingPolicy;
        static readonly UPPER_CAMEL_CASE_WITH_SPACES : Internal.FieldNamingPolicy;
        static readonly UPPER_CAMEL_CASE : Internal.FieldNamingPolicy;
        static readonly LOWER_CASE_WITH_DOTS : Internal.FieldNamingPolicy;
        static readonly LOWER_CASE_WITH_UNDERSCORES : Internal.FieldNamingPolicy;
        static readonly LOWER_CASE_WITH_DASHES : Internal.FieldNamingPolicy;
        get class(): Internal.Class<any>;
        get declaringClass(): Internal.Class<Internal.FieldNamingPolicy>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    type FieldNamingPolicy_ = "lower_case_with_dashes" | "upper_camel_case_with_spaces" | "lower_case_with_underscores" | "identity" | "upper_camel_case" | "lower_case_with_dots" | FieldNamingPolicy;
    class FluidAttributes {
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        getOverlayTexture(): ResourceLocation;
        isLighterThanAir(): boolean;
        notifyAll(): void;
        isGaseous(): boolean;
        isGaseous(arg0: Internal.BlockAndTintGetter_, arg1: BlockPos_): boolean;
        isGaseous(arg0: net.minecraftforge.fluids.FluidStack_): boolean;
        getRarity(arg0: Internal.BlockAndTintGetter_, arg1: BlockPos_): Rarity;
        getRarity(): Rarity;
        getRarity(arg0: net.minecraftforge.fluids.FluidStack_): Rarity;
        getEmptySound(arg0: net.minecraftforge.fluids.FluidStack_): Internal.SoundEvent;
        getEmptySound(): Internal.SoundEvent;
        getEmptySound(arg0: Internal.BlockAndTintGetter_, arg1: BlockPos_): Internal.SoundEvent;
        notify(): void;
        getBucket(arg0: net.minecraftforge.fluids.FluidStack_): Internal.ItemStack;
        getFlowingTexture(arg0: net.minecraftforge.fluids.FluidStack_): ResourceLocation;
        getFlowingTexture(arg0: Internal.BlockAndTintGetter_, arg1: BlockPos_): ResourceLocation;
        getFlowingTexture(): ResourceLocation;
        hashCode(): number;
        static builder(arg0: ResourceLocation_, arg1: ResourceLocation_): Internal.FluidAttributes$Builder;
        getStillTexture(arg0: net.minecraftforge.fluids.FluidStack_): ResourceLocation;
        getStillTexture(): ResourceLocation;
        getStillTexture(arg0: Internal.BlockAndTintGetter_, arg1: BlockPos_): ResourceLocation;
        getBlock(arg0: Internal.BlockAndTintGetter_, arg1: BlockPos_, arg2: Internal.FluidState_): Internal.BlockState;
        getStateForPlacement(arg0: Internal.BlockAndTintGetter_, arg1: BlockPos_, arg2: net.minecraftforge.fluids.FluidStack_): Internal.FluidState;
        getTranslationKey(arg0: net.minecraftforge.fluids.FluidStack_): string;
        getTranslationKey(): string;
        getFillSound(arg0: Internal.BlockAndTintGetter_, arg1: BlockPos_): Internal.SoundEvent;
        getFillSound(): Internal.SoundEvent;
        getFillSound(arg0: net.minecraftforge.fluids.FluidStack_): Internal.SoundEvent;
        getColor(arg0: net.minecraftforge.fluids.FluidStack_): number;
        getColor(): number;
        getColor(arg0: Internal.BlockAndTintGetter_, arg1: BlockPos_): number;
        getDensity(): number;
        getDensity(arg0: net.minecraftforge.fluids.FluidStack_): number;
        getDensity(arg0: Internal.BlockAndTintGetter_, arg1: BlockPos_): number;
        getLuminosity(arg0: net.minecraftforge.fluids.FluidStack_): number;
        getLuminosity(arg0: Internal.BlockAndTintGetter_, arg1: BlockPos_): number;
        getLuminosity(): number;
        doesVaporize(arg0: Internal.BlockAndTintGetter_, arg1: BlockPos_, arg2: net.minecraftforge.fluids.FluidStack_): boolean;
        getViscosity(): number;
        getViscosity(arg0: Internal.BlockAndTintGetter_, arg1: BlockPos_): number;
        getViscosity(arg0: net.minecraftforge.fluids.FluidStack_): number;
        canBePlacedInWorld(arg0: Internal.BlockAndTintGetter_, arg1: BlockPos_, arg2: net.minecraftforge.fluids.FluidStack_): boolean;
        canBePlacedInWorld(arg0: Internal.BlockAndTintGetter_, arg1: BlockPos_, arg2: Internal.FluidState_): boolean;
        getDisplayName(arg0: net.minecraftforge.fluids.FluidStack_): Internal.Component;
        equals(arg0: any): boolean;
        getTextures(): Internal.Stream<ResourceLocation>;
        toString(): string;
        vaporize(arg0: Internal.Player_, arg1: Internal.Level_, arg2: BlockPos_, arg3: net.minecraftforge.fluids.FluidStack_): void;
        getTemperature(arg0: net.minecraftforge.fluids.FluidStack_): number;
        getTemperature(arg0: Internal.BlockAndTintGetter_, arg1: BlockPos_): number;
        getTemperature(): number;
        static readonly BUCKET_VOLUME : 1000;
        get overlayTexture(): ResourceLocation;
        get translationKey(): string;
        get color(): number;
        get density(): number;
        get textures(): Internal.Stream<ResourceLocation>;
        get lighterThanAir(): boolean;
        get gaseous(): boolean;
        get emptySound(): Internal.SoundEvent;
        get stillTexture(): ResourceLocation;
        get viscosity(): number;
        get flowingTexture(): ResourceLocation;
        get temperature(): number;
        get luminosity(): number;
        get class(): Internal.Class<any>;
        get fillSound(): Internal.SoundEvent;
        get rarity(): Rarity;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    type FluidAttributes_ = FluidAttributes;
    interface Long2LongFunction extends Internal.Function<number, number>, Internal.LongUnaryOperator {
        getOrDefault(arg0: any, arg1: number): number;
        getOrDefault(arg0: number, arg1: number): number;
        andThenShort(arg0: Internal.Long2ShortFunction_): Internal.Long2ShortFunction;
        composeByte(arg0: Internal.Byte2LongFunction_): Internal.Byte2LongFunction;
        andThenInt(arg0: Internal.Long2IntFunction_): Internal.Long2IntFunction;
        composeReference<T_>(arg0: Internal.Reference2LongFunction_<T_>): Internal.Reference2LongFunction<T_>;
        andThen<T_>(arg0: java_.util.function_.Function_<number, T_>): java_.util.function_.Function<number, T_>;
        andThen(arg0: Internal.LongUnaryOperator_): Internal.LongUnaryOperator;
        put(arg0: number, arg1: number): number;
        remove(arg0: number): number;
        remove(arg0: any): number;
        defaultReturnValue(): number;
        defaultReturnValue(arg0: number): void;
        andThenDouble(arg0: Internal.Long2DoubleFunction_): Internal.Long2DoubleFunction;
        andThenObject<T_>(arg0: Internal.Long2ObjectFunction_<T_>): Internal.Long2ObjectFunction<T_>;
        get(arg0: any): number;
        get(arg0: number): number;
        andThenLong(arg0: Internal.Long2LongFunction_): Internal.Long2LongFunction;
        composeLong(arg0: Internal.Long2LongFunction_): Internal.Long2LongFunction;
        andThenByte(arg0: Internal.Long2ByteFunction_): Internal.Long2ByteFunction;
        andThenFloat(arg0: Internal.Long2FloatFunction_): Internal.Long2FloatFunction;
        apply(arg0: number): number;
        containsKey(arg0: any): boolean;
        containsKey(arg0: number): boolean;
        composeInt(arg0: Internal.Int2LongFunction_): Internal.Int2LongFunction;
        clear(): void;
        composeFloat(arg0: Internal.Float2LongFunction_): Internal.Float2LongFunction;
        andThenChar(arg0: Internal.Long2CharFunction_): Internal.Long2CharFunction;
        applyAsLong(arg0: number): number;
        composeObject<T_>(arg0: Internal.Object2LongFunction_<T_>): Internal.Object2LongFunction<T_>;
        size(): number;
        compose<T_>(arg0: java_.util.function_.Function_<T_, number>): java_.util.function_.Function<T_, number>;
        compose(arg0: Internal.LongUnaryOperator_): Internal.LongUnaryOperator;
        composeShort(arg0: Internal.Short2LongFunction_): Internal.Short2LongFunction;
        andThenReference<T_>(arg0: Internal.Long2ReferenceFunction_<T_>): Internal.Long2ReferenceFunction<T_>;
        composeChar(arg0: Internal.Char2LongFunction_): Internal.Char2LongFunction;
        composeDouble(arg0: Internal.Double2LongFunction_): Internal.Double2LongFunction;
    }
    type Long2LongFunction_ = ((arg0: number) => number) | Long2LongFunction;
    interface RegistryAccess {
    }
    type RegistryAccess_ = RegistryAccess;
    interface ImmutableStringReader {
        getCursor(): number;
        getRemainingLength(): number;
        getTotalLength(): number;
        canRead(): boolean;
        canRead(arg0: number): boolean;
        getRemaining(): string;
        getRead(): string;
        getString(): string;
        peek(arg0: number): string;
        peek(): string;
    }
    type ImmutableStringReader_ = ImmutableStringReader;
    class Direction extends Internal.Enum<Internal.Direction> implements Internal.StringRepresentable {
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        getIndex(): number;
        static valueOf(arg0: string): Internal.Direction;
        static valueOf<T_>(arg0: Internal.Class_<T_>, arg1: string): T_;
        notifyAll(): void;
        static values(): Internal.Direction[];
        compareTo(arg0: Internal.Direction_): number;
        describeConstable(): Internal.Optional<Internal.Enum$EnumDesc<Internal.Direction>>;
        notify(): void;
        getClockWise(): Internal.Direction;
        getDeclaringClass(): Internal.Class<Internal.Direction>;
        getYaw(): number;
        getHorizontalIndex(): number;
        getX(): number;
        getY(): number;
        getPitch(): number;
        getZ(): number;
        hashCode(): number;
        equals(arg0: any): boolean;
        name(): string;
        getCounterClockWise(): Internal.Direction;
        getOpposite(): Internal.Direction;
        toString(): string;
        ordinal(): number;
        static readonly DOWN : Internal.Direction;
        static readonly NORTH : Internal.Direction;
        static readonly WEST : Internal.Direction;
        static readonly UP : Internal.Direction;
        static readonly SOUTH : Internal.Direction;
        static readonly EAST : Internal.Direction;
        get clockWise(): Internal.Direction;
        get horizontalIndex(): number;
        get x(): number;
        get index(): number;
        get y(): number;
        get z(): number;
        get counterClockWise(): Internal.Direction;
        get opposite(): Internal.Direction;
        get pitch(): number;
        get class(): Internal.Class<any>;
        get yaw(): number;
        get declaringClass(): Internal.Class<Internal.Direction>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    type Direction_ = "east" | "south" | "north" | "west" | "up" | "down" | Direction;
    abstract class QuestObjectBase {
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        deleteChildren(): void;
        readNetData(buffer: Internal.FriendlyByteBuf_): void;
        notifyAll(): void;
        getMutableTitle(): Internal.MutableComponent;
        getTags(): Internal.Set<string>;
        writeData(nbt: Internal.CompoundTag_): void;
        static getCodeString(object: Internal.QuestObjectBase_): string;
        getCodeString(): string;
        static getCodeString(id: number): string;
        createSubGroup(group: Internal.ConfigGroup_): Internal.ConfigGroup;
        editedFromGUIOnServer(): void;
        notify(): void;
        forceProgress(teamData: Internal.TeamData_, progressChange: Internal.ProgressChange_): void;
        getTitle(): Internal.Component;
        getAltIcon(): Internal.Icon;
        hashCode(): number;
        getObjectType(): Internal.QuestObjectType;
        getPath(): string;
        clearCachedData(): void;
        getParentID(): number;
        readData(nbt: Internal.CompoundTag_): void;
        editedFromGUI(): void;
        refreshJEI(): number;
        static parseCodeString(id: string): number;
        hasTag(tag: string): boolean;
        getQuestChapter(): Internal.Chapter;
        getQuestFile(): Internal.QuestFile;
        static getID(object: Internal.QuestObjectBase_): number;
        writeNetData(buffer: Internal.FriendlyByteBuf_): void;
        onEditButtonClicked(gui: Internal.Runnable_): void;
        getConfig(config: Internal.ConfigGroup_): void;
        getIcon(): Internal.Icon;
        forceProgressRaw(teamData: Internal.TeamData_, progressChange: Internal.ProgressChange_): void;
        getAltTitle(): Internal.Component;
        static isNull(object: Internal.QuestObjectBase_): boolean;
        equals(object: any): boolean;
        toString(): string;
        deleteSelf(): void;
        onCreated(): void;
        static titleToID(s: string): Internal.Optional<string>;
        invalid : boolean;
        icon : Internal.ItemStack;
        static sendNotifications : Internal.Tristate;
        id : number;
        title : string;
        get path(): string;
        get codeString(): string;
        get altTitle(): Internal.Component;
        get questFile(): Internal.QuestFile;
        get class(): Internal.Class<any>;
        get parentID(): number;
        get mutableTitle(): Internal.MutableComponent;
        get tags(): Internal.Set<string>;
        get altIcon(): Internal.Icon;
        get objectType(): Internal.QuestObjectType;
        get questChapter(): Internal.Chapter;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    type QuestObjectBase_ = QuestObjectBase;
    abstract class FileSystemProvider {
        isSameFile(arg0: Internal.Path_, arg1: Internal.Path_): boolean;
        getFileStore(arg0: Internal.Path_): Internal.FileStore;
        newByteChannel(arg0: Internal.Path_, arg1: Internal.Set_<Internal.OpenOption_>, arg2: any_<any>[]): Internal.SeekableByteChannel;
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        newAsynchronousFileChannel(arg0: Internal.Path_, arg1: Internal.Set_<Internal.OpenOption_>, arg2: Internal.ExecutorService_, arg3: any_<any>[]): Internal.AsynchronousFileChannel;
        getFileAttributeView<V>(arg0: Internal.Path_, arg1: Internal.Class_<V>, arg2: any_[]): V;
        notifyAll(): void;
        createSymbolicLink(arg0: Internal.Path_, arg1: Internal.Path_, arg2: any_<any>[]): void;
        static installedProviders(): Internal.List<Internal.FileSystemProvider>;
        delete(arg0: Internal.Path_): void;
        notify(): void;
        createLink(arg0: Internal.Path_, arg1: Internal.Path_): void;
        setAttribute(arg0: Internal.Path_, arg1: string, arg2: any, arg3: any_[]): void;
        newFileChannel(arg0: Internal.Path_, arg1: Internal.Set_<Internal.OpenOption_>, arg2: any_<any>[]): Internal.FileChannel;
        newInputStream(arg0: Internal.Path_, arg1: Internal.OpenOption_[]): Internal.InputStream;
        hashCode(): number;
        readAttributes<A>(arg0: Internal.Path_, arg1: Internal.Class_<A>, arg2: any_[]): A;
        readAttributes(arg0: Internal.Path_, arg1: string, arg2: any_[]): Internal.Map<string, any>;
        newOutputStream(arg0: Internal.Path_, arg1: Internal.OpenOption_[]): Internal.OutputStream;
        getPath(arg0: Internal.URI_): Internal.Path;
        createDirectory(arg0: Internal.Path_, arg1: any_<any>[]): void;
        copy(arg0: Internal.Path_, arg1: Internal.Path_, arg2: any_[]): void;
        move(arg0: Internal.Path_, arg1: Internal.Path_, arg2: any_[]): void;
        getScheme(): string;
        newFileSystem(arg0: Internal.URI_, arg1: Internal.Map_<string, any>): Internal.FileSystem;
        newFileSystem(arg0: Internal.Path_, arg1: Internal.Map_<string, any>): Internal.FileSystem;
        deleteIfExists(arg0: Internal.Path_): boolean;
        newDirectoryStream(arg0: Internal.Path_, arg1: Internal.DirectoryStream$Filter_<Internal.Path_>): Internal.DirectoryStream<Internal.Path>;
        getFileSystem(arg0: Internal.URI_): Internal.FileSystem;
        checkAccess(arg0: Internal.Path_, arg1: any_[]): void;
        readSymbolicLink(arg0: Internal.Path_): Internal.Path;
        isHidden(arg0: Internal.Path_): boolean;
        equals(arg0: any): boolean;
        toString(): string;
        get scheme(): string;
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    type FileSystemProvider_ = FileSystemProvider;
    abstract class BlockBuilder extends Internal.BuilderBase<Internal.Block> {
        noItem(): Internal.BlockBuilder;
        suffocating(b: boolean): Internal.BlockBuilder;
        getClass(): Internal.Class<any>;
        translationKey(key: string): Internal.BuilderBase<Internal.Block>;
        newID(pre: string, post: string): ResourceLocation;
        type(type: string): Internal.BuilderBase<Internal.Block>;
        unbreakable(): Internal.BlockBuilder;
        model(m: string): Internal.BlockBuilder;
        tag(tag: ResourceLocation_): Internal.BlockBuilder;
        generateDataJsons(generator: Internal.DataJsonGenerator_): void;
        tagBoth(tag: ResourceLocation_): Internal.BlockBuilder;
        defaultCutout(): Internal.BlockBuilder;
        item(i: Internal.Consumer_<Internal.BlockItemBuilder_>): Internal.BlockBuilder;
        resistance(r: number): Internal.BlockBuilder;
        hardness(h: number): Internal.BlockBuilder;
        slipperiness(f: number): Internal.BlockBuilder;
        getRegistryType(): Internal.RegistryObjectBuilderTypes<Internal.Block>;
        textureSide(direction: Internal.Direction_, tex: string): Internal.BlockBuilder;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        clientRegistry(minecraft: Internal.Minecraft_): void;
        waterlogged(): Internal.BlockBuilder;
        transformObject(obj: Internal.Block_): Internal.Block;
        color(index: number, c: Internal.Color_): Internal.BlockBuilder;
        textureAll(tex: string): Internal.BlockBuilder;
        displayName(name: string): Internal.BuilderBase<Internal.Block>;
        notifyAll(): void;
        box(x0: number, y0: number, z0: number, x1: number, y1: number, z1: number): Internal.BlockBuilder;
        box(x0: number, y0: number, z0: number, x1: number, y1: number, z1: number, scale16: boolean): Internal.BlockBuilder;
        viewBlocking(b: boolean): Internal.BlockBuilder;
        notify(): void;
        transparent(b: boolean): Internal.BlockBuilder;
        createAdditionalObjects(): void;
        tagBlock(tag: ResourceLocation_): Internal.BlockBuilder;
        fullBlock(f: boolean): Internal.BlockBuilder;
        createProperties(): Internal.BlockBehaviour$Properties;
        notSolid(): Internal.BlockBuilder;
        generateBlockModels(builder: Internal.BlockBuilder_): Internal.Map<ResourceLocation, Internal.JsonObject>;
        hashCode(): number;
        noCollission(): Internal.BlockBuilder;
        get(): Internal.Block;
        requiresTool(f: boolean): Internal.BlockBuilder;
        renderType(l: string): Internal.BlockBuilder;
        jumpFactor(f: number): Internal.BlockBuilder;
        createShape(): Internal.VoxelShape;
        generateAssetJsons(generator: Internal.AssetJsonGenerator_): void;
        noCollision(): Internal.BlockBuilder;
        opaque(o: boolean): Internal.BlockBuilder;
        randomTick(randomTickCallback: Internal.Consumer_<Internal.RandomTickCallbackJS_>): Internal.BlockBuilder;
        getTranslationKeyGroup(): string;
        texture(id: string, tex: string): Internal.BlockBuilder;
        noDrops(): Internal.BlockBuilder;
        generateLang(lang: Internal.Map_<string, string>): void;
        tagItem(tag: ResourceLocation_): Internal.BlockBuilder;
        speedFactor(f: number): Internal.BlockBuilder;
        noValidSpawns(b: boolean): Internal.BlockBuilder;
        createObject(): Internal.Block;
        lightLevel(light: number): Internal.BlockBuilder;
        addResourcePackLocations(path: string, list: Internal.List_<ResourceLocation_>, packType: Internal.PackType_): void;
        defaultTranslucent(): Internal.BlockBuilder;
        material(m: Internal.MaterialJS_): Internal.BlockBuilder;
        equals(arg0: any): boolean;
        toString(): string;
        redstoneConductor(b: boolean): Internal.BlockBuilder;
        lootTable : ((arg0: Internal.LootBuilder) => void);
        modelJson : Internal.JsonObject;
        blockstateJson : Internal.JsonObject;
        readonly id : ResourceLocation;
        randomTickCallback : ((arg0: Internal.RandomTickCallbackJS) => void);
        get registryType(): Internal.RegistryObjectBuilderTypes<Internal.Block>;
        get class(): Internal.Class<any>;
        get translationKeyGroup(): string;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    type BlockBuilder_ = BlockBuilder;
    interface BiConsumer <T, U> {
        andThen(arg0: Internal.BiConsumer_<T, U>): Internal.BiConsumer<T, U>;
        accept(arg0: T, arg1: U): void;
    }
    type BiConsumer_<T, U> = ((arg0: T, arg1: U) => void) | BiConsumer<T, U>;
    class ModuleDescriptor$Requires$Modifier extends Internal.Enum<Internal.ModuleDescriptor$Requires$Modifier> {
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        static valueOf(arg0: string): Internal.ModuleDescriptor$Requires$Modifier;
        static valueOf<T_>(arg0: Internal.Class_<T_>, arg1: string): T_;
        notifyAll(): void;
        static values(): Internal.ModuleDescriptor$Requires$Modifier[];
        compareTo(arg0: Internal.ModuleDescriptor$Requires$Modifier_): number;
        describeConstable(): Internal.Optional<Internal.Enum$EnumDesc<Internal.ModuleDescriptor$Requires$Modifier>>;
        notify(): void;
        getDeclaringClass(): Internal.Class<Internal.ModuleDescriptor$Requires$Modifier>;
        hashCode(): number;
        equals(arg0: any): boolean;
        name(): string;
        toString(): string;
        ordinal(): number;
        static readonly TRANSITIVE : Internal.ModuleDescriptor$Requires$Modifier;
        static readonly SYNTHETIC : Internal.ModuleDescriptor$Requires$Modifier;
        static readonly MANDATED : Internal.ModuleDescriptor$Requires$Modifier;
        static readonly STATIC : Internal.ModuleDescriptor$Requires$Modifier;
        get class(): Internal.Class<any>;
        get declaringClass(): Internal.Class<Internal.ModuleDescriptor$Requires$Modifier>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    type ModuleDescriptor$Requires$Modifier_ = "synthetic" | "static" | "mandated" | "transitive" | ModuleDescriptor$Requires$Modifier;
    interface Char2BooleanFunction extends Internal.Function<string, boolean>, java_.util.function_.IntPredicate {
        getOrDefault(arg0: any, arg1: boolean): boolean;
        getOrDefault(arg0: string, arg1: boolean): boolean;
        andThenShort(arg0: Internal.Boolean2ShortFunction_): Internal.Char2ShortFunction;
        composeByte(arg0: Internal.Byte2CharFunction_): Internal.Byte2BooleanFunction;
        andThenInt(arg0: Internal.Boolean2IntFunction_): Internal.Char2IntFunction;
        composeReference<T_>(arg0: Internal.Reference2CharFunction_<T_>): Internal.Reference2BooleanFunction<T_>;
        andThen<T_>(arg0: java_.util.function_.Function_<boolean, T_>): java_.util.function_.Function<string, T_>;
        put(arg0: string, arg1: boolean): boolean;
        remove(arg0: string): boolean;
        remove(arg0: any): boolean;
        defaultReturnValue(): boolean;
        defaultReturnValue(arg0: boolean): void;
        andThenDouble(arg0: Internal.Boolean2DoubleFunction_): Internal.Char2DoubleFunction;
        andThenObject<T_>(arg0: Internal.Boolean2ObjectFunction_<T_>): Internal.Char2ObjectFunction<T_>;
        and(arg0: java_.util.function_.IntPredicate_): java_.util.function_.IntPredicate;
        get(arg0: any): boolean;
        get(arg0: string): boolean;
        andThenLong(arg0: Internal.Boolean2LongFunction_): Internal.Char2LongFunction;
        composeLong(arg0: Internal.Long2CharFunction_): Internal.Long2BooleanFunction;
        andThenByte(arg0: Internal.Boolean2ByteFunction_): Internal.Char2ByteFunction;
        andThenFloat(arg0: Internal.Boolean2FloatFunction_): Internal.Char2FloatFunction;
        or(arg0: java_.util.function_.IntPredicate_): java_.util.function_.IntPredicate;
        test(arg0: number): boolean;
        apply(arg0: string): boolean;
        containsKey(arg0: string): boolean;
        containsKey(arg0: any): boolean;
        composeInt(arg0: Internal.Int2CharFunction_): Internal.Int2BooleanFunction;
        clear(): void;
        composeFloat(arg0: Internal.Float2CharFunction_): Internal.Float2BooleanFunction;
        andThenChar(arg0: Internal.Boolean2CharFunction_): Internal.Char2CharFunction;
        composeObject<T_>(arg0: Internal.Object2CharFunction_<T_>): Internal.Object2BooleanFunction<T_>;
        size(): number;
        compose<T_>(arg0: java_.util.function_.Function_<T_, string>): java_.util.function_.Function<T_, boolean>;
        negate(): java_.util.function_.IntPredicate;
        composeShort(arg0: Internal.Short2CharFunction_): Internal.Short2BooleanFunction;
        andThenReference<T_>(arg0: Internal.Boolean2ReferenceFunction_<T_>): Internal.Char2ReferenceFunction<T_>;
        composeChar(arg0: Internal.Char2CharFunction_): Internal.Char2BooleanFunction;
        composeDouble(arg0: Internal.Double2CharFunction_): Internal.Double2BooleanFunction;
    }
    type Char2BooleanFunction_ = ((arg0: string) => boolean) | Char2BooleanFunction;
    interface Enemy {
    }
    type Enemy_ = Enemy;
    abstract class RenderingHints$Key {
        isCompatibleValue(arg0: any): boolean;
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        hashCode(): number;
        notifyAll(): void;
        equals(arg0: any): boolean;
        toString(): string;
        notify(): void;
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    type RenderingHints$Key_ = RenderingHints$Key;
    interface LevelAccessor extends Internal.CommonLevelAccessor, Internal.LevelTimeAccess {
        getExistingBlockEntity(arg0: BlockPos_): Internal.BlockEntity;
        isAreaLoaded(arg0: BlockPos_, arg1: number): boolean;
    }
    type LevelAccessor_ = LevelAccessor;
    class Tag <T> {
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        hashCode(): number;
        notifyAll(): void;
        equals(arg0: any): boolean;
        toString(): string;
        notify(): void;
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    type Tag_<T> = Tag<T>;
    class ScreenPaintEventJS extends Internal.PaintEventJS {
        cancel(): void;
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        getPlayer(): Internal.ClientPlayerJS;
        vertex(m: Internal.Matrix4f_, x: number, y: number, z: number, col: number): void;
        vertex(m: Internal.Matrix4f_, x: number, y: number, z: number, col: number, u: number, v: number): void;
        notifyAll(): void;
        scale(x: number, y: number): void;
        scale(scale: number): void;
        scale(x: number, y: number, z: number): void;
        notify(): void;
        translate(x: number, y: number): void;
        translate(x: number, y: number, z: number): void;
        setShaderColor(r: number, g: number, b: number, a: number): void;
        pop(): void;
        setPositionColorShader(): void;
        getMatrix(): Internal.Matrix4f;
        post(id: string): boolean;
        post(id: string, sub: string): boolean;
        post(t: Internal.ScriptType_, id: string, sub: string): boolean;
        post(t: Internal.ScriptType_, id: string): boolean;
        hashCode(): number;
        resetShaderColor(): void;
        end(): void;
        alignX(x: number, w: number, alignX: number): number;
        text(text: Internal.Component_, x: number, y: number, color: number, shadow: boolean): void;
        alignY(y: number, h: number, alignY: number): number;
        isCancelled(): boolean;
        setShaderTexture(tex: ResourceLocation_): void;
        beginQuads(texture: boolean): void;
        beginQuads(format: Internal.VertexFormat_): void;
        bindTextureForSetup(tex: ResourceLocation_): void;
        getEntity(): Internal.EntityJS;
        rotateDeg(angle: number): void;
        push(): void;
        setShaderInstance(shader: Internal.Supplier_<Internal.ShaderInstance_>): void;
        getLevel(): Internal.ClientLevelJS;
        rawText(text: Internal.FormattedCharSequence_, x: number, y: number, color: number, shadow: boolean): void;
        equals(arg0: any): boolean;
        toString(): string;
        rectangle(x: number, y: number, z: number, w: number, h: number, color: number): void;
        rectangle(x: number, y: number, z: number, w: number, h: number, color: number, u0: number, v0: number, u1: number, v1: number): void;
        rotateRad(angle: number): void;
        setPositionColorTextureShader(): void;
        begin(type: Internal.VertexFormat$Mode_, format: Internal.VertexFormat_): void;
        canCancel(): boolean;
        readonly mouseX : number;
        readonly mc : Internal.Minecraft;
        readonly mouseY : number;
        readonly width : number;
        readonly delta : number;
        readonly screen : Internal.Screen;
        readonly tesselator : Internal.Tesselator;
        readonly buffer : Internal.BufferBuilder;
        readonly inventory : boolean;
        readonly matrices : Internal.PoseStack;
        readonly height : number;
        readonly font : net.minecraft.client.gui.Font;
        get level(): Internal.ClientLevelJS;
        get cancelled(): boolean;
        get matrix(): Internal.Matrix4f;
        get class(): Internal.Class<any>;
        get entity(): Internal.EntityJS;
        get player(): Internal.ClientPlayerJS;
        set shaderTexture(tex: ResourceLocation_);
        set shaderInstance(shader: Internal.Supplier_<Internal.ShaderInstance_>);
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    type ScreenPaintEventJS_ = ScreenPaintEventJS;
    abstract class VolatileImage extends Internal.Image implements Internal.Transparency {
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        contentsLost(): boolean;
        getProperty(arg0: string, arg1: Internal.ImageObserver_): any;
        notifyAll(): void;
        getCapabilities(): Internal.ImageCapabilities;
        getCapabilities(arg0: Internal.GraphicsConfiguration_): Internal.ImageCapabilities;
        getWidth(): number;
        getWidth(arg0: Internal.ImageObserver_): number;
        notify(): void;
        getSnapshot(): Internal.BufferedImage;
        getTransparency(): number;
        getScaledInstance(arg0: number, arg1: number, arg2: number): Internal.Image;
        setAccelerationPriority(arg0: number): void;
        getHeight(): number;
        getHeight(arg0: Internal.ImageObserver_): number;
        flush(): void;
        hashCode(): number;
        getSource(): Internal.ImageProducer;
        equals(arg0: any): boolean;
        getAccelerationPriority(): number;
        toString(): string;
        createGraphics(): Internal.Graphics2D;
        getGraphics(): Internal.Graphics;
        validate(arg0: Internal.GraphicsConfiguration_): number;
        static readonly OPAQUE : 1;
        static readonly SCALE_DEFAULT : 1;
        static readonly TRANSLUCENT : 3;
        static readonly UndefinedProperty : any;
        static readonly IMAGE_OK : 0;
        static readonly BITMASK : 2;
        static readonly SCALE_FAST : 2;
        static readonly SCALE_AREA_AVERAGING : 16;
        static readonly IMAGE_RESTORED : 1;
        static readonly SCALE_SMOOTH : 4;
        static readonly SCALE_REPLICATE : 8;
        static readonly IMAGE_INCOMPATIBLE : 2;
        get capabilities(): Internal.ImageCapabilities;
        get accelerationPriority(): number;
        get transparency(): number;
        get width(): number;
        get source(): Internal.ImageProducer;
        get graphics(): Internal.Graphics;
        get class(): Internal.Class<any>;
        get snapshot(): Internal.BufferedImage;
        get height(): number;
        set accelerationPriority(arg0: number);
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    type VolatileImage_ = VolatileImage;
    interface IForgeBlockGetter {
        getExistingBlockEntity(arg0: BlockPos_): Internal.BlockEntity;
    }
    type IForgeBlockGetter_ = IForgeBlockGetter;
    interface ConstantDesc {
        resolveConstantDesc(arg0: Internal.MethodHandles$Lookup_): any;
    }
    type ConstantDesc_ = ConstantDesc;
    interface DoubleStream extends Internal.BaseStream<number, Internal.DoubleStream> {
        average(): Internal.OptionalDouble;
        sequential(): Internal.DoubleStream;
        takeWhile(arg0: java_.util.function_.DoublePredicate_): Internal.DoubleStream;
        distinct(): Internal.DoubleStream;
        findFirst(): Internal.OptionalDouble;
        sum(): number;
        skip(arg0: number): Internal.DoubleStream;
        allMatch(arg0: java_.util.function_.DoublePredicate_): boolean;
        mapToObj<U_>(arg0: Internal.DoubleFunction_<U_>): Internal.Stream<U_>;
        mapMulti(arg0: Internal.DoubleStream$DoubleMapMultiConsumer_): Internal.DoubleStream;
        iterator(): Internal.PrimitiveIterator$OfDouble;
        min(): Internal.OptionalDouble;
        mapToLong(arg0: Internal.DoubleToLongFunction_): Internal.LongStream;
        parallel(): Internal.DoubleStream;
        noneMatch(arg0: java_.util.function_.DoublePredicate_): boolean;
        findAny(): Internal.OptionalDouble;
        isParallel(): boolean;
        limit(arg0: number): Internal.DoubleStream;
        toArray(): number[];
        forEachOrdered(arg0: java_.util.function_.DoubleConsumer_): void;
        close(): void;
        anyMatch(arg0: java_.util.function_.DoublePredicate_): boolean;
        map(arg0: Internal.DoubleUnaryOperator_): Internal.DoubleStream;
        unordered(): Internal.DoubleStream;
        reduce(arg0: number, arg1: Internal.DoubleBinaryOperator_): number;
        reduce(arg0: Internal.DoubleBinaryOperator_): Internal.OptionalDouble;
        spliterator(): Internal.Spliterator$OfDouble;
        max(): Internal.OptionalDouble;
        forEach(arg0: java_.util.function_.DoubleConsumer_): void;
        count(): number;
        dropWhile(arg0: java_.util.function_.DoublePredicate_): Internal.DoubleStream;
        peek(arg0: java_.util.function_.DoubleConsumer_): Internal.DoubleStream;
        flatMap(arg0: Internal.DoubleFunction_<Internal.DoubleStream_>): Internal.DoubleStream;
        filter(arg0: java_.util.function_.DoublePredicate_): Internal.DoubleStream;
        onClose(arg0: Internal.Runnable_): Internal.DoubleStream;
        sorted(): Internal.DoubleStream;
        boxed(): Internal.Stream<number>;
        summaryStatistics(): Internal.DoubleSummaryStatistics;
        mapToInt(arg0: Internal.DoubleToIntFunction_): Internal.IntStream;
        collect<R_>(arg0: Internal.Supplier_<R_>, arg1: Internal.ObjDoubleConsumer_<R_>, arg2: Internal.BiConsumer_<R_, R_>): R_;
    }
    type DoubleStream_ = DoubleStream;
    interface Long2ObjectMap$FastEntrySet <V> extends Internal.ObjectSet<Internal.Long2ObjectMap$Entry<V>> {
        add(arg0: Internal.Long2ObjectMap$Entry_<V>): boolean;
        spliterator(): Internal.ObjectSpliterator<Internal.Long2ObjectMap$Entry<V>>;
        forEach(arg0: Internal.Consumer_<Internal.Long2ObjectMap$Entry_<V>>): void;
        containsAll(arg0: Internal.Collection_<any>): boolean;
        isEmpty(): boolean;
        clear(): void;
        fastIterator(): Internal.ObjectIterator<Internal.Long2ObjectMap$Entry<V>>;
        remove(arg0: any): boolean;
        removeIf(arg0: Internal.Predicate_<Internal.Long2ObjectMap$Entry_<V>>): boolean;
        fastForEach(arg0: Internal.Consumer_<Internal.Long2ObjectMap$Entry_<V>>): void;
        removeAll(arg0: Internal.Collection_<any>): boolean;
        contains(arg0: any): boolean;
        iterator(): Internal.ObjectIterator<Internal.Long2ObjectMap$Entry<V>>;
        size(): number;
        addAll(arg0: Internal.Collection_<Internal.Long2ObjectMap$Entry_<V>>): boolean;
        stream(): Internal.Stream<Internal.Long2ObjectMap$Entry<V>>;
        hashCode(): number;
        equals(arg0: any): boolean;
        toArray<T_>(arg0: T_[]): T_[];
        toArray<T_>(arg0: Internal.IntFunction_<T_[]>): T_[];
        toArray(): any[];
        parallelStream(): Internal.Stream<Internal.Long2ObjectMap$Entry<V>>;
        retainAll(arg0: Internal.Collection_<any>): boolean;
    }
    type Long2ObjectMap$FastEntrySet_<V> = Long2ObjectMap$FastEntrySet<V>;
    class ScriptFile implements Internal.Comparable<Internal.ScriptFile> {
        getError(): Internal.Throwable;
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        load(): boolean;
        hashCode(): number;
        notifyAll(): void;
        equals(arg0: any): boolean;
        toString(): string;
        compareTo(o: Internal.ScriptFile_): number;
        notify(): void;
        readonly source : ((arg0: Internal.ScriptFileInfo) => Internal.InputStream);
        readonly pack : Internal.ScriptPack;
        readonly info : Internal.ScriptFileInfo;
        get error(): Internal.Throwable;
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    type ScriptFile_ = ScriptFile;
    interface RenderableImage {
        getHeight(): number;
        createRendering(arg0: Internal.RenderContext_): Internal.RenderedImage;
        isDynamic(): boolean;
        getProperty(arg0: string): any;
        createScaledRendering(arg0: number, arg1: number, arg2: Internal.RenderingHints_): Internal.RenderedImage;
        getPropertyNames(): string[];
        getSources(): Internal.Vector<Internal.RenderableImage>;
        getWidth(): number;
        createDefaultRendering(): Internal.RenderedImage;
        getMinX(): number;
        getMinY(): number;
    }
    type RenderableImage_ = RenderableImage;
    interface SortedSet <E> extends Internal.Set<E> {
        add(arg0: E): boolean;
        tailSet(arg0: E): Internal.SortedSet<E>;
        last(): E;
        headSet(arg0: E): Internal.SortedSet<E>;
        spliterator(): Internal.Spliterator<E>;
        forEach(arg0: Internal.Consumer_<E>): void;
        containsAll(arg0: Internal.Collection_<any>): boolean;
        isEmpty(): boolean;
        clear(): void;
        remove(arg0: any): boolean;
        removeIf(arg0: Internal.Predicate_<E>): boolean;
        comparator(): Internal.Comparator<E>;
        removeAll(arg0: Internal.Collection_<any>): boolean;
        contains(arg0: any): boolean;
        iterator(): Internal.Iterator<E>;
        size(): number;
        stream(): Internal.Stream<E>;
        addAll(arg0: Internal.Collection_<E>): boolean;
        hashCode(): number;
        equals(arg0: any): boolean;
        toArray<T_>(arg0: T_[]): T_[];
        toArray(): any[];
        toArray<T_>(arg0: Internal.IntFunction_<T_[]>): T_[];
        subSet(arg0: E, arg1: E): Internal.SortedSet<E>;
        parallelStream(): Internal.Stream<E>;
        first(): E;
        retainAll(arg0: Internal.Collection_<any>): boolean;
    }
    type SortedSet_<E> = SortedSet<E>;
    class Type {
        getDescriptor(): string;
        static getDescriptor(arg0: Internal.Class_<any>): string;
        getClass(): Internal.Class<any>;
        getElementType(): Internal.Type;
        static getArgumentTypes(arg0: string): Internal.Type[];
        static getArgumentTypes(arg0: Internal.Method_): Internal.Type[];
        getArgumentTypes(): Internal.Type[];
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        notifyAll(): void;
        static getArgumentsAndReturnSizes(arg0: string): number;
        getArgumentsAndReturnSizes(): number;
        notify(): void;
        getDimensions(): number;
        getSort(): number;
        getSize(): number;
        static getMethodDescriptor(arg0: Internal.Type_, arg1: Internal.Type_[]): string;
        static getMethodDescriptor(arg0: Internal.Method_): string;
        getReturnType(): Internal.Type;
        static getReturnType(arg0: string): Internal.Type;
        static getReturnType(arg0: Internal.Method_): Internal.Type;
        getInternalName(): string;
        static getInternalName(arg0: Internal.Class_<any>): string;
        static getType(arg0: Internal.Class_<any>): Internal.Type;
        static getType(arg0: string): Internal.Type;
        static getType(arg0: Internal.Method_): Internal.Type;
        static getType(arg0: Internal.Constructor_<any>): Internal.Type;
        hashCode(): number;
        equals(arg0: any): boolean;
        static getConstructorDescriptor(arg0: Internal.Constructor_<any>): string;
        static getObjectType(arg0: string): Internal.Type;
        static getMethodType(arg0: Internal.Type_, arg1: Internal.Type_[]): Internal.Type;
        static getMethodType(arg0: string): Internal.Type;
        toString(): string;
        getClassName(): string;
        getOpcode(arg0: number): number;
        static readonly CHAR_TYPE : Internal.Type;
        static readonly FLOAT : 6;
        static readonly DOUBLE_TYPE : Internal.Type;
        static readonly ARRAY : 9;
        static readonly LONG_TYPE : Internal.Type;
        static readonly BYTE_TYPE : Internal.Type;
        static readonly CHAR : 2;
        static readonly VOID_TYPE : Internal.Type;
        static readonly OBJECT : 10;
        static readonly BOOLEAN_TYPE : Internal.Type;
        static readonly FLOAT_TYPE : Internal.Type;
        static readonly BOOLEAN : 1;
        static readonly INT : 5;
        static readonly SHORT : 4;
        static readonly BYTE : 3;
        static readonly METHOD : 11;
        static readonly SHORT_TYPE : Internal.Type;
        static readonly DOUBLE : 8;
        static readonly VOID : 0;
        static readonly LONG : 7;
        static readonly INT_TYPE : Internal.Type;
        get argumentsAndReturnSizes(): number;
        get internalName(): string;
        get size(): number;
        get className(): string;
        get descriptor(): string;
        get argumentTypes(): Internal.Type[];
        get sort(): number;
        get class(): Internal.Class<any>;
        get elementType(): Internal.Type;
        get returnType(): Internal.Type;
        get dimensions(): number;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    type Type_ = Type;
    interface AccessorMobEffect {
        getType(): Internal.MobEffectCategory;
    }
    type AccessorMobEffect_ = AccessorMobEffect;
    class ImmutableMultimap$Builder <K, V> {
        orderKeysBy(arg0: Internal.Comparator_<K>): Internal.ImmutableMultimap$Builder<K, V>;
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        build(): Internal.ImmutableMultimap<K, V>;
        hashCode(): number;
        orderValuesBy(arg0: Internal.Comparator_<V>): Internal.ImmutableMultimap$Builder<K, V>;
        notifyAll(): void;
        equals(arg0: any): boolean;
        putAll(arg0: Internal.Multimap_<K, V>): Internal.ImmutableMultimap$Builder<K, V>;
        putAll(arg0: K, arg1: V[]): Internal.ImmutableMultimap$Builder<K, V>;
        putAll(arg0: K, arg1: Internal.Iterable_<V>): Internal.ImmutableMultimap$Builder<K, V>;
        putAll(arg0: Internal.Iterable_<Internal.Map$Entry_<K, V>>): Internal.ImmutableMultimap$Builder<K, V>;
        toString(): string;
        notify(): void;
        put(arg0: Internal.Map$Entry_<K, V>): Internal.ImmutableMultimap$Builder<K, V>;
        put(arg0: K, arg1: V): Internal.ImmutableMultimap$Builder<K, V>;
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    type ImmutableMultimap$Builder_<K, V> = ImmutableMultimap$Builder<K, V>;
    interface ObjectIterator <K> extends Internal.Iterator<K> {
        next(): K;
        hasNext(): boolean;
        skip(arg0: number): number;
        forEachRemaining(arg0: Internal.Consumer_<K>): void;
        remove(): void;
    }
    type ObjectIterator_<K> = ObjectIterator<K>;
    interface Byte2DoubleFunction extends Internal.Function<number, number>, Internal.IntToDoubleFunction {
        getOrDefault(arg0: any, arg1: number): number;
        getOrDefault(arg0: number, arg1: number): number;
        applyAsDouble(arg0: number): number;
        andThenShort(arg0: Internal.Double2ShortFunction_): Internal.Byte2ShortFunction;
        composeByte(arg0: Internal.Byte2ByteFunction_): Internal.Byte2DoubleFunction;
        andThenInt(arg0: Internal.Double2IntFunction_): Internal.Byte2IntFunction;
        composeReference<T_>(arg0: Internal.Reference2ByteFunction_<T_>): Internal.Reference2DoubleFunction<T_>;
        andThen<T_>(arg0: java_.util.function_.Function_<number, T_>): java_.util.function_.Function<number, T_>;
        put(arg0: number, arg1: number): number;
        remove(arg0: number): number;
        remove(arg0: any): number;
        defaultReturnValue(): number;
        defaultReturnValue(arg0: number): void;
        andThenDouble(arg0: Internal.Double2DoubleFunction_): Internal.Byte2DoubleFunction;
        andThenObject<T_>(arg0: Internal.Double2ObjectFunction_<T_>): Internal.Byte2ObjectFunction<T_>;
        get(arg0: any): number;
        get(arg0: number): number;
        andThenLong(arg0: Internal.Double2LongFunction_): Internal.Byte2LongFunction;
        composeLong(arg0: Internal.Long2ByteFunction_): Internal.Long2DoubleFunction;
        andThenByte(arg0: Internal.Double2ByteFunction_): Internal.Byte2ByteFunction;
        andThenFloat(arg0: Internal.Double2FloatFunction_): Internal.Byte2FloatFunction;
        apply(arg0: number): number;
        containsKey(arg0: any): boolean;
        containsKey(arg0: number): boolean;
        composeInt(arg0: Internal.Int2ByteFunction_): Internal.Int2DoubleFunction;
        clear(): void;
        composeFloat(arg0: Internal.Float2ByteFunction_): Internal.Float2DoubleFunction;
        andThenChar(arg0: Internal.Double2CharFunction_): Internal.Byte2CharFunction;
        composeObject<T_>(arg0: Internal.Object2ByteFunction_<T_>): Internal.Object2DoubleFunction<T_>;
        size(): number;
        compose<T_>(arg0: java_.util.function_.Function_<T_, number>): java_.util.function_.Function<T_, number>;
        composeShort(arg0: Internal.Short2ByteFunction_): Internal.Short2DoubleFunction;
        andThenReference<T_>(arg0: Internal.Double2ReferenceFunction_<T_>): Internal.Byte2ReferenceFunction<T_>;
        composeChar(arg0: Internal.Char2ByteFunction_): Internal.Char2DoubleFunction;
        composeDouble(arg0: Internal.Double2ByteFunction_): Internal.Double2DoubleFunction;
    }
    type Byte2DoubleFunction_ = ((arg0: number) => number) | Byte2DoubleFunction;
    class ProtectionDomain {
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        hashCode(): number;
        notifyAll(): void;
        equals(arg0: any): boolean;
        getPermissions(): Internal.PermissionCollection;
        getClassLoader(): Internal.ClassLoader;
        toString(): string;
        getPrincipals(): Internal.Principal[];
        implies(arg0: Internal.Permission_): boolean;
        staticPermissionsOnly(): boolean;
        getCodeSource(): Internal.CodeSource;
        notify(): void;
        get classLoader(): Internal.ClassLoader;
        get permissions(): Internal.PermissionCollection;
        get principals(): Internal.Principal[];
        get codeSource(): Internal.CodeSource;
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    type ProtectionDomain_ = ProtectionDomain;
    interface Keyable {
        keys<T>(arg0: Internal.DynamicOps_<T>): Internal.Stream<T>;
    }
    type Keyable_ = Keyable;
    /**
    */
    class AxeItemBuilder extends Internal.HandheldItemBuilder {
        barWidth(barWidth: Internal.ToIntFunction_<Internal.ItemStackJS_>): Internal.ItemBuilder;
        getClass(): Internal.Class<any>;
        maxStackSize(v: number): Internal.ItemBuilder;
        translationKey(key: string): Internal.BuilderBase<Internal.Item>;
        newID(pre: string, post: string): ResourceLocation;
        use(use: Internal.ItemBuilder$UseCallback_): Internal.ItemBuilder;
        maxDamage(v: number): Internal.ItemBuilder;
        textureJson(json: Internal.JsonObject_): Internal.ItemBuilder;
        tooltip(text: Internal.Component_): Internal.ItemBuilder;
        modifyTier(callback: Internal.Consumer_<Internal.MutableToolTier_>): Internal.HandheldItemBuilder;
        type(type: string): Internal.BuilderBase<Internal.Item>;
        containerItem(id: string): Internal.ItemBuilder;
        subtypes(fn: java_.util.function_.Function_<Internal.ItemStackJS_, Internal.Collection_<Internal.ItemStackJS_>>): Internal.ItemBuilder;
        modelJson(json: Internal.JsonObject_): Internal.ItemBuilder;
        burnTime(v: number): Internal.ItemBuilder;
        useDuration(useDuration: Internal.ToIntFunction_<Internal.ItemStackJS_>): Internal.ItemBuilder;
        tag(tag: ResourceLocation_): Internal.BuilderBase<Internal.Item>;
        parentModel(m: string): Internal.ItemBuilder;
        generateDataJsons(generator: Internal.DataJsonGenerator_): void;
        group(g: string): Internal.ItemBuilder;
        static ofArmorMaterial(o: any): Internal.ArmorMaterial;
        /**
        */
        modifyAttribute(attribute: net.minecraft.world.entity.ai.attributes.Attribute_, identifier: string, d: number, operation: Internal.AttributeModifier$Operation_): Internal.ItemBuilder;
        getRegistryType(): Internal.RegistryObjectBuilderTypes<Internal.Item>;
        attackDamageBonus(f: number): Internal.HandheldItemBuilder;
        glow(v: boolean): Internal.ItemBuilder;
        useAnimation(animation: Internal.UseAnim_): Internal.ItemBuilder;
        rarity(v: Rarity_): Internal.ItemBuilder;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        clientRegistry(minecraft: Internal.Minecraft_): void;
        transformObject(obj: Internal.Item_): Internal.Item;
        color(callback: Internal.ItemBuilder$ItemColorJS_): Internal.ItemBuilder;
        color(index: number, c: Internal.Color_): Internal.ItemBuilder;
        displayName(name: string): Internal.BuilderBase<Internal.Item>;
        notifyAll(): void;
        barColor(barColor: java_.util.function_.Function_<Internal.ItemStackJS_, Internal.Color_>): Internal.ItemBuilder;
        notify(): void;
        createAdditionalObjects(): void;
        speed(f: number): Internal.HandheldItemBuilder;
        tier(t: Internal.Tier_): Internal.HandheldItemBuilder;
        hashCode(): number;
        get(): Internal.Item;
        speedBaseline(f: number): Internal.HandheldItemBuilder;
        generateAssetJsons(generator: Internal.AssetJsonGenerator_): void;
        getTranslationKeyGroup(): string;
        texture(key: string, tex: string): Internal.ItemBuilder;
        texture(tex: string): Internal.ItemBuilder;
        generateLang(lang: Internal.Map_<string, string>): void;
        food(b: Internal.Consumer_<Internal.FoodBuilder_>): Internal.ItemBuilder;
        createObject(): Internal.Item;
        releaseUsing(releaseUsing: Internal.ItemBuilder$ReleaseUsingCallback_): Internal.ItemBuilder;
        attackDamageBaseline(f: number): Internal.HandheldItemBuilder;
        unstackable(): Internal.ItemBuilder;
        addResourcePackLocations(path: string, list: Internal.List_<ResourceLocation_>, packType: Internal.PackType_): void;
        equals(arg0: any): boolean;
        toString(): string;
        finishUsing(finishUsing: Internal.ItemBuilder$FinishUsingCallback_): Internal.ItemBuilder;
        createItemProperties(): Internal.Item$Properties;
        static readonly TOOL_TIERS : {"gold":any,"diamond":any,"iron":any,"wood":any,"stone":any,"netherite":any};
        static readonly ARMOR_TIERS : {"gold":any,"chain":any,"diamond":any,"turtle":any,"iron":any,"leather":any,"netherite":any};
        readonly id : ResourceLocation;
        get registryType(): Internal.RegistryObjectBuilderTypes<Internal.Item>;
        get class(): Internal.Class<any>;
        get translationKeyGroup(): string;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    /**
    */
    type AxeItemBuilder_ = AxeItemBuilder;
    interface IForgeFriendlyByteBuf {
        readRegistryIdSafe<T>(arg0: Internal.Class_<T>): T;
        readRegistryId<T>(): T;
        readFluidStack(): net.minecraftforge.fluids.FluidStack;
        readRegistryIdUnsafe<T>(arg0: Internal.IForgeRegistry_<T>): T;
        writeRegistryId<T>(arg0: T): void;
        writeFluidStack(arg0: net.minecraftforge.fluids.FluidStack_): void;
        writeRegistryIdUnsafe(arg0: Internal.IForgeRegistry_<any>, arg1: ResourceLocation_): void;
        writeRegistryIdUnsafe<T>(arg0: Internal.IForgeRegistry_<T>, arg1: T): void;
    }
    type IForgeFriendlyByteBuf_ = IForgeFriendlyByteBuf;
    interface DoublesAccess {
    }
    type DoublesAccess_ = DoublesAccess;
    interface MessageSizeEstimator$Handle {
        size(arg0: any): number;
    }
    type MessageSizeEstimator$Handle_ = MessageSizeEstimator$Handle;
    interface SlotAccess {
    }
    type SlotAccess_ = SlotAccess;
    interface Shape {
        contains(arg0: Internal.Rectangle2D_): boolean;
        contains(arg0: number, arg1: number, arg2: number, arg3: number): boolean;
        contains(arg0: number, arg1: number): boolean;
        contains(arg0: Internal.Point2D_): boolean;
        getPathIterator(arg0: Internal.AffineTransform_): Internal.PathIterator;
        getPathIterator(arg0: Internal.AffineTransform_, arg1: number): Internal.PathIterator;
        intersects(arg0: number, arg1: number, arg2: number, arg3: number): boolean;
        intersects(arg0: Internal.Rectangle2D_): boolean;
        getBounds2D(): Internal.Rectangle2D;
        getBounds(): Internal.Rectangle;
    }
    type Shape_ = Shape;
    class BlockSnapshot {
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        restore(arg0: boolean): boolean;
        restore(arg0: boolean, arg1: boolean): boolean;
        restore(): boolean;
        getBlockEntity(): Internal.BlockEntity;
        notifyAll(): void;
        restoreToLocation(arg0: Internal.LevelAccessor_, arg1: BlockPos_, arg2: boolean, arg3: boolean): boolean;
        getTag(): Internal.CompoundTag;
        getReplacedBlock(): Internal.BlockState;
        notify(): void;
        getCurrentBlock(): Internal.BlockState;
        getLevel(): Internal.LevelAccessor;
        getPos(): BlockPos;
        hashCode(): number;
        equals(arg0: any): boolean;
        static create(arg0: Internal.ResourceKey_<Internal.Level_>, arg1: Internal.LevelAccessor_, arg2: BlockPos_): Internal.BlockSnapshot;
        static create(arg0: Internal.ResourceKey_<Internal.Level_>, arg1: Internal.LevelAccessor_, arg2: BlockPos_, arg3: number): Internal.BlockSnapshot;
        toString(): string;
        getFlag(): number;
        get flag(): number;
        get currentBlock(): Internal.BlockState;
        get level(): Internal.LevelAccessor;
        get pos(): BlockPos;
        get blockEntity(): Internal.BlockEntity;
        get replacedBlock(): Internal.BlockState;
        get tag(): Internal.CompoundTag;
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    type BlockSnapshot_ = BlockSnapshot;
    interface LootActionsContainer <A> {
        addAction(arg0: Internal.ILootAction_): A;
        addWeightedLoot(arg0: any_[]): A;
        addWeightedLoot(arg0: Internal.NumberProvider_, arg1: boolean, arg2: any_[]): A;
        addWeightedLoot(arg0: Internal.NumberProvider_, arg1: any_[]): A;
        modifyLoot(arg0: ItemFilter_, arg1: Internal.ModifyLootAction$Callback_): A;
        triggerExplosion(arg0: number, arg1: boolean, arg2: boolean): A;
        triggerLightningStrike(arg0: boolean): A;
        removeLoot(arg0: ItemFilter_): A;
        replaceLoot(arg0: ItemFilter_, arg1: Internal.ItemStack_): A;
        addLoot(arg0: Internal.ItemStack_[]): A;
    }
    type LootActionsContainer_<A> = LootActionsContainer<A>;
    class ItemEntity extends Internal.Entity implements Internal.AccessorItemEntity, Internal.ItemEntityAccess, Internal.LycheeCounter {
        getClass(): Internal.Class<any>;
        resetDynamicLight(): void;
        getCapability<T_>(arg0: Internal.Capability_<T_>, arg1: Internal.Direction_): Internal.LazyOptional<T_>;
        getCapability<T_>(arg0: Internal.Capability_<T_>): Internal.LazyOptional<T_>;
        captureDrops(arg0: Internal.Collection_<Internal.ItemEntity_>): Internal.Collection<Internal.ItemEntity>;
        captureDrops(): Internal.Collection<Internal.ItemEntity>;
        canBeRiddenInWater(arg0: Internal.Entity_): boolean;
        isDynamicLightEnabled(): boolean;
        changeDimension(arg0: Internal.ServerLevel_, arg1: Internal.ITeleporter_): Internal.Entity;
        serializeNBT(): Internal.CompoundTag;
        invalidateCaps(): void;
        setDynamicLightEnabled(arg0: boolean): void;
        shouldUpdateDynamicLight(): boolean;
        revive(): void;
        setVisualScale(arg0: number): void;
        lychee$getRecipeId(): ResourceLocation;
        dynamicLightTick(): void;
        getPersistentDataKJS(): Internal.CompoundTag;
        canUpdate(): boolean;
        canUpdate(arg0: boolean): void;
        getDynamicLightY(): number;
        getDynamicLightZ(): number;
        getDynamicLightX(): number;
        areCapsCompatible(arg0: Internal.CapabilityProvider_<Internal.Entity_>): boolean;
        areCapsCompatible(arg0: Internal.CapabilityDispatcher_): boolean;
        getEyeHeightAccess(arg0: Internal.Pose_, arg1: Internal.EntityDimensions_): number;
        reviveCaps(): void;
        lambdynlights$updateDynamicLight(arg0: Internal.LevelRenderer_): boolean;
        handler$bih000$removed(arg0: Internal.CallbackInfo_): void;
        canRiderInteract(): boolean;
        lambdynlights$scheduleTrackedChunksRebuild(arg0: Internal.LevelRenderer_): void;
        handler$bih001$onTick(arg0: Internal.CallbackInfo_): void;
        onAddedToWorld(): void;
        canTrample(arg0: Internal.BlockState_, arg1: BlockPos_, arg2: number): boolean;
        lychee$setCount(arg0: number): void;
        getClassification(arg0: boolean): Internal.MobCategory;
        handler$bih000$onRemove(arg0: Internal.CallbackInfo_): void;
        lychee$getCount(): number;
        shouldRiderSit(): boolean;
        getPickedResult(arg0: Internal.HitResult_): Internal.ItemStack;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        notifyAll(): void;
        getPersistentData(): Internal.CompoundTag;
        notify(): void;
        lychee$setRecipeId(arg0: ResourceLocation_): void;
        hashCode(): number;
        setDimension(arg0: Internal.EntityDimensions_): void;
        isAddedToWorld(): boolean;
        getParts(): any[];
        getDynamicLightWorld(): Internal.Level;
        onRemovedFromWorld(): void;
        lychee$update(arg0: ResourceLocation_, arg1: Internal.Recipe_<any>): void;
        getLuminance(): number;
        isMultipartEntity(): boolean;
        deserializeNBT(arg0: Internal.CompoundTag_): void;
        asKJS(): any;
        equals(arg0: any): boolean;
        toString(): string;
        getVisualScale(): number;
        lifespan : number;
        get luminance(): number;
        get dynamicLightEnabled(): boolean;
        get persistentData(): Internal.CompoundTag;
        get multipartEntity(): boolean;
        get addedToWorld(): boolean;
        get dynamicLightY(): number;
        get dynamicLightZ(): number;
        get dynamicLightX(): number;
        get visualScale(): number;
        get persistentDataKJS(): Internal.CompoundTag;
        get parts(): any[];
        get class(): Internal.Class<any>;
        get dynamicLightWorld(): Internal.Level;
        set dynamicLightEnabled(arg0: boolean);
        set visualScale(arg0: number);
        set dimension(arg0: Internal.EntityDimensions_);
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    type ItemEntity_ = ItemEntity;
    interface DoubleToLongFunction {
        applyAsLong(arg0: number): number;
    }
    type DoubleToLongFunction_ = ((arg0: number) => number) | DoubleToLongFunction;
    interface LongComparator extends Internal.Comparator<number> {
        compare(arg0: number, arg1: number): number;
        thenComparingLong(arg0: Internal.ToLongFunction_<number>): Internal.Comparator<number>;
        thenComparingInt(arg0: Internal.ToIntFunction_<number>): Internal.Comparator<number>;
        thenComparing(arg0: Internal.Comparator_<number>): Internal.Comparator<number>;
        thenComparing(arg0: Internal.LongComparator_): Internal.LongComparator;
        thenComparing<U_>(arg0: java_.util.function_.Function_<number, U_>, arg1: Internal.Comparator_<U_>): Internal.Comparator<number>;
        thenComparing<U_>(arg0: java_.util.function_.Function_<number, U_>): Internal.Comparator<number>;
        thenComparingDouble(arg0: Internal.ToDoubleFunction_<number>): Internal.Comparator<number>;
        equals(arg0: any): boolean;
        reversed(): Internal.LongComparator;
    }
    type LongComparator_ = ((arg0: number, arg1: number) => number) | LongComparator;
    interface ChunkRandom {
        getRandom(arg0: number): Internal.Random;
    }
    type ChunkRandom_ = ChunkRandom;
    class Exception extends Internal.Throwable {
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        printStackTrace(): void;
        printStackTrace(arg0: Internal.PrintWriter_): void;
        printStackTrace(arg0: Internal.PrintStream_): void;
        getLocalizedMessage(): string;
        notifyAll(): void;
        initCause(arg0: Internal.Throwable_): Internal.Throwable;
        getMessage(): string;
        getCause(): Internal.Throwable;
        notify(): void;
        addSuppressed(arg0: Internal.Throwable_): void;
        setStackTrace(arg0: any_[]): void;
        getStackTrace(): any[];
        hashCode(): number;
        equals(arg0: any): boolean;
        getSuppressed(): Internal.Throwable[];
        toString(): string;
        fillInStackTrace(): Internal.Throwable;
        get localizedMessage(): string;
        get cause(): Internal.Throwable;
        get stackTrace(): any[];
        get suppressed(): Internal.Throwable[];
        get message(): string;
        get class(): Internal.Class<any>;
        set stackTrace(arg0: any_[]);
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    type Exception_ = Exception;
    interface MessageSizeEstimator {
        newHandle(): Internal.MessageSizeEstimator$Handle;
    }
    type MessageSizeEstimator_ = MessageSizeEstimator;
    interface Map$Entry <K, V> {
        getKey(): K;
        getValue(): V;
        hashCode(): number;
        setValue(arg0: V): V;
        equals(arg0: any): boolean;
    }
    type Map$Entry_<K, V> = Map$Entry<K, V>;
    interface ConfigFormat <C> {
        createWriter(): Internal.ConfigWriter;
        supportsType(arg0: Internal.Class_<any>): boolean;
        initEmptyFile(arg0: Internal.WriterSupplier_): void;
        initEmptyFile(arg0: Internal.File_): void;
        initEmptyFile(arg0: Internal.Path_): void;
        supportsComments(): boolean;
        isInMemory(): boolean;
        createConfig(arg0: Internal.Supplier_<Internal.Map_<string, any>>): C;
        createConfig(): C;
        createParser(): Internal.ConfigParser<C>;
        createConcurrentConfig(): C;
    }
    type ConfigFormat_<C> = ConfigFormat<C>;
    abstract class AbstractLongSet extends Internal.AbstractLongCollection implements Internal.Cloneable, Internal.LongSet {
        getClass(): Internal.Class<any>;
        longIterator(): Internal.LongIterator;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        notifyAll(): void;
        notify(): void;
        remove(arg0: number): boolean;
        remove(arg0: any): boolean;
        removeAll(arg0: Internal.LongCollection_): boolean;
        removeAll(arg0: Internal.Collection_<any>): boolean;
        iterator(): Internal.LongIterator;
        stream(): Internal.Stream<number>;
        hashCode(): number;
        toArray(arg0: number[]): number[];
        toArray(): any[];
        toArray<T_>(arg0: T_[]): T_[];
        toArray<T_>(arg0: Internal.IntFunction_<T_[]>): T_[];
        longStream(): Internal.LongStream;
        parallelStream(): Internal.Stream<number>;
        rem(arg0: number): boolean;
        add(arg0: number): boolean;
        longSpliterator(): Internal.LongSpliterator;
        toLongArray(arg0: number[]): number[];
        toLongArray(): number[];
        spliterator(): Internal.LongSpliterator;
        forEach(arg0: Internal.LongConsumer_): void;
        forEach(arg0: Internal.Consumer_<number>): void;
        forEach(arg0: java_.util.function_.LongConsumer_): void;
        containsAll(arg0: Internal.Collection_<any>): boolean;
        containsAll(arg0: Internal.LongCollection_): boolean;
        isEmpty(): boolean;
        clear(): void;
        longParallelStream(): Internal.LongStream;
        removeIf(arg0: it.unimi.dsi.fastutil.longs.LongPredicate_): boolean;
        removeIf(arg0: Internal.Predicate_<number>): boolean;
        removeIf(arg0: Internal.LongPredicate_): boolean;
        contains(arg0: number): boolean;
        contains(arg0: any): boolean;
        size(): number;
        addAll(arg0: Internal.LongCollection_): boolean;
        addAll(arg0: Internal.Collection_<number>): boolean;
        equals(arg0: any): boolean;
        toString(): string;
        retainAll(arg0: Internal.Collection_<any>): boolean;
        retainAll(arg0: Internal.LongCollection_): boolean;
        get class(): Internal.Class<any>;
        get empty(): boolean;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    type AbstractLongSet_ = AbstractLongSet;
    class FieldPosition {
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        getEndIndex(): number;
        hashCode(): number;
        notifyAll(): void;
        getFieldAttribute(): Internal.Format$Field;
        equals(arg0: any): boolean;
        getField(): number;
        setEndIndex(arg0: number): void;
        toString(): string;
        getBeginIndex(): number;
        setBeginIndex(arg0: number): void;
        notify(): void;
        get field(): number;
        get fieldAttribute(): Internal.Format$Field;
        get endIndex(): number;
        get beginIndex(): number;
        get class(): Internal.Class<any>;
        set endIndex(arg0: number);
        set beginIndex(arg0: number);
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    type FieldPosition_ = FieldPosition;
    class StringBuffer extends Internal.AbstractStringBuilder implements Internal.Serializable, Internal.Comparable<Internal.StringBuffer>, Internal.CharSequence {
        deleteCharAt(arg0: number): Internal.StringBuffer;
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        codePointAt(arg0: number): number;
        notifyAll(): void;
        setCharAt(arg0: number, arg1: string): void;
        replace(arg0: number, arg1: number, arg2: string): Internal.StringBuffer;
        insert(arg0: number, arg1: number): Internal.StringBuffer;
        insert(arg0: number, arg1: string): Internal.StringBuffer;
        insert(arg0: number, arg1: boolean): Internal.StringBuffer;
        insert(arg0: number, arg1: Internal.CharSequence_, arg2: number, arg3: number): Internal.StringBuffer;
        insert(arg0: number, arg1: any): Internal.StringBuffer;
        insert(arg0: number, arg1: string[], arg2: number, arg3: number): Internal.StringBuffer;
        insert(arg0: number, arg1: string[]): Internal.StringBuffer;
        insert(arg0: number, arg1: Internal.CharSequence_): Internal.StringBuffer;
        compareTo(arg0: Internal.StringBuffer_): number;
        delete(arg0: number, arg1: number): Internal.StringBuffer;
        notify(): void;
        substring(arg0: number, arg1: number): string;
        substring(arg0: number): string;
        capacity(): number;
        appendCodePoint(arg0: number): Internal.StringBuffer;
        hashCode(): number;
        codePointBefore(arg0: number): number;
        indexOf(arg0: string): number;
        indexOf(arg0: string, arg1: number): number;
        codePointCount(arg0: number, arg1: number): number;
        trimToSize(): void;
        getChars(arg0: number, arg1: number, arg2: string[], arg3: number): void;
        isEmpty(): boolean;
        length(): number;
        subSequence(arg0: number, arg1: number): Internal.CharSequence;
        reverse(): Internal.StringBuffer;
        lastIndexOf(arg0: string, arg1: number): number;
        lastIndexOf(arg0: string): number;
        setLength(arg0: number): void;
        equals(arg0: any): boolean;
        toString(): string;
        ensureCapacity(arg0: number): void;
        offsetByCodePoints(arg0: number, arg1: number): number;
        charAt(arg0: number): string;
        append(arg0: string[]): Internal.StringBuffer;
        append(arg0: number): Internal.StringBuffer;
        append(arg0: string[], arg1: number, arg2: number): Internal.StringBuffer;
        append(arg0: boolean): Internal.StringBuffer;
        append(arg0: string): Internal.StringBuffer;
        append(arg0: Internal.StringBuffer_): Internal.StringBuffer;
        append(arg0: Internal.CharSequence_): Internal.StringBuffer;
        append(arg0: Internal.CharSequence_, arg1: number, arg2: number): Internal.StringBuffer;
        append(arg0: any): Internal.StringBuffer;
        get class(): Internal.Class<any>;
        get empty(): boolean;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    type StringBuffer_ = StringBuffer;
    class ValueRange implements Internal.Serializable {
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        notifyAll(): void;
        getMaximum(): number;
        getSmallestMaximum(): number;
        notify(): void;
        isIntValue(): boolean;
        getLargestMinimum(): number;
        isValidValue(arg0: number): boolean;
        hashCode(): number;
        static of(arg0: number, arg1: number): Internal.ValueRange;
        static of(arg0: number, arg1: number, arg2: number, arg3: number): Internal.ValueRange;
        static of(arg0: number, arg1: number, arg2: number): Internal.ValueRange;
        equals(arg0: any): boolean;
        getMinimum(): number;
        checkValidValue(arg0: number, arg1: Internal.TemporalField_): number;
        checkValidIntValue(arg0: number, arg1: Internal.TemporalField_): number;
        toString(): string;
        isFixed(): boolean;
        isValidIntValue(arg0: number): boolean;
        get largestMinimum(): number;
        get smallestMaximum(): number;
        get intValue(): boolean;
        get maximum(): number;
        get fixed(): boolean;
        get class(): Internal.Class<any>;
        get minimum(): number;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    type ValueRange_ = ValueRange;
    class ResourceKey <T> implements Internal.Comparable<Internal.ResourceKey<any>>, Internal.ResourceKeyAccess, Internal.SpecialEquality {
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        getNamespace(): string;
        hashCode(): number;
        notifyAll(): void;
        equals(arg0: any): boolean;
        getPath(): string;
        getRegistryName(): ResourceLocation;
        toString(): string;
        compareTo(arg0: Internal.ResourceKey_<any>): number;
        notify(): void;
        specialEquals(o: any, shallow: boolean): boolean;
        get path(): string;
        get namespace(): string;
        get registryName(): ResourceLocation;
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    type ResourceKey_<T> = ResourceKey<T>;
    interface IntIterable extends Internal.Iterable<number> {
        iterator(): Internal.IntIterator;
        spliterator(): Internal.IntSpliterator;
        forEach(arg0: java_.util.function_.IntConsumer_): void;
        forEach(arg0: Internal.Consumer_<number>): void;
        forEach(arg0: Internal.IntConsumer_): void;
        intIterator(): Internal.IntIterator;
        intSpliterator(): Internal.IntSpliterator;
    }
    type IntIterable_ = IntIterable;
    /**
    * Fired when you need to add some datapack json to the server.
    *
    * Low priority event is fired first, as they will be overriden later.
    *
    * And vise versa for high priority events.
    */
    class DataPackEventJS extends Internal.ServerEventJS {
        cancel(): void;
        getServer(): Internal.ServerJS;
        add(id: ResourceLocation_, content: string): void;
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        isCancelled(): boolean;
        notifyAll(): void;
        addJson(id: ResourceLocation_, json: Internal.JsonElement_): void;
        notify(): void;
        post(t: Internal.ScriptType_, id: string, sub: string): boolean;
        post(t: Internal.ScriptType_, id: string): boolean;
        hashCode(): number;
        equals(arg0: any): boolean;
        toString(): string;
        canCancel(): boolean;
        get server(): Internal.ServerJS;
        get cancelled(): boolean;
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    /**
    * Fired when you need to add some datapack json to the server.
    *
    * Low priority event is fired first, as they will be overriden later.
    *
    * And vise versa for high priority events.
    */
    type DataPackEventJS_ = DataPackEventJS;
    class NoiseRouter extends Internal.Record {
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        hashCode(): number;
        notifyAll(): void;
        equals(arg0: any): boolean;
        toString(): string;
        notify(): void;
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    type NoiseRouter_ = NoiseRouter;
    class PoiType extends Internal.ForgeRegistryEntry<Internal.PoiType> implements Internal.PoiTypeAccess {
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        getBlockStates(): Internal.ImmutableSet<Internal.BlockState>;
        hashCode(): number;
        notifyAll(): void;
        equals(arg0: any): boolean;
        getRegistryType(): Internal.Class<Internal.PoiType>;
        getRegistryName(): ResourceLocation;
        setRegistryName(arg0: ResourceLocation_): Internal.PoiType;
        setRegistryName(arg0: string): Internal.PoiType;
        setRegistryName(arg0: string, arg1: string): Internal.PoiType;
        toString(): string;
        notify(): void;
        readonly delegate : Internal.IRegistryDelegate<Internal.PoiType>;
        get registryType(): Internal.Class<Internal.PoiType>;
        get blockStates(): Internal.ImmutableSet<Internal.BlockState>;
        get registryName(): ResourceLocation;
        get class(): Internal.Class<any>;
        set registryName(arg0: ResourceLocation_);
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    type PoiType_ = PoiType;
    interface MultiBufferSource {
    }
    type MultiBufferSource_ = MultiBufferSource;
    interface Int2FloatFunction extends Internal.Function<number, number>, Internal.IntToDoubleFunction {
        getOrDefault(arg0: any, arg1: number): number;
        getOrDefault(arg0: number, arg1: number): number;
        applyAsDouble(arg0: number): number;
        andThenShort(arg0: Internal.Float2ShortFunction_): Internal.Int2ShortFunction;
        composeByte(arg0: Internal.Byte2IntFunction_): Internal.Byte2FloatFunction;
        andThenInt(arg0: Internal.Float2IntFunction_): Internal.Int2IntFunction;
        composeReference<T_>(arg0: Internal.Reference2IntFunction_<T_>): Internal.Reference2FloatFunction<T_>;
        andThen<T_>(arg0: java_.util.function_.Function_<number, T_>): java_.util.function_.Function<number, T_>;
        put(arg0: number, arg1: number): number;
        remove(arg0: number): number;
        remove(arg0: any): number;
        defaultReturnValue(): number;
        defaultReturnValue(arg0: number): void;
        andThenDouble(arg0: Internal.Float2DoubleFunction_): Internal.Int2DoubleFunction;
        andThenObject<T_>(arg0: Internal.Float2ObjectFunction_<T_>): Internal.Int2ObjectFunction<T_>;
        get(arg0: any): number;
        get(arg0: number): number;
        andThenLong(arg0: Internal.Float2LongFunction_): Internal.Int2LongFunction;
        composeLong(arg0: Internal.Long2IntFunction_): Internal.Long2FloatFunction;
        andThenByte(arg0: Internal.Float2ByteFunction_): Internal.Int2ByteFunction;
        andThenFloat(arg0: Internal.Float2FloatFunction_): Internal.Int2FloatFunction;
        apply(arg0: number): number;
        containsKey(arg0: any): boolean;
        containsKey(arg0: number): boolean;
        composeInt(arg0: Internal.Int2IntFunction_): Internal.Int2FloatFunction;
        clear(): void;
        composeFloat(arg0: Internal.Float2IntFunction_): Internal.Float2FloatFunction;
        andThenChar(arg0: Internal.Float2CharFunction_): Internal.Int2CharFunction;
        composeObject<T_>(arg0: Internal.Object2IntFunction_<T_>): Internal.Object2FloatFunction<T_>;
        size(): number;
        compose<T_>(arg0: java_.util.function_.Function_<T_, number>): java_.util.function_.Function<T_, number>;
        composeShort(arg0: Internal.Short2IntFunction_): Internal.Short2FloatFunction;
        andThenReference<T_>(arg0: Internal.Float2ReferenceFunction_<T_>): Internal.Int2ReferenceFunction<T_>;
        composeChar(arg0: Internal.Char2IntFunction_): Internal.Char2FloatFunction;
        composeDouble(arg0: Internal.Double2IntFunction_): Internal.Double2FloatFunction;
    }
    type Int2FloatFunction_ = ((arg0: number) => number) | Int2FloatFunction;
    class StoneButtonBlockBuilder extends Internal.ShapedBlockBuilder {
        noItem(): Internal.BlockBuilder;
        suffocating(b: boolean): Internal.BlockBuilder;
        getClass(): Internal.Class<any>;
        translationKey(key: string): Internal.BuilderBase<Internal.Block>;
        newID(pre: string, post: string): ResourceLocation;
        type(type: string): Internal.BuilderBase<Internal.Block>;
        unbreakable(): Internal.BlockBuilder;
        model(m: string): Internal.BlockBuilder;
        tag(tag: ResourceLocation_): Internal.BlockBuilder;
        generateDataJsons(generator: Internal.DataJsonGenerator_): void;
        tagBoth(tag: ResourceLocation_): Internal.BlockBuilder;
        defaultCutout(): Internal.BlockBuilder;
        item(i: Internal.Consumer_<Internal.BlockItemBuilder_>): Internal.BlockBuilder;
        resistance(r: number): Internal.BlockBuilder;
        hardness(h: number): Internal.BlockBuilder;
        slipperiness(f: number): Internal.BlockBuilder;
        getRegistryType(): Internal.RegistryObjectBuilderTypes<Internal.Block>;
        textureSide(direction: Internal.Direction_, tex: string): Internal.BlockBuilder;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        clientRegistry(minecraft: Internal.Minecraft_): void;
        waterlogged(): Internal.BlockBuilder;
        transformObject(obj: Internal.Block_): Internal.Block;
        color(index: number, c: Internal.Color_): Internal.BlockBuilder;
        textureAll(tex: string): Internal.BlockBuilder;
        displayName(name: string): Internal.BuilderBase<Internal.Block>;
        notifyAll(): void;
        box(x0: number, y0: number, z0: number, x1: number, y1: number, z1: number): Internal.BlockBuilder;
        box(x0: number, y0: number, z0: number, x1: number, y1: number, z1: number, scale16: boolean): Internal.BlockBuilder;
        viewBlocking(b: boolean): Internal.BlockBuilder;
        notify(): void;
        transparent(b: boolean): Internal.BlockBuilder;
        createAdditionalObjects(): void;
        tagBlock(tag: ResourceLocation_): Internal.BlockBuilder;
        fullBlock(f: boolean): Internal.BlockBuilder;
        createProperties(): Internal.BlockBehaviour$Properties;
        notSolid(): Internal.BlockBuilder;
        generateBlockModels(builder: Internal.BlockBuilder_): Internal.Map<ResourceLocation, Internal.JsonObject>;
        hashCode(): number;
        noCollission(): Internal.BlockBuilder;
        get(): Internal.Block;
        requiresTool(f: boolean): Internal.BlockBuilder;
        renderType(l: string): Internal.BlockBuilder;
        jumpFactor(f: number): Internal.BlockBuilder;
        createShape(): Internal.VoxelShape;
        generateAssetJsons(generator: Internal.AssetJsonGenerator_): void;
        noCollision(): Internal.BlockBuilder;
        opaque(o: boolean): Internal.BlockBuilder;
        randomTick(randomTickCallback: Internal.Consumer_<Internal.RandomTickCallbackJS_>): Internal.BlockBuilder;
        getTranslationKeyGroup(): string;
        texture(id: string, tex: string): Internal.BlockBuilder;
        noDrops(): Internal.BlockBuilder;
        generateLang(lang: Internal.Map_<string, string>): void;
        tagItem(tag: ResourceLocation_): Internal.BlockBuilder;
        speedFactor(f: number): Internal.BlockBuilder;
        noValidSpawns(b: boolean): Internal.BlockBuilder;
        createObject(): Internal.Block;
        lightLevel(light: number): Internal.BlockBuilder;
        addResourcePackLocations(path: string, list: Internal.List_<ResourceLocation_>, packType: Internal.PackType_): void;
        defaultTranslucent(): Internal.BlockBuilder;
        material(m: Internal.MaterialJS_): Internal.BlockBuilder;
        equals(arg0: any): boolean;
        toString(): string;
        redstoneConductor(b: boolean): Internal.BlockBuilder;
        lootTable : ((arg0: Internal.LootBuilder) => void);
        modelJson : Internal.JsonObject;
        blockstateJson : Internal.JsonObject;
        readonly id : ResourceLocation;
        randomTickCallback : ((arg0: Internal.RandomTickCallbackJS) => void);
        get registryType(): Internal.RegistryObjectBuilderTypes<Internal.Block>;
        get class(): Internal.Class<any>;
        get translationKeyGroup(): string;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    type StoneButtonBlockBuilder_ = StoneButtonBlockBuilder;
    class SmithingRecipeJS extends Internal.RecipeJS {
        parseResultItemList(o: any): Internal.List<Internal.ItemStackJS>;
        getClass(): Internal.Class<any>;
        ingredientAction(filter: Internal.IngredientActionFilter_, action: Internal.IngredientAction_): Internal.RecipeJS;
        convertReplacedInput(index: number, oldIngredient: Internal.IngredientJS_, newIngredient: Internal.IngredientJS_): Internal.IngredientJS;
        getUniqueId(): string;
        replaceOutput(i: Internal.IngredientJS_, with_: Internal.ItemStackJS_, exact: boolean): boolean;
        replaceOutput(i: Internal.IngredientJS_, with_: Internal.ItemStackJS_, exact: boolean, func: Internal.BiFunction_<Internal.ItemStackJS_, Internal.ItemStackJS_, Internal.ItemStackJS_>): boolean;
        parseIngredientItemList(o: any): Internal.List<Internal.IngredientJS>;
        merge(data: any): Internal.RecipeJS;
        getPath(): string;
        create(args: Internal.ListJS_): void;
        parseIngredientItemStackList(o: any): Internal.List<Internal.IngredientStackJS>;
        id(_id: ResourceLocation_): Internal.RecipeJS;
        parseIngredientItem(o: any, key: string): Internal.IngredientJS;
        parseIngredientItem(o: any): Internal.IngredientJS;
        group(g: string): Internal.RecipeJS;
        getOriginalRecipeResult(): Internal.ItemStackJS;
        getOriginalRecipeIngredients(): Internal.List<Internal.IngredientJS>;
        getInputIndex(ingredient: Internal.IngredientJS_, exact: boolean): number;
        setGroup(g: string): void;
        serialize(): void;
        replaceInput(i: Internal.IngredientJS_, with_: Internal.IngredientJS_, exact: boolean, func: Internal.BiFunction_<Internal.IngredientJS_, Internal.IngredientJS_, Internal.IngredientJS_>): boolean;
        replaceInput(i: Internal.IngredientJS_, with_: Internal.IngredientJS_, exact: boolean): boolean;
        getType(): string;
        getGroup(): string;
        hasOutput(ingredient: Internal.IngredientJS_, exact: boolean): boolean;
        keepIngredient(filter: Internal.IngredientActionFilter_): Internal.RecipeJS;
        customIngredientAction(filter: Internal.IngredientActionFilter_, id: string): Internal.RecipeJS;
        modifyResult(callback: Internal.ModifyRecipeResultCallback_): Internal.RecipeJS;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        getMod(): string;
        notifyAll(): void;
        convertReplacedOutput(index: number, oldStack: Internal.ItemStackJS_, newStack: Internal.ItemStackJS_): Internal.ItemStackJS;
        save(): void;
        damageIngredient(filter: Internal.IngredientActionFilter_): Internal.RecipeJS;
        damageIngredient(filter: Internal.IngredientActionFilter_, damage: number): Internal.RecipeJS;
        getId(): string;
        dontAdd(): void;
        notify(): void;
        serializeJson(): void;
        createRecipe(): Internal.Recipe<any>;
        getFromToString(): string;
        hashCode(): number;
        deserializeJson(): void;
        getOrCreateId(): ResourceLocation;
        deserialize(): void;
        serializeNBTAsJson(): boolean;
        getOutputIndex(ingredient: Internal.IngredientJS_, exact: boolean): number;
        serializeIngredientStack(in_: Internal.IngredientStackJS_): Internal.JsonElement;
        resultFromRecipeJson(json: Internal.JsonObject_): Internal.ItemStackJS;
        stage(s: string): Internal.RecipeJS;
        equals(arg0: any): boolean;
        serializeItemStack(stack: Internal.ItemStackJS_): Internal.JsonElement;
        toString(): string;
        hasInput(ingredient: Internal.IngredientJS_, exact: boolean): boolean;
        parseResultItem(o: any): Internal.ItemStackJS;
        replaceIngredient(filter: Internal.IngredientActionFilter_, item: Internal.ItemStackJS_): Internal.RecipeJS;
        static currentRecipe : Internal.RecipeJS;
        originalJson : Internal.JsonObject;
        serializeOutputs : boolean;
        originalRecipe : Internal.Recipe<any>;
        readonly inputItems : Internal.List<((arg0: Internal.ItemStackJS) => boolean)>;
        static itemErrors : false;
        json : Internal.JsonObject;
        readonly outputItems : Internal.List<Internal.ItemStackJS>;
        type : Internal.RecipeTypeJS;
        serializeInputs : boolean;
        get path(): string;
        get originalRecipeIngredients(): Internal.List<Internal.IngredientJS>;
        get mod(): string;
        get originalRecipeResult(): Internal.ItemStackJS;
        get orCreateId(): ResourceLocation;
        get class(): Internal.Class<any>;
        get fromToString(): string;
        get uniqueId(): string;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    type SmithingRecipeJS_ = SmithingRecipeJS;
    class FluidAttributes$Builder {
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        density(arg0: number): Internal.FluidAttributes$Builder;
        translationKey(arg0: string): Internal.FluidAttributes$Builder;
        overlay(arg0: ResourceLocation_): Internal.FluidAttributes$Builder;
        color(arg0: number): Internal.FluidAttributes$Builder;
        notifyAll(): void;
        sound(arg0: Internal.SoundEvent_): Internal.FluidAttributes$Builder;
        sound(arg0: Internal.SoundEvent_, arg1: Internal.SoundEvent_): Internal.FluidAttributes$Builder;
        gaseous(): Internal.FluidAttributes$Builder;
        notify(): void;
        viscosity(arg0: number): Internal.FluidAttributes$Builder;
        build(arg0: Internal.Fluid_): Internal.FluidAttributes;
        hashCode(): number;
        equals(arg0: any): boolean;
        temperature(arg0: number): Internal.FluidAttributes$Builder;
        luminosity(arg0: number): Internal.FluidAttributes$Builder;
        toString(): string;
        rarity(arg0: Rarity_): Internal.FluidAttributes$Builder;
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    type FluidAttributes$Builder_ = FluidAttributes$Builder;
    interface ItemSupplier {
    }
    type ItemSupplier_ = ItemSupplier;
    interface Key extends Internal.Serializable {
        getEncoded(): number[];
        getAlgorithm(): string;
        getFormat(): string;
    }
    type Key_ = Key;
    interface Byte2DoubleMap extends Internal.Byte2DoubleFunction, Internal.Map<number, number> {
        getOrDefault(arg0: number, arg1: number): number;
        getOrDefault(arg0: any, arg1: number): number;
        applyAsDouble(arg0: number): number;
        replace(arg0: number, arg1: number, arg2: number): boolean;
        replace(arg0: number, arg1: number): number;
        composeByte(arg0: Internal.Byte2ByteFunction_): Internal.Byte2DoubleFunction;
        composeReference<T_>(arg0: Internal.Reference2ByteFunction_<T_>): Internal.Reference2DoubleFunction<T_>;
        andThen<T_>(arg0: java_.util.function_.Function_<number, T_>): java_.util.function_.Function<number, T_>;
        containsValue(arg0: number): boolean;
        containsValue(arg0: any): boolean;
        put(arg0: number, arg1: number): number;
        compute(arg0: number, arg1: Internal.BiFunction_<number, number, number>): number;
        defaultReturnValue(): number;
        defaultReturnValue(arg0: number): void;
        andThenObject<T_>(arg0: Internal.Double2ObjectFunction_<T_>): Internal.Byte2ObjectFunction<T_>;
        merge(arg0: number, arg1: number, arg2: Internal.BiFunction_<number, number, number>): number;
        composeLong(arg0: Internal.Long2ByteFunction_): Internal.Long2DoubleFunction;
        entrySet(): Internal.ObjectSet<Internal.Map$Entry<number, number>>;
        containsKey(arg0: number): boolean;
        containsKey(arg0: any): boolean;
        composeObject<T_>(arg0: Internal.Object2ByteFunction_<T_>): Internal.Object2DoubleFunction<T_>;
        size(): number;
        compose<T_>(arg0: java_.util.function_.Function_<T_, number>): java_.util.function_.Function<T_, number>;
        composeShort(arg0: Internal.Short2ByteFunction_): Internal.Short2DoubleFunction;
        mergeDouble(arg0: number, arg1: number, arg2: Internal.DoubleBinaryOperator_): number;
        mergeDouble(arg0: number, arg1: number, arg2: it.unimi.dsi.fastutil.doubles.DoubleBinaryOperator_): number;
        composeChar(arg0: Internal.Char2ByteFunction_): Internal.Char2DoubleFunction;
        composeDouble(arg0: Internal.Double2ByteFunction_): Internal.Double2DoubleFunction;
        byte2DoubleEntrySet(): Internal.ObjectSet<Internal.Byte2DoubleMap$Entry>;
        computeIfAbsent(arg0: number, arg1: Internal.IntToDoubleFunction_): number;
        computeIfAbsent(arg0: number, arg1: java_.util.function_.Function_<number, number>): number;
        computeIfAbsent(arg0: number, arg1: Internal.Byte2DoubleFunction_): number;
        values(): Internal.DoubleCollection;
        andThenShort(arg0: Internal.Double2ShortFunction_): Internal.Byte2ShortFunction;
        computeIfAbsentPartial(arg0: number, arg1: Internal.Byte2DoubleFunction_): number;
        replaceAll(arg0: Internal.BiFunction_<number, number, number>): void;
        andThenInt(arg0: Internal.Double2IntFunction_): Internal.Byte2IntFunction;
        remove(arg0: number, arg1: number): boolean;
        remove(arg0: any): number;
        remove(arg0: any, arg1: any): boolean;
        remove(arg0: number): number;
        andThenDouble(arg0: Internal.Double2DoubleFunction_): Internal.Byte2DoubleFunction;
        hashCode(): number;
        putAll(arg0: Internal.Map_<number, number>): void;
        get(arg0: any): number;
        get(arg0: number): number;
        andThenLong(arg0: Internal.Double2LongFunction_): Internal.Byte2LongFunction;
        keySet(): Internal.ByteSet;
        andThenByte(arg0: Internal.Double2ByteFunction_): Internal.Byte2ByteFunction;
        andThenFloat(arg0: Internal.Double2FloatFunction_): Internal.Byte2FloatFunction;
        apply(arg0: number): number;
        computeIfAbsentNullable(arg0: number, arg1: Internal.IntFunction_<number>): number;
        forEach(arg0: Internal.BiConsumer_<number, number>): void;
        composeInt(arg0: Internal.Int2ByteFunction_): Internal.Int2DoubleFunction;
        isEmpty(): boolean;
        clear(): void;
        composeFloat(arg0: Internal.Float2ByteFunction_): Internal.Float2DoubleFunction;
        andThenChar(arg0: Internal.Double2CharFunction_): Internal.Byte2CharFunction;
        computeIfPresent(arg0: number, arg1: Internal.BiFunction_<number, number, number>): number;
        equals(arg0: any): boolean;
        andThenReference<T_>(arg0: Internal.Double2ReferenceFunction_<T_>): Internal.Byte2ReferenceFunction<T_>;
        putIfAbsent(arg0: number, arg1: number): number;
    }
    type Byte2DoubleMap_ = Byte2DoubleMap;
    class NativeJavaClass extends Internal.NativeJavaObject implements dev.latvian.mods.rhino.Function {
        enumerationIteratorNext(cx: Internal.Context_, currentId: Internal.Consumer_<any>): boolean;
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        setParentScope(m: Internal.Scriptable_): void;
        static canConvert(cx: Internal.Context_, fromObj: any, to: Internal.Class_<any>): boolean;
        notifyAll(): void;
        getIds(): any[];
        getClassObject(): Internal.Class<any>;
        construct(cx: Internal.Context_, scope: Internal.Scriptable_, args: any[]): Internal.Scriptable;
        getAllIds(): any[];
        delete(name: string): void;
        delete(index: number): void;
        delete(key: Internal.Symbol_): void;
        notify(): void;
        put(name: string, start: Internal.Scriptable_, value: any): void;
        put(symbol: Internal.Symbol_, start: Internal.Scriptable_, value: any): void;
        put(index: number, start: Internal.Scriptable_, value: any): void;
        unwrap(): any;
        getDefaultValue(hint: Internal.Class_<any>): any;
        getPrototype(): Internal.Scriptable;
        hashCode(): number;
        get(name: string, start: Internal.Scriptable_): any;
        get(index: number, start: Internal.Scriptable_): any;
        get(key: Internal.Symbol_, start: Internal.Scriptable_): any;
        has(name: string, start: Internal.Scriptable_): boolean;
        has(key: Internal.Symbol_, start: Internal.Scriptable_): boolean;
        has(index: number, start: Internal.Scriptable_): boolean;
        hasInstance(value: Internal.Scriptable_): boolean;
        addCustomProperty(name: string, getter: Internal.CustomProperty_): void;
        setPrototype(m: Internal.Scriptable_): void;
        call(cx: Internal.Context_, scope: Internal.Scriptable_, thisObj: Internal.Scriptable_, args: any[]): any;
        equals(arg0: any): boolean;
        toString(): string;
        enumerationIteratorHasNext(cx: Internal.Context_, currentId: Internal.Consumer_<any>): boolean;
        getClassName(): string;
        getParentScope(): Internal.Scriptable;
        static readonly NOT_FOUND : any;
        get classObject(): Internal.Class<any>;
        get parentScope(): Internal.Scriptable;
        get ids(): any[];
        get className(): string;
        get class(): Internal.Class<any>;
        get allIds(): any[];
        get prototype(): Internal.Scriptable;
        set parentScope(m: Internal.Scriptable_);
        set prototype(m: Internal.Scriptable_);
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    type NativeJavaClass_ = NativeJavaClass;
    interface Decoder <A> {
        simple(): Internal.Decoder$Simple<A>;
        terminal(): Internal.Decoder$Terminal<A>;
        parse<T>(arg0: Internal.DynamicOps_<T>, arg1: T): Internal.DataResult<A>;
        parse<T>(arg0: Internal.Dynamic_<T>): Internal.DataResult<A>;
        withLifecycle(arg0: Internal.Lifecycle_): Internal.Decoder<A>;
        decode<T>(arg0: Internal.DynamicOps_<T>, arg1: T): Internal.DataResult<Internal.Pair<A, T>>;
        decode<T>(arg0: Internal.Dynamic_<T>): Internal.DataResult<Internal.Pair<A, T>>;
        promotePartial(arg0: Internal.Consumer_<string>): Internal.Decoder<A>;
        flatMap<B>(arg0: java_.util.function_.Function_<A, Internal.DataResult_<B>>): Internal.Decoder<B>;
        boxed(): Internal.Decoder$Boxed<A>;
        fieldOf(arg0: string): Internal.MapDecoder<A>;
        map<B>(arg0: java_.util.function_.Function_<A, B>): Internal.Decoder<B>;
    }
    type Decoder_<A> = Decoder<A>;
    interface ItemLike {
    }
    type ItemLike_ = ItemLike;
    interface Int2LongFunction extends Internal.Function<number, number>, Internal.IntToLongFunction {
        getOrDefault(arg0: any, arg1: number): number;
        getOrDefault(arg0: number, arg1: number): number;
        andThenShort(arg0: Internal.Long2ShortFunction_): Internal.Int2ShortFunction;
        composeByte(arg0: Internal.Byte2IntFunction_): Internal.Byte2LongFunction;
        andThenInt(arg0: Internal.Long2IntFunction_): Internal.Int2IntFunction;
        composeReference<T_>(arg0: Internal.Reference2IntFunction_<T_>): Internal.Reference2LongFunction<T_>;
        andThen<T_>(arg0: java_.util.function_.Function_<number, T_>): java_.util.function_.Function<number, T_>;
        put(arg0: number, arg1: number): number;
        remove(arg0: number): number;
        remove(arg0: any): number;
        defaultReturnValue(): number;
        defaultReturnValue(arg0: number): void;
        andThenDouble(arg0: Internal.Long2DoubleFunction_): Internal.Int2DoubleFunction;
        andThenObject<T_>(arg0: Internal.Long2ObjectFunction_<T_>): Internal.Int2ObjectFunction<T_>;
        get(arg0: any): number;
        get(arg0: number): number;
        andThenLong(arg0: Internal.Long2LongFunction_): Internal.Int2LongFunction;
        composeLong(arg0: Internal.Long2IntFunction_): Internal.Long2LongFunction;
        andThenByte(arg0: Internal.Long2ByteFunction_): Internal.Int2ByteFunction;
        andThenFloat(arg0: Internal.Long2FloatFunction_): Internal.Int2FloatFunction;
        apply(arg0: number): number;
        containsKey(arg0: any): boolean;
        containsKey(arg0: number): boolean;
        composeInt(arg0: Internal.Int2IntFunction_): Internal.Int2LongFunction;
        clear(): void;
        composeFloat(arg0: Internal.Float2IntFunction_): Internal.Float2LongFunction;
        andThenChar(arg0: Internal.Long2CharFunction_): Internal.Int2CharFunction;
        applyAsLong(arg0: number): number;
        composeObject<T_>(arg0: Internal.Object2IntFunction_<T_>): Internal.Object2LongFunction<T_>;
        size(): number;
        compose<T_>(arg0: java_.util.function_.Function_<T_, number>): java_.util.function_.Function<T_, number>;
        composeShort(arg0: Internal.Short2IntFunction_): Internal.Short2LongFunction;
        andThenReference<T_>(arg0: Internal.Long2ReferenceFunction_<T_>): Internal.Int2ReferenceFunction<T_>;
        composeChar(arg0: Internal.Char2IntFunction_): Internal.Char2LongFunction;
        composeDouble(arg0: Internal.Double2IntFunction_): Internal.Double2LongFunction;
    }
    type Int2LongFunction_ = ((arg0: number) => number) | Int2LongFunction;
    interface FloatPredicate extends Internal.Predicate<number>, java_.util.function_.DoublePredicate {
        or(arg0: Internal.FloatPredicate_): Internal.FloatPredicate;
        or(arg0: java_.util.function_.DoublePredicate_): Internal.FloatPredicate;
        or(arg0: Internal.Predicate_<number>): Internal.Predicate<number>;
        test(arg0: number): boolean;
        and(arg0: java_.util.function_.DoublePredicate_): Internal.FloatPredicate;
        and(arg0: Internal.FloatPredicate_): Internal.FloatPredicate;
        and(arg0: Internal.Predicate_<number>): Internal.Predicate<number>;
        negate(): Internal.FloatPredicate;
    }
    type FloatPredicate_ = ((arg0: number) => boolean) | FloatPredicate;
    class RootCommandNode <S> extends Internal.CommandNode<S> {
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        getName(): string;
        getRedirect(): Internal.CommandNode<S>;
        isValidInput(arg0: string): boolean;
        notifyAll(): void;
        compareTo(arg0: Internal.CommandNode_<S>): number;
        notify(): void;
        findAmbiguities(arg0: Internal.AmbiguityConsumer_<S>): void;
        listSuggestions(arg0: Internal.CommandContext_<S>, arg1: Internal.SuggestionsBuilder_): Internal.CompletableFuture<Internal.Suggestions>;
        createBuilder(): Internal.ArgumentBuilder<S, any>;
        hashCode(): number;
        getRedirectModifier(): Internal.RedirectModifier<S>;
        getRelevantNodes(arg0: Internal.StringReader_): Internal.Collection<Internal.CommandNode<S>>;
        getCommand(): Internal.Command<S>;
        getChild(arg0: string): Internal.CommandNode<S>;
        getExamples(): Internal.Collection<string>;
        getUsageText(): string;
        parse(arg0: Internal.StringReader_, arg1: Internal.CommandContextBuilder_<S>): void;
        isFork(): boolean;
        canUse(arg0: S): boolean;
        getChildren(): Internal.Collection<Internal.CommandNode<S>>;
        getRequirement(): Internal.Predicate<S>;
        equals(arg0: any): boolean;
        toString(): string;
        addChild(arg0: Internal.CommandNode_<S>): void;
        get redirect(): Internal.CommandNode<S>;
        get fork(): boolean;
        get examples(): Internal.Collection<string>;
        get children(): Internal.Collection<Internal.CommandNode<S>>;
        get name(): string;
        get usageText(): string;
        get requirement(): Internal.Predicate<S>;
        get redirectModifier(): Internal.RedirectModifier<S>;
        get class(): Internal.Class<any>;
        get command(): Internal.Command<S>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    type RootCommandNode_<S> = RootCommandNode<S>;
    /**
    * Fired when the client is initalizing.
    */
    class ClientEventJS extends Internal.EventJS {
        cancel(): void;
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        isCancelled(): boolean;
        getPlayer(): Internal.ClientPlayerJS;
        notifyAll(): void;
        getEntity(): Internal.EntityJS;
        notify(): void;
        getLevel(): Internal.ClientLevelJS;
        post(id: string): boolean;
        post(id: string, sub: string): boolean;
        post(t: Internal.ScriptType_, id: string, sub: string): boolean;
        post(t: Internal.ScriptType_, id: string): boolean;
        hashCode(): number;
        equals(arg0: any): boolean;
        toString(): string;
        canCancel(): boolean;
        get level(): Internal.ClientLevelJS;
        get cancelled(): boolean;
        get class(): Internal.Class<any>;
        get entity(): Internal.EntityJS;
        get player(): Internal.ClientPlayerJS;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    /**
    * Fired when the client is initalizing.
    */
    type ClientEventJS_ = ClientEventJS;
    abstract class MenuComponent implements Internal.Serializable {
        setName(arg0: string): void;
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        getParent(): Internal.MenuContainer;
        dispatchEvent(arg0: Internal.AWTEvent_): void;
        getName(): string;
        notifyAll(): void;
        getAccessibleContext(): Internal.AccessibleContext;
        notify(): void;
        postEvent(arg0: java_.awt.Event_): boolean;
        hashCode(): number;
        equals(arg0: any): boolean;
        removeNotify(): void;
        getFont(): Internal.Font;
        toString(): string;
        setFont(arg0: Internal.Font_): void;
        get accessibleContext(): Internal.AccessibleContext;
        get parent(): Internal.MenuContainer;
        get name(): string;
        get class(): Internal.Class<any>;
        get font(): Internal.Font;
        set name(arg0: string);
        set font(arg0: Internal.Font_);
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    type MenuComponent_ = MenuComponent;
    class BasicBlockJS$Builder extends Internal.BlockBuilder {
        noItem(): Internal.BlockBuilder;
        suffocating(b: boolean): Internal.BlockBuilder;
        getClass(): Internal.Class<any>;
        translationKey(key: string): Internal.BuilderBase<Internal.Block>;
        newID(pre: string, post: string): ResourceLocation;
        type(type: string): Internal.BuilderBase<Internal.Block>;
        unbreakable(): Internal.BlockBuilder;
        model(m: string): Internal.BlockBuilder;
        tag(tag: ResourceLocation_): Internal.BlockBuilder;
        generateDataJsons(generator: Internal.DataJsonGenerator_): void;
        tagBoth(tag: ResourceLocation_): Internal.BlockBuilder;
        defaultCutout(): Internal.BlockBuilder;
        item(i: Internal.Consumer_<Internal.BlockItemBuilder_>): Internal.BlockBuilder;
        resistance(r: number): Internal.BlockBuilder;
        hardness(h: number): Internal.BlockBuilder;
        slipperiness(f: number): Internal.BlockBuilder;
        getRegistryType(): Internal.RegistryObjectBuilderTypes<Internal.Block>;
        textureSide(direction: Internal.Direction_, tex: string): Internal.BlockBuilder;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        clientRegistry(minecraft: Internal.Minecraft_): void;
        waterlogged(): Internal.BlockBuilder;
        transformObject(obj: Internal.Block_): Internal.Block;
        color(index: number, c: Internal.Color_): Internal.BlockBuilder;
        textureAll(tex: string): Internal.BlockBuilder;
        displayName(name: string): Internal.BuilderBase<Internal.Block>;
        notifyAll(): void;
        box(x0: number, y0: number, z0: number, x1: number, y1: number, z1: number): Internal.BlockBuilder;
        box(x0: number, y0: number, z0: number, x1: number, y1: number, z1: number, scale16: boolean): Internal.BlockBuilder;
        viewBlocking(b: boolean): Internal.BlockBuilder;
        notify(): void;
        transparent(b: boolean): Internal.BlockBuilder;
        createAdditionalObjects(): void;
        tagBlock(tag: ResourceLocation_): Internal.BlockBuilder;
        fullBlock(f: boolean): Internal.BlockBuilder;
        createProperties(): Internal.BlockBehaviour$Properties;
        notSolid(): Internal.BlockBuilder;
        generateBlockModels(builder: Internal.BlockBuilder_): Internal.Map<ResourceLocation, Internal.JsonObject>;
        hashCode(): number;
        noCollission(): Internal.BlockBuilder;
        get(): Internal.Block;
        requiresTool(f: boolean): Internal.BlockBuilder;
        renderType(l: string): Internal.BlockBuilder;
        jumpFactor(f: number): Internal.BlockBuilder;
        createShape(): Internal.VoxelShape;
        generateAssetJsons(generator: Internal.AssetJsonGenerator_): void;
        noCollision(): Internal.BlockBuilder;
        opaque(o: boolean): Internal.BlockBuilder;
        randomTick(randomTickCallback: Internal.Consumer_<Internal.RandomTickCallbackJS_>): Internal.BlockBuilder;
        getTranslationKeyGroup(): string;
        texture(id: string, tex: string): Internal.BlockBuilder;
        noDrops(): Internal.BlockBuilder;
        generateLang(lang: Internal.Map_<string, string>): void;
        tagItem(tag: ResourceLocation_): Internal.BlockBuilder;
        speedFactor(f: number): Internal.BlockBuilder;
        noValidSpawns(b: boolean): Internal.BlockBuilder;
        createObject(): Internal.Block;
        lightLevel(light: number): Internal.BlockBuilder;
        addResourcePackLocations(path: string, list: Internal.List_<ResourceLocation_>, packType: Internal.PackType_): void;
        defaultTranslucent(): Internal.BlockBuilder;
        material(m: Internal.MaterialJS_): Internal.BlockBuilder;
        equals(arg0: any): boolean;
        toString(): string;
        redstoneConductor(b: boolean): Internal.BlockBuilder;
        lootTable : ((arg0: Internal.LootBuilder) => void);
        modelJson : Internal.JsonObject;
        blockstateJson : Internal.JsonObject;
        readonly id : ResourceLocation;
        randomTickCallback : ((arg0: Internal.RandomTickCallbackJS) => void);
        get registryType(): Internal.RegistryObjectBuilderTypes<Internal.Block>;
        get class(): Internal.Class<any>;
        get translationKeyGroup(): string;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    type BasicBlockJS$Builder_ = BasicBlockJS$Builder;
    abstract class ContentHandler {
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        hashCode(): number;
        notifyAll(): void;
        equals(arg0: any): boolean;
        getContent(arg0: Internal.URLConnection_): any;
        getContent(arg0: Internal.URLConnection_, arg1: Internal.Class_[]): any;
        toString(): string;
        notify(): void;
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    type ContentHandler_ = ContentHandler;
    class ClientLevel extends Internal.Level implements Internal.BiomeSeedProvider, Internal.ClientLevelAccess {
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        getCapability<T_>(arg0: Internal.Capability_<T_>, arg1: Internal.Direction_): Internal.LazyOptional<T_>;
        getCapability<T_>(arg0: Internal.Capability_<T_>): Internal.LazyOptional<T_>;
        notifyAll(): void;
        areCapsCompatible(arg0: Internal.CapabilityProvider_<Internal.Level_>): boolean;
        areCapsCompatible(arg0: Internal.CapabilityDispatcher_): boolean;
        getMaxEntityRadius(): number;
        addFreshBlockEntities(arg0: Internal.Collection_<Internal.BlockEntity_>): void;
        asKJS(): any;
        notify(): void;
        reviveCaps(): void;
        markAndNotifyBlock(arg0: BlockPos_, arg1: Internal.LevelChunk_, arg2: Internal.BlockState_, arg3: Internal.BlockState_, arg4: number, arg5: number): void;
        redirect$zoc000$redirectTick(blockEntity: Internal.TickingBlockEntity_): void;
        invalidateCaps(): void;
        hashCode(): number;
        increaseMaxEntityRadius(arg0: number): number;
        equals(arg0: any): boolean;
        getExistingBlockEntity(arg0: BlockPos_): Internal.BlockEntity;
        isAreaLoaded(arg0: BlockPos_, arg1: number): boolean;
        toString(): string;
        close(): void;
        getBiomeSeed(): number;
        restoringBlockSnapshots : boolean;
        capturedBlockSnapshots : Internal.ArrayList<Internal.BlockSnapshot>;
        captureBlockSnapshots : boolean;
        get maxEntityRadius(): number;
        get biomeSeed(): number;
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    type ClientLevel_ = ClientLevel;
    interface Paint extends Internal.Transparency {
        createContext(arg0: Internal.ColorModel_, arg1: Internal.Rectangle_, arg2: Internal.Rectangle2D_, arg3: Internal.AffineTransform_, arg4: Internal.RenderingHints_): Internal.PaintContext;
        getTransparency(): number;
    }
    type Paint_ = Paint;
    class KeyModifiers {
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        capsLock(): boolean;
        onlyControl(): boolean;
        notifyAll(): void;
        shift(): boolean;
        alt(): boolean;
        start(): boolean;
        numLock(): boolean;
        control(): boolean;
        notify(): void;
        hashCode(): number;
        equals(arg0: any): boolean;
        toString(): string;
        static readonly NONE : Internal.KeyModifiers;
        readonly modifiers : number;
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    type KeyModifiers_ = KeyModifiers;
    interface Temporal extends Internal.TemporalAccessor {
        getLong(arg0: Internal.TemporalField_): number;
        with(arg0: Internal.TemporalField_, arg1: number): Internal.Temporal;
        with(arg0: Internal.TemporalAdjuster_): Internal.Temporal;
        minus(arg0: Internal.TemporalAmount_): Internal.Temporal;
        minus(arg0: number, arg1: Internal.TemporalUnit_): Internal.Temporal;
        query<R_>(arg0: Internal.TemporalQuery_<R_>): R_;
        get(arg0: Internal.TemporalField_): number;
        range(arg0: Internal.TemporalField_): Internal.ValueRange;
        until(arg0: Internal.Temporal_, arg1: Internal.TemporalUnit_): number;
        isSupported(arg0: Internal.TemporalUnit_): boolean;
        isSupported(arg0: Internal.TemporalField_): boolean;
        plus(arg0: number, arg1: Internal.TemporalUnit_): Internal.Temporal;
        plus(arg0: Internal.TemporalAmount_): Internal.Temporal;
    }
    type Temporal_ = Temporal;
    abstract class FloatBuffer extends Internal.Buffer implements Internal.Comparable<Internal.FloatBuffer> {
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        compact(): Internal.FloatBuffer;
        notifyAll(): void;
        compareTo(arg0: Internal.FloatBuffer_): number;
        notify(): void;
        asReadOnlyBuffer(): Internal.FloatBuffer;
        put(arg0: number[]): Internal.FloatBuffer;
        put(arg0: number, arg1: number[], arg2: number, arg3: number): Internal.FloatBuffer;
        put(arg0: number, arg1: number[]): Internal.FloatBuffer;
        put(arg0: number[], arg1: number, arg2: number): Internal.FloatBuffer;
        put(arg0: number, arg1: Internal.FloatBuffer_, arg2: number, arg3: number): Internal.FloatBuffer;
        put(arg0: Internal.FloatBuffer_): Internal.FloatBuffer;
        put(arg0: number, arg1: number): Internal.FloatBuffer;
        put(arg0: number): Internal.FloatBuffer;
        capacity(): number;
        isReadOnly(): boolean;
        slice(arg0: number, arg1: number): Internal.FloatBuffer;
        slice(): Internal.FloatBuffer;
        array(): number[];
        hashCode(): number;
        get(): number;
        get(arg0: number, arg1: number[]): Internal.FloatBuffer;
        get(arg0: number): number;
        get(arg0: number, arg1: number[], arg2: number, arg3: number): Internal.FloatBuffer;
        get(arg0: number[], arg1: number, arg2: number): Internal.FloatBuffer;
        get(arg0: number[]): Internal.FloatBuffer;
        limit(arg0: number): Internal.FloatBuffer;
        limit(): number;
        arrayOffset(): number;
        flip(): Internal.FloatBuffer;
        order(): Internal.ByteOrder;
        hasArray(): boolean;
        hasRemaining(): boolean;
        clear(): Internal.FloatBuffer;
        duplicate(): Internal.FloatBuffer;
        remaining(): number;
        static allocate(arg0: number): Internal.FloatBuffer;
        rewind(): Internal.FloatBuffer;
        mismatch(arg0: Internal.FloatBuffer_): number;
        equals(arg0: any): boolean;
        reset(): Internal.FloatBuffer;
        toString(): string;
        position(arg0: number): Internal.FloatBuffer;
        position(): number;
        isDirect(): boolean;
        static wrap(arg0: number[]): Internal.FloatBuffer;
        static wrap(arg0: number[], arg1: number, arg2: number): Internal.FloatBuffer;
        mark(): Internal.FloatBuffer;
        get direct(): boolean;
        get readOnly(): boolean;
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    type FloatBuffer_ = FloatBuffer;
    class ArgumentTypeWrapper extends Internal.Enum<Internal.ArgumentTypeWrapper> {
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        static valueOf(name: string): Internal.ArgumentTypeWrapper;
        static valueOf<T_>(arg0: Internal.Class_<T_>, arg1: string): T_;
        notifyAll(): void;
        static values(): Internal.ArgumentTypeWrapper[];
        static byName(name: ResourceLocation_): Internal.ClassWrapper<any>;
        compareTo(arg0: Internal.ArgumentTypeWrapper_): number;
        describeConstable(): Internal.Optional<Internal.Enum$EnumDesc<Internal.ArgumentTypeWrapper>>;
        notify(): void;
        getDeclaringClass(): Internal.Class<Internal.ArgumentTypeWrapper>;
        hashCode(): number;
        equals(arg0: any): boolean;
        getResult(context: Internal.CommandContext_<Internal.CommandSourceStack_>, input: string): any;
        name(): string;
        create(): Internal.ArgumentType<any>;
        toString(): string;
        ordinal(): number;
        static readonly ROTATION : Internal.ArgumentTypeWrapper;
        static readonly VEC2_CENTERED : Internal.ArgumentTypeWrapper;
        static readonly FLOAT : Internal.ArgumentTypeWrapper;
        static readonly PARTICLE : Internal.ArgumentTypeWrapper;
        static readonly INT_RANGE : Internal.ArgumentTypeWrapper;
        static readonly BLOCK_STATE : Internal.ArgumentTypeWrapper;
        static readonly NBT_TAG : Internal.ArgumentTypeWrapper;
        static readonly NBT_PATH : Internal.ArgumentTypeWrapper;
        static readonly ANGLE : Internal.ArgumentTypeWrapper;
        static readonly ITEM_PREDICATE : Internal.ArgumentTypeWrapper;
        static readonly BLOCK_POS_LOADED : Internal.ArgumentTypeWrapper;
        static readonly BLOCK_POS : Internal.ArgumentTypeWrapper;
        static readonly MESSAGE : Internal.ArgumentTypeWrapper;
        static readonly ITEM_SLOT : Internal.ArgumentTypeWrapper;
        static readonly ENTITY : Internal.ArgumentTypeWrapper;
        static readonly BLOCK_PREDICATE : Internal.ArgumentTypeWrapper;
        static readonly DIMENSION : Internal.ArgumentTypeWrapper;
        static readonly VEC2 : Internal.ArgumentTypeWrapper;
        static readonly COLOR : Internal.ArgumentTypeWrapper;
        static readonly VEC3 : Internal.ArgumentTypeWrapper;
        static readonly ITEM_STACK : Internal.ArgumentTypeWrapper;
        static readonly SWIZZLE : Internal.ArgumentTypeWrapper;
        static readonly DOUBLE : Internal.ArgumentTypeWrapper;
        static readonly ENTITIES : Internal.ArgumentTypeWrapper;
        static readonly UUID : Internal.ArgumentTypeWrapper;
        static readonly INTEGER : Internal.ArgumentTypeWrapper;
        static readonly LONG : Internal.ArgumentTypeWrapper;
        static readonly WORD : Internal.ArgumentTypeWrapper;
        static readonly ITEM_ENCHANTMENT : Internal.ArgumentTypeWrapper;
        static readonly VEC3_CENTERED : Internal.ArgumentTypeWrapper;
        static readonly TIME : Internal.ArgumentTypeWrapper;
        static readonly GREEDY_STRING : Internal.ArgumentTypeWrapper;
        static readonly NBT_COMPOUND : Internal.ArgumentTypeWrapper;
        static readonly BOOLEAN : Internal.ArgumentTypeWrapper;
        static readonly PLAYER : Internal.ArgumentTypeWrapper;
        static readonly RESOURCE_LOCATION : Internal.ArgumentTypeWrapper;
        static readonly FLOAT_RANGE : Internal.ArgumentTypeWrapper;
        static readonly PLAYERS : Internal.ArgumentTypeWrapper;
        static readonly ENTITY_SUMMON : Internal.ArgumentTypeWrapper;
        static readonly GAME_PROFILE : Internal.ArgumentTypeWrapper;
        static readonly COLUMN_POS : Internal.ArgumentTypeWrapper;
        static readonly STRING : Internal.ArgumentTypeWrapper;
        static readonly COMPONENT : Internal.ArgumentTypeWrapper;
        static readonly MOB_EFFECT : Internal.ArgumentTypeWrapper;
        static readonly ENTITY_ANCHOR : Internal.ArgumentTypeWrapper;
        get class(): Internal.Class<any>;
        get declaringClass(): Internal.Class<Internal.ArgumentTypeWrapper>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    type ArgumentTypeWrapper_ = "swizzle" | "nbt_path" | "string" | "color" | "item_slot" | "integer" | "mob_effect" | "float" | "uuid" | "long" | "resource_location" | "block_pos_loaded" | "block_predicate" | "game_profile" | "angle" | "particle" | "int_range" | "dimension" | "nbt_compound" | "player" | "double" | "greedy_string" | "players" | "float_range" | "block_pos" | "rotation" | "vec3" | "vec2" | "message" | "nbt_tag" | "column_pos" | "vec2_centered" | "vec3_centered" | "component" | "boolean" | "item_enchantment" | "entities" | "block_state" | "entity_summon" | "item_stack" | "entity_anchor" | "time" | "word" | "entity" | "item_predicate" | ArgumentTypeWrapper;
    interface ExpInvokerMixin {
        an_getExperienceReward(arg0: Internal.Player_): number;
        an_shouldDropExperience(): boolean;
    }
    type ExpInvokerMixin_ = ExpInvokerMixin;
    interface AnnotatedType extends Internal.AnnotatedElement {
        getAnnotationsByType<T_>(arg0: Internal.Class_<T_>): T_[];
        getDeclaredAnnotationsByType<T_>(arg0: Internal.Class_<T_>): T_[];
        isAnnotationPresent(arg0: Internal.Class_<Internal.Annotation_>): boolean;
        getAnnotatedOwnerType(): Internal.AnnotatedType;
        getType(): java_.lang.reflect.Type;
        getAnnotation<T_>(arg0: Internal.Class_<T_>): T_;
        getDeclaredAnnotation<T_>(arg0: Internal.Class_<T_>): T_;
        getAnnotations(): Internal.Annotation[];
        getDeclaredAnnotations(): Internal.Annotation[];
    }
    type AnnotatedType_ = AnnotatedType;
    interface Comparable <T> {
        compareTo(arg0: T): number;
    }
    type Comparable_<T> = Comparable<T>;
    interface IForgeFluid {
        getAttributes(): Internal.FluidAttributes;
        getExplosionResistance(arg0: Internal.FluidState_, arg1: Internal.BlockGetter_, arg2: BlockPos_, arg3: Internal.Explosion_): number;
        isEntityInside(arg0: Internal.FluidState_, arg1: Internal.LevelReader_, arg2: BlockPos_, arg3: Internal.Entity_, arg4: number, arg5: Internal.HolderSet_<Internal.Fluid_>, arg6: boolean): boolean;
        isAABBInsideMaterial(arg0: Internal.FluidState_, arg1: Internal.LevelReader_, arg2: BlockPos_, arg3: Internal.AABB_, arg4: Internal.Material_): boolean;
        isAABBInsideLiquid(arg0: Internal.FluidState_, arg1: Internal.LevelReader_, arg2: BlockPos_, arg3: Internal.AABB_): boolean;
    }
    type IForgeFluid_ = IForgeFluid;
    interface WindowListener extends Internal.EventListener {
        windowDeactivated(arg0: Internal.WindowEvent_): void;
        windowClosed(arg0: Internal.WindowEvent_): void;
        windowOpened(arg0: Internal.WindowEvent_): void;
        windowActivated(arg0: Internal.WindowEvent_): void;
        windowClosing(arg0: Internal.WindowEvent_): void;
        windowDeiconified(arg0: Internal.WindowEvent_): void;
        windowIconified(arg0: Internal.WindowEvent_): void;
    }
    type WindowListener_ = WindowListener;
    abstract class Dimension2D implements Internal.Cloneable {
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        getHeight(): number;
        setSize(arg0: number, arg1: number): void;
        setSize(arg0: Internal.Dimension2D_): void;
        hashCode(): number;
        notifyAll(): void;
        equals(arg0: any): boolean;
        clone(): any;
        toString(): string;
        getWidth(): number;
        notify(): void;
        get width(): number;
        get class(): Internal.Class<any>;
        get height(): number;
        set size(arg0: Internal.Dimension2D_);
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    type Dimension2D_ = Dimension2D;
    interface DragSourceMotionListener extends Internal.EventListener {
        dragMouseMoved(arg0: Internal.DragSourceDragEvent_): void;
    }
    type DragSourceMotionListener_ = DragSourceMotionListener;
    abstract class IntProvider {
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        hashCode(): number;
        notifyAll(): void;
        equals(arg0: any): boolean;
        toString(): string;
        notify(): void;
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    type IntProvider_ = IntProvider;
    interface Int2ReferenceFunction <V> extends Internal.Function<number, V>, Internal.IntFunction<V> {
        getOrDefault(arg0: number, arg1: V): V;
        getOrDefault(arg0: any, arg1: V): V;
        andThenShort(arg0: Internal.Reference2ShortFunction_<V>): Internal.Int2ShortFunction;
        composeByte(arg0: Internal.Byte2IntFunction_): Internal.Byte2ReferenceFunction<V>;
        andThenInt(arg0: Internal.Reference2IntFunction_<V>): Internal.Int2IntFunction;
        andThen<V_>(arg0: java_.util.function_.Function_<V, V_>): java_.util.function_.Function<number, V_>;
        composeReference<T_>(arg0: Internal.Reference2IntFunction_<T_>): Internal.Reference2ReferenceFunction<T_, V>;
        put(arg0: number, arg1: V): V;
        remove(arg0: any): V;
        remove(arg0: number): V;
        defaultReturnValue(arg0: V): void;
        defaultReturnValue(): V;
        andThenDouble(arg0: Internal.Reference2DoubleFunction_<V>): Internal.Int2DoubleFunction;
        andThenObject<T_>(arg0: Internal.Reference2ObjectFunction_<V, T_>): Internal.Int2ObjectFunction<T_>;
        get(arg0: any): V;
        get(arg0: number): V;
        andThenLong(arg0: Internal.Reference2LongFunction_<V>): Internal.Int2LongFunction;
        composeLong(arg0: Internal.Long2IntFunction_): Internal.Long2ReferenceFunction<V>;
        andThenByte(arg0: Internal.Reference2ByteFunction_<V>): Internal.Int2ByteFunction;
        andThenFloat(arg0: Internal.Reference2FloatFunction_<V>): Internal.Int2FloatFunction;
        apply(arg0: number): V;
        containsKey(arg0: any): boolean;
        containsKey(arg0: number): boolean;
        composeInt(arg0: Internal.Int2IntFunction_): Internal.Int2ReferenceFunction<V>;
        clear(): void;
        composeFloat(arg0: Internal.Float2IntFunction_): Internal.Float2ReferenceFunction<V>;
        andThenChar(arg0: Internal.Reference2CharFunction_<V>): Internal.Int2CharFunction;
        composeObject<T_>(arg0: Internal.Object2IntFunction_<T_>): Internal.Object2ReferenceFunction<T_, V>;
        size(): number;
        compose<T_>(arg0: java_.util.function_.Function_<T_, number>): java_.util.function_.Function<T_, V>;
        composeShort(arg0: Internal.Short2IntFunction_): Internal.Short2ReferenceFunction<V>;
        andThenReference<T_>(arg0: Internal.Reference2ReferenceFunction_<V, T_>): Internal.Int2ReferenceFunction<T_>;
        composeChar(arg0: Internal.Char2IntFunction_): Internal.Char2ReferenceFunction<V>;
        composeDouble(arg0: Internal.Double2IntFunction_): Internal.Double2ReferenceFunction<V>;
    }
    type Int2ReferenceFunction_<V> = ((arg0: number) => V) | Int2ReferenceFunction<V>;
    class ContextMenuItem implements Internal.Comparable<Internal.ContextMenuItem> {
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        setYesNo(s: Internal.Component_): Internal.ContextMenuItem;
        notifyAll(): void;
        compareTo(o: Internal.ContextMenuItem_): number;
        drawIcon(matrixStack: Internal.PoseStack_, theme: Internal.Theme_, x: number, y: number, w: number, h: number): void;
        notify(): void;
        setCloseMenu(v: boolean): Internal.ContextMenuItem;
        addMouseOverText(list: Internal.TooltipList_): void;
        setEnabled(v: Internal.BooleanSupplier_): Internal.ContextMenuItem;
        setEnabled(v: boolean): Internal.ContextMenuItem;
        hashCode(): number;
        equals(arg0: any): boolean;
        onClicked(panel: Internal.Panel_, button: Internal.MouseButton_): void;
        toString(): string;
        createWidget(panel: Internal.ContextMenu_): dev.ftb.mods.ftblibrary.ui.Widget;
        static readonly SEPARATOR : Internal.ContextMenuItem;
        icon : Internal.Icon;
        static readonly TRUE : (() => boolean);
        callback : (() => void);
        static readonly FALSE : (() => boolean);
        title : Internal.Component;
        yesNoText : Internal.Component;
        closeMenu : boolean;
        enabled : (() => boolean);
        get class(): Internal.Class<any>;
        set yesNo(s: Internal.Component_);
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    type ContextMenuItem_ = ContextMenuItem;
    class Property {
        getClass(): Internal.Class<any>;
        getValue(): string;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        getName(): string;
        hashCode(): number;
        notifyAll(): void;
        equals(arg0: any): boolean;
        getSignature(): string;
        toString(): string;
        isSignatureValid(arg0: Internal.PublicKey_): boolean;
        notify(): void;
        hasSignature(): boolean;
        get signature(): string;
        get name(): string;
        get class(): Internal.Class<any>;
        get value(): string;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    type Property_ = Property;
    interface RedirectModifier <S> {
        apply(arg0: Internal.CommandContext_<S>): Internal.Collection<S>;
    }
    type RedirectModifier_<S> = ((arg0: Internal.CommandContext<S>) => Internal.Collection<S>) | RedirectModifier<S>;
    class StairBlockBuilder extends Internal.ShapedBlockBuilder {
        noItem(): Internal.BlockBuilder;
        suffocating(b: boolean): Internal.BlockBuilder;
        getClass(): Internal.Class<any>;
        translationKey(key: string): Internal.BuilderBase<Internal.Block>;
        newID(pre: string, post: string): ResourceLocation;
        type(type: string): Internal.BuilderBase<Internal.Block>;
        unbreakable(): Internal.BlockBuilder;
        model(m: string): Internal.BlockBuilder;
        tag(tag: ResourceLocation_): Internal.BlockBuilder;
        generateDataJsons(generator: Internal.DataJsonGenerator_): void;
        tagBoth(tag: ResourceLocation_): Internal.BlockBuilder;
        defaultCutout(): Internal.BlockBuilder;
        item(i: Internal.Consumer_<Internal.BlockItemBuilder_>): Internal.BlockBuilder;
        resistance(r: number): Internal.BlockBuilder;
        hardness(h: number): Internal.BlockBuilder;
        slipperiness(f: number): Internal.BlockBuilder;
        getRegistryType(): Internal.RegistryObjectBuilderTypes<Internal.Block>;
        textureSide(direction: Internal.Direction_, tex: string): Internal.BlockBuilder;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        clientRegistry(minecraft: Internal.Minecraft_): void;
        waterlogged(): Internal.BlockBuilder;
        transformObject(obj: Internal.Block_): Internal.Block;
        color(index: number, c: Internal.Color_): Internal.BlockBuilder;
        textureAll(tex: string): Internal.BlockBuilder;
        displayName(name: string): Internal.BuilderBase<Internal.Block>;
        notifyAll(): void;
        box(x0: number, y0: number, z0: number, x1: number, y1: number, z1: number): Internal.BlockBuilder;
        box(x0: number, y0: number, z0: number, x1: number, y1: number, z1: number, scale16: boolean): Internal.BlockBuilder;
        viewBlocking(b: boolean): Internal.BlockBuilder;
        notify(): void;
        transparent(b: boolean): Internal.BlockBuilder;
        createAdditionalObjects(): void;
        tagBlock(tag: ResourceLocation_): Internal.BlockBuilder;
        fullBlock(f: boolean): Internal.BlockBuilder;
        createProperties(): Internal.BlockBehaviour$Properties;
        notSolid(): Internal.BlockBuilder;
        generateBlockModels(builder: Internal.BlockBuilder_): Internal.Map<ResourceLocation, Internal.JsonObject>;
        hashCode(): number;
        noCollission(): Internal.BlockBuilder;
        get(): Internal.Block;
        requiresTool(f: boolean): Internal.BlockBuilder;
        renderType(l: string): Internal.BlockBuilder;
        jumpFactor(f: number): Internal.BlockBuilder;
        createShape(): Internal.VoxelShape;
        generateAssetJsons(generator: Internal.AssetJsonGenerator_): void;
        noCollision(): Internal.BlockBuilder;
        opaque(o: boolean): Internal.BlockBuilder;
        randomTick(randomTickCallback: Internal.Consumer_<Internal.RandomTickCallbackJS_>): Internal.BlockBuilder;
        getTranslationKeyGroup(): string;
        texture(id: string, tex: string): Internal.BlockBuilder;
        noDrops(): Internal.BlockBuilder;
        generateLang(lang: Internal.Map_<string, string>): void;
        tagItem(tag: ResourceLocation_): Internal.BlockBuilder;
        speedFactor(f: number): Internal.BlockBuilder;
        noValidSpawns(b: boolean): Internal.BlockBuilder;
        createObject(): Internal.Block;
        lightLevel(light: number): Internal.BlockBuilder;
        addResourcePackLocations(path: string, list: Internal.List_<ResourceLocation_>, packType: Internal.PackType_): void;
        defaultTranslucent(): Internal.BlockBuilder;
        material(m: Internal.MaterialJS_): Internal.BlockBuilder;
        equals(arg0: any): boolean;
        toString(): string;
        redstoneConductor(b: boolean): Internal.BlockBuilder;
        lootTable : ((arg0: Internal.LootBuilder) => void);
        modelJson : Internal.JsonObject;
        blockstateJson : Internal.JsonObject;
        readonly id : ResourceLocation;
        randomTickCallback : ((arg0: Internal.RandomTickCallbackJS) => void);
        get registryType(): Internal.RegistryObjectBuilderTypes<Internal.Block>;
        get class(): Internal.Class<any>;
        get translationKeyGroup(): string;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    type StairBlockBuilder_ = StairBlockBuilder;
    class Matrix4f implements Internal.Matrix4fExtended, Internal.Matrix4fAccess {
        multiplyBackward(arg0: Internal.Matrix4f_): void;
        getClass(): Internal.Class<any>;
        rotate(quaternion: Internal.Quaternion_): void;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        copyIntoArray(): number[];
        notifyAll(): void;
        copyFromArray(arg0: number[]): void;
        setTranslation(arg0: number, arg1: number, arg2: number): void;
        notify(): void;
        translate(x: number, y: number, z: number): void;
        hashCode(): number;
        equals(arg0: any): boolean;
        transformVecZ(x: number, y: number, z: number): number;
        transformVecY(x: number, y: number, z: number): number;
        toString(): string;
        transformVecX(x: number, y: number, z: number): number;
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    type Matrix4f_ = Matrix4f;
    interface ScatteringByteChannel extends Internal.ReadableByteChannel {
        isOpen(): boolean;
        read(arg0: Internal.ByteBuffer_[], arg1: number, arg2: number): number;
        read(arg0: Internal.ByteBuffer_[]): number;
        read(arg0: Internal.ByteBuffer_): number;
        close(): void;
    }
    type ScatteringByteChannel_ = ScatteringByteChannel;
    abstract class GuiComponent {
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        hashCode(): number;
        notifyAll(): void;
        equals(arg0: any): boolean;
        toString(): string;
        notify(): void;
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    type GuiComponent_ = GuiComponent;
    interface ItemFiltersStack {
        createDataIF(item: Internal.Item_): any;
        getInventoryFilterData(): Internal.ItemInventory;
        getItemFiltersData(): any;
        getStringValueFilterData(): Internal.StringValueData<any>;
    }
    type ItemFiltersStack_ = ItemFiltersStack;
    interface Boolean2ReferenceFunction <V> extends Internal.Function<boolean, V> {
        getOrDefault(arg0: any, arg1: V): V;
        getOrDefault(arg0: boolean, arg1: V): V;
        andThenShort(arg0: Internal.Reference2ShortFunction_<V>): Internal.Boolean2ShortFunction;
        composeByte(arg0: Internal.Byte2BooleanFunction_): Internal.Byte2ReferenceFunction<V>;
        andThenInt(arg0: Internal.Reference2IntFunction_<V>): Internal.Boolean2IntFunction;
        andThen<V_>(arg0: java_.util.function_.Function_<V, V_>): java_.util.function_.Function<boolean, V_>;
        composeReference<T_>(arg0: Internal.Reference2BooleanFunction_<T_>): Internal.Reference2ReferenceFunction<T_, V>;
        put(arg0: boolean, arg1: V): V;
        remove(arg0: any): V;
        remove(arg0: boolean): V;
        defaultReturnValue(): V;
        defaultReturnValue(arg0: V): void;
        andThenDouble(arg0: Internal.Reference2DoubleFunction_<V>): Internal.Boolean2DoubleFunction;
        andThenObject<T_>(arg0: Internal.Reference2ObjectFunction_<V, T_>): Internal.Boolean2ObjectFunction<T_>;
        get(arg0: any): V;
        get(arg0: boolean): V;
        andThenLong(arg0: Internal.Reference2LongFunction_<V>): Internal.Boolean2LongFunction;
        composeLong(arg0: Internal.Long2BooleanFunction_): Internal.Long2ReferenceFunction<V>;
        andThenByte(arg0: Internal.Reference2ByteFunction_<V>): Internal.Boolean2ByteFunction;
        andThenFloat(arg0: Internal.Reference2FloatFunction_<V>): Internal.Boolean2FloatFunction;
        apply(arg0: boolean): V;
        containsKey(arg0: boolean): boolean;
        containsKey(arg0: any): boolean;
        composeInt(arg0: Internal.Int2BooleanFunction_): Internal.Int2ReferenceFunction<V>;
        clear(): void;
        composeFloat(arg0: Internal.Float2BooleanFunction_): Internal.Float2ReferenceFunction<V>;
        andThenChar(arg0: Internal.Reference2CharFunction_<V>): Internal.Boolean2CharFunction;
        composeObject<T_>(arg0: Internal.Object2BooleanFunction_<T_>): Internal.Object2ReferenceFunction<T_, V>;
        size(): number;
        compose<T_>(arg0: java_.util.function_.Function_<T_, boolean>): java_.util.function_.Function<T_, V>;
        composeShort(arg0: Internal.Short2BooleanFunction_): Internal.Short2ReferenceFunction<V>;
        andThenReference<T_>(arg0: Internal.Reference2ReferenceFunction_<V, T_>): Internal.Boolean2ReferenceFunction<T_>;
        composeChar(arg0: Internal.Char2BooleanFunction_): Internal.Char2ReferenceFunction<V>;
        composeDouble(arg0: Internal.Double2BooleanFunction_): Internal.Double2ReferenceFunction<V>;
    }
    type Boolean2ReferenceFunction_<V> = ((arg0: boolean) => V) | Boolean2ReferenceFunction<V>;
    interface ItemHandler extends Internal.Iterable<Internal.ItemStack> {
        getHeight(): number;
        iterator(): Internal.Iterator<Internal.ItemStack>;
        spliterator(): Internal.Spliterator<Internal.ItemStack>;
        extractItem(arg0: number, arg1: number, arg2: boolean): Internal.ItemStack;
        forEach(arg0: Internal.Consumer_<Internal.ItemStack_>): void;
        getSlotLimit(arg0: number): number;
        isItemValid(arg0: number, arg1: Internal.ItemStack_): boolean;
        getStackInSlot(arg0: number): Internal.ItemStack;
        getSlots(): number;
        getWidth(): number;
        insertItem(arg0: number, arg1: Internal.ItemStack_, arg2: boolean): Internal.ItemStack;
    }
    type ItemHandler_ = ItemHandler;
    interface ChannelOutboundInvoker {
        disconnect(): Internal.ChannelFuture;
        disconnect(arg0: Internal.ChannelPromise_): Internal.ChannelFuture;
        newProgressivePromise(): Internal.ChannelProgressivePromise;
        read(): Internal.ChannelOutboundInvoker;
        deregister(arg0: Internal.ChannelPromise_): Internal.ChannelFuture;
        deregister(): Internal.ChannelFuture;
        newFailedFuture(arg0: Internal.Throwable_): Internal.ChannelFuture;
        writeAndFlush(arg0: any, arg1: Internal.ChannelPromise_): Internal.ChannelFuture;
        writeAndFlush(arg0: any): Internal.ChannelFuture;
        bind(arg0: Internal.SocketAddress_): Internal.ChannelFuture;
        bind(arg0: Internal.SocketAddress_, arg1: Internal.ChannelPromise_): Internal.ChannelFuture;
        voidPromise(): Internal.ChannelPromise;
        newSucceededFuture(): Internal.ChannelFuture;
        flush(): Internal.ChannelOutboundInvoker;
        close(arg0: Internal.ChannelPromise_): Internal.ChannelFuture;
        close(): Internal.ChannelFuture;
        write(arg0: any): Internal.ChannelFuture;
        write(arg0: any, arg1: Internal.ChannelPromise_): Internal.ChannelFuture;
        connect(arg0: Internal.SocketAddress_, arg1: Internal.SocketAddress_, arg2: Internal.ChannelPromise_): Internal.ChannelFuture;
        connect(arg0: Internal.SocketAddress_, arg1: Internal.ChannelPromise_): Internal.ChannelFuture;
        connect(arg0: Internal.SocketAddress_): Internal.ChannelFuture;
        connect(arg0: Internal.SocketAddress_, arg1: Internal.SocketAddress_): Internal.ChannelFuture;
        newPromise(): Internal.ChannelPromise;
    }
    type ChannelOutboundInvoker_ = ChannelOutboundInvoker;
    interface Appendable {
        append(arg0: Internal.CharSequence_): Internal.Appendable;
        append(arg0: Internal.CharSequence_, arg1: number, arg2: number): Internal.Appendable;
        append(arg0: string): Internal.Appendable;
    }
    type Appendable_ = Appendable;
    interface IMultiblockedRenderer extends Internal.IRenderer {
        hasTESR(arg0: Internal.BlockEntity_): boolean;
        isRaw(): boolean;
        registerTextureSwitchEvent(): void;
        createBoolSwitch(arg0: number, arg1: number, arg2: string, arg3: string, arg4: boolean, arg5: Internal.Consumer_<boolean>): Internal.WidgetGroup;
        onPreAccess(arg0: Internal.IComponent_): void;
        getUnlocalizedName(): string;
        renderModel(arg0: Internal.BlockAndTintGetter_, arg1: BlockPos_, arg2: Internal.BlockState_, arg3: Internal.Direction_, arg4: Internal.Random_, arg5: Internal.IModelData_): Internal.List<Internal.BakedQuad>;
        renderItem(arg0: Internal.ItemStack_, arg1: Internal.ItemTransforms$TransformType_, arg2: boolean, arg3: Internal.PoseStack_, arg4: Internal.MultiBufferSource_, arg5: number, arg6: number, arg7: Internal.BakedModel_): void;
        onTextureSwitchEvent(arg0: Internal.TextureStitchEvent$Pre_): void;
        onPostAccess(arg0: Internal.IComponent_): void;
        createConfigurator(arg0: Internal.WidgetGroup_, arg1: Internal.DraggableScrollableWidgetGroup_, arg2: Internal.IMultiblockedRenderer_): Internal.Supplier<Internal.IMultiblockedRenderer>;
        toJson(arg0: Internal.Gson_, arg1: Internal.JsonObject_): Internal.JsonObject;
        getType(): string;
        fromJson(arg0: Internal.Gson_, arg1: Internal.JsonObject_): Internal.IMultiblockedRenderer;
        render(arg0: Internal.BlockEntity_, arg1: number, arg2: Internal.PoseStack_, arg3: Internal.MultiBufferSource_, arg4: number, arg5: number): void;
        getParticleTexture(): Internal.TextureAtlasSprite;
        isGlobalRenderer(arg0: Internal.BlockEntity_): boolean;
    }
    type IMultiblockedRenderer_ = IMultiblockedRenderer;
    class Attribute extends Internal.ForgeRegistryEntry<Internal.Attribute> {
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        hashCode(): number;
        notifyAll(): void;
        equals(arg0: any): boolean;
        getRegistryType(): Internal.Class<Internal.Attribute>;
        getRegistryName(): ResourceLocation;
        toString(): string;
        setRegistryName(arg0: ResourceLocation_): Internal.Attribute;
        setRegistryName(arg0: string): Internal.Attribute;
        setRegistryName(arg0: string, arg1: string): Internal.Attribute;
        notify(): void;
        readonly delegate : Internal.IRegistryDelegate<Internal.Attribute>;
        get registryType(): Internal.Class<Internal.Attribute>;
        get registryName(): ResourceLocation;
        get class(): Internal.Class<any>;
        set registryName(arg0: ResourceLocation_);
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    type Attribute_ = "generic.max_health" | "minecraft:generic.max_health" | "generic.follow_range" | "minecraft:generic.follow_range" | "generic.knockback_resistance" | "minecraft:generic.knockback_resistance" | "generic.movement_speed" | "minecraft:generic.movement_speed" | "generic.flying_speed" | "minecraft:generic.flying_speed" | "generic.attack_damage" | "minecraft:generic.attack_damage" | "generic.attack_knockback" | "minecraft:generic.attack_knockback" | "generic.attack_speed" | "minecraft:generic.attack_speed" | "generic.armor" | "minecraft:generic.armor" | "generic.armor_toughness" | "minecraft:generic.armor_toughness" | "generic.luck" | "minecraft:generic.luck" | "zombie.spawn_reinforcements" | "minecraft:zombie.spawn_reinforcements" | "horse.jump_strength" | "minecraft:horse.jump_strength" | "paraglider:max_stamina" | "botania:pixie_spawn_chance" | "forge:swim_speed" | "forge:nametag_distance" | "forge:entity_gravity" | "forge:reach_distance" | "malum:magic_resistance" | "malum:magic_proficiency" | "malum:magic_damage" | "malum:scythe_proficiency" | "malum:spirit_spoils" | "malum:spirit_reach" | "malum:heart_of_stone_strength" | "malum:heart_of_stone_recovery_speed" | "malum:heart_of_stone_hunger_cost" | "malum:heart_of_stone_capacity" | "malum:soul_ward_strength" | "malum:soul_ward_recovery_speed" | "malum:soul_ward_shatter_cooldown" | "malum:soul_ward_capacity" | Attribute;
    interface NeutralMob {
    }
    type NeutralMob_ = NeutralMob;
    class ChannelOption <T> extends Internal.AbstractConstant<Internal.ChannelOption<T>> {
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        static valueOf<T_>(arg0: string): Internal.ChannelOption<T_>;
        static valueOf<T_>(arg0: Internal.Class_<any>, arg1: string): Internal.ChannelOption<T_>;
        notifyAll(): void;
        static newInstance<T_>(arg0: string): Internal.ChannelOption<T_>;
        compareTo(arg0: Internal.ChannelOption_<Internal.ChannelOption_<T>>): number;
        notify(): void;
        hashCode(): number;
        equals(arg0: any): boolean;
        name(): string;
        static exists(arg0: string): boolean;
        toString(): string;
        id(): number;
        validate(arg0: Internal.ChannelOption_<Internal.ChannelOption_<T>>): void;
        static readonly WRITE_BUFFER_HIGH_WATER_MARK : Internal.ChannelOption<number>;
        static readonly WRITE_BUFFER_LOW_WATER_MARK : Internal.ChannelOption<number>;
        static readonly DATAGRAM_CHANNEL_ACTIVE_ON_REGISTRATION : Internal.ChannelOption<boolean>;
        static readonly IP_TOS : Internal.ChannelOption<number>;
        static readonly SINGLE_EVENTEXECUTOR_PER_GROUP : Internal.ChannelOption<boolean>;
        static readonly SO_SNDBUF : Internal.ChannelOption<number>;
        static readonly IP_MULTICAST_IF : Internal.ChannelOption<Internal.NetworkInterface>;
        static readonly WRITE_BUFFER_WATER_MARK : Internal.ChannelOption<Internal.WriteBufferWaterMark>;
        static readonly TCP_NODELAY : Internal.ChannelOption<boolean>;
        static readonly TCP_FASTOPEN : Internal.ChannelOption<number>;
        static readonly SO_LINGER : Internal.ChannelOption<number>;
        static readonly SO_RCVBUF : Internal.ChannelOption<number>;
        static readonly SO_KEEPALIVE : Internal.ChannelOption<boolean>;
        static readonly ALLOCATOR : Internal.ChannelOption<Internal.ByteBufAllocator>;
        static readonly IP_MULTICAST_ADDR : Internal.ChannelOption<Internal.InetAddress>;
        static readonly IP_MULTICAST_LOOP_DISABLED : Internal.ChannelOption<boolean>;
        static readonly TCP_FASTOPEN_CONNECT : Internal.ChannelOption<boolean>;
        static readonly MESSAGE_SIZE_ESTIMATOR : Internal.ChannelOption<Internal.MessageSizeEstimator>;
        static readonly WRITE_SPIN_COUNT : Internal.ChannelOption<number>;
        static readonly SO_TIMEOUT : Internal.ChannelOption<number>;
        static readonly SO_REUSEADDR : Internal.ChannelOption<boolean>;
        static readonly CONNECT_TIMEOUT_MILLIS : Internal.ChannelOption<number>;
        static readonly ALLOW_HALF_CLOSURE : Internal.ChannelOption<boolean>;
        static readonly SO_BACKLOG : Internal.ChannelOption<number>;
        static readonly MAX_MESSAGES_PER_READ : Internal.ChannelOption<number>;
        static readonly AUTO_CLOSE : Internal.ChannelOption<boolean>;
        static readonly MAX_MESSAGES_PER_WRITE : Internal.ChannelOption<number>;
        static readonly SO_BROADCAST : Internal.ChannelOption<boolean>;
        static readonly AUTO_READ : Internal.ChannelOption<boolean>;
        static readonly IP_MULTICAST_TTL : Internal.ChannelOption<number>;
        static readonly RCVBUF_ALLOCATOR : Internal.ChannelOption<Internal.RecvByteBufAllocator>;
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    type ChannelOption_<T> = ChannelOption<T>;
    interface WriterSupplier {
        get(): Internal.Writer;
    }
    type WriterSupplier_ = WriterSupplier;
    class Dialog$ModalityType extends Internal.Enum<Internal.Dialog$ModalityType> {
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        static valueOf(arg0: string): Internal.Dialog$ModalityType;
        static valueOf<T_>(arg0: Internal.Class_<T_>, arg1: string): T_;
        notifyAll(): void;
        static values(): Internal.Dialog$ModalityType[];
        compareTo(arg0: Internal.Dialog$ModalityType_): number;
        describeConstable(): Internal.Optional<Internal.Enum$EnumDesc<Internal.Dialog$ModalityType>>;
        notify(): void;
        getDeclaringClass(): Internal.Class<Internal.Dialog$ModalityType>;
        hashCode(): number;
        equals(arg0: any): boolean;
        name(): string;
        toString(): string;
        ordinal(): number;
        static readonly TOOLKIT_MODAL : Internal.Dialog$ModalityType;
        static readonly APPLICATION_MODAL : Internal.Dialog$ModalityType;
        static readonly MODELESS : Internal.Dialog$ModalityType;
        static readonly DOCUMENT_MODAL : Internal.Dialog$ModalityType;
        get class(): Internal.Class<any>;
        get declaringClass(): Internal.Class<Internal.Dialog$ModalityType>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    type Dialog$ModalityType_ = "application_modal" | "modeless" | "document_modal" | "toolkit_modal" | Dialog$ModalityType;
    interface Recipe <C> {
    }
    type Recipe_<C> = Recipe<C>;
    class Raster {
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        createChild(arg0: number, arg1: number, arg2: number, arg3: number, arg4: number, arg5: number, arg6: number[]): Internal.Raster;
        notifyAll(): void;
        getSampleFloat(arg0: number, arg1: number, arg2: number): number;
        createTranslatedChild(arg0: number, arg1: number): Internal.Raster;
        getNumDataElements(): number;
        getNumBands(): number;
        getWidth(): number;
        static createWritableRaster(arg0: Internal.SampleModel_, arg1: Internal.DataBuffer_, arg2: Internal.Point_): Internal.WritableRaster;
        static createWritableRaster(arg0: Internal.SampleModel_, arg1: Internal.Point_): Internal.WritableRaster;
        notify(): void;
        getBounds(): Internal.Rectangle;
        getSampleModel(): Internal.SampleModel;
        getHeight(): number;
        static createRaster(arg0: Internal.SampleModel_, arg1: Internal.DataBuffer_, arg2: Internal.Point_): Internal.Raster;
        getTransferType(): number;
        hashCode(): number;
        getPixels(arg0: number, arg1: number, arg2: number, arg3: number, arg4: number[]): number[];
        getSampleDouble(arg0: number, arg1: number, arg2: number): number;
        getParent(): Internal.Raster;
        static createBandedRaster(arg0: number, arg1: number, arg2: number, arg3: number, arg4: Internal.Point_): Internal.WritableRaster;
        static createBandedRaster(arg0: number, arg1: number, arg2: number, arg3: number, arg4: number[], arg5: number[], arg6: Internal.Point_): Internal.WritableRaster;
        static createBandedRaster(arg0: Internal.DataBuffer_, arg1: number, arg2: number, arg3: number, arg4: number[], arg5: number[], arg6: Internal.Point_): Internal.WritableRaster;
        getDataBuffer(): Internal.DataBuffer;
        getSamples(arg0: number, arg1: number, arg2: number, arg3: number, arg4: number, arg5: number[]): number[];
        getPixel(arg0: number, arg1: number, arg2: number[]): number[];
        static createPackedRaster(arg0: number, arg1: number, arg2: number, arg3: number, arg4: number, arg5: Internal.Point_): Internal.WritableRaster;
        static createPackedRaster(arg0: Internal.DataBuffer_, arg1: number, arg2: number, arg3: number, arg4: Internal.Point_): Internal.WritableRaster;
        static createPackedRaster(arg0: number, arg1: number, arg2: number, arg3: number[], arg4: Internal.Point_): Internal.WritableRaster;
        static createPackedRaster(arg0: Internal.DataBuffer_, arg1: number, arg2: number, arg3: number, arg4: number[], arg5: Internal.Point_): Internal.WritableRaster;
        createCompatibleWritableRaster(): Internal.WritableRaster;
        createCompatibleWritableRaster(arg0: number, arg1: number): Internal.WritableRaster;
        createCompatibleWritableRaster(arg0: Internal.Rectangle_): Internal.WritableRaster;
        createCompatibleWritableRaster(arg0: number, arg1: number, arg2: number, arg3: number): Internal.WritableRaster;
        getSampleModelTranslateX(): number;
        getSampleModelTranslateY(): number;
        equals(arg0: any): boolean;
        getDataElements(arg0: number, arg1: number, arg2: any): any;
        getDataElements(arg0: number, arg1: number, arg2: number, arg3: number, arg4: any): any;
        toString(): string;
        static createInterleavedRaster(arg0: number, arg1: number, arg2: number, arg3: number, arg4: Internal.Point_): Internal.WritableRaster;
        static createInterleavedRaster(arg0: number, arg1: number, arg2: number, arg3: number, arg4: number, arg5: number[], arg6: Internal.Point_): Internal.WritableRaster;
        static createInterleavedRaster(arg0: Internal.DataBuffer_, arg1: number, arg2: number, arg3: number, arg4: number, arg5: number[], arg6: Internal.Point_): Internal.WritableRaster;
        getSample(arg0: number, arg1: number, arg2: number): number;
        getMinX(): number;
        getMinY(): number;
        get parent(): Internal.Raster;
        get dataBuffer(): Internal.DataBuffer;
        get numDataElements(): number;
        get numBands(): number;
        get minY(): number;
        get minX(): number;
        get width(): number;
        get bounds(): Internal.Rectangle;
        get transferType(): number;
        get sampleModelTranslateX(): number;
        get class(): Internal.Class<any>;
        get sampleModel(): Internal.SampleModel;
        get height(): number;
        get sampleModelTranslateY(): number;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    type Raster_ = Raster;
    class UseAnim extends Internal.Enum<Internal.UseAnim> {
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        static valueOf(arg0: string): Internal.UseAnim;
        static valueOf<T_>(arg0: Internal.Class_<T_>, arg1: string): T_;
        notifyAll(): void;
        static values(): Internal.UseAnim[];
        compareTo(arg0: Internal.UseAnim_): number;
        describeConstable(): Internal.Optional<Internal.Enum$EnumDesc<Internal.UseAnim>>;
        notify(): void;
        getDeclaringClass(): Internal.Class<Internal.UseAnim>;
        hashCode(): number;
        equals(arg0: any): boolean;
        name(): string;
        toString(): string;
        ordinal(): number;
        static readonly BLOCK : Internal.UseAnim;
        static readonly EAT : Internal.UseAnim;
        static readonly BOW : Internal.UseAnim;
        static readonly NONE : Internal.UseAnim;
        static readonly DRINK : Internal.UseAnim;
        static readonly SPEAR : Internal.UseAnim;
        static readonly CROSSBOW : Internal.UseAnim;
        static readonly SPYGLASS : Internal.UseAnim;
        get class(): Internal.Class<any>;
        get declaringClass(): Internal.Class<Internal.UseAnim>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    type UseAnim_ = "spear" | "crossbow" | "eat" | "spyglass" | "block" | "none" | "bow" | "drink" | UseAnim;
    interface AccessorDamageSource {
        botania_setBypassArmor(): Internal.DamageSource;
    }
    type AccessorDamageSource_ = AccessorDamageSource;
    interface TaskType$Provider {
        create(arg0: Internal.Quest_): Internal.Task;
    }
    type TaskType$Provider_ = ((arg0: Internal.Quest) => Internal.Task) | TaskType$Provider;
    class TimeUnit extends Internal.Enum<Internal.TimeUnit> {
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        notifyAll(): void;
        static values(): Internal.TimeUnit[];
        compareTo(arg0: Internal.TimeUnit_): number;
        convert(arg0: Internal.Duration_): number;
        convert(arg0: number, arg1: Internal.TimeUnit_): number;
        describeConstable(): Internal.Optional<Internal.Enum$EnumDesc<Internal.TimeUnit>>;
        notify(): void;
        toSeconds(arg0: number): number;
        sleep(arg0: number): void;
        getDeclaringClass(): Internal.Class<Internal.TimeUnit>;
        hashCode(): number;
        static of(arg0: Internal.ChronoUnit_): Internal.TimeUnit;
        toMillis(arg0: number): number;
        toDays(arg0: number): number;
        toChronoUnit(): Internal.ChronoUnit;
        timedJoin(arg0: Internal.Thread_, arg1: number): void;
        timedWait(arg0: any, arg1: number): void;
        static valueOf(arg0: string): Internal.TimeUnit;
        static valueOf<T_>(arg0: Internal.Class_<T_>, arg1: string): T_;
        toNanos(arg0: number): number;
        toMinutes(arg0: number): number;
        toHours(arg0: number): number;
        equals(arg0: any): boolean;
        name(): string;
        toString(): string;
        toMicros(arg0: number): number;
        ordinal(): number;
        static readonly MILLISECONDS : Internal.TimeUnit;
        static readonly MICROSECONDS : Internal.TimeUnit;
        static readonly HOURS : Internal.TimeUnit;
        static readonly SECONDS : Internal.TimeUnit;
        static readonly NANOSECONDS : Internal.TimeUnit;
        static readonly DAYS : Internal.TimeUnit;
        static readonly MINUTES : Internal.TimeUnit;
        get class(): Internal.Class<any>;
        get declaringClass(): Internal.Class<Internal.TimeUnit>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    type TimeUnit_ = "milliseconds" | "seconds" | "hours" | "minutes" | "days" | "nanoseconds" | "microseconds" | TimeUnit;
    class Pose extends Internal.Enum<Internal.Pose> {
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        static valueOf(arg0: string): Internal.Pose;
        static valueOf<T_>(arg0: Internal.Class_<T_>, arg1: string): T_;
        notifyAll(): void;
        static values(): Internal.Pose[];
        compareTo(arg0: Internal.Pose_): number;
        describeConstable(): Internal.Optional<Internal.Enum$EnumDesc<Internal.Pose>>;
        notify(): void;
        getDeclaringClass(): Internal.Class<Internal.Pose>;
        hashCode(): number;
        equals(arg0: any): boolean;
        name(): string;
        toString(): string;
        ordinal(): number;
        static readonly SLEEPING : Internal.Pose;
        static readonly FALL_FLYING : Internal.Pose;
        static readonly LONG_JUMPING : Internal.Pose;
        static readonly DYING : Internal.Pose;
        static readonly CROUCHING : Internal.Pose;
        static readonly STANDING : Internal.Pose;
        static readonly SWIMMING : Internal.Pose;
        static readonly SPIN_ATTACK : Internal.Pose;
        get class(): Internal.Class<any>;
        get declaringClass(): Internal.Class<Internal.Pose>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    type Pose_ = "standing" | "swimming" | "crouching" | "long_jumping" | "dying" | "fall_flying" | "spin_attack" | "sleeping" | Pose;
    interface LootFunctionsContainer <F> {
        setName(arg0: Internal.Component_): F;
        enchantWithLevels(arg0: Internal.NumberProvider_): F;
        enchantWithLevels(arg0: Internal.NumberProvider_, arg1: boolean): F;
        damage(arg0: Internal.NumberProvider_): F;
        addFunction(arg0: Internal.LootItemFunction$Builder_): F;
        functions(arg0: ItemFilter_, arg1: Internal.Consumer_<Internal.LootFunctionsContainer_<F>>): F;
        limitCount(arg0: Internal.NumberProvider_, arg1: Internal.NumberProvider_): F;
        addAttributes(arg0: Internal.Consumer_<Internal.AddAttributesFunction$Builder_>): F;
        applyBonus(arg0: Internal.Enchantment_, arg1: number): F;
        addNBT(arg0: Internal.CompoundTag_): F;
        addNbt(arg0: Internal.CompoundTag_): F;
        replaceLore(arg0: Internal.Component_[]): F;
        applyBinomialDistributionBonus(arg0: Internal.Enchantment_, arg1: number, arg2: number): F;
        addAction(arg0: Internal.ILootAction_): F;
        addLore(arg0: Internal.Component_[]): F;
        applyOreBonus(arg0: Internal.Enchantment_): F;
        addPotion(arg0: Internal.Potion_): F;
        applyLootingBonus(arg0: Internal.NumberProvider_): F;
        enchantRandomly(): F;
        enchantRandomly(arg0: Internal.Enchantment_[]): F;
        smeltLoot(): F;
        simulateExplosionDecay(): F;
    }
    type LootFunctionsContainer_<F> = LootFunctionsContainer<F>;
    interface BufferVertexConsumer extends Internal.VertexConsumer {
        applyBakedLighting(arg0: number, arg1: Internal.ByteBuffer_): number;
        createSink(factory: Internal.VertexType_<any>): Internal.VertexSink;
        putBulkData(arg0: Internal.PoseStack$Pose_, arg1: Internal.BakedQuad_, arg2: number[], arg3: number, arg4: number, arg5: number, arg6: number, arg7: number[], arg8: number, arg9: boolean): void;
        putBulkData(arg0: Internal.PoseStack$Pose_, arg1: Internal.BakedQuad_, arg2: number, arg3: number, arg4: number, arg5: number, arg6: number, arg7: number, arg8: boolean): void;
        putBulkData(arg0: Internal.PoseStack$Pose_, arg1: Internal.BakedQuad_, arg2: number, arg3: number, arg4: number, arg5: number, arg6: number, arg7: number): void;
        putBulkData(arg0: Internal.PoseStack$Pose_, arg1: Internal.BakedQuad_, arg2: number, arg3: number, arg4: number, arg5: number, arg6: number, arg7: boolean): void;
        applyBakedNormals(arg0: Internal.Vector3f_, arg1: Internal.ByteBuffer_, arg2: Internal.Matrix3f_): void;
    }
    type BufferVertexConsumer_ = BufferVertexConsumer;
    interface Function4 <T1, T2, T3, T4, R> {
        apply(arg0: T1, arg1: T2, arg2: T3, arg3: T4): R;
        curry3(): Internal.Function3<T1, T2, T3, java_.util.function_.Function<T4, R>>;
        curry2(): Internal.BiFunction<T1, T2, Internal.BiFunction<T3, T4, R>>;
        curry(): java_.util.function_.Function<T1, Internal.Function3<T2, T3, T4, R>>;
    }
    type Function4_<T1, T2, T3, T4, R> = Function4<T1, T2, T3, T4, R>;
    class Item$Properties {
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        hashCode(): number;
        notifyAll(): void;
        equals(arg0: any): boolean;
        setNoRepair(): Internal.Item$Properties;
        toString(): string;
        notify(): void;
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    type Item$Properties_ = Item$Properties;
    abstract class URLStreamHandler {
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        hashCode(): number;
        notifyAll(): void;
        equals(arg0: any): boolean;
        toString(): string;
        notify(): void;
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    type URLStreamHandler_ = URLStreamHandler;
    interface Byte2BooleanFunction extends Internal.Function<number, boolean>, java_.util.function_.IntPredicate {
        getOrDefault(arg0: any, arg1: boolean): boolean;
        getOrDefault(arg0: number, arg1: boolean): boolean;
        andThenShort(arg0: Internal.Boolean2ShortFunction_): Internal.Byte2ShortFunction;
        composeByte(arg0: Internal.Byte2ByteFunction_): Internal.Byte2BooleanFunction;
        andThenInt(arg0: Internal.Boolean2IntFunction_): Internal.Byte2IntFunction;
        composeReference<T_>(arg0: Internal.Reference2ByteFunction_<T_>): Internal.Reference2BooleanFunction<T_>;
        andThen<T_>(arg0: java_.util.function_.Function_<boolean, T_>): java_.util.function_.Function<number, T_>;
        put(arg0: number, arg1: boolean): boolean;
        remove(arg0: number): boolean;
        remove(arg0: any): boolean;
        defaultReturnValue(): boolean;
        defaultReturnValue(arg0: boolean): void;
        andThenDouble(arg0: Internal.Boolean2DoubleFunction_): Internal.Byte2DoubleFunction;
        andThenObject<T_>(arg0: Internal.Boolean2ObjectFunction_<T_>): Internal.Byte2ObjectFunction<T_>;
        and(arg0: java_.util.function_.IntPredicate_): java_.util.function_.IntPredicate;
        get(arg0: any): boolean;
        get(arg0: number): boolean;
        andThenLong(arg0: Internal.Boolean2LongFunction_): Internal.Byte2LongFunction;
        composeLong(arg0: Internal.Long2ByteFunction_): Internal.Long2BooleanFunction;
        andThenByte(arg0: Internal.Boolean2ByteFunction_): Internal.Byte2ByteFunction;
        andThenFloat(arg0: Internal.Boolean2FloatFunction_): Internal.Byte2FloatFunction;
        or(arg0: java_.util.function_.IntPredicate_): java_.util.function_.IntPredicate;
        test(arg0: number): boolean;
        apply(arg0: number): boolean;
        containsKey(arg0: number): boolean;
        containsKey(arg0: any): boolean;
        composeInt(arg0: Internal.Int2ByteFunction_): Internal.Int2BooleanFunction;
        clear(): void;
        composeFloat(arg0: Internal.Float2ByteFunction_): Internal.Float2BooleanFunction;
        andThenChar(arg0: Internal.Boolean2CharFunction_): Internal.Byte2CharFunction;
        composeObject<T_>(arg0: Internal.Object2ByteFunction_<T_>): Internal.Object2BooleanFunction<T_>;
        size(): number;
        compose<T_>(arg0: java_.util.function_.Function_<T_, number>): java_.util.function_.Function<T_, boolean>;
        negate(): java_.util.function_.IntPredicate;
        composeShort(arg0: Internal.Short2ByteFunction_): Internal.Short2BooleanFunction;
        andThenReference<T_>(arg0: Internal.Boolean2ReferenceFunction_<T_>): Internal.Byte2ReferenceFunction<T_>;
        composeChar(arg0: Internal.Char2ByteFunction_): Internal.Char2BooleanFunction;
        composeDouble(arg0: Internal.Double2ByteFunction_): Internal.Double2BooleanFunction;
    }
    type Byte2BooleanFunction_ = ((arg0: number) => boolean) | Byte2BooleanFunction;
    class RecordCodecBuilder <O, F> implements Internal.App<Internal.RecordCodecBuilder$Mu<O>, F> {
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        static instance<O_>(): Internal.RecordCodecBuilder$Instance<O_>;
        static mapCodec<O_>(arg0: java_.util.function_.Function_<Internal.RecordCodecBuilder$Instance_<O_>, Internal.App_<Internal.RecordCodecBuilder$Mu_<O_>, O_>>): Internal.MapCodec<O_>;
        notifyAll(): void;
        static deprecated<O_, F_>(arg0: F_, arg1: number): Internal.RecordCodecBuilder<O_, F_>;
        notify(): void;
        static point<O_, F_>(arg0: F_): Internal.RecordCodecBuilder<O_, F_>;
        static point<O_, F_>(arg0: F_, arg1: Internal.Lifecycle_): Internal.RecordCodecBuilder<O_, F_>;
        static build<O_>(arg0: Internal.App_<Internal.RecordCodecBuilder$Mu_<O_>, O_>): Internal.MapCodec<O_>;
        hashCode(): number;
        static stable<O_, F_>(arg0: F_): Internal.RecordCodecBuilder<O_, F_>;
        static unbox<O_, F_>(arg0: Internal.App_<Internal.RecordCodecBuilder$Mu_<O_>, F_>): Internal.RecordCodecBuilder<O_, F_>;
        equals(arg0: any): boolean;
        static of<O_, F_>(arg0: java_.util.function_.Function_<O_, F_>, arg1: string, arg2: Internal.Codec_<F_>): Internal.RecordCodecBuilder<O_, F_>;
        static of<O_, F_>(arg0: java_.util.function_.Function_<O_, F_>, arg1: Internal.MapCodec_<F_>): Internal.RecordCodecBuilder<O_, F_>;
        static create<O_>(arg0: java_.util.function_.Function_<Internal.RecordCodecBuilder$Instance_<O_>, Internal.App_<Internal.RecordCodecBuilder$Mu_<O_>, O_>>): Internal.Codec<O_>;
        toString(): string;
        dependent<E_>(arg0: java_.util.function_.Function_<O, E_>, arg1: Internal.MapEncoder_<E_>, arg2: java_.util.function_.Function_<Internal.RecordCodecBuilder$Mu_<O>, Internal.MapDecoder_<E_>>): Internal.RecordCodecBuilder<O, E_>;
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    type RecordCodecBuilder_<O, F> = RecordCodecBuilder<O, F>;
    interface TypeDescriptor {
        descriptorString(): string;
    }
    type TypeDescriptor_ = TypeDescriptor;
    class ChapterGroup extends Internal.QuestObject {
        getClass(): Internal.Class<any>;
        isDefaultGroup(): boolean;
        getIndex(): number;
        getMutableTitle(): Internal.MutableComponent;
        getTags(): Internal.Set<string>;
        static getCodeString(object: Internal.QuestObjectBase_): string;
        getCodeString(): string;
        static getCodeString(id: number): string;
        writeData(nbt: Internal.CompoundTag_): void;
        createSubGroup(group: Internal.ConfigGroup_): Internal.ConfigGroup;
        editedFromGUIOnServer(): void;
        forceProgress(teamData: Internal.TeamData_, progressChange: Internal.ProgressChange_): void;
        isCompletedRaw(data: Internal.TeamData_): boolean;
        getTitle(): Internal.Component;
        getPath(): string;
        clearCachedData(): void;
        static parseCodeString(id: string): number;
        readData(nbt: Internal.CompoundTag_): void;
        editedFromGUI(): void;
        hasTag(tag: string): boolean;
        onCompleted(data: Internal.QuestProgressEventData_<any>): void;
        static getID(object: Internal.QuestObjectBase_): number;
        isVisible(data: Internal.TeamData_): boolean;
        onEditButtonClicked(gui: Internal.Runnable_): void;
        getChildren(): Internal.Collection<Internal.QuestObject>;
        onStarted(data: Internal.QuestProgressEventData_<any>): void;
        getAltTitle(): Internal.Component;
        getVisibleChapters(data: Internal.TeamData_): Internal.List<Internal.Chapter>;
        deleteSelf(): void;
        cacheProgress(): boolean;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        deleteChildren(): void;
        readNetData(buffer: Internal.FriendlyByteBuf_): void;
        notifyAll(): void;
        notify(): void;
        getRelativeProgressFromChildren(data: Internal.TeamData_): number;
        static getRelativeProgressFromChildren(progressSum: number, count: number): number;
        hashCode(): number;
        getAltIcon(): Internal.Icon;
        getObjectType(): Internal.QuestObjectType;
        hasUnclaimedRewardsRaw(teamData: Internal.TeamData_, player: Internal.UUID_): boolean;
        getParentID(): number;
        getProgressColor(data: Internal.TeamData_, dim: boolean): Internal.Color4I;
        getProgressColor(data: Internal.TeamData_): Internal.Color4I;
        refreshJEI(): number;
        getQuestChapter(): Internal.Chapter;
        getFirstVisibleChapter(data: Internal.TeamData_): Internal.Chapter;
        getQuestFile(): Internal.QuestFile;
        writeNetData(buffer: Internal.FriendlyByteBuf_): void;
        getConfig(config: Internal.ConfigGroup_): void;
        getIcon(): Internal.Icon;
        forceProgressRaw(teamData: Internal.TeamData_, progressChange: Internal.ProgressChange_): void;
        static isNull(object: Internal.QuestObjectBase_): boolean;
        equals(object: any): boolean;
        toString(): string;
        static titleToID(s: string): Internal.Optional<string>;
        onCreated(): void;
        disableToast : boolean;
        readonly file : Internal.QuestFile;
        readonly chapters : Internal.List<Internal.Chapter>;
        invalid : boolean;
        icon : Internal.ItemStack;
        static sendNotifications : Internal.Tristate;
        id : number;
        title : string;
        guiCollapsed : boolean;
        get codeString(): string;
        get index(): number;
        get questFile(): Internal.QuestFile;
        get parentID(): number;
        get mutableTitle(): Internal.MutableComponent;
        get tags(): Internal.Set<string>;
        get altIcon(): Internal.Icon;
        get objectType(): Internal.QuestObjectType;
        get path(): string;
        get defaultGroup(): boolean;
        get children(): Internal.Collection<Internal.QuestObject>;
        get altTitle(): Internal.Component;
        get class(): Internal.Class<any>;
        get questChapter(): Internal.Chapter;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    type ChapterGroup_ = ChapterGroup;
    abstract class BaseScreen extends Internal.Panel implements Internal.IOpenableScreen {
        closeGui(openPrevScreen: boolean): void;
        closeGui(): void;
        setY(v: number): void;
        setX(v: number): void;
        shouldDraw(): boolean;
        getContentHeight(): number;
        isDefaultScrollVertical(): boolean;
        openYesNo(title: Internal.Component_, desc: Internal.Component_, callback: Internal.Runnable_): void;
        drawForeground(matrixStack: Internal.PoseStack_, theme: Internal.Theme_, x: number, y: number, w: number, h: number): void;
        static getClipboardString(): string;
        onInit(): boolean;
        setOffset(flag: boolean): void;
        getScrollStep(): number;
        getMouseY(): number;
        onClosed(): void;
        isMouseOver(x: number, y: number, w: number, h: number): boolean;
        isMouseOver(widget: dev.ftb.mods.ftblibrary.ui.Widget_): boolean;
        isMouseOver(): boolean;
        getTheme(): Internal.Theme;
        getMouseX(): number;
        getWidget(index: number): dev.ftb.mods.ftblibrary.ui.Widget;
        openGui(): void;
        initGui(): void;
        addMouseOverText(list: Internal.TooltipList_): void;
        playClickSound(): void;
        isEnabled(): boolean;
        refreshWidgets(): void;
        handleClick(scheme: string, path: string): boolean;
        handleClick(click: string): boolean;
        isOffset(): boolean;
        charTyped(c: string, modifiers: Internal.KeyModifiers_): boolean;
        openYesNoFull(title: Internal.Component_, desc: Internal.Component_, callback: Internal.BooleanConsumer_): void;
        onClosedByKey(key: dev.ftb.mods.ftblibrary.ui.input.Key_): boolean;
        mouseDoubleClicked(button: Internal.MouseButton_): boolean;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        drawWidget(matrixStack: Internal.PoseStack_, theme: Internal.Theme_, widget: dev.ftb.mods.ftblibrary.ui.Widget_, index: number, x: number, y: number, w: number, h: number): void;
        shouldAddMouseOverText(): boolean;
        notify(): void;
        mouseReleased(button: Internal.MouseButton_): void;
        getScrollX(): number;
        getContentWidth(): number;
        getScrollY(): number;
        getPartialTicks(): number;
        keyReleased(key: dev.ftb.mods.ftblibrary.ui.input.Key_): void;
        drawDefaultBackground(matrixStack: Internal.PoseStack_): boolean;
        static setClipboardString(string: string): void;
        static isShiftKeyDown(): boolean;
        setScrollStep(s: number): void;
        updateGui(mx: number, my: number, pt: number): void;
        getWidgetType(): Internal.WidgetType;
        doesGuiPauseGame(): boolean;
        movePanelScroll(dx: number, dy: number): boolean;
        getPrevScreen(): Internal.Screen;
        draw(matrixStack: Internal.PoseStack_, theme: Internal.Theme_, x: number, y: number, w: number, h: number): void;
        checkMouseOver(mouseX: number, mouseY: number): boolean;
        setWidth(v: number): void;
        getOnlyInteractWithWidgetsInside(): boolean;
        addWidgets(): void;
        openContextMenu(panel: Internal.Panel_): void;
        openContextMenu(menu: Internal.List_<Internal.ContextMenuItem_>): Internal.ContextMenu;
        addAll(list: Internal.Iterable_<dev.ftb.mods.ftblibrary.ui.Widget_>): void;
        equals(arg0: any): boolean;
        scrollPanel(scroll: number): boolean;
        toString(): string;
        setScrollX(scroll: number): void;
        setScrollY(scroll: number): void;
        static isMouseButtonDown(button: Internal.MouseButton_): boolean;
        getClass(): Internal.Class<any>;
        collidesWith(x: number, y: number, w: number, h: number): boolean;
        acceptGhostIngredient(ingredient: any): void;
        isGhostIngredientTarget(ingredient: any): boolean;
        run(): void;
        align(layout: Internal.WidgetLayout_): number;
        getGui(): Internal.BaseScreen;
        mousePressed(button: Internal.MouseButton_): boolean;
        setPos(x: number, y: number): void;
        getTitle(): Internal.Component;
        drawBackground(matrixStack: Internal.PoseStack_, theme: Internal.Theme_, x: number, y: number, w: number, h: number): void;
        static isCtrlKeyDown(): boolean;
        drawOffsetBackground(matrixStack: Internal.PoseStack_, theme: Internal.Theme_, x: number, y: number, w: number, h: number): void;
        updateMouseOver(mouseX: number, mouseY: number): void;
        getScreen(): Internal.Window;
        add(widget: dev.ftb.mods.ftblibrary.ui.Widget_): void;
        keyPressed(key: dev.ftb.mods.ftblibrary.ui.input.Key_): boolean;
        setOnlyInteractWithWidgetsInside(value: boolean): void;
        setPosAndSize(x: number, y: number, w: number, h: number): dev.ftb.mods.ftblibrary.ui.Widget;
        setOnlyRenderWidgetsInside(value: boolean): void;
        tick(): void;
        setHeight(v: number): void;
        alignWidgets(): void;
        mouseScrolled(scroll: number): boolean;
        notifyAll(): void;
        openAfter(runnable: Internal.Runnable_): Internal.Runnable;
        closeContextMenu(): void;
        isMouseOverAnyWidget(): boolean;
        setSize(w: number, h: number): void;
        hashCode(): number;
        openGuiLater(): void;
        static isKeyDown(key: number): boolean;
        clearWidgets(): void;
        getCursor(): Internal.CursorType;
        getOnlyRenderWidgetsInside(): boolean;
        onBack(): void;
        getX(): number;
        getY(): number;
        onPostInit(): void;
        getIngredientUnderMouse(): any;
        itemRenderer : Internal.ItemRenderer;
        posX : number;
        parent : Internal.Panel;
        posY : number;
        contextMenu : Internal.Panel;
        attachedScrollbar : Internal.PanelScrollBar;
        width : number;
        contentWidthExtra : number;
        readonly widgets : Internal.List<dev.ftb.mods.ftblibrary.ui.Widget>;
        contentHeightExtra : number;
        height : number;
        get mouseX(): number;
        get cursor(): Internal.CursorType;
        get ingredientUnderMouse(): any;
        get mouseY(): number;
        get shiftKeyDown(): boolean;
        get screen(): Internal.Window;
        get scrollStep(): number;
        get title(): Internal.Component;
        get enabled(): boolean;
        get contentWidth(): number;
        get mouseOverAnyWidget(): boolean;
        get theme(): Internal.Theme;
        get class(): Internal.Class<any>;
        get defaultScrollVertical(): boolean;
        get onlyInteractWithWidgetsInside(): boolean;
        get clipboardString(): string;
        get offset(): boolean;
        get prevScreen(): Internal.Screen;
        get mouseOver(): boolean;
        get widgetType(): Internal.WidgetType;
        get contentHeight(): number;
        get ctrlKeyDown(): boolean;
        get onlyRenderWidgetsInside(): boolean;
        get x(): number;
        get y(): number;
        get scrollY(): number;
        get gui(): Internal.BaseScreen;
        get scrollX(): number;
        get partialTicks(): number;
        set onlyInteractWithWidgetsInside(value: boolean);
        set clipboardString(string: string);
        set offset(flag: boolean);
        set onlyRenderWidgetsInside(value: boolean);
        set x(v: number);
        set y(v: number);
        set scrollY(scroll: number);
        set scrollStep(s: number);
        set scrollX(scroll: number);
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    type BaseScreen_ = BaseScreen;
    interface Float2ByteFunction extends Internal.Function<number, number>, Internal.DoubleToIntFunction {
        getOrDefault(arg0: any, arg1: number): number;
        getOrDefault(arg0: number, arg1: number): number;
        andThenShort(arg0: Internal.Byte2ShortFunction_): Internal.Float2ShortFunction;
        composeByte(arg0: Internal.Byte2FloatFunction_): Internal.Byte2ByteFunction;
        andThenInt(arg0: Internal.Byte2IntFunction_): Internal.Float2IntFunction;
        composeReference<T_>(arg0: Internal.Reference2FloatFunction_<T_>): Internal.Reference2ByteFunction<T_>;
        andThen<T_>(arg0: java_.util.function_.Function_<number, T_>): java_.util.function_.Function<number, T_>;
        put(arg0: number, arg1: number): number;
        remove(arg0: number): number;
        remove(arg0: any): number;
        defaultReturnValue(): number;
        defaultReturnValue(arg0: number): void;
        andThenDouble(arg0: Internal.Byte2DoubleFunction_): Internal.Float2DoubleFunction;
        andThenObject<T_>(arg0: Internal.Byte2ObjectFunction_<T_>): Internal.Float2ObjectFunction<T_>;
        get(arg0: any): number;
        get(arg0: number): number;
        andThenLong(arg0: Internal.Byte2LongFunction_): Internal.Float2LongFunction;
        composeLong(arg0: Internal.Long2FloatFunction_): Internal.Long2ByteFunction;
        andThenByte(arg0: Internal.Byte2ByteFunction_): Internal.Float2ByteFunction;
        andThenFloat(arg0: Internal.Byte2FloatFunction_): Internal.Float2FloatFunction;
        applyAsInt(arg0: number): number;
        apply(arg0: number): number;
        containsKey(arg0: any): boolean;
        containsKey(arg0: number): boolean;
        composeInt(arg0: Internal.Int2FloatFunction_): Internal.Int2ByteFunction;
        clear(): void;
        composeFloat(arg0: Internal.Float2FloatFunction_): Internal.Float2ByteFunction;
        andThenChar(arg0: Internal.Byte2CharFunction_): Internal.Float2CharFunction;
        composeObject<T_>(arg0: Internal.Object2FloatFunction_<T_>): Internal.Object2ByteFunction<T_>;
        size(): number;
        compose<T_>(arg0: java_.util.function_.Function_<T_, number>): java_.util.function_.Function<T_, number>;
        composeShort(arg0: Internal.Short2FloatFunction_): Internal.Short2ByteFunction;
        andThenReference<T_>(arg0: Internal.Byte2ReferenceFunction_<T_>): Internal.Float2ReferenceFunction<T_>;
        composeChar(arg0: Internal.Char2FloatFunction_): Internal.Char2ByteFunction;
        composeDouble(arg0: Internal.Double2FloatFunction_): Internal.Double2ByteFunction;
    }
    type Float2ByteFunction_ = ((arg0: number) => number) | Float2ByteFunction;
    class ModelProperty <T> implements Internal.Predicate<T> {
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        or(arg0: Internal.Predicate_<T>): Internal.Predicate<T>;
        test(arg0: T): boolean;
        and(arg0: Internal.Predicate_<T>): Internal.Predicate<T>;
        negate(): Internal.Predicate<T>;
        hashCode(): number;
        notifyAll(): void;
        equals(arg0: any): boolean;
        toString(): string;
        notify(): void;
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    type ModelProperty_<T> = ModelProperty<T>;
    interface ResourceKeyAccess {
    }
    type ResourceKeyAccess_ = ResourceKeyAccess;
    class DraggableScrollableWidgetGroup extends Internal.WidgetGroup {
        getClass(): Internal.Class<any>;
        mouseWheelMove(arg0: number, arg1: number, arg2: number): boolean;
        setYBarStyle(arg0: Internal.IGuiTexture_, arg1: Internal.IGuiTexture_): Internal.DraggableScrollableWidgetGroup;
        mouseDragged(arg0: number, arg1: number, arg2: number, arg3: number, arg4: number): boolean;
        drawInForeground(arg0: Internal.PoseStack_, arg1: number, arg2: number, arg3: number): void;
        readUpdateInfo(arg0: number, arg1: Internal.FriendlyByteBuf_): void;
        toRectangleBox(): Internal.Rect2i;
        getScrollYOffset(): number;
        isActive(): boolean;
        getGui(): Internal.ModularUI;
        getWidgetBottomHeight(): number;
        updateScreen(): void;
        clearAllWidgets(): void;
        setYScrollBarWidth(arg0: number): Internal.DraggableScrollableWidgetGroup;
        mouseMoved(arg0: number, arg1: number): void;
        isChild(arg0: com.lowdragmc.lowdraglib.gui.widget.Widget_): boolean;
        setVisible(arg0: boolean): void;
        static isMouseOver(arg0: number, arg1: number, arg2: number, arg3: number, arg4: number, arg5: number): boolean;
        addSelfPosition(arg0: number, arg1: number): Internal.Position;
        isParent(arg0: Internal.WidgetGroup_): boolean;
        keyPressed(arg0: number, arg1: number, arg2: number): boolean;
        setHoverTexture(arg0: Internal.IGuiTexture_[]): com.lowdragmc.lowdraglib.gui.widget.Widget;
        isMouseOverElement(arg0: number, arg1: number): boolean;
        isVisible(): boolean;
        getSelfPosition(): Internal.Position;
        setClientSideWidget(): Internal.WidgetGroup;
        handleClientAction(arg0: number, arg1: Internal.FriendlyByteBuf_): void;
        mouseClicked(arg0: number, arg1: number, arg2: number): boolean;
        setXScrollBarHeight(arg0: number): Internal.DraggableScrollableWidgetGroup;
        charTyped(arg0: string, arg1: number): boolean;
        removeWidget(arg0: com.lowdragmc.lowdraglib.gui.widget.Widget_): void;
        readInitialData(arg0: Internal.FriendlyByteBuf_): void;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        notifyAll(): void;
        isInitialized(): boolean;
        computeMax(): void;
        setUseScissor(arg0: boolean): void;
        setBackground(arg0: Internal.IGuiTexture_): Internal.DraggableScrollableWidgetGroup;
        setBackground(arg0: Internal.IGuiTexture_[]): com.lowdragmc.lowdraglib.gui.widget.Widget;
        notify(): void;
        mouseReleased(arg0: number, arg1: number, arg2: number): boolean;
        setDraggable(arg0: boolean): Internal.DraggableScrollableWidgetGroup;
        setSize(arg0: Internal.Size_): void;
        getScrollXOffset(): number;
        initWidget(): void;
        hashCode(): number;
        getNativeWidgets(): Internal.List<Internal.SlotWidget>;
        keyReleased(arg0: number, arg1: number, arg2: number): boolean;
        setXBarStyle(arg0: Internal.IGuiTexture_, arg1: Internal.IGuiTexture_): Internal.DraggableScrollableWidgetGroup;
        waitToRemoved(arg0: com.lowdragmc.lowdraglib.gui.widget.Widget_): void;
        detectAndSendChanges(): void;
        getPhantomTargets(arg0: any): Internal.List<Internal.Target>;
        getParent(): Internal.WidgetGroup;
        setSelfPosition(arg0: Internal.Position_): void;
        isRemote(): boolean;
        setFocus(arg0: boolean): void;
        setUiAccess(arg0: Internal.WidgetUIAccess_): void;
        drawInBackground(arg0: Internal.PoseStack_, arg1: number, arg2: number, arg3: number): void;
        getParentPosition(): Internal.Position;
        getSize(): Internal.Size;
        setActive(arg0: boolean): void;
        getPosition(): Internal.Position;
        getIngredientOverMouse(arg0: number, arg1: number): any;
        isFocus(): boolean;
        equals(arg0: any): boolean;
        onFocusChanged(arg0: com.lowdragmc.lowdraglib.gui.widget.Widget_, arg1: com.lowdragmc.lowdraglib.gui.widget.Widget_): void;
        setHoverTooltips(arg0: Internal.List_<Internal.Component_>): com.lowdragmc.lowdraglib.gui.widget.Widget;
        setHoverTooltips(arg0: string[]): com.lowdragmc.lowdraglib.gui.widget.Widget;
        setHoverTooltips(arg0: Internal.Component_[]): com.lowdragmc.lowdraglib.gui.widget.Widget;
        writeInitialData(arg0: Internal.FriendlyByteBuf_): void;
        toString(): string;
        setParentPosition(arg0: Internal.Position_): void;
        addWidget(arg0: com.lowdragmc.lowdraglib.gui.widget.Widget_): Internal.WidgetGroup;
        addWidget(arg0: number, arg1: com.lowdragmc.lowdraglib.gui.widget.Widget_): Internal.WidgetGroup;
        setGui(arg0: Internal.ModularUI_): void;
        getContainedWidgets(arg0: boolean): Internal.List<com.lowdragmc.lowdraglib.gui.widget.Widget>;
        readonly widgets : Internal.List<com.lowdragmc.lowdraglib.gui.widget.Widget>;
        get selfPosition(): Internal.Position;
        get parent(): Internal.WidgetGroup;
        get scrollXOffset(): number;
        get visible(): boolean;
        get nativeWidgets(): Internal.List<Internal.SlotWidget>;
        get active(): boolean;
        get focus(): boolean;
        get remote(): boolean;
        get widgetBottomHeight(): number;
        get parentPosition(): Internal.Position;
        get size(): Internal.Size;
        get initialized(): boolean;
        get gui(): Internal.ModularUI;
        get position(): Internal.Position;
        get scrollYOffset(): number;
        get class(): Internal.Class<any>;
        set selfPosition(arg0: Internal.Position_);
        set useScissor(arg0: boolean);
        set visible(arg0: boolean);
        set active(arg0: boolean);
        set focus(arg0: boolean);
        set hoverTooltips(arg0: Internal.List_<Internal.Component_>);
        set xScrollBarHeight(arg0: number);
        set yScrollBarWidth(arg0: number);
        set parentPosition(arg0: Internal.Position_);
        set size(arg0: Internal.Size_);
        set draggable(arg0: boolean);
        set hoverTexture(arg0: Internal.IGuiTexture_[]);
        set background(arg0: Internal.IGuiTexture_);
        set gui(arg0: Internal.ModularUI_);
        set uiAccess(arg0: Internal.WidgetUIAccess_);
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    type DraggableScrollableWidgetGroup_ = DraggableScrollableWidgetGroup;
    abstract class Buffer {
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        hasArray(): boolean;
        notifyAll(): void;
        hasRemaining(): boolean;
        clear(): Internal.Buffer;
        duplicate(): Internal.Buffer;
        notify(): void;
        remaining(): number;
        capacity(): number;
        isReadOnly(): boolean;
        rewind(): Internal.Buffer;
        slice(arg0: number, arg1: number): Internal.Buffer;
        slice(): Internal.Buffer;
        array(): any;
        hashCode(): number;
        equals(arg0: any): boolean;
        limit(arg0: number): Internal.Buffer;
        limit(): number;
        reset(): Internal.Buffer;
        arrayOffset(): number;
        toString(): string;
        position(): number;
        position(arg0: number): Internal.Buffer;
        flip(): Internal.Buffer;
        isDirect(): boolean;
        mark(): Internal.Buffer;
        get direct(): boolean;
        get readOnly(): boolean;
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    type Buffer_ = Buffer;
    class ResourceTexture implements Internal.IGuiTexture {
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        hashCode(): number;
        notifyAll(): void;
        equals(arg0: any): boolean;
        updateTick(): void;
        toString(): string;
        draw(arg0: Internal.PoseStack_, arg1: number, arg2: number, arg3: number, arg4: number, arg5: number, arg6: number): void;
        draw(arg0: Internal.PoseStack_, arg1: number, arg2: number, arg3: number, arg4: number): void;
        drawSubArea(arg0: Internal.PoseStack_, arg1: number, arg2: number, arg3: number, arg4: number, arg5: number, arg6: number, arg7: number, arg8: number): void;
        notify(): void;
        getSubTexture(arg0: number, arg1: number, arg2: number, arg3: number): Internal.ResourceTexture;
        readonly offsetX : number;
        readonly imageWidth : number;
        readonly offsetY : number;
        static readonly EMPTY : Internal.IGuiTexture;
        readonly imageHeight : number;
        readonly imageLocation : ResourceLocation;
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    type ResourceTexture_ = ResourceTexture;
    class ItemTransforms$TransformType extends Internal.Enum<Internal.ItemTransforms$TransformType> {
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        static valueOf(arg0: string): Internal.ItemTransforms$TransformType;
        static valueOf<T_>(arg0: Internal.Class_<T_>, arg1: string): T_;
        notifyAll(): void;
        static values(): Internal.ItemTransforms$TransformType[];
        compareTo(arg0: Internal.ItemTransforms$TransformType_): number;
        describeConstable(): Internal.Optional<Internal.Enum$EnumDesc<Internal.ItemTransforms$TransformType>>;
        notify(): void;
        getDeclaringClass(): Internal.Class<Internal.ItemTransforms$TransformType>;
        hashCode(): number;
        equals(arg0: any): boolean;
        name(): string;
        toString(): string;
        ordinal(): number;
        static readonly HEAD : Internal.ItemTransforms$TransformType;
        static readonly THIRD_PERSON_LEFT_HAND : Internal.ItemTransforms$TransformType;
        static readonly THIRD_PERSON_RIGHT_HAND : Internal.ItemTransforms$TransformType;
        static readonly FIRST_PERSON_RIGHT_HAND : Internal.ItemTransforms$TransformType;
        static readonly GROUND : Internal.ItemTransforms$TransformType;
        static readonly FIRST_PERSON_LEFT_HAND : Internal.ItemTransforms$TransformType;
        static readonly FIXED : Internal.ItemTransforms$TransformType;
        static readonly GUI : Internal.ItemTransforms$TransformType;
        static readonly NONE : Internal.ItemTransforms$TransformType;
        get class(): Internal.Class<any>;
        get declaringClass(): Internal.Class<Internal.ItemTransforms$TransformType>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    type ItemTransforms$TransformType_ = "head" | "third_person_left_hand" | "gui" | "ground" | "fixed" | "none" | "third_person_right_hand" | "first_person_left_hand" | "first_person_right_hand" | ItemTransforms$TransformType;
    interface GuiEventListener {
    }
    type GuiEventListener_ = GuiEventListener;
    class Scoreboard {
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        hashCode(): number;
        notifyAll(): void;
        equals(arg0: any): boolean;
        toString(): string;
        notify(): void;
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    type Scoreboard_ = Scoreboard;
    class ImmutableMap$Builder <K, V> {
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        buildOrThrow(): Internal.ImmutableMap<K, V>;
        build(): Internal.ImmutableMap<K, V>;
        hashCode(): number;
        notifyAll(): void;
        equals(arg0: any): boolean;
        putAll(arg0: Internal.Iterable_<Internal.Map$Entry_<K, V>>): Internal.ImmutableMap$Builder<K, V>;
        putAll(arg0: Internal.Map_<K, V>): Internal.ImmutableMap$Builder<K, V>;
        toString(): string;
        orderEntriesByValue(arg0: Internal.Comparator_<V>): Internal.ImmutableMap$Builder<K, V>;
        notify(): void;
        put(arg0: K, arg1: V): Internal.ImmutableMap$Builder<K, V>;
        put(arg0: Internal.Map$Entry_<K, V>): Internal.ImmutableMap$Builder<K, V>;
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    type ImmutableMap$Builder_<K, V> = ImmutableMap$Builder<K, V>;
    class MotiveBuilder extends Internal.BuilderBase<Internal.Motive> {
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        clientRegistry(minecraft: Internal.Minecraft_): void;
        generateAssetJsons(generator: Internal.AssetJsonGenerator_): void;
        transformObject(obj: Internal.Motive_): Internal.Motive;
        translationKey(key: string): Internal.BuilderBase<Internal.Motive>;
        getTranslationKeyGroup(): string;
        newID(pre: string, post: string): ResourceLocation;
        displayName(name: string): Internal.BuilderBase<Internal.Motive>;
        notifyAll(): void;
        generateLang(lang: Internal.Map_<string, string>): void;
        type(type: string): Internal.BuilderBase<Internal.Motive>;
        notify(): void;
        createAdditionalObjects(): void;
        createObject(): Internal.Motive;
        addResourcePackLocations(path: string, list: Internal.List_<ResourceLocation_>, packType: Internal.PackType_): void;
        hashCode(): number;
        equals(arg0: any): boolean;
        get(): Internal.Motive;
        getRegistryType(): Internal.RegistryObjectBuilderTypes<Internal.Motive>;
        width(width: number): Internal.MotiveBuilder;
        toString(): string;
        tag(tag: ResourceLocation_): Internal.BuilderBase<Internal.Motive>;
        generateDataJsons(generator: Internal.DataJsonGenerator_): void;
        height(height: number): Internal.MotiveBuilder;
        readonly id : ResourceLocation;
        get registryType(): Internal.RegistryObjectBuilderTypes<Internal.Motive>;
        get class(): Internal.Class<any>;
        get translationKeyGroup(): string;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    type MotiveBuilder_ = MotiveBuilder;
    /**
    */
    abstract class ItemBuilder extends Internal.BuilderBase<Internal.Item> {
        barWidth(barWidth: Internal.ToIntFunction_<Internal.ItemStackJS_>): Internal.ItemBuilder;
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        clientRegistry(minecraft: Internal.Minecraft_): void;
        maxStackSize(v: number): Internal.ItemBuilder;
        transformObject(obj: Internal.Item_): Internal.Item;
        translationKey(key: string): Internal.BuilderBase<Internal.Item>;
        color(callback: Internal.ItemBuilder$ItemColorJS_): Internal.ItemBuilder;
        color(index: number, c: Internal.Color_): Internal.ItemBuilder;
        newID(pre: string, post: string): ResourceLocation;
        displayName(name: string): Internal.BuilderBase<Internal.Item>;
        use(use: Internal.ItemBuilder$UseCallback_): Internal.ItemBuilder;
        notifyAll(): void;
        maxDamage(v: number): Internal.ItemBuilder;
        textureJson(json: Internal.JsonObject_): Internal.ItemBuilder;
        tooltip(text: Internal.Component_): Internal.ItemBuilder;
        type(type: string): Internal.BuilderBase<Internal.Item>;
        barColor(barColor: java_.util.function_.Function_<Internal.ItemStackJS_, Internal.Color_>): Internal.ItemBuilder;
        containerItem(id: string): Internal.ItemBuilder;
        notify(): void;
        createAdditionalObjects(): void;
        subtypes(fn: java_.util.function_.Function_<Internal.ItemStackJS_, Internal.Collection_<Internal.ItemStackJS_>>): Internal.ItemBuilder;
        modelJson(json: Internal.JsonObject_): Internal.ItemBuilder;
        hashCode(): number;
        burnTime(v: number): Internal.ItemBuilder;
        get(): Internal.Item;
        useDuration(useDuration: Internal.ToIntFunction_<Internal.ItemStackJS_>): Internal.ItemBuilder;
        tag(tag: ResourceLocation_): Internal.BuilderBase<Internal.Item>;
        parentModel(m: string): Internal.ItemBuilder;
        generateDataJsons(generator: Internal.DataJsonGenerator_): void;
        group(g: string): Internal.ItemBuilder;
        generateAssetJsons(generator: Internal.AssetJsonGenerator_): void;
        getTranslationKeyGroup(): string;
        texture(key: string, tex: string): Internal.ItemBuilder;
        texture(tex: string): Internal.ItemBuilder;
        generateLang(lang: Internal.Map_<string, string>): void;
        createObject(): Internal.Item;
        static ofArmorMaterial(o: any): Internal.ArmorMaterial;
        food(b: Internal.Consumer_<Internal.FoodBuilder_>): Internal.ItemBuilder;
        releaseUsing(releaseUsing: Internal.ItemBuilder$ReleaseUsingCallback_): Internal.ItemBuilder;
        unstackable(): Internal.ItemBuilder;
        addResourcePackLocations(path: string, list: Internal.List_<ResourceLocation_>, packType: Internal.PackType_): void;
        /**
        */
        modifyAttribute(attribute: net.minecraft.world.entity.ai.attributes.Attribute_, identifier: string, d: number, operation: Internal.AttributeModifier$Operation_): Internal.ItemBuilder;
        equals(arg0: any): boolean;
        getRegistryType(): Internal.RegistryObjectBuilderTypes<Internal.Item>;
        toString(): string;
        finishUsing(finishUsing: Internal.ItemBuilder$FinishUsingCallback_): Internal.ItemBuilder;
        glow(v: boolean): Internal.ItemBuilder;
        useAnimation(animation: Internal.UseAnim_): Internal.ItemBuilder;
        rarity(v: Rarity_): Internal.ItemBuilder;
        createItemProperties(): Internal.Item$Properties;
        static readonly TOOL_TIERS : {"gold":any,"diamond":any,"iron":any,"wood":any,"stone":any,"netherite":any};
        static readonly ARMOR_TIERS : {"gold":any,"chain":any,"diamond":any,"turtle":any,"iron":any,"leather":any,"netherite":any};
        readonly id : ResourceLocation;
        get registryType(): Internal.RegistryObjectBuilderTypes<Internal.Item>;
        get class(): Internal.Class<any>;
        get translationKeyGroup(): string;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    /**
    */
    type ItemBuilder_ = ItemBuilder;
    class PropertyMap extends Internal.ForwardingMultimap<string, Internal.Property> {
        getClass(): Internal.Class<any>;
        containsEntry(arg0: any, arg1: any): boolean;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        forEach(arg0: Internal.BiConsumer_<string, Internal.Property_>): void;
        asMap(): Internal.Map<string, Internal.Collection<Internal.Property>>;
        keys(): Internal.Multiset<string>;
        containsKey(arg0: any): boolean;
        notifyAll(): void;
        values(): Internal.Collection<Internal.Property>;
        isEmpty(): boolean;
        clear(): void;
        replaceValues(arg0: string, arg1: Internal.Iterable_<Internal.Property_>): Internal.Collection<Internal.Property>;
        notify(): void;
        containsValue(arg0: any): boolean;
        put(arg0: string, arg1: Internal.Property_): boolean;
        remove(arg0: any, arg1: any): boolean;
        removeAll(arg0: any): Internal.Collection<Internal.Property>;
        entries(): Internal.Collection<Internal.Map$Entry<string, Internal.Property>>;
        size(): number;
        hashCode(): number;
        putAll(arg0: Internal.Multimap_<string, Internal.Property_>): boolean;
        putAll(arg0: string, arg1: Internal.Iterable_<Internal.Property_>): boolean;
        equals(arg0: any): boolean;
        get(arg0: string): Internal.Collection<Internal.Property>;
        toString(): string;
        keySet(): Internal.Set<string>;
        get class(): Internal.Class<any>;
        get empty(): boolean;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    type PropertyMap_ = PropertyMap;
    class FallingBlockBuilder extends Internal.BlockBuilder {
        noItem(): Internal.BlockBuilder;
        suffocating(b: boolean): Internal.BlockBuilder;
        getClass(): Internal.Class<any>;
        translationKey(key: string): Internal.BuilderBase<Internal.Block>;
        newID(pre: string, post: string): ResourceLocation;
        type(type: string): Internal.BuilderBase<Internal.Block>;
        unbreakable(): Internal.BlockBuilder;
        model(m: string): Internal.BlockBuilder;
        tag(tag: ResourceLocation_): Internal.BlockBuilder;
        generateDataJsons(generator: Internal.DataJsonGenerator_): void;
        tagBoth(tag: ResourceLocation_): Internal.BlockBuilder;
        defaultCutout(): Internal.BlockBuilder;
        item(i: Internal.Consumer_<Internal.BlockItemBuilder_>): Internal.BlockBuilder;
        resistance(r: number): Internal.BlockBuilder;
        hardness(h: number): Internal.BlockBuilder;
        slipperiness(f: number): Internal.BlockBuilder;
        dustColor(color: Internal.Color_): Internal.FallingBlockBuilder;
        getRegistryType(): Internal.RegistryObjectBuilderTypes<Internal.Block>;
        textureSide(direction: Internal.Direction_, tex: string): Internal.BlockBuilder;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        clientRegistry(minecraft: Internal.Minecraft_): void;
        waterlogged(): Internal.BlockBuilder;
        transformObject(obj: Internal.Block_): Internal.Block;
        color(index: number, c: Internal.Color_): Internal.BlockBuilder;
        textureAll(tex: string): Internal.BlockBuilder;
        displayName(name: string): Internal.BuilderBase<Internal.Block>;
        notifyAll(): void;
        box(x0: number, y0: number, z0: number, x1: number, y1: number, z1: number): Internal.BlockBuilder;
        box(x0: number, y0: number, z0: number, x1: number, y1: number, z1: number, scale16: boolean): Internal.BlockBuilder;
        viewBlocking(b: boolean): Internal.BlockBuilder;
        notify(): void;
        transparent(b: boolean): Internal.BlockBuilder;
        createAdditionalObjects(): void;
        tagBlock(tag: ResourceLocation_): Internal.BlockBuilder;
        fullBlock(f: boolean): Internal.BlockBuilder;
        createProperties(): Internal.BlockBehaviour$Properties;
        notSolid(): Internal.BlockBuilder;
        generateBlockModels(builder: Internal.BlockBuilder_): Internal.Map<ResourceLocation, Internal.JsonObject>;
        hashCode(): number;
        noCollission(): Internal.BlockBuilder;
        get(): Internal.Block;
        requiresTool(f: boolean): Internal.BlockBuilder;
        renderType(l: string): Internal.BlockBuilder;
        jumpFactor(f: number): Internal.BlockBuilder;
        createShape(): Internal.VoxelShape;
        generateAssetJsons(generator: Internal.AssetJsonGenerator_): void;
        noCollision(): Internal.BlockBuilder;
        opaque(o: boolean): Internal.BlockBuilder;
        randomTick(randomTickCallback: Internal.Consumer_<Internal.RandomTickCallbackJS_>): Internal.BlockBuilder;
        getTranslationKeyGroup(): string;
        texture(id: string, tex: string): Internal.BlockBuilder;
        noDrops(): Internal.BlockBuilder;
        generateLang(lang: Internal.Map_<string, string>): void;
        tagItem(tag: ResourceLocation_): Internal.BlockBuilder;
        speedFactor(f: number): Internal.BlockBuilder;
        noValidSpawns(b: boolean): Internal.BlockBuilder;
        createObject(): Internal.Block;
        lightLevel(light: number): Internal.BlockBuilder;
        addResourcePackLocations(path: string, list: Internal.List_<ResourceLocation_>, packType: Internal.PackType_): void;
        defaultTranslucent(): Internal.BlockBuilder;
        material(m: Internal.MaterialJS_): Internal.BlockBuilder;
        equals(arg0: any): boolean;
        toString(): string;
        redstoneConductor(b: boolean): Internal.BlockBuilder;
        lootTable : ((arg0: Internal.LootBuilder) => void);
        modelJson : Internal.JsonObject;
        blockstateJson : Internal.JsonObject;
        readonly id : ResourceLocation;
        randomTickCallback : ((arg0: Internal.RandomTickCallbackJS) => void);
        get registryType(): Internal.RegistryObjectBuilderTypes<Internal.Block>;
        get class(): Internal.Class<any>;
        get translationKeyGroup(): string;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    type FallingBlockBuilder_ = FallingBlockBuilder;
    class BYGPlayerTrackedData extends Internal.Record {
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        hashCode(): number;
        notifyAll(): void;
        discoveredBiomesByNameSpace(): Internal.Map<string, Internal.Set<Internal.ResourceKey<Internal.Biome>>>;
        equals(arg0: any): boolean;
        playerCreate(arg0: Internal.ServerPlayer_): void;
        toString(): string;
        tickPerSecond(arg0: Internal.ServerPlayer_): void;
        notify(): void;
        static fromCodec(arg0: Internal.Map_<string, Internal.Set_<Internal.ResourceKey_<Internal.Biome_>>>): Internal.BYGPlayerTrackedData;
        static readonly CODEC : Internal.Codec<Internal.BYGPlayerTrackedData>;
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    type BYGPlayerTrackedData_ = BYGPlayerTrackedData;
    class CommandDispatcher <S> {
        getClass(): Internal.Class<any>;
        getSmartUsage(arg0: Internal.CommandNode_<S>, arg1: S): Internal.Map<Internal.CommandNode<S>, string>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        setConsumer(arg0: Internal.ResultConsumer_<S>): void;
        getCompletionSuggestions(arg0: Internal.ParseResults_<S>, arg1: number): Internal.CompletableFuture<Internal.Suggestions>;
        getCompletionSuggestions(arg0: Internal.ParseResults_<S>): Internal.CompletableFuture<Internal.Suggestions>;
        notifyAll(): void;
        getAllUsage(arg0: Internal.CommandNode_<S>, arg1: S, arg2: boolean): string[];
        parse(arg0: string, arg1: S): Internal.ParseResults<S>;
        parse(arg0: Internal.StringReader_, arg1: S): Internal.ParseResults<S>;
        execute(arg0: Internal.ParseResults_<S>): number;
        execute(arg0: Internal.StringReader_, arg1: S): number;
        execute(arg0: string, arg1: S): number;
        notify(): void;
        findAmbiguities(arg0: Internal.AmbiguityConsumer_<S>): void;
        hashCode(): number;
        equals(arg0: any): boolean;
        getPath(arg0: Internal.CommandNode_<S>): Internal.Collection<string>;
        toString(): string;
        findNode(arg0: Internal.Collection_<string>): Internal.CommandNode<S>;
        getRoot(): Internal.RootCommandNode<S>;
        register(arg0: Internal.LiteralArgumentBuilder_<S>): Internal.LiteralCommandNode<S>;
        static readonly ARGUMENT_SEPARATOR : " ";
        static readonly ARGUMENT_SEPARATOR_CHAR : " ";
        get root(): Internal.RootCommandNode<S>;
        get class(): Internal.Class<any>;
        set consumer(arg0: Internal.ResultConsumer_<S>);
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    type CommandDispatcher_<S> = CommandDispatcher<S>;
    interface RewardType$Provider {
        create(arg0: Internal.Quest_): Internal.Reward;
    }
    type RewardType$Provider_ = ((arg0: Internal.Quest) => Internal.Reward) | RewardType$Provider;
    class HumanoidModel <T> extends Internal.AgeableListModel<T> implements Internal.ArmedModel, Internal.HeadedModel {
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        hashCode(): number;
        notifyAll(): void;
        equals(arg0: any): boolean;
        handler$zed000$poseLeftArm(arg0: Internal.LivingEntity_, arg1: Internal.CallbackInfo_): void;
        toString(): string;
        handler$zed000$setupAnim(arg0: Internal.LivingEntity_, arg1: number, arg2: number, arg3: number, arg4: number, arg5: number, arg6: Internal.CallbackInfo_): void;
        handler$zed000$poseRightArm(arg0: Internal.LivingEntity_, arg1: Internal.CallbackInfo_): void;
        notify(): void;
        animationType : Internal.TwoHandedAnimation;
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    type HumanoidModel_<T> = HumanoidModel<T>;
    interface ByteIterator extends Internal.PrimitiveIterator<number, Internal.ByteConsumer> {
        next(): number;
        nextByte(): number;
        hasNext(): boolean;
        skip(arg0: number): number;
        forEachRemaining(arg0: java_.util.function_.IntConsumer_): void;
        forEachRemaining(arg0: Internal.ByteConsumer_): void;
        forEachRemaining(arg0: Internal.Consumer_<number>): void;
        remove(): void;
    }
    type ByteIterator_ = ByteIterator;
    class PlatformWrapper$ModInfo {
        getVersion(): string;
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        getName(): string;
        hashCode(): number;
        notifyAll(): void;
        equals(arg0: any): boolean;
        toString(): string;
        getId(): string;
        notify(): void;
        get name(): string;
        get id(): string;
        get version(): string;
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    type PlatformWrapper$ModInfo_ = PlatformWrapper$ModInfo;
    interface VillagerProfessionAccess {
    }
    type VillagerProfessionAccess_ = VillagerProfessionAccess;
    class Locale$LanguageRange {
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        getWeight(): number;
        getRange(): string;
        hashCode(): number;
        notifyAll(): void;
        equals(arg0: any): boolean;
        static mapEquivalents(arg0: Internal.List_<Internal.Locale$LanguageRange_>, arg1: Internal.Map_<string, Internal.List_<string>>): Internal.List<Internal.Locale$LanguageRange>;
        toString(): string;
        static parse(arg0: string): Internal.List<Internal.Locale$LanguageRange>;
        static parse(arg0: string, arg1: Internal.Map_<string, Internal.List_<string>>): Internal.List<Internal.Locale$LanguageRange>;
        notify(): void;
        static readonly MAX_WEIGHT : 1.0;
        static readonly MIN_WEIGHT : 0.0;
        get weight(): number;
        get range(): string;
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    type Locale$LanguageRange_ = Locale$LanguageRange;
    class URI implements Internal.Comparable<Internal.URI>, Internal.Serializable {
        getClass(): Internal.Class<any>;
        toASCIIString(): string;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        resolve(arg0: string): Internal.URI;
        resolve(arg0: Internal.URI_): Internal.URI;
        isOpaque(): boolean;
        notifyAll(): void;
        compareTo(arg0: Internal.URI_): number;
        notify(): void;
        getRawAuthority(): string;
        hashCode(): number;
        normalize(): Internal.URI;
        getPath(): string;
        static create(arg0: string): Internal.URI;
        relativize(arg0: Internal.URI_): Internal.URI;
        getQuery(): string;
        getHost(): string;
        toURL(): Internal.URL;
        getScheme(): string;
        getAuthority(): string;
        getRawFragment(): string;
        getRawUserInfo(): string;
        parseServerAuthority(): Internal.URI;
        getRawSchemeSpecificPart(): string;
        getRawQuery(): string;
        getPort(): number;
        equals(arg0: any): boolean;
        isAbsolute(): boolean;
        toString(): string;
        getFragment(): string;
        getRawPath(): string;
        getUserInfo(): string;
        getSchemeSpecificPart(): string;
        get rawFragment(): string;
        get userInfo(): string;
        get opaque(): boolean;
        get scheme(): string;
        get query(): string;
        get schemeSpecificPart(): string;
        get rawUserInfo(): string;
        get path(): string;
        get fragment(): string;
        get rawPath(): string;
        get rawSchemeSpecificPart(): string;
        get port(): number;
        get rawAuthority(): string;
        get absolute(): boolean;
        get authority(): string;
        get host(): string;
        get class(): Internal.Class<any>;
        get rawQuery(): string;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    type URI_ = URI;
    interface ModuleFinder {
        find(arg0: string): Internal.Optional<Internal.ModuleReference>;
        findAll(): Internal.Set<Internal.ModuleReference>;
    }
    type ModuleFinder_ = ModuleFinder;
    interface Color extends Internal.SpecialEquality {
        getRgbKJS(): number;
        createTextColorKJS(): Internal.TextColor;
        getArgbKJS(): number;
        getHexKJS(): string;
        getFireworkColorKJS(): number;
        getSerializeKJS(): string;
        specialEquals(o: any, shallow: boolean): boolean;
    }
    type Color_ = Color;
    interface Decoder$Boxed <A> {
        decoder(): Internal.Decoder<A>;
        decode<T>(arg0: Internal.Dynamic_<T>): Internal.DataResult<Internal.Pair<A, T>>;
    }
    type Decoder$Boxed_<A> = Decoder$Boxed<A>;
    interface WatchEvent$Kind <T> {
        name(): string;
        type(): Internal.Class<T>;
    }
    type WatchEvent$Kind_<T> = WatchEvent$Kind<T>;
    interface IModelData {
        setData<T>(arg0: Internal.ModelProperty_<T>, arg1: T): T;
        hasProperty(arg0: Internal.ModelProperty_<any>): boolean;
        getData<T>(arg0: Internal.ModelProperty_<T>): T;
    }
    type IModelData_ = IModelData;
    interface TileObserver {
        tileUpdate(arg0: Internal.WritableRenderedImage_, arg1: number, arg2: number, arg3: boolean): void;
    }
    type TileObserver_ = TileObserver;
    interface AccessorMultiBufferSource {
        getFallbackBuffer(): Internal.BufferBuilder;
        getFixedBuffers(): Internal.Map<Internal.RenderType, Internal.BufferBuilder>;
    }
    type AccessorMultiBufferSource_ = AccessorMultiBufferSource;
    class HashMap <K, V> extends Internal.AbstractMap<K, V> implements Internal.Map<K, V>, Internal.Cloneable, Internal.Serializable {
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        getOrDefault(arg0: any, arg1: V): V;
        notifyAll(): void;
        computeIfAbsent(arg0: K, arg1: java_.util.function_.Function_<K, V>): V;
        values(): Internal.Collection<V>;
        replace(arg0: K, arg1: V): V;
        replace(arg0: K, arg1: V, arg2: V): boolean;
        replaceAll(arg0: Internal.BiFunction_<K, V, V>): void;
        notify(): void;
        containsValue(arg0: any): boolean;
        put(arg0: K, arg1: V): V;
        remove(arg0: any, arg1: any): boolean;
        remove(arg0: any): V;
        compute(arg0: K, arg1: Internal.BiFunction_<K, V, V>): V;
        hashCode(): number;
        putAll(arg0: Internal.Map_<K, V>): void;
        merge(arg0: K, arg1: V, arg2: Internal.BiFunction_<V, V, V>): V;
        get(arg0: any): V;
        keySet(): Internal.Set<K>;
        entrySet(): Internal.Set<Internal.Map$Entry<K, V>>;
        containsKey(arg0: any): boolean;
        forEach(arg0: Internal.BiConsumer_<K, V>): void;
        isEmpty(): boolean;
        clear(): void;
        computeIfPresent(arg0: K, arg1: Internal.BiFunction_<K, V, V>): V;
        size(): number;
        equals(arg0: any): boolean;
        clone(): any;
        toString(): string;
        putIfAbsent(arg0: K, arg1: V): V;
        get class(): Internal.Class<any>;
        get empty(): boolean;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    type HashMap_<K, V> = HashMap<K, V>;
    interface ICapabilityProvider {
        getCapability<T>(arg0: Internal.Capability_<T>, arg1: Internal.Direction_): Internal.LazyOptional<T>;
        getCapability<T>(arg0: Internal.Capability_<T>): Internal.LazyOptional<T>;
    }
    type ICapabilityProvider_ = ICapabilityProvider;
    class Climate$Sampler extends Internal.Record {
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        hashCode(): number;
        notifyAll(): void;
        equals(arg0: any): boolean;
        toString(): string;
        notify(): void;
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    type Climate$Sampler_ = Climate$Sampler;
    interface CharacterIterator extends Internal.Cloneable {
        next(): string;
        current(): string;
        getIndex(): number;
        previous(): string;
        last(): string;
        setIndex(arg0: number): string;
        getEndIndex(): number;
        clone(): any;
        getBeginIndex(): number;
        first(): string;
    }
    type CharacterIterator_ = CharacterIterator;
    interface ExecutorService extends Internal.Executor {
        submit(arg0: Internal.Runnable_): Internal.Future<any>;
        submit<T_>(arg0: Internal.Runnable_, arg1: T_): Internal.Future<T_>;
        submit<T_>(arg0: java_.util.concurrent.Callable_<T_>): Internal.Future<T_>;
        isTerminated(): boolean;
        invokeAll<T_>(arg0: Internal.Collection_<java_.util.concurrent.Callable_<T_>>): Internal.List<Internal.Future<T_>>;
        invokeAll<T_>(arg0: Internal.Collection_<java_.util.concurrent.Callable_<T_>>, arg1: number, arg2: Internal.TimeUnit_): Internal.List<Internal.Future<T_>>;
        awaitTermination(arg0: number, arg1: Internal.TimeUnit_): boolean;
        shutdownNow(): Internal.List<Internal.Runnable>;
        invokeAny<T_>(arg0: Internal.Collection_<java_.util.concurrent.Callable_<T_>>, arg1: number, arg2: Internal.TimeUnit_): T_;
        invokeAny<T_>(arg0: Internal.Collection_<java_.util.concurrent.Callable_<T_>>): T_;
        execute(arg0: Internal.Runnable_): void;
        shutdown(): void;
        isShutdown(): boolean;
    }
    type ExecutorService_ = ExecutorService;
    class InputMethodHighlight {
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        getStyle(): Internal.Map<Internal.TextAttribute, any>;
        getState(): number;
        hashCode(): number;
        getVariation(): number;
        notifyAll(): void;
        equals(arg0: any): boolean;
        isSelected(): boolean;
        toString(): string;
        notify(): void;
        static readonly UNSELECTED_CONVERTED_TEXT_HIGHLIGHT : Internal.InputMethodHighlight;
        static readonly SELECTED_CONVERTED_TEXT_HIGHLIGHT : Internal.InputMethodHighlight;
        static readonly RAW_TEXT : 0;
        static readonly CONVERTED_TEXT : 1;
        static readonly UNSELECTED_RAW_TEXT_HIGHLIGHT : Internal.InputMethodHighlight;
        static readonly SELECTED_RAW_TEXT_HIGHLIGHT : Internal.InputMethodHighlight;
        get style(): Internal.Map<Internal.TextAttribute, any>;
        get state(): number;
        get class(): Internal.Class<any>;
        get variation(): number;
        get selected(): boolean;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    type InputMethodHighlight_ = InputMethodHighlight;
    interface ChronoLocalDate extends Internal.Temporal, Internal.TemporalAdjuster, Internal.Comparable<Internal.ChronoLocalDate> {
        minus(arg0: number, arg1: Internal.TemporalUnit_): Internal.ChronoLocalDate;
        minus(arg0: Internal.TemporalAmount_): Internal.ChronoLocalDate;
        toEpochDay(): number;
        isEqual(arg0: Internal.ChronoLocalDate_): boolean;
        adjustInto(arg0: Internal.Temporal_): Internal.Temporal;
        range(arg0: Internal.TemporalField_): Internal.ValueRange;
        compareTo(arg0: Internal.ChronoLocalDate_): number;
        lengthOfYear(): number;
        lengthOfMonth(): number;
        getEra(): Internal.Era;
        hashCode(): number;
        get(arg0: Internal.TemporalField_): number;
        getChronology(): Internal.Chronology;
        query<R_>(arg0: Internal.TemporalQuery_<R_>): R_;
        format(arg0: Internal.DateTimeFormatter_): string;
        isLeapYear(): boolean;
        isSupported(arg0: Internal.TemporalUnit_): boolean;
        isSupported(arg0: Internal.TemporalField_): boolean;
        isBefore(arg0: Internal.ChronoLocalDate_): boolean;
        plus(arg0: number, arg1: Internal.TemporalUnit_): Internal.ChronoLocalDate;
        plus(arg0: Internal.TemporalAmount_): Internal.ChronoLocalDate;
        getLong(arg0: Internal.TemporalField_): number;
        atTime(arg0: Internal.LocalTime_): Internal.ChronoLocalDateTime<any>;
        with(arg0: Internal.TemporalAdjuster_): Internal.ChronoLocalDate;
        with(arg0: Internal.TemporalField_, arg1: number): Internal.ChronoLocalDate;
        equals(arg0: any): boolean;
        until(arg0: Internal.ChronoLocalDate_): Internal.ChronoPeriod;
        until(arg0: Internal.Temporal_, arg1: Internal.TemporalUnit_): number;
        toString(): string;
        isAfter(arg0: Internal.ChronoLocalDate_): boolean;
    }
    type ChronoLocalDate_ = ChronoLocalDate;
    interface NonNullPredicate <T> {
        test(arg0: T): boolean;
    }
    type NonNullPredicate_<T> = ((arg0: T) => boolean) | NonNullPredicate<T>;
    class ItemFoodEatenEventJS extends Internal.PlayerEventJS {
        cancel(): void;
        getServer(): Internal.ServerJS;
        getClass(): Internal.Class<any>;
        addGameStage(stage: string): void;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        isCancelled(): boolean;
        getPlayer(): Internal.PlayerJS<any>;
        notifyAll(): void;
        getItem(): Internal.ItemStackJS;
        getEntity(): Internal.EntityJS;
        notify(): void;
        getLevel(): Internal.LevelJS;
        getMinecraftPlayer(): Internal.Player;
        post(id: string): boolean;
        post(id: string, sub: string): boolean;
        post(t: Internal.ScriptType_, id: string, sub: string): boolean;
        post(t: Internal.ScriptType_, id: string): boolean;
        hasGameStage(stage: string): boolean;
        hashCode(): number;
        equals(arg0: any): boolean;
        removeGameStage(stage: string): void;
        toString(): string;
        canCancel(): boolean;
        get server(): Internal.ServerJS;
        get item(): Internal.ItemStackJS;
        get level(): Internal.LevelJS;
        get minecraftPlayer(): Internal.Player;
        get cancelled(): boolean;
        get class(): Internal.Class<any>;
        get entity(): Internal.EntityJS;
        get player(): Internal.PlayerJS<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    type ItemFoodEatenEventJS_ = ItemFoodEatenEventJS;
    abstract class MinMaxBounds <T> {
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        hashCode(): number;
        notifyAll(): void;
        equals(arg0: any): boolean;
        toString(): string;
        notify(): void;
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    type MinMaxBounds_<T> = MinMaxBounds<T>;
    interface LongIterable extends Internal.Iterable<number> {
        longSpliterator(): Internal.LongSpliterator;
        longIterator(): Internal.LongIterator;
        iterator(): Internal.LongIterator;
        spliterator(): Internal.LongSpliterator;
        forEach(arg0: java_.util.function_.LongConsumer_): void;
        forEach(arg0: Internal.Consumer_<number>): void;
        forEach(arg0: Internal.LongConsumer_): void;
    }
    type LongIterable_ = LongIterable;
    interface ClientLevelAccess {
        byg_invokeAddEntity(arg0: number, arg1: Internal.Entity_): void;
    }
    type ClientLevelAccess_ = ClientLevelAccess;
    abstract class Locale$IsoCountryCode extends Internal.Enum<Internal.Locale$IsoCountryCode> {
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        static valueOf(arg0: string): Internal.Locale$IsoCountryCode;
        static valueOf<T_>(arg0: Internal.Class_<T_>, arg1: string): T_;
        notifyAll(): void;
        static values(): Internal.Locale$IsoCountryCode[];
        compareTo(arg0: Internal.Locale$IsoCountryCode_): number;
        describeConstable(): Internal.Optional<Internal.Enum$EnumDesc<Internal.Locale$IsoCountryCode>>;
        notify(): void;
        getDeclaringClass(): Internal.Class<Internal.Locale$IsoCountryCode>;
        hashCode(): number;
        equals(arg0: any): boolean;
        name(): string;
        toString(): string;
        ordinal(): number;
        static readonly PART3 : Internal.Locale$IsoCountryCode;
        static readonly PART1_ALPHA2 : Internal.Locale$IsoCountryCode;
        static readonly PART1_ALPHA3 : Internal.Locale$IsoCountryCode;
        get class(): Internal.Class<any>;
        get declaringClass(): Internal.Class<Internal.Locale$IsoCountryCode>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    type Locale$IsoCountryCode_ = "part3" | "part1_alpha2" | "part1_alpha3" | Locale$IsoCountryCode;
    interface ItemStackKJS extends Internal.AsKJS {
        removeTagKJS(): void;
        asKJS(): any;
    }
    type ItemStackKJS_ = ItemStackKJS;
    class ClientGenerateAssetsEventJS extends Internal.EventJS {
        cancel(): void;
        add(location: ResourceLocation_, json: Internal.JsonElement_): void;
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        isCancelled(): boolean;
        notifyAll(): void;
        addLang(key: string, value: string): void;
        notify(): void;
        addBlockState(id: ResourceLocation_, consumer: Internal.Consumer_<Internal.VariantBlockStateGenerator_>): void;
        post(t: Internal.ScriptType_, id: string, sub: string): boolean;
        post(t: Internal.ScriptType_, id: string): boolean;
        hashCode(): number;
        equals(arg0: any): boolean;
        toString(): string;
        addModel(type: string, id: ResourceLocation_, consumer: Internal.Consumer_<Internal.ModelGenerator_>): void;
        getAllAssets(): Internal.Map<ResourceLocation, Internal.JsonElement>;
        addMultipartBlockState(id: ResourceLocation_, consumer: Internal.Consumer_<Internal.MultipartBlockStateGenerator_>): void;
        canCancel(): boolean;
        readonly generator : Internal.AssetJsonGenerator;
        get allAssets(): Internal.Map<ResourceLocation, Internal.JsonElement>;
        get cancelled(): boolean;
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    type ClientGenerateAssetsEventJS_ = ClientGenerateAssetsEventJS;
    interface BiomeSpecialEffects$GrassColorModifier$ColorModifier {
        modifyGrassColor(arg0: number, arg1: number, arg2: number): number;
    }
    type BiomeSpecialEffects$GrassColorModifier$ColorModifier_ = ((arg0: number, arg1: number, arg2: number) => number) | BiomeSpecialEffects$GrassColorModifier$ColorModifier;
    abstract class SocketAddress implements Internal.Serializable {
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        hashCode(): number;
        notifyAll(): void;
        equals(arg0: any): boolean;
        toString(): string;
        notify(): void;
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    type SocketAddress_ = SocketAddress;
    interface StringBuilderAppendable {
        appendString(arg0: Internal.StringBuilder_): void;
    }
    type StringBuilderAppendable_ = StringBuilderAppendable;
    abstract class NumberConfig <T> extends Internal.ConfigFromString<T> {
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        getName(): string;
        setCanEdit(e: boolean): Internal.ConfigValue<Internal.ConfigValue<Internal.ConfigValue<T>>>;
        notifyAll(): void;
        isEqual(v1: Internal.ConfigValue_<Internal.ConfigValue_<T>>, v2: Internal.ConfigValue_<Internal.ConfigValue_<T>>): boolean;
        compareTo(o: Internal.ConfigValue_<Internal.ConfigValue_<Internal.ConfigValue_<T>>>): number;
        notify(): void;
        getCanEdit(): boolean;
        getStringFromValue(v: Internal.ConfigValue_<Internal.ConfigValue_<T>>): string;
        getTooltip(): string;
        hashCode(): number;
        getStringForGUI(v: Internal.ConfigValue_<Internal.ConfigValue_<T>>): Internal.Component;
        getPath(): string;
        copy(value: Internal.ConfigValue_<Internal.ConfigValue_<T>>): Internal.ConfigValue<Internal.ConfigValue<T>>;
        static info(key: string, value: any): Internal.Component;
        init(g: Internal.ConfigGroup_, i: string, v: Internal.ConfigValue_<Internal.ConfigValue_<T>>, c: Internal.Consumer_<Internal.ConfigValue_<Internal.ConfigValue_<T>>>, def: Internal.ConfigValue_<Internal.ConfigValue_<T>>): Internal.ConfigValue<Internal.ConfigValue<Internal.ConfigValue<T>>>;
        getColor(v: Internal.ConfigValue_<Internal.ConfigValue_<T>>): Internal.Color4I;
        addInfo(list: Internal.TooltipList_): void;
        parse(arg0: Internal.Consumer_<Internal.ConfigValue_<Internal.ConfigValue_<T>>>, arg1: string): boolean;
        getIcon(v: Internal.ConfigValue_<Internal.ConfigValue_<T>>): Internal.Icon;
        setIcon(i: Internal.Icon_): Internal.ConfigValue<Internal.ConfigValue<Internal.ConfigValue<T>>>;
        setOrder(o: number): Internal.ConfigValue<Internal.ConfigValue<Internal.ConfigValue<T>>>;
        getNameKey(): string;
        setNameKey(key: string): Internal.ConfigValue<Internal.ConfigValue<Internal.ConfigValue<T>>>;
        equals(arg0: any): boolean;
        onClicked(button: Internal.MouseButton_, callback: Internal.ConfigCallback_): void;
        toString(): string;
        setCurrentValue(v: Internal.ConfigValue_<Internal.ConfigValue_<T>>): boolean;
        fader(v: boolean): Internal.NumberConfig<Internal.ConfigValue<Internal.ConfigValue<T>>>;
        readonly min : Internal.ConfigValue<Internal.ConfigValue<T>>;
        readonly max : Internal.ConfigValue<Internal.ConfigValue<T>>;
        static readonly COLOR : Internal.Color4I;
        defaultValue : Internal.ConfigValue<Internal.ConfigValue<T>>;
        id : string;
        static readonly NULL_TEXT : Internal.TextComponent;
        setter : ((arg0: Internal.ConfigValue<Internal.ConfigValue<T>>) => void);
        value : Internal.ConfigValue<Internal.ConfigValue<T>>;
        group : Internal.ConfigGroup;
        get path(): string;
        get nameKey(): string;
        get canEdit(): boolean;
        get name(): string;
        get tooltip(): string;
        get class(): Internal.Class<any>;
        set nameKey(key: string);
        set canEdit(e: boolean);
        set icon(i: Internal.Icon_);
        set currentValue(v: Internal.ConfigValue_<Internal.ConfigValue_<T>>);
        set order(o: number);
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    type NumberConfig_<T> = NumberConfig<T>;
    interface Object2IntFunction <K> extends Internal.Function<K, number>, Internal.ToIntFunction<K> {
        getOrDefault(arg0: any, arg1: number): number;
        andThenShort(arg0: Internal.Int2ShortFunction_): Internal.Object2ShortFunction<K>;
        composeByte(arg0: Internal.Byte2ObjectFunction_<K>): Internal.Byte2IntFunction;
        andThenInt(arg0: Internal.Int2IntFunction_): Internal.Object2IntFunction<K>;
        composeReference<T_>(arg0: Internal.Reference2ObjectFunction_<T_, K>): Internal.Reference2IntFunction<T_>;
        andThen<T_>(arg0: java_.util.function_.Function_<number, T_>): java_.util.function_.Function<K, T_>;
        put(arg0: K, arg1: number): number;
        remove(arg0: any): number;
        defaultReturnValue(): number;
        defaultReturnValue(arg0: number): void;
        andThenDouble(arg0: Internal.Int2DoubleFunction_): Internal.Object2DoubleFunction<K>;
        andThenObject<T_>(arg0: Internal.Int2ObjectFunction_<T_>): Internal.Object2ObjectFunction<K, T_>;
        get(arg0: any): number;
        andThenLong(arg0: Internal.Int2LongFunction_): Internal.Object2LongFunction<K>;
        composeLong(arg0: Internal.Long2ObjectFunction_<K>): Internal.Long2IntFunction;
        andThenByte(arg0: Internal.Int2ByteFunction_): Internal.Object2ByteFunction<K>;
        andThenFloat(arg0: Internal.Int2FloatFunction_): Internal.Object2FloatFunction<K>;
        applyAsInt(arg0: K): number;
        removeInt(arg0: any): number;
        apply(arg0: K): number;
        containsKey(arg0: any): boolean;
        composeInt(arg0: Internal.Int2ObjectFunction_<K>): Internal.Int2IntFunction;
        clear(): void;
        composeFloat(arg0: Internal.Float2ObjectFunction_<K>): Internal.Float2IntFunction;
        andThenChar(arg0: Internal.Int2CharFunction_): Internal.Object2CharFunction<K>;
        getInt(arg0: any): number;
        composeObject<T_>(arg0: Internal.Object2ObjectFunction_<T_, K>): Internal.Object2IntFunction<T_>;
        size(): number;
        compose<V_>(arg0: java_.util.function_.Function_<V_, K>): java_.util.function_.Function<V_, number>;
        composeShort(arg0: Internal.Short2ObjectFunction_<K>): Internal.Short2IntFunction;
        andThenReference<T_>(arg0: Internal.Int2ReferenceFunction_<T_>): Internal.Object2ReferenceFunction<K, T_>;
        composeChar(arg0: Internal.Char2ObjectFunction_<K>): Internal.Char2IntFunction;
        composeDouble(arg0: Internal.Double2ObjectFunction_<K>): Internal.Double2IntFunction;
    }
    type Object2IntFunction_<K> = ((arg0: any) => number) | Object2IntFunction<K>;
    class Pattern implements Internal.Serializable {
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        notifyAll(): void;
        splitAsStream(arg0: Internal.CharSequence_): Internal.Stream<string>;
        pattern(): string;
        flags(): number;
        asMatchPredicate(): Internal.Predicate<string>;
        matcher(arg0: Internal.CharSequence_): Internal.Matcher;
        static matches(arg0: string, arg1: Internal.CharSequence_): boolean;
        notify(): void;
        static quote(arg0: string): string;
        split(arg0: Internal.CharSequence_): string[];
        split(arg0: Internal.CharSequence_, arg1: number): string[];
        static compile(arg0: string): Internal.Pattern;
        static compile(arg0: string, arg1: number): Internal.Pattern;
        hashCode(): number;
        equals(arg0: any): boolean;
        toString(): string;
        asPredicate(): Internal.Predicate<string>;
        static readonly DOTALL : 32;
        static readonly UNICODE_CASE : 64;
        static readonly LITERAL : 16;
        static readonly UNICODE_CHARACTER_CLASS : 256;
        static readonly CASE_INSENSITIVE : 2;
        static readonly CANON_EQ : 128;
        static readonly COMMENTS : 4;
        static readonly UNIX_LINES : 1;
        static readonly MULTILINE : 8;
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    type Pattern_ = Pattern;
    class MethodType implements Internal.Constable, Internal.TypeDescriptor$OfMethod<Internal.Class<any>, Internal.MethodType>, Internal.Serializable {
        getClass(): Internal.Class<any>;
        toMethodDescriptorString(): string;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        dropParameterTypes(arg0: number, arg1: number): Internal.MethodType;
        changeReturnType(arg0: Internal.Class_<any>): Internal.MethodType;
        notifyAll(): void;
        static fromMethodDescriptorString(arg0: string, arg1: Internal.ClassLoader_): Internal.MethodType;
        lastParameterType(): Internal.Class<any>;
        describeConstable(): Internal.Optional<Internal.MethodTypeDesc>;
        notify(): void;
        changeParameterType(arg0: number, arg1: Internal.Class_<any>): Internal.MethodType;
        unwrap(): Internal.MethodType;
        hasWrappers(): boolean;
        static methodType(arg0: Internal.Class_<any>, arg1: Internal.Class_<any>[]): Internal.MethodType;
        static methodType(arg0: Internal.Class_<any>, arg1: Internal.MethodType_): Internal.MethodType;
        static methodType(arg0: Internal.Class_<any>, arg1: Internal.Class_<any>, arg2: Internal.Class_<any>[]): Internal.MethodType;
        static methodType(arg0: Internal.Class_<any>, arg1: Internal.List_<Internal.Class_<any>>): Internal.MethodType;
        static methodType(arg0: Internal.Class_<any>, arg1: Internal.Class_<any>): Internal.MethodType;
        static methodType(arg0: Internal.Class_<any>): Internal.MethodType;
        parameterArray(): Internal.Class<any>[];
        hashCode(): number;
        appendParameterTypes(arg0: Internal.List_<Internal.Class_<any>>): Internal.MethodType;
        appendParameterTypes(arg0: Internal.Class_<any>[]): Internal.MethodType;
        parameterType(arg0: number): Internal.Class<any>;
        erase(): Internal.MethodType;
        parameterCount(): number;
        descriptorString(): string;
        insertParameterTypes(arg0: number, arg1: Internal.List_<Internal.Class_<any>>): Internal.MethodType;
        insertParameterTypes(arg0: number, arg1: Internal.Class_<any>[]): Internal.MethodType;
        generic(): Internal.MethodType;
        hasPrimitives(): boolean;
        equals(arg0: any): boolean;
        parameterList(): Internal.List<Internal.Class<any>>;
        toString(): string;
        static genericMethodType(arg0: number, arg1: boolean): Internal.MethodType;
        static genericMethodType(arg0: number): Internal.MethodType;
        wrap(): Internal.MethodType;
        returnType(): Internal.Class<any>;
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    type MethodType_ = MethodType;
    interface AccessorRenderBuffers {
        getEntityBuilders(): Internal.SortedMap<Internal.RenderType, Internal.BufferBuilder>;
    }
    type AccessorRenderBuffers_ = AccessorRenderBuffers;
    interface ItemAccess {
        setCategory(arg0: Internal.CreativeModeTab_): void;
        getCategory(): Internal.CreativeModeTab;
    }
    type ItemAccess_ = ItemAccess;
    interface CommentedConfig extends Internal.UnmodifiableCommentedConfig, Internal.Config {
        getByte(arg0: Internal.List_<string>): number;
        getByte(arg0: string): number;
        getEnum<T_>(arg0: string, arg1: Internal.Class_<T_>, arg2: Internal.EnumGetMethod_): T_;
        getEnum<T_>(arg0: Internal.List_<string>, arg1: Internal.Class_<T_>): T_;
        getEnum<T_>(arg0: Internal.List_<string>, arg1: Internal.Class_<T_>, arg2: Internal.EnumGetMethod_): T_;
        getEnum<T_>(arg0: string, arg1: Internal.Class_<T_>): T_;
        getByteOrElse(arg0: Internal.List_<string>, arg1: number): number;
        getByteOrElse(arg0: string, arg1: number): number;
        removeAll(arg0: Internal.UnmodifiableConfig_): void;
        unmodifiable(): Internal.UnmodifiableCommentedConfig;
        getComments(arg0: Internal.Map_<string, Internal.UnmodifiableCommentedConfig$CommentNode_>): void;
        getComments(): Internal.Map<string, Internal.UnmodifiableCommentedConfig$CommentNode>;
        checked(): Internal.CommentedConfig;
        getIntOrElse(arg0: string, arg1: Internal.IntSupplier_): number;
        getIntOrElse(arg0: string, arg1: number): number;
        getIntOrElse(arg0: Internal.List_<string>, arg1: number): number;
        getIntOrElse(arg0: Internal.List_<string>, arg1: Internal.IntSupplier_): number;
        createSubConfig(): Internal.CommentedConfig;
        add(arg0: Internal.List_<string>, arg1: any): boolean;
        add(arg0: string, arg1: any): boolean;
        entrySet(): Internal.Set<Internal.CommentedConfig$Entry>;
        configFormat(): Internal.ConfigFormat<any>;
        getOptionalInt(arg0: string): Internal.OptionalInt;
        getOptionalInt(arg0: Internal.List_<string>): Internal.OptionalInt;
        getCharOrElse(arg0: Internal.List_<string>, arg1: string): string;
        getCharOrElse(arg0: string, arg1: string): string;
        getInt(arg0: string): number;
        getInt(arg0: Internal.List_<string>): number;
        getChar(arg0: string): string;
        getChar(arg0: Internal.List_<string>): string;
        contains(arg0: Internal.List_<string>): boolean;
        contains(arg0: string): boolean;
        size(): number;
        getShortOrElse(arg0: string, arg1: number): number;
        getShortOrElse(arg0: Internal.List_<string>, arg1: number): number;
        containsComment(arg0: Internal.List_<string>): boolean;
        containsComment(arg0: string): boolean;
        update(arg0: Internal.List_<string>, arg1: any): void;
        update(arg0: string, arg1: any): void;
        getLongOrElse(arg0: string, arg1: Internal.LongSupplier_): number;
        getLongOrElse(arg0: Internal.List_<string>, arg1: Internal.LongSupplier_): number;
        getLongOrElse(arg0: Internal.List_<string>, arg1: number): number;
        getLongOrElse(arg0: string, arg1: number): number;
        remove<T_>(arg0: Internal.List_<string>): T_;
        remove<T_>(arg0: string): T_;
        putAll(arg0: Internal.UnmodifiableConfig_): void;
        get<T_>(arg0: string): T_;
        get<T_>(arg0: Internal.List_<string>): T_;
        valueMap(): Internal.Map<string, any>;
        getOrElse<T_>(arg0: Internal.List_<string>, arg1: T_): T_;
        getOrElse<T_>(arg0: string, arg1: Internal.Supplier_<T_>): T_;
        getOrElse<T_>(arg0: string, arg1: T_): T_;
        getOrElse<T_>(arg0: Internal.List_<string>, arg1: Internal.Supplier_<T_>): T_;
        getEnumOrElse<T_>(arg0: string, arg1: Internal.Class_<T_>, arg2: Internal.EnumGetMethod_, arg3: Internal.Supplier_<T_>): T_;
        getEnumOrElse<T_>(arg0: Internal.List_<string>, arg1: T_): T_;
        getEnumOrElse<T_>(arg0: Internal.List_<string>, arg1: T_, arg2: Internal.EnumGetMethod_): T_;
        getEnumOrElse<T_>(arg0: string, arg1: T_): T_;
        getEnumOrElse<T_>(arg0: string, arg1: T_, arg2: Internal.EnumGetMethod_): T_;
        getEnumOrElse<T_>(arg0: Internal.List_<string>, arg1: Internal.Class_<T_>, arg2: Internal.EnumGetMethod_, arg3: Internal.Supplier_<T_>): T_;
        getEnumOrElse<T_>(arg0: Internal.List_<string>, arg1: Internal.Class_<T_>, arg2: Internal.Supplier_<T_>): T_;
        getEnumOrElse<T_>(arg0: string, arg1: Internal.Class_<T_>, arg2: Internal.Supplier_<T_>): T_;
        getComment(arg0: string): string;
        getComment(arg0: Internal.List_<string>): string;
        removeComment(arg0: Internal.List_<string>): string;
        removeComment(arg0: string): string;
        putAllComments(arg0: Internal.UnmodifiableCommentedConfig_): void;
        putAllComments(arg0: Internal.Map_<string, Internal.UnmodifiableCommentedConfig$CommentNode_>): void;
        set<T_>(arg0: string, arg1: any): T_;
        set<T_>(arg0: Internal.List_<string>, arg1: any): T_;
        apply<T_>(arg0: string): T_;
        apply<T_>(arg0: Internal.List_<string>): T_;
        getShort(arg0: string): number;
        getShort(arg0: Internal.List_<string>): number;
        getOptionalComment(arg0: Internal.List_<string>): Internal.Optional<string>;
        getOptionalComment(arg0: string): Internal.Optional<string>;
        clear(): void;
        isEmpty(): boolean;
        commentMap(): Internal.Map<string, string>;
        getLong(arg0: string): number;
        getLong(arg0: Internal.List_<string>): number;
        getOptional<T_>(arg0: string): Internal.Optional<T_>;
        getOptional<T_>(arg0: Internal.List_<string>): Internal.Optional<T_>;
        addAll(arg0: Internal.UnmodifiableConfig_): void;
        clearComments(): void;
        isNull(arg0: string): boolean;
        isNull(arg0: Internal.List_<string>): boolean;
        setComment(arg0: string, arg1: string): string;
        setComment(arg0: Internal.List_<string>, arg1: string): string;
        getRaw<T_>(arg0: string): T_;
        getRaw<T_>(arg0: Internal.List_<string>): T_;
        getOptionalLong(arg0: string): Internal.OptionalLong;
        getOptionalLong(arg0: Internal.List_<string>): Internal.OptionalLong;
        getOptionalEnum<T_>(arg0: string, arg1: Internal.Class_<T_>): Internal.Optional<T_>;
        getOptionalEnum<T_>(arg0: Internal.List_<string>, arg1: Internal.Class_<T_>): Internal.Optional<T_>;
        getOptionalEnum<T_>(arg0: string, arg1: Internal.Class_<T_>, arg2: Internal.EnumGetMethod_): Internal.Optional<T_>;
        getOptionalEnum<T_>(arg0: Internal.List_<string>, arg1: Internal.Class_<T_>, arg2: Internal.EnumGetMethod_): Internal.Optional<T_>;
    }
    type CommentedConfig_ = CommentedConfig;
    interface Long2ObjectMap <V> extends Internal.Long2ObjectFunction<V>, Internal.Map<number, V> {
        long2ObjectEntrySet(): Internal.ObjectSet<Internal.Long2ObjectMap$Entry<V>>;
        getOrDefault(arg0: number, arg1: V): V;
        getOrDefault(arg0: any, arg1: V): V;
        computeIfAbsent(arg0: number, arg1: Internal.Long2ObjectFunction_<V>): V;
        computeIfAbsent(arg0: number, arg1: Internal.LongFunction_<V>): V;
        computeIfAbsent(arg0: number, arg1: java_.util.function_.Function_<number, V>): V;
        values(): Internal.ObjectCollection<V>;
        andThenShort(arg0: Internal.Object2ShortFunction_<V>): Internal.Long2ShortFunction;
        replace(arg0: number, arg1: V, arg2: V): boolean;
        replace(arg0: number, arg1: V): V;
        composeByte(arg0: Internal.Byte2LongFunction_): Internal.Byte2ObjectFunction<V>;
        computeIfAbsentPartial(arg0: number, arg1: Internal.Long2ObjectFunction_<V>): V;
        replaceAll(arg0: Internal.BiFunction_<number, V, V>): void;
        andThenInt(arg0: Internal.Object2IntFunction_<V>): Internal.Long2IntFunction;
        containsValue(arg0: any): boolean;
        andThen<V_>(arg0: java_.util.function_.Function_<V, V_>): java_.util.function_.Function<number, V_>;
        composeReference<T_>(arg0: Internal.Reference2LongFunction_<T_>): Internal.Reference2ObjectFunction<T_, V>;
        put(arg0: number, arg1: V): V;
        remove(arg0: any): V;
        remove(arg0: number, arg1: any): boolean;
        remove(arg0: number): V;
        remove(arg0: any, arg1: any): boolean;
        compute(arg0: number, arg1: Internal.BiFunction_<number, V, V>): V;
        defaultReturnValue(): V;
        defaultReturnValue(arg0: V): void;
        andThenDouble(arg0: Internal.Object2DoubleFunction_<V>): Internal.Long2DoubleFunction;
        andThenObject<T_>(arg0: Internal.Object2ObjectFunction_<V, T_>): Internal.Long2ObjectFunction<T_>;
        hashCode(): number;
        putAll(arg0: Internal.Map_<number, V>): void;
        merge(arg0: number, arg1: V, arg2: Internal.BiFunction_<V, V, V>): V;
        get(arg0: any): V;
        get(arg0: number): V;
        andThenLong(arg0: Internal.Object2LongFunction_<V>): Internal.Long2LongFunction;
        composeLong(arg0: Internal.Long2LongFunction_): Internal.Long2ObjectFunction<V>;
        keySet(): Internal.LongSet;
        andThenByte(arg0: Internal.Object2ByteFunction_<V>): Internal.Long2ByteFunction;
        andThenFloat(arg0: Internal.Object2FloatFunction_<V>): Internal.Long2FloatFunction;
        apply(arg0: number): V;
        entrySet(): Internal.ObjectSet<Internal.Map$Entry<number, V>>;
        containsKey(arg0: number): boolean;
        containsKey(arg0: any): boolean;
        forEach(arg0: Internal.BiConsumer_<number, V>): void;
        composeInt(arg0: Internal.Int2LongFunction_): Internal.Int2ObjectFunction<V>;
        isEmpty(): boolean;
        clear(): void;
        composeFloat(arg0: Internal.Float2LongFunction_): Internal.Float2ObjectFunction<V>;
        andThenChar(arg0: Internal.Object2CharFunction_<V>): Internal.Long2CharFunction;
        composeObject<T_>(arg0: Internal.Object2LongFunction_<T_>): Internal.Object2ObjectFunction<T_, V>;
        computeIfPresent(arg0: number, arg1: Internal.BiFunction_<number, V, V>): V;
        size(): number;
        compose<T_>(arg0: java_.util.function_.Function_<T_, number>): java_.util.function_.Function<T_, V>;
        equals(arg0: any): boolean;
        composeShort(arg0: Internal.Short2LongFunction_): Internal.Short2ObjectFunction<V>;
        andThenReference<T_>(arg0: Internal.Object2ReferenceFunction_<V, T_>): Internal.Long2ReferenceFunction<T_>;
        composeChar(arg0: Internal.Char2LongFunction_): Internal.Char2ObjectFunction<V>;
        composeDouble(arg0: Internal.Double2LongFunction_): Internal.Double2ObjectFunction<V>;
        putIfAbsent(arg0: number, arg1: V): V;
    }
    type Long2ObjectMap_<V> = Long2ObjectMap<V>;
    interface LevelTimeAccess extends Internal.LevelReader {
        getExistingBlockEntity(arg0: BlockPos_): Internal.BlockEntity;
        isAreaLoaded(arg0: BlockPos_, arg1: number): boolean;
    }
    type LevelTimeAccess_ = LevelTimeAccess;
    class ParticleRenderingPhase extends Internal.Enum<Internal.ParticleRenderingPhase> {
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        static valueOf(arg0: string): Internal.ParticleRenderingPhase;
        static valueOf<T_>(arg0: Internal.Class_<T_>, arg1: string): T_;
        notifyAll(): void;
        static values(): Internal.ParticleRenderingPhase[];
        compareTo(arg0: Internal.ParticleRenderingPhase_): number;
        describeConstable(): Internal.Optional<Internal.Enum$EnumDesc<Internal.ParticleRenderingPhase>>;
        notify(): void;
        getDeclaringClass(): Internal.Class<Internal.ParticleRenderingPhase>;
        hashCode(): number;
        equals(arg0: any): boolean;
        name(): string;
        toString(): string;
        ordinal(): number;
        static readonly OPAQUE : Internal.ParticleRenderingPhase;
        static readonly TRANSLUCENT : Internal.ParticleRenderingPhase;
        static readonly EVERYTHING : Internal.ParticleRenderingPhase;
        get class(): Internal.Class<any>;
        get declaringClass(): Internal.Class<Internal.ParticleRenderingPhase>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    type ParticleRenderingPhase_ = "translucent" | "opaque" | "everything" | ParticleRenderingPhase;
    interface ICapabilitySerializable <T> extends Internal.ICapabilityProvider, Internal.INBTSerializable<T> {
        serializeNBT(): T;
        getCapability<T_>(arg0: Internal.Capability_<T_>, arg1: Internal.Direction_): Internal.LazyOptional<T_>;
        getCapability<T_>(arg0: Internal.Capability_<T_>): Internal.LazyOptional<T_>;
        deserializeNBT(arg0: T): void;
    }
    type ICapabilitySerializable_<T> = ICapabilitySerializable<T>;
    interface MethodHandleDesc extends Internal.ConstantDesc {
        invocationType(): Internal.MethodTypeDesc;
        equals(arg0: any): boolean;
        resolveConstantDesc(arg0: Internal.MethodHandles$Lookup_): any;
        asType(arg0: Internal.MethodTypeDesc_): Internal.MethodHandleDesc;
    }
    type MethodHandleDesc_ = MethodHandleDesc;
    interface IForgeMobEffect {
        getCurativeItems(): Internal.List<Internal.ItemStack>;
        getSortOrder(arg0: Internal.MobEffectInstance_): number;
    }
    type IForgeMobEffect_ = IForgeMobEffect;
    abstract class Button extends dev.ftb.mods.ftblibrary.ui.Widget {
        static isMouseButtonDown(button: Internal.MouseButton_): boolean;
        closeGui(openPrevScreen: boolean): void;
        closeGui(): void;
        getClass(): Internal.Class<any>;
        setY(v: number): void;
        collidesWith(x: number, y: number, w: number, h: number): boolean;
        setX(v: number): void;
        shouldDraw(): boolean;
        acceptGhostIngredient(ingredient: any): void;
        isGhostIngredientTarget(ingredient: any): boolean;
        run(): void;
        getGui(): Internal.BaseScreen;
        mousePressed(button: Internal.MouseButton_): boolean;
        setPos(x: number, y: number): void;
        getTitle(): Internal.Component;
        static getClipboardString(): string;
        drawBackground(matrixStack: Internal.PoseStack_, theme: Internal.Theme_, x: number, y: number, w: number, h: number): void;
        static isCtrlKeyDown(): boolean;
        updateMouseOver(mouseX: number, mouseY: number): void;
        getScreen(): Internal.Window;
        getMouseY(): number;
        onClosed(): void;
        isMouseOver(): boolean;
        keyPressed(key: dev.ftb.mods.ftblibrary.ui.input.Key_): boolean;
        getMouseX(): number;
        openGui(): void;
        setTitle(s: Internal.Component_): Internal.Button;
        setPosAndSize(x: number, y: number, w: number, h: number): dev.ftb.mods.ftblibrary.ui.Widget;
        tick(): void;
        setHeight(v: number): void;
        setIcon(i: Internal.Icon_): Internal.Button;
        addMouseOverText(list: Internal.TooltipList_): void;
        playClickSound(): void;
        handleClick(click: string): boolean;
        handleClick(scheme: string, path: string): boolean;
        isEnabled(): boolean;
        onClicked(arg0: Internal.MouseButton_): void;
        charTyped(c: string, modifiers: Internal.KeyModifiers_): boolean;
        mouseDoubleClicked(button: Internal.MouseButton_): boolean;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        mouseScrolled(scroll: number): boolean;
        notifyAll(): void;
        shouldAddMouseOverText(): boolean;
        openAfter(runnable: Internal.Runnable_): Internal.Runnable;
        closeContextMenu(): void;
        notify(): void;
        mouseReleased(button: Internal.MouseButton_): void;
        setSize(w: number, h: number): void;
        hashCode(): number;
        getPartialTicks(): number;
        openGuiLater(): void;
        static isKeyDown(key: number): boolean;
        keyReleased(key: dev.ftb.mods.ftblibrary.ui.input.Key_): void;
        static setClipboardString(string: string): void;
        static isShiftKeyDown(): boolean;
        getCursor(): Internal.CursorType;
        getWidgetType(): Internal.WidgetType;
        draw(matrixStack: Internal.PoseStack_, theme: Internal.Theme_, x: number, y: number, w: number, h: number): void;
        drawIcon(matrixStack: Internal.PoseStack_, theme: Internal.Theme_, x: number, y: number, w: number, h: number): void;
        checkMouseOver(mouseX: number, mouseY: number): boolean;
        setWidth(v: number): void;
        openContextMenu(panel: Internal.Panel_): void;
        getX(): number;
        getY(): number;
        equals(arg0: any): boolean;
        toString(): string;
        getIngredientUnderMouse(): any;
        posX : number;
        parent : Internal.Panel;
        posY : number;
        width : number;
        height : number;
        get mouseX(): number;
        get cursor(): Internal.CursorType;
        get ingredientUnderMouse(): any;
        get clipboardString(): string;
        get mouseY(): number;
        get shiftKeyDown(): boolean;
        get mouseOver(): boolean;
        get screen(): Internal.Window;
        get title(): Internal.Component;
        get enabled(): boolean;
        get widgetType(): Internal.WidgetType;
        get ctrlKeyDown(): boolean;
        get x(): number;
        get y(): number;
        get gui(): Internal.BaseScreen;
        get class(): Internal.Class<any>;
        get partialTicks(): number;
        set clipboardString(string: string);
        set icon(i: Internal.Icon_);
        set x(v: number);
        set y(v: number);
        set title(s: Internal.Component_);
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    type Button_ = Button;
    abstract class AttributeValue {
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        hashCode(): number;
        notifyAll(): void;
        equals(arg0: any): boolean;
        toString(): string;
        notify(): void;
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    type AttributeValue_ = AttributeValue;
    class ItemToolTierEventJS extends Internal.StartupEventJS {
        cancel(): void;
        add(id: string, tier: Internal.Consumer_<Internal.MutableToolTier_>): void;
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        isCancelled(): boolean;
        post(id: string): boolean;
        post(id: string, sub: string): boolean;
        post(t: Internal.ScriptType_, id: string, sub: string): boolean;
        post(t: Internal.ScriptType_, id: string): boolean;
        hashCode(): number;
        notifyAll(): void;
        equals(arg0: any): boolean;
        toString(): string;
        notify(): void;
        canCancel(): boolean;
        get cancelled(): boolean;
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    type ItemToolTierEventJS_ = ItemToolTierEventJS;
    interface DoublePredicate extends Internal.Predicate<number>, java_.util.function_.DoublePredicate {
        or(arg0: Internal.Predicate_<number>): Internal.Predicate<number>;
        or(arg0: java_.util.function_.DoublePredicate_): Internal.DoublePredicate;
        or(arg0: Internal.DoublePredicate_): Internal.DoublePredicate;
        test(arg0: number): boolean;
        and(arg0: java_.util.function_.DoublePredicate_): Internal.DoublePredicate;
        and(arg0: Internal.DoublePredicate_): Internal.DoublePredicate;
        and(arg0: Internal.Predicate_<number>): Internal.Predicate<number>;
        negate(): Internal.DoublePredicate;
    }
    type DoublePredicate_ = ((arg0: number) => boolean) | DoublePredicate;
    interface Function6 <T1, T2, T3, T4, T5, T6, R> {
        apply(arg0: T1, arg1: T2, arg2: T3, arg3: T4, arg4: T5, arg5: T6): R;
        curry5(): Internal.Function5<T1, T2, T3, T4, T5, java_.util.function_.Function<T6, R>>;
        curry3(): Internal.Function3<T1, T2, T3, Internal.Function3<T4, T5, T6, R>>;
        curry4(): Internal.Function4<T1, T2, T3, T4, Internal.BiFunction<T5, T6, R>>;
        curry2(): Internal.BiFunction<T1, T2, Internal.Function4<T3, T4, T5, T6, R>>;
        curry(): java_.util.function_.Function<T1, Internal.Function5<T2, T3, T4, T5, T6, R>>;
    }
    type Function6_<T1, T2, T3, T4, T5, T6, R> = Function6<T1, T2, T3, T4, T5, T6, R>;
    interface TemporalAmount {
        subtractFrom(arg0: Internal.Temporal_): Internal.Temporal;
        get(arg0: Internal.TemporalUnit_): number;
        getUnits(): Internal.List<Internal.TemporalUnit>;
        addTo(arg0: Internal.Temporal_): Internal.Temporal;
    }
    type TemporalAmount_ = TemporalAmount;
    interface RecvByteBufAllocator {
        newHandle(): Internal.RecvByteBufAllocator$Handle;
    }
    type RecvByteBufAllocator_ = RecvByteBufAllocator;
    interface List <E> extends Internal.Collection<E> {
        replaceAll(arg0: Internal.UnaryOperator_<E>): void;
        remove(arg0: any): boolean;
        remove(arg0: number): E;
        removeAll(arg0: Internal.Collection_<any>): boolean;
        iterator(): Internal.Iterator<E>;
        stream(): Internal.Stream<E>;
        hashCode(): number;
        get(arg0: number): E;
        toArray(): any[];
        toArray<T_>(arg0: T_[]): T_[];
        toArray<T_>(arg0: Internal.IntFunction_<T_[]>): T_[];
        parallelStream(): Internal.Stream<E>;
        indexOf(arg0: any): number;
        add(arg0: number, arg1: E): void;
        add(arg0: E): boolean;
        subList(arg0: number, arg1: number): Internal.List<E>;
        set(arg0: number, arg1: E): E;
        spliterator(): Internal.Spliterator<E>;
        forEach(arg0: Internal.Consumer_<E>): void;
        containsAll(arg0: Internal.Collection_<any>): boolean;
        isEmpty(): boolean;
        clear(): void;
        sort(arg0: Internal.Comparator_<E>): void;
        removeIf(arg0: Internal.Predicate_<E>): boolean;
        lastIndexOf(arg0: any): number;
        contains(arg0: any): boolean;
        size(): number;
        addAll(arg0: number, arg1: Internal.Collection_<E>): boolean;
        addAll(arg0: Internal.Collection_<E>): boolean;
        equals(arg0: any): boolean;
        listIterator(arg0: number): Internal.ListIterator<E>;
        listIterator(): Internal.ListIterator<E>;
        retainAll(arg0: Internal.Collection_<any>): boolean;
    }
    type List_<E> = List<E>;
    class Commands {
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        hashCode(): number;
        notifyAll(): void;
        equals(arg0: any): boolean;
        toString(): string;
        notify(): void;
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    type Commands_ = Commands;
    class AmbientAdditionsSettings {
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        hashCode(): number;
        notifyAll(): void;
        equals(arg0: any): boolean;
        toString(): string;
        notify(): void;
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    type AmbientAdditionsSettings_ = AmbientAdditionsSettings;
    interface AWTEventListener extends Internal.EventListener {
        eventDispatched(arg0: Internal.AWTEvent_): void;
    }
    type AWTEventListener_ = AWTEventListener;
    class LocalDate implements Internal.Temporal, Internal.TemporalAdjuster, Internal.ChronoLocalDate, Internal.Serializable {
        getClass(): Internal.Class<any>;
        atStartOfDay(): Internal.LocalDateTime;
        atStartOfDay(arg0: Internal.ZoneId_): Internal.ZonedDateTime;
        toEpochDay(): number;
        isEqual(arg0: Internal.ChronoLocalDate_): boolean;
        compareTo(arg0: Internal.ChronoLocalDate_): number;
        getDayOfWeek(): Internal.DayOfWeek;
        lengthOfMonth(): number;
        getEra(): Internal.IsoEra;
        static from(arg0: Internal.TemporalAccessor_): Internal.LocalDate;
        static ofYearDay(arg0: number, arg1: number): Internal.LocalDate;
        getMonth(): Internal.Month;
        plusMonths(arg0: number): Internal.LocalDate;
        plusYears(arg0: number): Internal.LocalDate;
        query<R_>(arg0: Internal.TemporalQuery_<R_>): R_;
        format(arg0: Internal.DateTimeFormatter_): string;
        isSupported(arg0: Internal.TemporalUnit_): boolean;
        isSupported(arg0: Internal.TemporalField_): boolean;
        plus(arg0: Internal.TemporalAmount_): Internal.LocalDate;
        plus(arg0: number, arg1: Internal.TemporalUnit_): Internal.LocalDate;
        atTime(arg0: Internal.LocalTime_): Internal.LocalDateTime;
        atTime(arg0: number, arg1: number): Internal.LocalDateTime;
        atTime(arg0: Internal.OffsetTime_): Internal.OffsetDateTime;
        atTime(arg0: number, arg1: number, arg2: number, arg3: number): Internal.LocalDateTime;
        atTime(arg0: number, arg1: number, arg2: number): Internal.LocalDateTime;
        getYear(): number;
        toEpochSecond(arg0: Internal.LocalTime_, arg1: Internal.ZoneOffset_): number;
        withDayOfMonth(arg0: number): Internal.LocalDate;
        withMonth(arg0: number): Internal.LocalDate;
        isAfter(arg0: Internal.ChronoLocalDate_): boolean;
        static ofInstant(arg0: Internal.Instant_, arg1: Internal.ZoneId_): Internal.LocalDate;
        minus(arg0: number, arg1: Internal.TemporalUnit_): Internal.LocalDate;
        minus(arg0: Internal.TemporalAmount_): Internal.LocalDate;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        datesUntil(arg0: Internal.LocalDate_): Internal.Stream<Internal.LocalDate>;
        datesUntil(arg0: Internal.LocalDate_, arg1: Internal.Period_): Internal.Stream<Internal.LocalDate>;
        notifyAll(): void;
        adjustInto(arg0: Internal.Temporal_): Internal.Temporal;
        range(arg0: Internal.TemporalField_): Internal.ValueRange;
        withYear(arg0: number): Internal.LocalDate;
        notify(): void;
        lengthOfYear(): number;
        plusDays(arg0: number): Internal.LocalDate;
        hashCode(): number;
        static now(arg0: Internal.ZoneId_): Internal.LocalDate;
        static now(arg0: Internal.Clock_): Internal.LocalDate;
        static now(): Internal.LocalDate;
        static of(arg0: number, arg1: Internal.Month_, arg2: number): Internal.LocalDate;
        static of(arg0: number, arg1: number, arg2: number): Internal.LocalDate;
        get(arg0: Internal.TemporalField_): number;
        getDayOfYear(): number;
        plusWeeks(arg0: number): Internal.LocalDate;
        getChronology(): Internal.IsoChronology;
        static ofEpochDay(arg0: number): Internal.LocalDate;
        getMonthValue(): number;
        minusYears(arg0: number): Internal.LocalDate;
        minusWeeks(arg0: number): Internal.LocalDate;
        withDayOfYear(arg0: number): Internal.LocalDate;
        isLeapYear(): boolean;
        static parse(arg0: Internal.CharSequence_, arg1: Internal.DateTimeFormatter_): Internal.LocalDate;
        static parse(arg0: Internal.CharSequence_): Internal.LocalDate;
        isBefore(arg0: Internal.ChronoLocalDate_): boolean;
        minusDays(arg0: number): Internal.LocalDate;
        getLong(arg0: Internal.TemporalField_): number;
        minusMonths(arg0: number): Internal.LocalDate;
        with(arg0: Internal.TemporalField_, arg1: number): Internal.LocalDate;
        with(arg0: Internal.TemporalAdjuster_): Internal.LocalDate;
        equals(arg0: any): boolean;
        until(arg0: Internal.ChronoLocalDate_): Internal.Period;
        until(arg0: Internal.Temporal_, arg1: Internal.TemporalUnit_): number;
        toString(): string;
        getDayOfMonth(): number;
        static readonly MIN : Internal.LocalDate;
        static readonly MAX : Internal.LocalDate;
        static readonly EPOCH : Internal.LocalDate;
        get dayOfWeek(): Internal.DayOfWeek;
        get month(): Internal.Month;
        get era(): Internal.IsoEra;
        get year(): number;
        get dayOfYear(): number;
        get dayOfMonth(): number;
        get monthValue(): number;
        get chronology(): Internal.IsoChronology;
        get leapYear(): boolean;
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    type LocalDate_ = LocalDate;
    class BlockPathTypes extends Internal.Enum<Internal.BlockPathTypes> {
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        static valueOf(arg0: string): Internal.BlockPathTypes;
        static valueOf<T_>(arg0: Internal.Class_<T_>, arg1: string): T_;
        notifyAll(): void;
        static values(): Internal.BlockPathTypes[];
        compareTo(arg0: Internal.BlockPathTypes_): number;
        describeConstable(): Internal.Optional<Internal.Enum$EnumDesc<Internal.BlockPathTypes>>;
        notify(): void;
        getDeclaringClass(): Internal.Class<Internal.BlockPathTypes>;
        hashCode(): number;
        equals(arg0: any): boolean;
        name(): string;
        toString(): string;
        ordinal(): number;
        getDanger(): Internal.BlockPathTypes;
        static readonly DAMAGE_CACTUS : Internal.BlockPathTypes;
        static readonly LAVA : Internal.BlockPathTypes;
        static readonly DANGER_POWDER_SNOW : Internal.BlockPathTypes;
        static readonly LEAVES : Internal.BlockPathTypes;
        static readonly BLOCKED : Internal.BlockPathTypes;
        static readonly WALKABLE : Internal.BlockPathTypes;
        static readonly DANGER_CACTUS : Internal.BlockPathTypes;
        static readonly TRAPDOOR : Internal.BlockPathTypes;
        static readonly BREACH : Internal.BlockPathTypes;
        static readonly POWDER_SNOW : Internal.BlockPathTypes;
        static readonly DOOR_WOOD_CLOSED : Internal.BlockPathTypes;
        static readonly DANGER_FIRE : Internal.BlockPathTypes;
        static readonly DAMAGE_FIRE : Internal.BlockPathTypes;
        static readonly WATER : Internal.BlockPathTypes;
        static readonly WATER_BORDER : Internal.BlockPathTypes;
        static readonly WALKABLE_DOOR : Internal.BlockPathTypes;
        static readonly DOOR_IRON_CLOSED : Internal.BlockPathTypes;
        static readonly FENCE : Internal.BlockPathTypes;
        static readonly OPEN : Internal.BlockPathTypes;
        static readonly RAIL : Internal.BlockPathTypes;
        static readonly DAMAGE_OTHER : Internal.BlockPathTypes;
        static readonly DOOR_OPEN : Internal.BlockPathTypes;
        static readonly UNPASSABLE_RAIL : Internal.BlockPathTypes;
        static readonly COCOA : Internal.BlockPathTypes;
        static readonly DANGER_OTHER : Internal.BlockPathTypes;
        static readonly STICKY_HONEY : Internal.BlockPathTypes;
        get danger(): Internal.BlockPathTypes;
        get class(): Internal.Class<any>;
        get declaringClass(): Internal.Class<Internal.BlockPathTypes>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    type BlockPathTypes_ = "damage_fire" | "damage_cactus" | "water_border" | "unpassable_rail" | "lava" | "door_open" | "blocked" | "leaves" | "danger_other" | "sticky_honey" | "damage_other" | "walkable_door" | "danger_fire" | "breach" | "danger_powder_snow" | "walkable" | "rail" | "water" | "cocoa" | "powder_snow" | "door_iron_closed" | "door_wood_closed" | "danger_cactus" | "trapdoor" | "fence" | "open" | BlockPathTypes;
    interface Config extends Internal.UnmodifiableConfig {
        getByte(arg0: Internal.List_<string>): number;
        getByte(arg0: string): number;
        getEnum<T_>(arg0: string, arg1: Internal.Class_<T_>, arg2: Internal.EnumGetMethod_): T_;
        getEnum<T_>(arg0: Internal.List_<string>, arg1: Internal.Class_<T_>): T_;
        getEnum<T_>(arg0: Internal.List_<string>, arg1: Internal.Class_<T_>, arg2: Internal.EnumGetMethod_): T_;
        getEnum<T_>(arg0: string, arg1: Internal.Class_<T_>): T_;
        getByteOrElse(arg0: Internal.List_<string>, arg1: number): number;
        getByteOrElse(arg0: string, arg1: number): number;
        removeAll(arg0: Internal.UnmodifiableConfig_): void;
        unmodifiable(): Internal.UnmodifiableConfig;
        checked(): Internal.Config;
        getIntOrElse(arg0: string, arg1: Internal.IntSupplier_): number;
        getIntOrElse(arg0: string, arg1: number): number;
        getIntOrElse(arg0: Internal.List_<string>, arg1: number): number;
        getIntOrElse(arg0: Internal.List_<string>, arg1: Internal.IntSupplier_): number;
        createSubConfig(): Internal.Config;
        add(arg0: Internal.List_<string>, arg1: any): boolean;
        add(arg0: string, arg1: any): boolean;
        entrySet(): Internal.Set<Internal.Config$Entry>;
        configFormat(): Internal.ConfigFormat<any>;
        getOptionalInt(arg0: string): Internal.OptionalInt;
        getOptionalInt(arg0: Internal.List_<string>): Internal.OptionalInt;
        getCharOrElse(arg0: Internal.List_<string>, arg1: string): string;
        getCharOrElse(arg0: string, arg1: string): string;
        getInt(arg0: string): number;
        getInt(arg0: Internal.List_<string>): number;
        getChar(arg0: string): string;
        getChar(arg0: Internal.List_<string>): string;
        contains(arg0: Internal.List_<string>): boolean;
        contains(arg0: string): boolean;
        size(): number;
        getShortOrElse(arg0: string, arg1: number): number;
        getShortOrElse(arg0: Internal.List_<string>, arg1: number): number;
        update(arg0: Internal.List_<string>, arg1: any): void;
        update(arg0: string, arg1: any): void;
        getLongOrElse(arg0: string, arg1: Internal.LongSupplier_): number;
        getLongOrElse(arg0: Internal.List_<string>, arg1: Internal.LongSupplier_): number;
        getLongOrElse(arg0: Internal.List_<string>, arg1: number): number;
        getLongOrElse(arg0: string, arg1: number): number;
        remove<T_>(arg0: Internal.List_<string>): T_;
        remove<T_>(arg0: string): T_;
        get<T_>(arg0: string): T_;
        get<T_>(arg0: Internal.List_<string>): T_;
        putAll(arg0: Internal.UnmodifiableConfig_): void;
        valueMap(): Internal.Map<string, any>;
        getOrElse<T_>(arg0: Internal.List_<string>, arg1: T_): T_;
        getOrElse<T_>(arg0: string, arg1: Internal.Supplier_<T_>): T_;
        getOrElse<T_>(arg0: string, arg1: T_): T_;
        getOrElse<T_>(arg0: Internal.List_<string>, arg1: Internal.Supplier_<T_>): T_;
        getEnumOrElse<T_>(arg0: string, arg1: Internal.Class_<T_>, arg2: Internal.EnumGetMethod_, arg3: Internal.Supplier_<T_>): T_;
        getEnumOrElse<T_>(arg0: Internal.List_<string>, arg1: T_): T_;
        getEnumOrElse<T_>(arg0: Internal.List_<string>, arg1: T_, arg2: Internal.EnumGetMethod_): T_;
        getEnumOrElse<T_>(arg0: string, arg1: T_): T_;
        getEnumOrElse<T_>(arg0: string, arg1: T_, arg2: Internal.EnumGetMethod_): T_;
        getEnumOrElse<T_>(arg0: Internal.List_<string>, arg1: Internal.Class_<T_>, arg2: Internal.EnumGetMethod_, arg3: Internal.Supplier_<T_>): T_;
        getEnumOrElse<T_>(arg0: Internal.List_<string>, arg1: Internal.Class_<T_>, arg2: Internal.Supplier_<T_>): T_;
        getEnumOrElse<T_>(arg0: string, arg1: Internal.Class_<T_>, arg2: Internal.Supplier_<T_>): T_;
        set<T_>(arg0: string, arg1: any): T_;
        set<T_>(arg0: Internal.List_<string>, arg1: any): T_;
        apply<T_>(arg0: string): T_;
        apply<T_>(arg0: Internal.List_<string>): T_;
        getShort(arg0: string): number;
        getShort(arg0: Internal.List_<string>): number;
        isEmpty(): boolean;
        clear(): void;
        getLong(arg0: string): number;
        getLong(arg0: Internal.List_<string>): number;
        getOptional<T_>(arg0: string): Internal.Optional<T_>;
        getOptional<T_>(arg0: Internal.List_<string>): Internal.Optional<T_>;
        addAll(arg0: Internal.UnmodifiableConfig_): void;
        isNull(arg0: string): boolean;
        isNull(arg0: Internal.List_<string>): boolean;
        getRaw<T_>(arg0: string): T_;
        getRaw<T_>(arg0: Internal.List_<string>): T_;
        getOptionalLong(arg0: string): Internal.OptionalLong;
        getOptionalLong(arg0: Internal.List_<string>): Internal.OptionalLong;
        getOptionalEnum<T_>(arg0: string, arg1: Internal.Class_<T_>): Internal.Optional<T_>;
        getOptionalEnum<T_>(arg0: Internal.List_<string>, arg1: Internal.Class_<T_>): Internal.Optional<T_>;
        getOptionalEnum<T_>(arg0: string, arg1: Internal.Class_<T_>, arg2: Internal.EnumGetMethod_): Internal.Optional<T_>;
        getOptionalEnum<T_>(arg0: Internal.List_<string>, arg1: Internal.Class_<T_>, arg2: Internal.EnumGetMethod_): Internal.Optional<T_>;
    }
    type Config_ = Config;
    interface AccessibleSelection {
        selectAllAccessibleSelection(): void;
        getAccessibleSelectionCount(): number;
        clearAccessibleSelection(): void;
        removeAccessibleSelection(arg0: number): void;
        isAccessibleChildSelected(arg0: number): boolean;
        getAccessibleSelection(arg0: number): Internal.Accessible;
        addAccessibleSelection(arg0: number): void;
    }
    type AccessibleSelection_ = AccessibleSelection;
    class MutableColor4I extends Internal.Color4I {
        redf(): number;
        getClass(): Internal.Class<any>;
        rgba(): number;
        static rgba(col: number): Internal.Color4I;
        static rgba(r: number, g: number, b: number, a: number): Internal.Color4I;
        addBrightness(b: number): Internal.Color4I;
        addBrightness(percent: number): Internal.Color4I;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        withAlpha(a: number): Internal.Color4I;
        static getChatFormattingColor(id: number): Internal.Color4I;
        static getChatFormattingColor(formatting: Internal.ChatFormatting_): Internal.Color4I;
        lerp(col: Internal.Color4I_, m: number): Internal.Color4I;
        notifyAll(): void;
        static rgb(r: number, g: number, b: number): Internal.Color4I;
        rgb(): number;
        static rgb(col: number): Internal.Color4I;
        static rgb(color: Vec3_): Internal.Color4I;
        withTint(col: Internal.Color4I_): Internal.Color4I;
        redi(): number;
        notify(): void;
        createPixelBuffer(): Internal.PixelBuffer;
        hashCode(): number;
        bluei(): number;
        mutable(): Internal.MutableColor4I;
        bluef(): number;
        copy(): Internal.MutableColor4I;
        hasPixelBuffer(): boolean;
        combineWith(icon: Internal.Icon_): Internal.Icon;
        combineWith(icons: Internal.Icon_[]): Internal.Icon;
        getJson(): Internal.JsonElement;
        drawStatic(matrixStack: Internal.PoseStack_, x: number, y: number, w: number, h: number): void;
        set(r: number, g: number, b: number, a: number): Internal.Color4I;
        set(col: Internal.Color4I_, a: number): Internal.Color4I;
        set(col: Internal.Color4I_): Internal.Color4I;
        set(col: number, a: number): Internal.Color4I;
        set(col: number): Internal.Color4I;
        withBorder(color: Internal.Color4I_, roundEdges: boolean): Internal.Icon;
        alphaf(): number;
        alphai(): number;
        withColor(color: Internal.Color4I_): Internal.Icon;
        isEmpty(): boolean;
        withUV(x: number, y: number, w: number, h: number, tw: number, th: number): Internal.Icon;
        withUV(u0: number, v0: number, u1: number, v1: number): Internal.Icon;
        setAlpha(a: number): Internal.Color4I;
        draw(matrixStack: Internal.PoseStack_, x: number, y: number, w: number, h: number): void;
        draw3D(matrixStack: Internal.PoseStack_): void;
        whiteIfEmpty(): Internal.Color4I;
        static getIcon(json: Internal.JsonElement_): Internal.Icon;
        static getIcon(id: ResourceLocation_): Internal.Icon;
        static getIcon(id: string): Internal.Icon;
        toStyle(): Internal.Style;
        isMutable(): boolean;
        getIngredient(): any;
        static hsb(h: number, s: number, b: number): Internal.Color4I;
        equals(o: any): boolean;
        withPadding(padding: number): Internal.Icon;
        withAlphaf(alpha: number): Internal.Color4I;
        static fromJson(element: Internal.JsonElement_): Internal.Color4I;
        greenf(): number;
        static get256(id: number): Internal.Color4I;
        toString(): string;
        setFromHSB(h: number, s: number, b: number): Internal.Color4I;
        static fromString(s: string): Internal.Color4I;
        greeni(): number;
        static readonly RED : Internal.Color4I;
        static readonly GRAY : Internal.Color4I;
        static readonly WHITE : Internal.Color4I;
        static readonly LIGHT_RED : Internal.Color4I;
        static readonly TEMP : Internal.Color4I;
        static readonly BLUE : Internal.Color4I;
        static readonly LIGHT_BLUE : Internal.Color4I;
        static readonly LIGHT_GREEN : Internal.Color4I;
        static readonly BLACK : Internal.Color4I;
        static readonly DARK_GRAY : Internal.Color4I;
        static readonly GREEN : Internal.Color4I;
        static readonly EMPTY : Internal.Color4I;
        get ingredient(): any;
        get json(): Internal.JsonElement;
        get class(): Internal.Class<any>;
        get empty(): boolean;
        set alpha(a: number);
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    type MutableColor4I_ = MutableColor4I;
    interface ToIntFunction <T> {
        applyAsInt(arg0: T): number;
    }
    type ToIntFunction_<T> = ((arg0: T) => number) | ToIntFunction<T>;
    interface Scriptable extends Internal.IdEnumerationIterator {
        enumerationIteratorNext(cx: Internal.Context_, currentId: Internal.Consumer_<any>): boolean;
        hasInstance(arg0: Internal.Scriptable_): boolean;
        setParentScope(arg0: Internal.Scriptable_): void;
        getIds(): any[];
        getAllIds(): any[];
        delete(arg0: string): void;
        delete(arg0: number): void;
        put(arg0: number, arg1: Internal.Scriptable_, arg2: any): void;
        put(arg0: string, arg1: Internal.Scriptable_, arg2: any): void;
        getDefaultValue(arg0: Internal.Class_<any>): any;
        setPrototype(arg0: Internal.Scriptable_): void;
        getPrototype(): Internal.Scriptable;
        get(arg0: number, arg1: Internal.Scriptable_): any;
        get(arg0: string, arg1: Internal.Scriptable_): any;
        enumerationIteratorHasNext(cx: Internal.Context_, currentId: Internal.Consumer_<any>): boolean;
        has(arg0: number, arg1: Internal.Scriptable_): boolean;
        has(arg0: string, arg1: Internal.Scriptable_): boolean;
        getClassName(): string;
        getParentScope(): Internal.Scriptable;
    }
    type Scriptable_ = Scriptable;
    class ItemInventory implements net.minecraft.world.Container {
        getClass(): Internal.Class<any>;
        getItems(): Internal.List<Internal.ItemStack>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        hashCode(): number;
        notifyAll(): void;
        equals(arg0: any): boolean;
        save(): void;
        toString(): string;
        notify(): void;
        readonly filter : Internal.ItemStack;
        readonly filterItem : Internal.InventoryFilterItem;
        get class(): Internal.Class<any>;
        get items(): Internal.List<Internal.ItemStack>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    type ItemInventory_ = ItemInventory;
    interface Spliterator$OfInt extends Internal.Spliterator$OfPrimitive<number, java_.util.function_.IntConsumer, Internal.Spliterator$OfInt> {
        trySplit(): Internal.Spliterator$OfInt;
        characteristics(): number;
        tryAdvance(arg0: Internal.Consumer_<number>): boolean;
        tryAdvance(arg0: java_.util.function_.IntConsumer_): boolean;
        getComparator(): Internal.Comparator<number>;
        getExactSizeIfKnown(): number;
        estimateSize(): number;
        hasCharacteristics(arg0: number): boolean;
        forEachRemaining(arg0: java_.util.function_.IntConsumer_): void;
        forEachRemaining(arg0: Internal.Consumer_<number>): void;
    }
    type Spliterator$OfInt_ = Spliterator$OfInt;
    abstract class AbstractCollection <E> implements Internal.Collection<E> {
        add(arg0: E): boolean;
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        spliterator(): Internal.Spliterator<E>;
        forEach(arg0: Internal.Consumer_<E>): void;
        notifyAll(): void;
        containsAll(arg0: Internal.Collection_<any>): boolean;
        isEmpty(): boolean;
        clear(): void;
        notify(): void;
        remove(arg0: any): boolean;
        removeIf(arg0: Internal.Predicate_<E>): boolean;
        removeAll(arg0: Internal.Collection_<any>): boolean;
        contains(arg0: any): boolean;
        iterator(): Internal.Iterator<E>;
        size(): number;
        stream(): Internal.Stream<E>;
        addAll(arg0: Internal.Collection_<E>): boolean;
        hashCode(): number;
        equals(arg0: any): boolean;
        toArray(): any[];
        toArray<T_>(arg0: T_[]): T_[];
        toArray<T_>(arg0: Internal.IntFunction_<T_[]>): T_[];
        parallelStream(): Internal.Stream<E>;
        toString(): string;
        retainAll(arg0: Internal.Collection_<any>): boolean;
        get class(): Internal.Class<any>;
        get empty(): boolean;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    type AbstractCollection_<E> = AbstractCollection<E>;
    interface LevelReader extends Internal.BlockAndTintGetter, Internal.CollisionGetter, Internal.BiomeManager$NoiseBiomeSource {
        getExistingBlockEntity(arg0: BlockPos_): Internal.BlockEntity;
        isAreaLoaded(arg0: BlockPos_, arg1: number): boolean;
    }
    type LevelReader_ = LevelReader;
    class CompletableFuture <T> implements Internal.Future<T>, Internal.CompletionStage<T> {
        cancel(arg0: boolean): boolean;
        getClass(): Internal.Class<any>;
        exceptionallyAsync(arg0: java_.util.function_.Function_<Internal.Throwable_, T>): Internal.CompletableFuture<T>;
        exceptionallyAsync(arg0: java_.util.function_.Function_<Internal.Throwable_, T>, arg1: Internal.Executor_): Internal.CompletableFuture<T>;
        obtrudeValue(arg0: T): void;
        static failedStage<U_>(arg0: Internal.Throwable_): Internal.CompletionStage<U_>;
        runAfterBothAsync(arg0: Internal.CompletionStage_<any>, arg1: Internal.Runnable_, arg2: Internal.Executor_): Internal.CompletableFuture<void>;
        runAfterBothAsync(arg0: Internal.CompletionStage_<any>, arg1: Internal.Runnable_): Internal.CompletableFuture<void>;
        obtrudeException(arg0: Internal.Throwable_): void;
        thenAcceptBoth<U_>(arg0: Internal.CompletionStage_<U_>, arg1: Internal.BiConsumer_<T, U_>): Internal.CompletableFuture<void>;
        exceptionallyCompose(arg0: java_.util.function_.Function_<Internal.Throwable_, Internal.CompletionStage_<T>>): Internal.CompletableFuture<T>;
        join(): T;
        applyToEither<U_>(arg0: Internal.CompletionStage_<T>, arg1: java_.util.function_.Function_<T, U_>): Internal.CompletableFuture<U_>;
        completeAsync(arg0: Internal.Supplier_<T>, arg1: Internal.Executor_): Internal.CompletableFuture<T>;
        completeAsync(arg0: Internal.Supplier_<T>): Internal.CompletableFuture<T>;
        isCompletedExceptionally(): boolean;
        thenApply<U_>(arg0: java_.util.function_.Function_<T, U_>): Internal.CompletableFuture<U_>;
        thenRun(arg0: Internal.Runnable_): Internal.CompletableFuture<void>;
        orTimeout(arg0: number, arg1: Internal.TimeUnit_): Internal.CompletableFuture<T>;
        getNow(arg0: T): T;
        exceptionally(arg0: java_.util.function_.Function_<Internal.Throwable_, T>): Internal.CompletableFuture<T>;
        handle<U_>(arg0: Internal.BiFunction_<T, Internal.Throwable_, U_>): Internal.CompletableFuture<U_>;
        thenCompose<U_>(arg0: java_.util.function_.Function_<T, Internal.CompletionStage_<U_>>): Internal.CompletableFuture<U_>;
        thenCombineAsync<U_, V_>(arg0: Internal.CompletionStage_<U_>, arg1: Internal.BiFunction_<T, U_, V_>): Internal.CompletableFuture<V_>;
        thenCombineAsync<U_, V_>(arg0: Internal.CompletionStage_<U_>, arg1: Internal.BiFunction_<T, U_, V_>, arg2: Internal.Executor_): Internal.CompletableFuture<V_>;
        static failedFuture<U_>(arg0: Internal.Throwable_): Internal.CompletableFuture<U_>;
        static completedFuture<U_>(arg0: U_): Internal.CompletableFuture<U_>;
        getNumberOfDependents(): number;
        whenCompleteAsync(arg0: Internal.BiConsumer_<T, Internal.Throwable_>): Internal.CompletableFuture<T>;
        whenCompleteAsync(arg0: Internal.BiConsumer_<T, Internal.Throwable_>, arg1: Internal.Executor_): Internal.CompletableFuture<T>;
        thenApplyAsync<U_>(arg0: java_.util.function_.Function_<T, U_>): Internal.CompletableFuture<U_>;
        thenApplyAsync<U_>(arg0: java_.util.function_.Function_<T, U_>, arg1: Internal.Executor_): Internal.CompletableFuture<U_>;
        thenAcceptAsync(arg0: Internal.Consumer_<T>): Internal.CompletableFuture<void>;
        thenAcceptAsync(arg0: Internal.Consumer_<T>, arg1: Internal.Executor_): Internal.CompletableFuture<void>;
        toCompletableFuture(): Internal.CompletableFuture<T>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        notifyAll(): void;
        notify(): void;
        thenRunAsync(arg0: Internal.Runnable_, arg1: Internal.Executor_): Internal.CompletableFuture<void>;
        thenRunAsync(arg0: Internal.Runnable_): Internal.CompletableFuture<void>;
        static runAsync(arg0: Internal.Runnable_): Internal.CompletableFuture<void>;
        static runAsync(arg0: Internal.Runnable_, arg1: Internal.Executor_): Internal.CompletableFuture<void>;
        static allOf(arg0: Internal.CompletableFuture_<any>[]): Internal.CompletableFuture<void>;
        applyToEitherAsync<U_>(arg0: Internal.CompletionStage_<T>, arg1: java_.util.function_.Function_<T, U_>, arg2: Internal.Executor_): Internal.CompletableFuture<U_>;
        applyToEitherAsync<U_>(arg0: Internal.CompletionStage_<T>, arg1: java_.util.function_.Function_<T, U_>): Internal.CompletableFuture<U_>;
        acceptEitherAsync(arg0: Internal.CompletionStage_<T>, arg1: Internal.Consumer_<T>): Internal.CompletableFuture<void>;
        acceptEitherAsync(arg0: Internal.CompletionStage_<T>, arg1: Internal.Consumer_<T>, arg2: Internal.Executor_): Internal.CompletableFuture<void>;
        runAfterEitherAsync(arg0: Internal.CompletionStage_<any>, arg1: Internal.Runnable_): Internal.CompletableFuture<void>;
        runAfterEitherAsync(arg0: Internal.CompletionStage_<any>, arg1: Internal.Runnable_, arg2: Internal.Executor_): Internal.CompletableFuture<void>;
        newIncompleteFuture<U_>(): Internal.CompletableFuture<U_>;
        hashCode(): number;
        acceptEither(arg0: Internal.CompletionStage_<T>, arg1: Internal.Consumer_<T>): Internal.CompletableFuture<void>;
        get(): T;
        get(arg0: number, arg1: Internal.TimeUnit_): T;
        copy(): Internal.CompletableFuture<T>;
        runAfterEither(arg0: Internal.CompletionStage_<any>, arg1: Internal.Runnable_): Internal.CompletableFuture<void>;
        thenComposeAsync<U_>(arg0: java_.util.function_.Function_<T, Internal.CompletionStage_<U_>>, arg1: Internal.Executor_): Internal.CompletableFuture<U_>;
        thenComposeAsync<U_>(arg0: java_.util.function_.Function_<T, Internal.CompletionStage_<U_>>): Internal.CompletableFuture<U_>;
        thenAccept(arg0: Internal.Consumer_<T>): Internal.CompletableFuture<void>;
        isCancelled(): boolean;
        runAfterBoth(arg0: Internal.CompletionStage_<any>, arg1: Internal.Runnable_): Internal.CompletableFuture<void>;
        static anyOf(arg0: Internal.CompletableFuture_<any>[]): Internal.CompletableFuture<any>;
        defaultExecutor(): Internal.Executor;
        handleAsync<U_>(arg0: Internal.BiFunction_<T, Internal.Throwable_, U_>, arg1: Internal.Executor_): Internal.CompletableFuture<U_>;
        handleAsync<U_>(arg0: Internal.BiFunction_<T, Internal.Throwable_, U_>): Internal.CompletableFuture<U_>;
        completeOnTimeout(arg0: T, arg1: number, arg2: Internal.TimeUnit_): Internal.CompletableFuture<T>;
        static supplyAsync<U_>(arg0: Internal.Supplier_<U_>, arg1: Internal.Executor_): Internal.CompletableFuture<U_>;
        static supplyAsync<U_>(arg0: Internal.Supplier_<U_>): Internal.CompletableFuture<U_>;
        completeExceptionally(arg0: Internal.Throwable_): boolean;
        isDone(): boolean;
        whenComplete(arg0: Internal.BiConsumer_<T, Internal.Throwable_>): Internal.CompletableFuture<T>;
        thenAcceptBothAsync<U_>(arg0: Internal.CompletionStage_<U_>, arg1: Internal.BiConsumer_<T, U_>, arg2: Internal.Executor_): Internal.CompletableFuture<void>;
        thenAcceptBothAsync<U_>(arg0: Internal.CompletionStage_<U_>, arg1: Internal.BiConsumer_<T, U_>): Internal.CompletableFuture<void>;
        static delayedExecutor(arg0: number, arg1: Internal.TimeUnit_): Internal.Executor;
        static delayedExecutor(arg0: number, arg1: Internal.TimeUnit_, arg2: Internal.Executor_): Internal.Executor;
        exceptionallyComposeAsync(arg0: java_.util.function_.Function_<Internal.Throwable_, Internal.CompletionStage_<T>>): Internal.CompletableFuture<T>;
        exceptionallyComposeAsync(arg0: java_.util.function_.Function_<Internal.Throwable_, Internal.CompletionStage_<T>>, arg1: Internal.Executor_): Internal.CompletableFuture<T>;
        thenCombine<U_, V_>(arg0: Internal.CompletionStage_<U_>, arg1: Internal.BiFunction_<T, U_, V_>): Internal.CompletableFuture<V_>;
        equals(arg0: any): boolean;
        toString(): string;
        minimalCompletionStage(): Internal.CompletionStage<T>;
        complete(arg0: T): boolean;
        static completedStage<U_>(arg0: U_): Internal.CompletionStage<U_>;
        get numberOfDependents(): number;
        get cancelled(): boolean;
        get completedExceptionally(): boolean;
        get class(): Internal.Class<any>;
        get done(): boolean;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    type CompletableFuture_<T> = CompletableFuture<T>;
    interface Encoder <A> {
        encode<T>(arg0: A, arg1: Internal.DynamicOps_<T>, arg2: T): Internal.DataResult<T>;
        flatComap<B>(arg0: java_.util.function_.Function_<B, Internal.DataResult_<A>>): Internal.Encoder<B>;
        comap<B>(arg0: java_.util.function_.Function_<B, A>): Internal.Encoder<B>;
        fieldOf(arg0: string): Internal.MapEncoder<A>;
        withLifecycle(arg0: Internal.Lifecycle_): Internal.Encoder<A>;
        encodeStart<T>(arg0: Internal.DynamicOps_<T>, arg1: A): Internal.DataResult<T>;
    }
    type Encoder_<A> = Encoder<A>;
    class BufferCapabilities implements Internal.Cloneable {
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        isFullScreenRequired(): boolean;
        notifyAll(): void;
        getFrontBufferCapabilities(): Internal.ImageCapabilities;
        notify(): void;
        isPageFlipping(): boolean;
        getFlipContents(): Internal.BufferCapabilities$FlipContents;
        hashCode(): number;
        getBackBufferCapabilities(): Internal.ImageCapabilities;
        equals(arg0: any): boolean;
        clone(): any;
        toString(): string;
        isMultiBufferAvailable(): boolean;
        get pageFlipping(): boolean;
        get fullScreenRequired(): boolean;
        get flipContents(): Internal.BufferCapabilities$FlipContents;
        get frontBufferCapabilities(): Internal.ImageCapabilities;
        get backBufferCapabilities(): Internal.ImageCapabilities;
        get multiBufferAvailable(): boolean;
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    type BufferCapabilities_ = BufferCapabilities;
    class CallbackInfoReturnable <R> extends Internal.CallbackInfo {
        cancel(): void;
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        isCancelled(): boolean;
        setReturnValue(arg0: R): void;
        getReturnValueB(): number;
        notifyAll(): void;
        getId(): string;
        getReturnValueI(): number;
        getReturnValueJ(): number;
        getReturnValueC(): string;
        getReturnValueD(): number;
        notify(): void;
        getReturnValueF(): number;
        static getCallInfoClassName(arg0: Internal.Type_): string;
        getReturnValue(): R;
        hashCode(): number;
        equals(arg0: any): boolean;
        isCancellable(): boolean;
        toString(): string;
        getReturnValueZ(): boolean;
        getReturnValueS(): number;
        get returnValueC(): string;
        get returnValueD(): number;
        get returnValueB(): number;
        get returnValue(): R;
        get returnValueF(): number;
        get returnValueI(): number;
        get returnValueJ(): number;
        get cancellable(): boolean;
        get returnValueS(): number;
        get cancelled(): boolean;
        get id(): string;
        get returnValueZ(): boolean;
        get class(): Internal.Class<any>;
        set returnValue(arg0: R);
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    type CallbackInfoReturnable_<R> = CallbackInfoReturnable<R>;
    class Package extends Internal.NamedPackage implements Internal.AnnotatedElement {
        getClass(): Internal.Class<any>;
        isSealed(arg0: Internal.URL_): boolean;
        isSealed(): boolean;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        static getPackage(arg0: string): Internal.Package;
        getName(): string;
        isAnnotationPresent(arg0: Internal.Class_<Internal.Annotation_>): boolean;
        notifyAll(): void;
        getSpecificationTitle(): string;
        getImplementationTitle(): string;
        isCompatibleWith(arg0: string): boolean;
        getAnnotations(): Internal.Annotation[];
        notify(): void;
        getSpecificationVendor(): string;
        getDeclaredAnnotations(): Internal.Annotation[];
        getAnnotationsByType<A_>(arg0: Internal.Class_<A_>): A_[];
        getDeclaredAnnotationsByType<A_>(arg0: Internal.Class_<A_>): A_[];
        getAnnotation<A_>(arg0: Internal.Class_<A_>): A_;
        hashCode(): number;
        equals(arg0: any): boolean;
        static getPackages(): Internal.Package[];
        getDeclaredAnnotation<A_>(arg0: Internal.Class_<A_>): A_;
        toString(): string;
        getSpecificationVersion(): string;
        getImplementationVendor(): string;
        getImplementationVersion(): string;
        get specificationVendor(): string;
        get declaredAnnotations(): Internal.Annotation[];
        get specificationTitle(): string;
        get implementationVersion(): string;
        get sealed(): boolean;
        get name(): string;
        get implementationVendor(): string;
        get annotations(): Internal.Annotation[];
        get implementationTitle(): string;
        get packages(): Internal.Package[];
        get class(): Internal.Class<any>;
        get specificationVersion(): string;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    type Package_ = Package;
    class PrintWriter extends Internal.Writer {
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        notifyAll(): void;
        format(arg0: string, arg1: any[]): Internal.PrintWriter;
        format(arg0: Internal.Locale_, arg1: string, arg2: any[]): Internal.PrintWriter;
        checkError(): boolean;
        notify(): void;
        printf(arg0: string, arg1: any[]): Internal.PrintWriter;
        printf(arg0: Internal.Locale_, arg1: string, arg2: any[]): Internal.PrintWriter;
        print(arg0: number): void;
        print(arg0: string): void;
        print(arg0: boolean): void;
        print(arg0: any): void;
        print(arg0: string[]): void;
        println(arg0: string[]): void;
        println(): void;
        println(arg0: boolean): void;
        println(arg0: string): void;
        println(arg0: any): void;
        println(arg0: number): void;
        flush(): void;
        hashCode(): number;
        equals(arg0: any): boolean;
        static nullWriter(): Internal.Writer;
        toString(): string;
        close(): void;
        write(arg0: string[], arg1: number, arg2: number): void;
        write(arg0: string): void;
        write(arg0: string, arg1: number, arg2: number): void;
        write(arg0: string[]): void;
        write(arg0: number): void;
        append(arg0: Internal.CharSequence_, arg1: number, arg2: number): Internal.PrintWriter;
        append(arg0: string): Internal.PrintWriter;
        append(arg0: Internal.CharSequence_): Internal.PrintWriter;
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    type PrintWriter_ = PrintWriter;
    class FormatStyle extends Internal.Enum<Internal.FormatStyle> {
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        static valueOf(arg0: string): Internal.FormatStyle;
        static valueOf<T_>(arg0: Internal.Class_<T_>, arg1: string): T_;
        notifyAll(): void;
        static values(): Internal.FormatStyle[];
        compareTo(arg0: Internal.FormatStyle_): number;
        describeConstable(): Internal.Optional<Internal.Enum$EnumDesc<Internal.FormatStyle>>;
        notify(): void;
        getDeclaringClass(): Internal.Class<Internal.FormatStyle>;
        hashCode(): number;
        equals(arg0: any): boolean;
        name(): string;
        toString(): string;
        ordinal(): number;
        static readonly MEDIUM : Internal.FormatStyle;
        static readonly FULL : Internal.FormatStyle;
        static readonly LONG : Internal.FormatStyle;
        static readonly SHORT : Internal.FormatStyle;
        get class(): Internal.Class<any>;
        get declaringClass(): Internal.Class<Internal.FormatStyle>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    type FormatStyle_ = "short" | "medium" | "long" | "full" | FormatStyle;
    class OptionalLong {
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        notifyAll(): void;
        isEmpty(): boolean;
        isPresent(): boolean;
        orElse(arg0: number): number;
        notify(): void;
        orElseThrow<X>(arg0: Internal.Supplier_<X>): number;
        orElseThrow(): number;
        static empty(): Internal.OptionalLong;
        getAsLong(): number;
        orElseGet(arg0: Internal.LongSupplier_): number;
        stream(): Internal.LongStream;
        hashCode(): number;
        ifPresentOrElse(arg0: java_.util.function_.LongConsumer_, arg1: Internal.Runnable_): void;
        ifPresent(arg0: java_.util.function_.LongConsumer_): void;
        static of(arg0: number): Internal.OptionalLong;
        equals(arg0: any): boolean;
        toString(): string;
        get asLong(): number;
        get present(): boolean;
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    type OptionalLong_ = OptionalLong;
    interface EnchantmentBuilder$DamageBonusFunction {
        getDamageBonus(arg0: number, arg1: string): number;
    }
    type EnchantmentBuilder$DamageBonusFunction_ = ((arg0: number, arg1: string) => number) | EnchantmentBuilder$DamageBonusFunction;
    interface ILootHandler {
        applyLootHandler(arg0: Internal.LootContext_, arg1: Internal.List_<Internal.ItemStack_>): boolean;
    }
    type ILootHandler_ = ILootHandler;
    /**
    * Fired when the player:
    * - opens the inventory
    * - closes the inventory
    */
    class InventoryEventJS extends Internal.PlayerEventJS {
        cancel(): void;
        getServer(): Internal.ServerJS;
        getClass(): Internal.Class<any>;
        addGameStage(stage: string): void;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        isCancelled(): boolean;
        getPlayer(): Internal.PlayerJS<any>;
        notifyAll(): void;
        getInventoryContainer(): Internal.AbstractContainerMenu;
        getEntity(): Internal.EntityJS;
        notify(): void;
        getLevel(): Internal.LevelJS;
        getMinecraftPlayer(): Internal.Player;
        post(id: string): boolean;
        post(id: string, sub: string): boolean;
        post(t: Internal.ScriptType_, id: string, sub: string): boolean;
        post(t: Internal.ScriptType_, id: string): boolean;
        hasGameStage(stage: string): boolean;
        hashCode(): number;
        equals(arg0: any): boolean;
        removeGameStage(stage: string): void;
        toString(): string;
        canCancel(): boolean;
        get server(): Internal.ServerJS;
        get inventoryContainer(): Internal.AbstractContainerMenu;
        get level(): Internal.LevelJS;
        get minecraftPlayer(): Internal.Player;
        get cancelled(): boolean;
        get class(): Internal.Class<any>;
        get entity(): Internal.EntityJS;
        get player(): Internal.PlayerJS<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    /**
    * Fired when the player:
    * - opens the inventory
    * - closes the inventory
    */
    type InventoryEventJS_ = InventoryEventJS;
    class BlockEntityPredicate implements Internal.BlockPredicate {
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        data(cd: Internal.BlockEntityPredicateDataCheck_): Internal.BlockEntityPredicate;
        hashCode(): number;
        notifyAll(): void;
        equals(arg0: any): boolean;
        toString(): string;
        check(block: Internal.BlockContainerJS_): boolean;
        notify(): void;
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    type BlockEntityPredicate_ = BlockEntityPredicate;
    class TagKey <T> extends Internal.Record {
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        hashCode(): number;
        notifyAll(): void;
        equals(arg0: any): boolean;
        toString(): string;
        notify(): void;
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    type TagKey_<T> = TagKey<T>;
    abstract class AccessibleContext {
        getClass(): Internal.Class<any>;
        getAccessibleRelationSet(): Internal.AccessibleRelationSet;
        getAccessibleStateSet(): Internal.AccessibleStateSet;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        notifyAll(): void;
        setAccessibleName(arg0: string): void;
        getAccessibleValue(): Internal.AccessibleValue;
        notify(): void;
        getAccessibleText(): Internal.AccessibleText;
        getAccessibleTable(): Internal.AccessibleTable;
        getAccessibleDescription(): string;
        getAccessibleEditableText(): Internal.AccessibleEditableText;
        hashCode(): number;
        setAccessibleDescription(arg0: string): void;
        getAccessibleParent(): Internal.Accessible;
        addPropertyChangeListener(arg0: Internal.PropertyChangeListener_): void;
        getAccessibleChildrenCount(): number;
        firePropertyChange(arg0: string, arg1: any, arg2: any): void;
        getAccessibleName(): string;
        getAccessibleIndexInParent(): number;
        setAccessibleParent(arg0: Internal.Accessible_): void;
        removePropertyChangeListener(arg0: Internal.PropertyChangeListener_): void;
        getAccessibleAction(): Internal.AccessibleAction;
        getAccessibleIcon(): any[];
        getAccessibleChild(arg0: number): Internal.Accessible;
        equals(arg0: any): boolean;
        getAccessibleRole(): Internal.AccessibleRole;
        getAccessibleSelection(): Internal.AccessibleSelection;
        toString(): string;
        getLocale(): Internal.Locale;
        getAccessibleComponent(): Internal.AccessibleComponent;
        static readonly ACCESSIBLE_COMPONENT_BOUNDS_CHANGED : "accessibleComponentBoundsChanged";
        static readonly ACCESSIBLE_INVALIDATE_CHILDREN : "accessibleInvalidateChildren";
        static readonly ACCESSIBLE_VISIBLE_DATA_PROPERTY : "AccessibleVisibleData";
        static readonly ACCESSIBLE_TABLE_ROW_HEADER_CHANGED : "accessibleTableRowHeaderChanged";
        static readonly ACCESSIBLE_SELECTION_PROPERTY : "AccessibleSelection";
        static readonly ACCESSIBLE_NAME_PROPERTY : "AccessibleName";
        static readonly ACCESSIBLE_HYPERTEXT_OFFSET : "AccessibleHypertextOffset";
        static readonly ACCESSIBLE_TEXT_ATTRIBUTES_CHANGED : "accessibleTextAttributesChanged";
        static readonly ACCESSIBLE_TABLE_SUMMARY_CHANGED : "accessibleTableSummaryChanged";
        static readonly ACCESSIBLE_CHILD_PROPERTY : "AccessibleChild";
        static readonly ACCESSIBLE_ACTIVE_DESCENDANT_PROPERTY : "AccessibleActiveDescendant";
        static readonly ACCESSIBLE_DESCRIPTION_PROPERTY : "AccessibleDescription";
        static readonly ACCESSIBLE_TABLE_ROW_DESCRIPTION_CHANGED : "accessibleTableRowDescriptionChanged";
        static readonly ACCESSIBLE_CARET_PROPERTY : "AccessibleCaret";
        static readonly ACCESSIBLE_ACTION_PROPERTY : "accessibleActionProperty";
        static readonly ACCESSIBLE_VALUE_PROPERTY : "AccessibleValue";
        static readonly ACCESSIBLE_TABLE_MODEL_CHANGED : "accessibleTableModelChanged";
        static readonly ACCESSIBLE_TABLE_COLUMN_DESCRIPTION_CHANGED : "accessibleTableColumnDescriptionChanged";
        static readonly ACCESSIBLE_STATE_PROPERTY : "AccessibleState";
        static readonly ACCESSIBLE_TABLE_COLUMN_HEADER_CHANGED : "accessibleTableColumnHeaderChanged";
        static readonly ACCESSIBLE_TEXT_PROPERTY : "AccessibleText";
        static readonly ACCESSIBLE_TABLE_CAPTION_CHANGED : "accessibleTableCaptionChanged";
        get accessibleChildrenCount(): number;
        get accessibleTable(): Internal.AccessibleTable;
        get locale(): Internal.Locale;
        get accessibleRole(): Internal.AccessibleRole;
        get accessibleSelection(): Internal.AccessibleSelection;
        get accessibleDescription(): string;
        get accessibleParent(): Internal.Accessible;
        get accessibleAction(): Internal.AccessibleAction;
        get accessibleIcon(): any[];
        get accessibleValue(): Internal.AccessibleValue;
        get accessibleStateSet(): Internal.AccessibleStateSet;
        get accessibleIndexInParent(): number;
        get accessibleComponent(): Internal.AccessibleComponent;
        get accessibleEditableText(): Internal.AccessibleEditableText;
        get accessibleName(): string;
        get class(): Internal.Class<any>;
        get accessibleText(): Internal.AccessibleText;
        get accessibleRelationSet(): Internal.AccessibleRelationSet;
        set accessibleDescription(arg0: string);
        set accessibleParent(arg0: Internal.Accessible_);
        set accessibleName(arg0: string);
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    type AccessibleContext_ = AccessibleContext;
    interface WatchEvent <T> {
        kind(): Internal.WatchEvent$Kind<T>;
        count(): number;
        context(): T;
    }
    type WatchEvent_<T> = WatchEvent<T>;
    interface IOnProjectileHit {
        setAddDamage(arg0: number): void;
        getAddDamage(): number;
        setMaxLifeTime(arg0: number): void;
        setOnHitAction(arg0: Internal.Consumer_<Internal.HitResult_>): void;
    }
    type IOnProjectileHit_ = IOnProjectileHit;
    class Rect2i {
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        hashCode(): number;
        notifyAll(): void;
        equals(arg0: any): boolean;
        toString(): string;
        notify(): void;
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    type Rect2i_ = Rect2i;
    interface CloseableResourceManager extends Internal.ResourceManager, Internal.AutoCloseable {
        close(): void;
    }
    type CloseableResourceManager_ = CloseableResourceManager;
    class LongSummaryStatistics implements java_.util.function_.LongConsumer, java_.util.function_.IntConsumer {
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        getMax(): number;
        notifyAll(): void;
        getAverage(): number;
        andThen(arg0: java_.util.function_.LongConsumer_): java_.util.function_.LongConsumer;
        andThen(arg0: java_.util.function_.IntConsumer_): java_.util.function_.IntConsumer;
        notify(): void;
        accept(arg0: number): void;
        getMin(): number;
        hashCode(): number;
        equals(arg0: any): boolean;
        toString(): string;
        getSum(): number;
        getCount(): number;
        combine(arg0: Internal.LongSummaryStatistics_): void;
        get average(): number;
        get min(): number;
        get max(): number;
        get count(): number;
        get sum(): number;
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    type LongSummaryStatistics_ = LongSummaryStatistics;
    class ZoneOffsetTransitionRule$TimeDefinition extends Internal.Enum<Internal.ZoneOffsetTransitionRule$TimeDefinition> {
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        static valueOf(arg0: string): Internal.ZoneOffsetTransitionRule$TimeDefinition;
        static valueOf<T_>(arg0: Internal.Class_<T_>, arg1: string): T_;
        notifyAll(): void;
        static values(): Internal.ZoneOffsetTransitionRule$TimeDefinition[];
        compareTo(arg0: Internal.ZoneOffsetTransitionRule$TimeDefinition_): number;
        describeConstable(): Internal.Optional<Internal.Enum$EnumDesc<Internal.ZoneOffsetTransitionRule$TimeDefinition>>;
        notify(): void;
        createDateTime(arg0: Internal.LocalDateTime_, arg1: Internal.ZoneOffset_, arg2: Internal.ZoneOffset_): Internal.LocalDateTime;
        getDeclaringClass(): Internal.Class<Internal.ZoneOffsetTransitionRule$TimeDefinition>;
        hashCode(): number;
        equals(arg0: any): boolean;
        name(): string;
        toString(): string;
        ordinal(): number;
        static readonly WALL : Internal.ZoneOffsetTransitionRule$TimeDefinition;
        static readonly UTC : Internal.ZoneOffsetTransitionRule$TimeDefinition;
        static readonly STANDARD : Internal.ZoneOffsetTransitionRule$TimeDefinition;
        get class(): Internal.Class<any>;
        get declaringClass(): Internal.Class<Internal.ZoneOffsetTransitionRule$TimeDefinition>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    type ZoneOffsetTransitionRule$TimeDefinition_ = "standard" | "utc" | "wall" | ZoneOffsetTransitionRule$TimeDefinition;
    class FriendlyByteBuf extends Internal.ByteBuf implements Internal.IForgeFriendlyByteBuf {
        asReadOnly(): Internal.ByteBuf;
        markReaderIndex(): Internal.ByteBuf;
        getByte(arg0: number): number;
        writeItemStack(arg0: Internal.ItemStack_, arg1: boolean): Internal.FriendlyByteBuf;
        release(arg0: number): boolean;
        release(): boolean;
        readDoubleLE(): number;
        writeZero(arg0: number): Internal.ByteBuf;
        resetReaderIndex(): Internal.ByteBuf;
        writeFloat(arg0: number): Internal.ByteBuf;
        setLongLE(arg0: number, arg1: number): Internal.ByteBuf;
        readRegistryId<T_>(): T_;
        readRetainedSlice(arg0: number): Internal.ByteBuf;
        slice(): Internal.ByteBuf;
        slice(arg0: number, arg1: number): Internal.ByteBuf;
        setDoubleLE(arg0: number, arg1: number): Internal.ByteBuf;
        getMediumLE(arg0: number): number;
        readUnsignedIntLE(): number;
        writeFloatLE(arg0: number): Internal.ByteBuf;
        readInt(): number;
        order(): Internal.ByteOrder;
        order(arg0: Internal.ByteOrder_): Internal.ByteBuf;
        writeMedium(arg0: number): Internal.ByteBuf;
        resetWriterIndex(): Internal.ByteBuf;
        writableBytes(): number;
        maxCapacity(): number;
        getUnsignedShort(arg0: number): number;
        bytesBefore(arg0: number): number;
        bytesBefore(arg0: number, arg1: number, arg2: number): number;
        bytesBefore(arg0: number, arg1: number): number;
        nioBufferCount(): number;
        setInt(arg0: number, arg1: number): Internal.ByteBuf;
        getInt(arg0: number): number;
        markWriterIndex(): Internal.ByteBuf;
        isReadable(): boolean;
        isReadable(arg0: number): boolean;
        writeBoolean(arg0: boolean): Internal.ByteBuf;
        setIntLE(arg0: number, arg1: number): Internal.ByteBuf;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        writeLongLE(arg0: number): Internal.ByteBuf;
        setShortLE(arg0: number, arg1: number): Internal.ByteBuf;
        retain(): Internal.ByteBuf;
        retain(arg0: number): Internal.ByteBuf;
        isWritable(arg0: number): boolean;
        isWritable(): boolean;
        notify(): void;
        readChar(): string;
        hasMemoryAddress(): boolean;
        capacity(arg0: number): Internal.ByteBuf;
        capacity(): number;
        readRegistryIdSafe<T_>(arg0: Internal.Class_<T_>): T_;
        readCharSequence(arg0: number, arg1: Internal.Charset_): Internal.CharSequence;
        isReadOnly(): boolean;
        readUnsignedShortLE(): number;
        readDouble(): number;
        readFloat(): number;
        getLongLE(arg0: number): number;
        getBoolean(arg0: number): boolean;
        copy(arg0: number, arg1: number): Internal.ByteBuf;
        copy(): Internal.ByteBuf;
        readShortLE(): number;
        readUnsignedMedium(): number;
        ensureWritable(arg0: number): Internal.ByteBuf;
        ensureWritable(arg0: number, arg1: boolean): number;
        writeInt(arg0: number): Internal.ByteBuf;
        readFloatLE(): number;
        getDoubleLE(arg0: number): number;
        hasArray(): boolean;
        memoryAddress(): number;
        maxFastWritableBytes(): number;
        readableBytes(): number;
        readSlice(arg0: number): Internal.ByteBuf;
        getIntLE(arg0: number): number;
        nioBuffers(): Internal.ByteBuffer[];
        nioBuffers(arg0: number, arg1: number): Internal.ByteBuffer[];
        forEachByteDesc(arg0: Internal.ByteProcessor_): number;
        forEachByteDesc(arg0: number, arg1: number, arg2: Internal.ByteProcessor_): number;
        skipBytes(arg0: number): Internal.ByteBuf;
        getLong(arg0: number): number;
        readLong(): number;
        readShort(): number;
        equals(arg0: any): boolean;
        setZero(arg0: number, arg1: number): Internal.ByteBuf;
        getUnsignedMedium(arg0: number): number;
        readBytes(arg0: Internal.ByteBuf_, arg1: number, arg2: number): Internal.ByteBuf;
        readBytes(arg0: number[], arg1: number, arg2: number): Internal.ByteBuf;
        readBytes(arg0: number[]): Internal.ByteBuf;
        readBytes(arg0: Internal.ByteBuf_): Internal.ByteBuf;
        readBytes(arg0: Internal.ByteBuf_, arg1: number): Internal.ByteBuf;
        readBytes(arg0: Internal.FileChannel_, arg1: number, arg2: number): number;
        readBytes(arg0: number): Internal.ByteBuf;
        readBytes(arg0: Internal.GatheringByteChannel_, arg1: number): number;
        readBytes(arg0: Internal.OutputStream_, arg1: number): Internal.ByteBuf;
        readBytes(arg0: Internal.ByteBuffer_): Internal.ByteBuf;
        readBoolean(): boolean;
        toString(): string;
        toString(arg0: number, arg1: number, arg2: Internal.Charset_): string;
        toString(arg0: Internal.Charset_): string;
        retainedSlice(arg0: number, arg1: number): Internal.ByteBuf;
        retainedSlice(): Internal.ByteBuf;
        readMediumLE(): number;
        setMedium(arg0: number, arg1: number): Internal.ByteBuf;
        isDirect(): boolean;
        setBoolean(arg0: number, arg1: boolean): Internal.ByteBuf;
        getClass(): Internal.Class<any>;
        getFloatLE(arg0: number): number;
        readerIndex(): number;
        readerIndex(arg0: number): Internal.ByteBuf;
        getCharSequence(arg0: number, arg1: number, arg2: Internal.Charset_): Internal.CharSequence;
        setShort(arg0: number, arg1: number): Internal.ByteBuf;
        compareTo(arg0: Internal.ByteBuf_): number;
        getBytes(arg0: number, arg1: Internal.ByteBuf_, arg2: number): Internal.ByteBuf;
        getBytes(arg0: number, arg1: Internal.ByteBuf_, arg2: number, arg3: number): Internal.ByteBuf;
        getBytes(arg0: number, arg1: number[]): Internal.ByteBuf;
        getBytes(arg0: number, arg1: Internal.GatheringByteChannel_, arg2: number): number;
        getBytes(arg0: number, arg1: Internal.ByteBuf_): Internal.ByteBuf;
        getBytes(arg0: number, arg1: Internal.OutputStream_, arg2: number): Internal.ByteBuf;
        getBytes(arg0: number, arg1: Internal.ByteBuffer_): Internal.ByteBuf;
        getBytes(arg0: number, arg1: Internal.FileChannel_, arg2: number, arg3: number): number;
        getBytes(arg0: number, arg1: number[], arg2: number, arg3: number): Internal.ByteBuf;
        unwrap(): Internal.ByteBuf;
        setDouble(arg0: number, arg1: number): Internal.ByteBuf;
        setChar(arg0: number, arg1: number): Internal.ByteBuf;
        refCnt(): number;
        getUnsignedIntLE(arg0: number): number;
        setFloatLE(arg0: number, arg1: number): Internal.ByteBuf;
        getUnsignedInt(arg0: number): number;
        writeRegistryIdUnsafe(arg0: Internal.IForgeRegistry_<any>, arg1: ResourceLocation_): void;
        writeRegistryIdUnsafe<T_>(arg0: Internal.IForgeRegistry_<T_>, arg1: T_): void;
        indexOf(arg0: number, arg1: number, arg2: number): number;
        writeByte(arg0: number): Internal.ByteBuf;
        nioBuffer(): Internal.ByteBuffer;
        nioBuffer(arg0: number, arg1: number): Internal.ByteBuffer;
        discardSomeReadBytes(): Internal.ByteBuf;
        touch(): Internal.ByteBuf;
        touch(arg0: any): Internal.ByteBuf;
        readRegistryIdUnsafe<T_>(arg0: Internal.IForgeRegistry_<T_>): T_;
        duplicate(): Internal.ByteBuf;
        writerIndex(): number;
        writerIndex(arg0: number): Internal.ByteBuf;
        writeCharSequence(arg0: Internal.CharSequence_, arg1: Internal.Charset_): number;
        readUnsignedInt(): number;
        getUnsignedShortLE(arg0: number): number;
        retainedDuplicate(): Internal.ByteBuf;
        getChar(arg0: number): string;
        setLong(arg0: number, arg1: number): Internal.ByteBuf;
        readMedium(): number;
        writeBytes(arg0: Internal.FileChannel_, arg1: number, arg2: number): number;
        writeBytes(arg0: Internal.ByteBuffer_): Internal.ByteBuf;
        writeBytes(arg0: number[], arg1: number, arg2: number): Internal.ByteBuf;
        writeBytes(arg0: number[]): Internal.ByteBuf;
        writeBytes(arg0: Internal.ByteBuf_, arg1: number, arg2: number): Internal.ByteBuf;
        writeBytes(arg0: Internal.ByteBuf_, arg1: number): Internal.ByteBuf;
        writeBytes(arg0: Internal.ByteBuf_): Internal.ByteBuf;
        writeBytes(arg0: Internal.ScatteringByteChannel_, arg1: number): number;
        writeBytes(arg0: Internal.InputStream_, arg1: number): number;
        forEachByte(arg0: number, arg1: number, arg2: Internal.ByteProcessor_): number;
        forEachByte(arg0: Internal.ByteProcessor_): number;
        setIndex(arg0: number, arg1: number): Internal.ByteBuf;
        writeShort(arg0: number): Internal.ByteBuf;
        getShortLE(arg0: number): number;
        alloc(): Internal.ByteBufAllocator;
        getMedium(arg0: number): number;
        readUnsignedShort(): number;
        setByte(arg0: number, arg1: number): Internal.ByteBuf;
        writeShortLE(arg0: number): Internal.ByteBuf;
        maxWritableBytes(): number;
        readFluidStack(): net.minecraftforge.fluids.FluidStack;
        notifyAll(): void;
        getDouble(arg0: number): number;
        getFloat(arg0: number): number;
        writeLong(arg0: number): Internal.ByteBuf;
        writeIntLE(arg0: number): Internal.ByteBuf;
        array(): number[];
        setCharSequence(arg0: number, arg1: Internal.CharSequence_, arg2: Internal.Charset_): number;
        hashCode(): number;
        internalNioBuffer(arg0: number, arg1: number): Internal.ByteBuffer;
        arrayOffset(): number;
        readIntLE(): number;
        setMediumLE(arg0: number, arg1: number): Internal.ByteBuf;
        readUnsignedByte(): number;
        readUnsignedMediumLE(): number;
        readLongLE(): number;
        writeDouble(arg0: number): Internal.ByteBuf;
        setBytes(arg0: number, arg1: Internal.ByteBuffer_): Internal.ByteBuf;
        setBytes(arg0: number, arg1: Internal.InputStream_, arg2: number): number;
        setBytes(arg0: number, arg1: Internal.ScatteringByteChannel_, arg2: number): number;
        setBytes(arg0: number, arg1: Internal.FileChannel_, arg2: number, arg3: number): number;
        setBytes(arg0: number, arg1: Internal.ByteBuf_, arg2: number): Internal.ByteBuf;
        setBytes(arg0: number, arg1: Internal.ByteBuf_): Internal.ByteBuf;
        setBytes(arg0: number, arg1: Internal.ByteBuf_, arg2: number, arg3: number): Internal.ByteBuf;
        setBytes(arg0: number, arg1: number[], arg2: number, arg3: number): Internal.ByteBuf;
        setBytes(arg0: number, arg1: number[]): Internal.ByteBuf;
        setFloat(arg0: number, arg1: number): Internal.ByteBuf;
        getShort(arg0: number): number;
        writeMediumLE(arg0: number): Internal.ByteBuf;
        clear(): Internal.ByteBuf;
        writeRegistryId<T_>(arg0: T_): void;
        getUnsignedByte(arg0: number): number;
        writeFluidStack(arg0: net.minecraftforge.fluids.FluidStack_): void;
        discardReadBytes(): Internal.ByteBuf;
        writeChar(arg0: number): Internal.ByteBuf;
        isContiguous(): boolean;
        writeDoubleLE(arg0: number): Internal.ByteBuf;
        getUnsignedMediumLE(arg0: number): number;
        readByte(): number;
        get readable(): boolean;
        get direct(): boolean;
        get readOnly(): boolean;
        get class(): Internal.Class<any>;
        get contiguous(): boolean;
        get writable(): boolean;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    type FriendlyByteBuf_ = FriendlyByteBuf;
    class Lifecycle {
        add(arg0: Internal.Lifecycle_): Internal.Lifecycle;
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        hashCode(): number;
        static stable(): Internal.Lifecycle;
        notifyAll(): void;
        equals(arg0: any): boolean;
        static deprecated(arg0: number): Internal.Lifecycle;
        toString(): string;
        static experimental(): Internal.Lifecycle;
        notify(): void;
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    type Lifecycle_ = Lifecycle;
    class FireworksJS$Shape extends Internal.Enum<Internal.FireworksJS$Shape> {
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        static valueOf(name: string): Internal.FireworksJS$Shape;
        static valueOf<T_>(arg0: Internal.Class_<T_>, arg1: string): T_;
        notifyAll(): void;
        static values(): Internal.FireworksJS$Shape[];
        compareTo(arg0: Internal.FireworksJS$Shape_): number;
        describeConstable(): Internal.Optional<Internal.Enum$EnumDesc<Internal.FireworksJS$Shape>>;
        notify(): void;
        getDeclaringClass(): Internal.Class<Internal.FireworksJS$Shape>;
        hashCode(): number;
        equals(arg0: any): boolean;
        static get(name: string): Internal.FireworksJS$Shape;
        name(): string;
        toString(): string;
        ordinal(): number;
        static readonly SMALL_BALL : Internal.FireworksJS$Shape;
        static readonly LARGE_BALL : Internal.FireworksJS$Shape;
        static readonly STAR : Internal.FireworksJS$Shape;
        static readonly CREEPER : Internal.FireworksJS$Shape;
        static readonly BURST : Internal.FireworksJS$Shape;
        static readonly VALUES : Internal.FireworksJS$Shape[];
        readonly type : number;
        get class(): Internal.Class<any>;
        get declaringClass(): Internal.Class<Internal.FireworksJS$Shape>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    type FireworksJS$Shape_ = "large_ball" | "star" | "burst" | "creeper" | "small_ball" | FireworksJS$Shape;
    class ScriptManager {
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        handler$cfa000$loadJavaClass(njc: Internal.Scriptable_, ex: any[], cir: Internal.CallbackInfoReturnable_<any>): void;
        loadFromDirectory(): void;
        load(): void;
        hashCode(): number;
        isClassAllowed(name: string): boolean;
        notifyAll(): void;
        equals(arg0: any): boolean;
        loadJavaClass(scope: Internal.Scriptable_, args: any[]): Internal.NativeJavaClass;
        unload(): void;
        toString(): string;
        notify(): void;
        readonly exampleScript : string;
        readonly type : Internal.ScriptType;
        firstLoad : boolean;
        readonly directory : Internal.Path;
        readonly packs : Internal.Map<string, Internal.ScriptPack>;
        readonly events : Internal.EventsJS;
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    type ScriptManager_ = ScriptManager;
    class AtomicInteger extends Internal.Number implements Internal.Serializable {
        setPlain(arg0: number): void;
        getClass(): Internal.Class<any>;
        getAndIncrement(): number;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        incrementAndGet(): number;
        weakCompareAndSetPlain(arg0: number, arg1: number): boolean;
        compareAndExchange(arg0: number, arg1: number): number;
        notifyAll(): void;
        getAcquire(): number;
        updateAndGet(arg0: Internal.IntUnaryOperator_): number;
        decrementAndGet(): number;
        notify(): void;
        getOpaque(): number;
        longValue(): number;
        hashCode(): number;
        get(): number;
        lazySet(arg0: number): void;
        getAndAdd(arg0: number): number;
        shortValue(): number;
        getAndSet(arg0: number): number;
        weakCompareAndSetAcquire(arg0: number, arg1: number): boolean;
        getAndAccumulate(arg0: number, arg1: Internal.IntBinaryOperator_): number;
        accumulateAndGet(arg0: number, arg1: Internal.IntBinaryOperator_): number;
        weakCompareAndSetVolatile(arg0: number, arg1: number): boolean;
        set(arg0: number): void;
        weakCompareAndSetRelease(arg0: number, arg1: number): boolean;
        weakCompareAndSet(arg0: number, arg1: number): boolean;
        intValue(): number;
        floatValue(): number;
        doubleValue(): number;
        setOpaque(arg0: number): void;
        getPlain(): number;
        compareAndExchangeRelease(arg0: number, arg1: number): number;
        compareAndSet(arg0: number, arg1: number): boolean;
        equals(arg0: any): boolean;
        compareAndExchangeAcquire(arg0: number, arg1: number): number;
        addAndGet(arg0: number): number;
        setRelease(arg0: number): void;
        toString(): string;
        getAndUpdate(arg0: Internal.IntUnaryOperator_): number;
        getAndDecrement(): number;
        byteValue(): number;
        get andDecrement(): number;
        get opaque(): number;
        get andIncrement(): number;
        get plain(): number;
        get class(): Internal.Class<any>;
        get acquire(): number;
        set opaque(arg0: number);
        set release(arg0: number);
        set plain(arg0: number);
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    type AtomicInteger_ = AtomicInteger;
    interface Supplier <T> {
        get(): T;
    }
    type Supplier_<T> = (() => T) | Supplier<T>;
    interface Int2DoubleFunction extends Internal.Function<number, number>, Internal.IntToDoubleFunction {
        getOrDefault(arg0: any, arg1: number): number;
        getOrDefault(arg0: number, arg1: number): number;
        applyAsDouble(arg0: number): number;
        andThenShort(arg0: Internal.Double2ShortFunction_): Internal.Int2ShortFunction;
        composeByte(arg0: Internal.Byte2IntFunction_): Internal.Byte2DoubleFunction;
        andThenInt(arg0: Internal.Double2IntFunction_): Internal.Int2IntFunction;
        composeReference<T_>(arg0: Internal.Reference2IntFunction_<T_>): Internal.Reference2DoubleFunction<T_>;
        andThen<T_>(arg0: java_.util.function_.Function_<number, T_>): java_.util.function_.Function<number, T_>;
        put(arg0: number, arg1: number): number;
        remove(arg0: number): number;
        remove(arg0: any): number;
        defaultReturnValue(): number;
        defaultReturnValue(arg0: number): void;
        andThenDouble(arg0: Internal.Double2DoubleFunction_): Internal.Int2DoubleFunction;
        andThenObject<T_>(arg0: Internal.Double2ObjectFunction_<T_>): Internal.Int2ObjectFunction<T_>;
        get(arg0: any): number;
        get(arg0: number): number;
        andThenLong(arg0: Internal.Double2LongFunction_): Internal.Int2LongFunction;
        composeLong(arg0: Internal.Long2IntFunction_): Internal.Long2DoubleFunction;
        andThenByte(arg0: Internal.Double2ByteFunction_): Internal.Int2ByteFunction;
        andThenFloat(arg0: Internal.Double2FloatFunction_): Internal.Int2FloatFunction;
        apply(arg0: number): number;
        containsKey(arg0: any): boolean;
        containsKey(arg0: number): boolean;
        composeInt(arg0: Internal.Int2IntFunction_): Internal.Int2DoubleFunction;
        clear(): void;
        composeFloat(arg0: Internal.Float2IntFunction_): Internal.Float2DoubleFunction;
        andThenChar(arg0: Internal.Double2CharFunction_): Internal.Int2CharFunction;
        composeObject<T_>(arg0: Internal.Object2IntFunction_<T_>): Internal.Object2DoubleFunction<T_>;
        size(): number;
        compose<T_>(arg0: java_.util.function_.Function_<T_, number>): java_.util.function_.Function<T_, number>;
        composeShort(arg0: Internal.Short2IntFunction_): Internal.Short2DoubleFunction;
        andThenReference<T_>(arg0: Internal.Double2ReferenceFunction_<T_>): Internal.Int2ReferenceFunction<T_>;
        composeChar(arg0: Internal.Char2IntFunction_): Internal.Char2DoubleFunction;
        composeDouble(arg0: Internal.Double2IntFunction_): Internal.Double2DoubleFunction;
    }
    type Int2DoubleFunction_ = ((arg0: number) => number) | Int2DoubleFunction;
    interface ServerKillCountDown {
        setKillCountdown(arg0: number, arg1: boolean): void;
    }
    type ServerKillCountDown_ = ServerKillCountDown;
    class NonNullList <E> extends Internal.AbstractList<E> {
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        notifyAll(): void;
        replaceAll(arg0: Internal.UnaryOperator_<E>): void;
        notify(): void;
        remove(arg0: number): E;
        remove(arg0: any): boolean;
        removeAll(arg0: Internal.Collection_<any>): boolean;
        iterator(): Internal.Iterator<E>;
        stream(): Internal.Stream<E>;
        hashCode(): number;
        get(arg0: number): E;
        toArray(): any[];
        toArray<T_>(arg0: T_[]): T_[];
        toArray<T_>(arg0: Internal.IntFunction_<T_[]>): T_[];
        parallelStream(): Internal.Stream<E>;
        indexOf(arg0: any): number;
        add(arg0: number, arg1: E): void;
        add(arg0: E): boolean;
        subList(arg0: number, arg1: number): Internal.List<E>;
        set(arg0: number, arg1: E): E;
        spliterator(): Internal.Spliterator<E>;
        forEach(arg0: Internal.Consumer_<E>): void;
        containsAll(arg0: Internal.Collection_<any>): boolean;
        isEmpty(): boolean;
        clear(): void;
        sort(arg0: Internal.Comparator_<E>): void;
        removeIf(arg0: Internal.Predicate_<E>): boolean;
        lastIndexOf(arg0: any): number;
        contains(arg0: any): boolean;
        size(): number;
        addAll(arg0: number, arg1: Internal.Collection_<E>): boolean;
        addAll(arg0: Internal.Collection_<E>): boolean;
        equals(arg0: any): boolean;
        listIterator(): Internal.ListIterator<E>;
        listIterator(arg0: number): Internal.ListIterator<E>;
        toString(): string;
        retainAll(arg0: Internal.Collection_<any>): boolean;
        get class(): Internal.Class<any>;
        get empty(): boolean;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    type NonNullList_<E> = NonNullList<E>;
    interface DoubleCollection extends Internal.Collection<number>, Internal.DoubleIterable {
        doubleSpliterator(): Internal.DoubleSpliterator;
        remove(arg0: any): boolean;
        removeAll(arg0: Internal.DoubleCollection_): boolean;
        removeAll(arg0: Internal.Collection_<any>): boolean;
        iterator(): Internal.DoubleIterator;
        stream(): Internal.Stream<number>;
        hashCode(): number;
        toArray(arg0: number[]): number[];
        toArray<T_>(arg0: T_[]): T_[];
        toArray<T_>(arg0: Internal.IntFunction_<T_[]>): T_[];
        toArray(): any[];
        parallelStream(): Internal.Stream<number>;
        rem(arg0: number): boolean;
        doubleIterator(): Internal.DoubleIterator;
        add(arg0: number): boolean;
        spliterator(): Internal.DoubleSpliterator;
        forEach(arg0: Internal.Consumer_<number>): void;
        forEach(arg0: java_.util.function_.DoubleConsumer_): void;
        forEach(arg0: Internal.DoubleConsumer_): void;
        containsAll(arg0: Internal.DoubleCollection_): boolean;
        containsAll(arg0: Internal.Collection_<any>): boolean;
        isEmpty(): boolean;
        clear(): void;
        doubleStream(): Internal.DoubleStream;
        removeIf(arg0: java_.util.function_.DoublePredicate_): boolean;
        removeIf(arg0: Internal.Predicate_<number>): boolean;
        removeIf(arg0: Internal.DoublePredicate_): boolean;
        doubleParallelStream(): Internal.DoubleStream;
        contains(arg0: number): boolean;
        contains(arg0: any): boolean;
        size(): number;
        addAll(arg0: Internal.DoubleCollection_): boolean;
        addAll(arg0: Internal.Collection_<number>): boolean;
        toDoubleArray(arg0: number[]): number[];
        toDoubleArray(): number[];
        equals(arg0: any): boolean;
        retainAll(arg0: Internal.DoubleCollection_): boolean;
        retainAll(arg0: Internal.Collection_<any>): boolean;
    }
    type DoubleCollection_ = DoubleCollection;
    interface AccessorMinecraft {
        bookshelf$getFontManager(): Internal.FontManager;
    }
    type AccessorMinecraft_ = AccessorMinecraft;
    /**
    * Fired by different tag when the server:
    * - loads
    * - ticks
    * - unloads
    */
    class ServerEventJS extends Internal.EventJS {
        cancel(): void;
        getServer(): Internal.ServerJS;
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        isCancelled(): boolean;
        post(t: Internal.ScriptType_, id: string, sub: string): boolean;
        post(t: Internal.ScriptType_, id: string): boolean;
        hashCode(): number;
        notifyAll(): void;
        equals(arg0: any): boolean;
        toString(): string;
        notify(): void;
        canCancel(): boolean;
        get server(): Internal.ServerJS;
        get cancelled(): boolean;
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    /**
    * Fired by different tag when the server:
    * - loads
    * - ticks
    * - unloads
    */
    type ServerEventJS_ = ServerEventJS;
    /**
    */
    class CompoundTag implements net.minecraft.nbt.Tag {
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        hashCode(): number;
        notifyAll(): void;
        merge(arg0: Internal.CompoundTag_): Internal.CompoundTag;
        equals(arg0: any): boolean;
        toString(): string;
        notify(): void;
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    /**
    */
    type CompoundTag_ = string | {[string]: string | number | boolean | Internal.CompoundTag_} | CompoundTag;
    class BlockIDPredicate$PropertyObject extends Internal.Record {
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        hashCode(): number;
        notifyAll(): void;
        equals(o: any): boolean;
        property(): net.minecraft.world.level.block.state.properties.Property<any>;
        toString(): string;
        value(): any;
        notify(): void;
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    type BlockIDPredicate$PropertyObject_ = BlockIDPredicate$PropertyObject;
    abstract class AgeableListModel <E> extends Internal.EntityModel<E> {
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        hashCode(): number;
        notifyAll(): void;
        equals(arg0: any): boolean;
        toString(): string;
        notify(): void;
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    type AgeableListModel_<E> = AgeableListModel<E>;
    interface MinecraftServerAccess {
        byg_getStorageSource(): Internal.LevelStorageSource$LevelStorageAccess;
    }
    type MinecraftServerAccess_ = MinecraftServerAccess;
    interface ResourceManager extends Internal.ResourceProvider {
    }
    type ResourceManager_ = ResourceManager;
    class DragGestureEvent extends Internal.EventObject {
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        notifyAll(): void;
        notify(): void;
        getSourceAsDragGestureRecognizer(): Internal.DragGestureRecognizer;
        getDragAction(): number;
        iterator(): Internal.Iterator<Internal.InputEvent>;
        getTriggerEvent(): Internal.InputEvent;
        getDragOrigin(): Internal.Point;
        hashCode(): number;
        getSource(): any;
        getDragSource(): Internal.DragSource;
        equals(arg0: any): boolean;
        startDrag(arg0: Internal.Cursor_, arg1: Internal.Transferable_): void;
        startDrag(arg0: Internal.Cursor_, arg1: Internal.Image_, arg2: Internal.Point_, arg3: Internal.Transferable_, arg4: Internal.DragSourceListener_): void;
        startDrag(arg0: Internal.Cursor_, arg1: Internal.Transferable_, arg2: Internal.DragSourceListener_): void;
        toArray(arg0: any[]): any[];
        toArray(): any[];
        toString(): string;
        getComponent(): java_.awt.Component;
        get component(): java_.awt.Component;
        get sourceAsDragGestureRecognizer(): Internal.DragGestureRecognizer;
        get triggerEvent(): Internal.InputEvent;
        get dragAction(): number;
        get source(): any;
        get class(): Internal.Class<any>;
        get dragSource(): Internal.DragSource;
        get dragOrigin(): Internal.Point;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    type DragGestureEvent_ = DragGestureEvent;
    class Locale$Category extends Internal.Enum<Internal.Locale$Category> {
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        static valueOf(arg0: string): Internal.Locale$Category;
        static valueOf<T_>(arg0: Internal.Class_<T_>, arg1: string): T_;
        notifyAll(): void;
        static values(): Internal.Locale$Category[];
        compareTo(arg0: Internal.Locale$Category_): number;
        describeConstable(): Internal.Optional<Internal.Enum$EnumDesc<Internal.Locale$Category>>;
        notify(): void;
        getDeclaringClass(): Internal.Class<Internal.Locale$Category>;
        hashCode(): number;
        equals(arg0: any): boolean;
        name(): string;
        toString(): string;
        ordinal(): number;
        static readonly DISPLAY : Internal.Locale$Category;
        static readonly FORMAT : Internal.Locale$Category;
        get class(): Internal.Class<any>;
        get declaringClass(): Internal.Class<Internal.Locale$Category>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    type Locale$Category_ = "display" | "format" | Locale$Category;
    interface Packet <T> {
    }
    type Packet_<T> = Packet<T>;
    interface Path extends Internal.Comparable<Internal.Path>, Internal.Iterable<Internal.Path>, Internal.Watchable {
        getName(arg0: number): Internal.Path;
        resolve(arg0: Internal.Path_): Internal.Path;
        resolve(arg0: string): Internal.Path;
        resolveSibling(arg0: Internal.Path_): Internal.Path;
        resolveSibling(arg0: string): Internal.Path;
        subpath(arg0: number, arg1: number): Internal.Path;
        compareTo(arg0: Internal.Path_): number;
        iterator(): Internal.Iterator<Internal.Path>;
        hashCode(): number;
        normalize(): Internal.Path;
        relativize(arg0: Internal.Path_): Internal.Path;
        getRoot(): Internal.Path;
        getFileName(): Internal.Path;
        getNameCount(): number;
        getParent(): Internal.Path;
        spliterator(): Internal.Spliterator<Internal.Path>;
        forEach(arg0: Internal.Consumer_<Internal.Path_>): void;
        toUri(): Internal.URI;
        toAbsolutePath(): Internal.Path;
        getFileSystem(): Internal.FileSystem;
        equals(arg0: any): boolean;
        toFile(): Internal.File;
        toRealPath(arg0: any_[]): Internal.Path;
        endsWith(arg0: string): boolean;
        endsWith(arg0: Internal.Path_): boolean;
        isAbsolute(): boolean;
        toString(): string;
        register(arg0: Internal.WatchService_, arg1: Internal.WatchEvent$Kind_<any>[]): Internal.WatchKey;
        register(arg0: Internal.WatchService_, arg1: Internal.WatchEvent$Kind_<any>[], arg2: any_[]): Internal.WatchKey;
        startsWith(arg0: string): boolean;
        startsWith(arg0: Internal.Path_): boolean;
    }
    type Path_ = Path;
    interface Comparator <T> {
        compare(arg0: T, arg1: T): number;
        thenComparingInt(arg0: Internal.ToIntFunction_<T>): Internal.Comparator<T>;
        thenComparingDouble(arg0: Internal.ToDoubleFunction_<T>): Internal.Comparator<T>;
        thenComparingLong(arg0: Internal.ToLongFunction_<T>): Internal.Comparator<T>;
        thenComparing(arg0: Internal.Comparator_<T>): Internal.Comparator<T>;
        thenComparing<U>(arg0: java_.util.function_.Function_<T, U>, arg1: Internal.Comparator_<U>): Internal.Comparator<T>;
        thenComparing<U>(arg0: java_.util.function_.Function_<T, U>): Internal.Comparator<T>;
        equals(arg0: any): boolean;
        reversed(): Internal.Comparator<T>;
    }
    type Comparator_<T> = ((arg0: any) => boolean) | Comparator<T>;
    class TeamRank extends Internal.Enum<Internal.TeamRank> implements Internal.StringRepresentable {
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        isAlly(): boolean;
        isNone(): boolean;
        static valueOf(name: string): Internal.TeamRank;
        static valueOf<T_>(arg0: Internal.Class_<T_>, arg1: string): T_;
        notifyAll(): void;
        static values(): Internal.TeamRank[];
        is(rank: Internal.TeamRank_): boolean;
        compareTo(arg0: Internal.TeamRank_): number;
        isMember(): boolean;
        describeConstable(): Internal.Optional<Internal.Enum$EnumDesc<Internal.TeamRank>>;
        isOfficer(): boolean;
        notify(): void;
        getDeclaringClass(): Internal.Class<Internal.TeamRank>;
        getPower(): number;
        isInvited(): boolean;
        isOwner(): boolean;
        isEnemy(): boolean;
        hashCode(): number;
        equals(arg0: any): boolean;
        name(): string;
        toString(): string;
        ordinal(): number;
        static readonly OWNER : Internal.TeamRank;
        static readonly INVITED : Internal.TeamRank;
        static readonly ALLY : Internal.TeamRank;
        static readonly NAME_MAP : Internal.NameMap<Internal.TeamRank>;
        static readonly ENEMY : Internal.TeamRank;
        static readonly OFFICER : Internal.TeamRank;
        static readonly VALUES : Internal.TeamRank[];
        static readonly NONE : Internal.TeamRank;
        static readonly MEMBER : Internal.TeamRank;
        get owner(): boolean;
        get ally(): boolean;
        get officer(): boolean;
        get member(): boolean;
        get invited(): boolean;
        get enemy(): boolean;
        get none(): boolean;
        get power(): number;
        get class(): Internal.Class<any>;
        get declaringClass(): Internal.Class<Internal.TeamRank>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    type TeamRank_ = "owner" | "ally" | "officer" | "invited" | "member" | "enemy" | "none" | TeamRank;
    interface Serializable {
    }
    type Serializable_ = Serializable;
    interface LayoutManager {
        preferredLayoutSize(arg0: Internal.Container_): Internal.Dimension;
        removeLayoutComponent(arg0: java_.awt.Component_): void;
        minimumLayoutSize(arg0: Internal.Container_): Internal.Dimension;
        layoutContainer(arg0: Internal.Container_): void;
        addLayoutComponent(arg0: string, arg1: java_.awt.Component_): void;
    }
    type LayoutManager_ = LayoutManager;
    class Configuration {
        findModule(arg0: string): Internal.Optional<Internal.ResolvedModule>;
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        resolve(arg0: Internal.ModuleFinder_, arg1: Internal.ModuleFinder_, arg2: Internal.Collection_<string>): Internal.Configuration;
        static resolve(arg0: Internal.ModuleFinder_, arg1: Internal.List_<Internal.Configuration_>, arg2: Internal.ModuleFinder_, arg3: Internal.Collection_<string>): Internal.Configuration;
        hashCode(): number;
        notifyAll(): void;
        equals(arg0: any): boolean;
        toString(): string;
        static resolveAndBind(arg0: Internal.ModuleFinder_, arg1: Internal.List_<Internal.Configuration_>, arg2: Internal.ModuleFinder_, arg3: Internal.Collection_<string>): Internal.Configuration;
        resolveAndBind(arg0: Internal.ModuleFinder_, arg1: Internal.ModuleFinder_, arg2: Internal.Collection_<string>): Internal.Configuration;
        notify(): void;
        modules(): Internal.Set<Internal.ResolvedModule>;
        parents(): Internal.List<Internal.Configuration>;
        static empty(): Internal.Configuration;
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    type Configuration_ = Configuration;
    interface IEventHandler {
        onEvent(arg0: Internal.EventJS_): void;
    }
    type IEventHandler_ = ((arg0: Internal.EventJS) => void) | IEventHandler;
    interface IntUnaryOperator {
        applyAsInt(arg0: number): number;
        compose(arg0: Internal.IntUnaryOperator_): Internal.IntUnaryOperator;
        andThen(arg0: Internal.IntUnaryOperator_): Internal.IntUnaryOperator;
    }
    type IntUnaryOperator_ = ((arg0: number) => number) | IntUnaryOperator;
    class QuestProgressEventData <T> {
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        hashCode(): number;
        notifyAll(): void;
        equals(arg0: any): boolean;
        toString(): string;
        notify(): void;
        withObject<N>(o: N): Internal.QuestProgressEventData<N>;
        readonly teamData : Internal.TeamData;
        readonly onlineMembers : Internal.List<Internal.ServerPlayer>;
        readonly notifiedPlayers : Internal.List<Internal.ServerPlayer>;
        readonly time : Internal.Date;
        readonly object : T;
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    type QuestProgressEventData_<T> = QuestProgressEventData<T>;
    class MultiblockShapeInfo {
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        hashCode(): number;
        notifyAll(): void;
        equals(arg0: any): boolean;
        static builder(): Internal.MultiblockShapeInfo$Builder;
        toString(): string;
        getBlocks(): Internal.BlockInfo[][][];
        notify(): void;
        get blocks(): Internal.BlockInfo[][][];
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    type MultiblockShapeInfo_ = MultiblockShapeInfo;
    class Gson {
        getAdapter<T>(arg0: Internal.Class_<T>): Internal.TypeAdapter<T>;
        getAdapter<T>(arg0: Internal.TypeToken_<T>): Internal.TypeAdapter<T>;
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        excluder(): Internal.Excluder;
        notifyAll(): void;
        newBuilder(): Internal.GsonBuilder;
        notify(): void;
        newJsonReader(arg0: Internal.Reader_): Internal.JsonReader;
        serializeNulls(): boolean;
        toJson(arg0: any, arg1: java_.lang.reflect.Type_, arg2: Internal.JsonWriter_): void;
        toJson(arg0: any, arg1: java_.lang.reflect.Type_, arg2: Internal.Appendable_): void;
        toJson(arg0: any, arg1: Internal.Appendable_): void;
        toJson(arg0: Internal.JsonElement_, arg1: Internal.JsonWriter_): void;
        toJson(arg0: Internal.JsonElement_, arg1: Internal.Appendable_): void;
        toJson(arg0: any, arg1: java_.lang.reflect.Type_): string;
        toJson(arg0: Internal.JsonElement_): string;
        toJson(arg0: any): string;
        fieldNamingStrategy(): Internal.FieldNamingStrategy;
        newJsonWriter(arg0: Internal.Writer_): Internal.JsonWriter;
        hashCode(): number;
        equals(arg0: any): boolean;
        toJsonTree(arg0: any): Internal.JsonElement;
        toJsonTree(arg0: any, arg1: java_.lang.reflect.Type_): Internal.JsonElement;
        fromJson<T>(arg0: Internal.JsonElement_, arg1: Internal.Class_<T>): T;
        fromJson<T>(arg0: Internal.JsonElement_, arg1: java_.lang.reflect.Type_): T;
        fromJson<T>(arg0: string, arg1: java_.lang.reflect.Type_): T;
        fromJson<T>(arg0: string, arg1: Internal.Class_<T>): T;
        fromJson<T>(arg0: Internal.Reader_, arg1: Internal.Class_<T>): T;
        fromJson<T>(arg0: Internal.Reader_, arg1: java_.lang.reflect.Type_): T;
        fromJson<T>(arg0: Internal.JsonReader_, arg1: java_.lang.reflect.Type_): T;
        toString(): string;
        getDelegateAdapter<T>(arg0: Internal.TypeAdapterFactory_, arg1: Internal.TypeToken_<T>): Internal.TypeAdapter<T>;
        htmlSafe(): boolean;
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    type Gson_ = Gson;
    interface LongPredicate {
        or(arg0: Internal.LongPredicate_): Internal.LongPredicate;
        test(arg0: number): boolean;
        and(arg0: Internal.LongPredicate_): Internal.LongPredicate;
        negate(): Internal.LongPredicate;
    }
    type LongPredicate_ = ((arg0: number) => boolean) | LongPredicate;
    class RecipeLogic$Status extends Internal.Enum<Internal.RecipeLogic$Status> {
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        static valueOf(arg0: string): Internal.RecipeLogic$Status;
        static valueOf<T_>(arg0: Internal.Class_<T_>, arg1: string): T_;
        notifyAll(): void;
        static values(): Internal.RecipeLogic$Status[];
        compareTo(arg0: Internal.RecipeLogic$Status_): number;
        describeConstable(): Internal.Optional<Internal.Enum$EnumDesc<Internal.RecipeLogic$Status>>;
        notify(): void;
        getDeclaringClass(): Internal.Class<Internal.RecipeLogic$Status>;
        hashCode(): number;
        equals(arg0: any): boolean;
        name(): string;
        toString(): string;
        ordinal(): number;
        static readonly WORKING : Internal.RecipeLogic$Status;
        static readonly SUSPEND : Internal.RecipeLogic$Status;
        static readonly IDLE : Internal.RecipeLogic$Status;
        get class(): Internal.Class<any>;
        get declaringClass(): Internal.Class<Internal.RecipeLogic$Status>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    type RecipeLogic$Status_ = "suspend" | "idle" | "working" | RecipeLogic$Status;
    abstract class Toolkit {
        beep(): void;
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        isModalityTypeSupported(arg0: Internal.Dialog$ModalityType_): boolean;
        createDragGestureRecognizer<T>(arg0: Internal.Class_<T>, arg1: Internal.DragSource_, arg2: java_.awt.Component_, arg3: number, arg4: Internal.DragGestureListener_): T;
        notifyAll(): void;
        getScreenInsets(arg0: Internal.GraphicsConfiguration_): Internal.Insets;
        getMenuShortcutKeyMaskEx(): number;
        addAWTEventListener(arg0: Internal.AWTEventListener_, arg1: number): void;
        notify(): void;
        getLockingKeyState(arg0: number): boolean;
        getFontMetrics(arg0: Internal.Font_): Internal.FontMetrics;
        areExtraMouseButtonsEnabled(): boolean;
        getAWTEventListeners(arg0: number): Internal.AWTEventListener[];
        getAWTEventListeners(): Internal.AWTEventListener[];
        checkImage(arg0: Internal.Image_, arg1: number, arg2: number, arg3: Internal.ImageObserver_): number;
        getScreenResolution(): number;
        removeAWTEventListener(arg0: Internal.AWTEventListener_): void;
        getPrintJob(arg0: Internal.Frame_, arg1: string, arg2: Internal.Properties_): Internal.PrintJob;
        getPrintJob(arg0: Internal.Frame_, arg1: string, arg2: Internal.JobAttributes_, arg3: Internal.PageAttributes_): Internal.PrintJob;
        hashCode(): number;
        getSystemEventQueue(): Internal.EventQueue;
        getBestCursorSize(arg0: number, arg1: number): Internal.Dimension;
        createCustomCursor(arg0: Internal.Image_, arg1: Internal.Point_, arg2: string): Internal.Cursor;
        isFrameStateSupported(arg0: number): boolean;
        getScreenSize(): Internal.Dimension;
        addPropertyChangeListener(arg0: string, arg1: Internal.PropertyChangeListener_): void;
        isAlwaysOnTopSupported(): boolean;
        getSystemClipboard(): Internal.Clipboard;
        getDesktopProperty(arg0: string): any;
        getFontList(): string[];
        getColorModel(): Internal.ColorModel;
        getPropertyChangeListeners(): Internal.PropertyChangeListener[];
        getPropertyChangeListeners(arg0: string): Internal.PropertyChangeListener[];
        static getProperty(arg0: string, arg1: string): string;
        createImage(arg0: number[], arg1: number, arg2: number): Internal.Image;
        createImage(arg0: number[]): Internal.Image;
        createImage(arg0: Internal.ImageProducer_): Internal.Image;
        createImage(arg0: Internal.URL_): Internal.Image;
        createImage(arg0: string): Internal.Image;
        static getDefaultToolkit(): Internal.Toolkit;
        isDynamicLayoutActive(): boolean;
        getSystemSelection(): Internal.Clipboard;
        removePropertyChangeListener(arg0: string, arg1: Internal.PropertyChangeListener_): void;
        sync(): void;
        setLockingKeyState(arg0: number, arg1: boolean): void;
        isModalExclusionTypeSupported(arg0: Internal.Dialog$ModalExclusionType_): boolean;
        equals(arg0: any): boolean;
        prepareImage(arg0: Internal.Image_, arg1: number, arg2: number, arg3: Internal.ImageObserver_): boolean;
        toString(): string;
        getMenuShortcutKeyMask(): number;
        getMaximumCursorColors(): number;
        setDynamicLayout(arg0: boolean): void;
        getImage(arg0: string): Internal.Image;
        getImage(arg0: Internal.URL_): Internal.Image;
        mapInputMethodHighlight(arg0: Internal.InputMethodHighlight_): Internal.Map<Internal.TextAttribute, any>;
        get dynamicLayoutActive(): boolean;
        get menuShortcutKeyMaskEx(): number;
        get aWTEventListeners(): Internal.AWTEventListener[];
        get systemClipboard(): Internal.Clipboard;
        get fontList(): string[];
        get systemEventQueue(): Internal.EventQueue;
        get screenSize(): Internal.Dimension;
        get systemSelection(): Internal.Clipboard;
        get colorModel(): Internal.ColorModel;
        get maximumCursorColors(): number;
        get screenResolution(): number;
        get propertyChangeListeners(): Internal.PropertyChangeListener[];
        get class(): Internal.Class<any>;
        get alwaysOnTopSupported(): boolean;
        get defaultToolkit(): Internal.Toolkit;
        get menuShortcutKeyMask(): number;
        set dynamicLayout(arg0: boolean);
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    type Toolkit_ = Toolkit;
    interface Object2FloatFunction <K> extends Internal.Function<K, number>, Internal.ToDoubleFunction<K> {
        getOrDefault(arg0: any, arg1: number): number;
        applyAsDouble(arg0: K): number;
        andThenShort(arg0: Internal.Float2ShortFunction_): Internal.Object2ShortFunction<K>;
        composeByte(arg0: Internal.Byte2ObjectFunction_<K>): Internal.Byte2FloatFunction;
        getFloat(arg0: any): number;
        andThenInt(arg0: Internal.Float2IntFunction_): Internal.Object2IntFunction<K>;
        composeReference<T_>(arg0: Internal.Reference2ObjectFunction_<T_, K>): Internal.Reference2FloatFunction<T_>;
        andThen<T_>(arg0: java_.util.function_.Function_<number, T_>): java_.util.function_.Function<K, T_>;
        put(arg0: K, arg1: number): number;
        remove(arg0: any): number;
        defaultReturnValue(): number;
        defaultReturnValue(arg0: number): void;
        andThenDouble(arg0: Internal.Float2DoubleFunction_): Internal.Object2DoubleFunction<K>;
        andThenObject<T_>(arg0: Internal.Float2ObjectFunction_<T_>): Internal.Object2ObjectFunction<K, T_>;
        get(arg0: any): number;
        andThenLong(arg0: Internal.Float2LongFunction_): Internal.Object2LongFunction<K>;
        composeLong(arg0: Internal.Long2ObjectFunction_<K>): Internal.Long2FloatFunction;
        andThenByte(arg0: Internal.Float2ByteFunction_): Internal.Object2ByteFunction<K>;
        andThenFloat(arg0: Internal.Float2FloatFunction_): Internal.Object2FloatFunction<K>;
        removeFloat(arg0: any): number;
        apply(arg0: K): number;
        containsKey(arg0: any): boolean;
        composeInt(arg0: Internal.Int2ObjectFunction_<K>): Internal.Int2FloatFunction;
        clear(): void;
        composeFloat(arg0: Internal.Float2ObjectFunction_<K>): Internal.Float2FloatFunction;
        andThenChar(arg0: Internal.Float2CharFunction_): Internal.Object2CharFunction<K>;
        composeObject<T_>(arg0: Internal.Object2ObjectFunction_<T_, K>): Internal.Object2FloatFunction<T_>;
        size(): number;
        compose<V_>(arg0: java_.util.function_.Function_<V_, K>): java_.util.function_.Function<V_, number>;
        composeShort(arg0: Internal.Short2ObjectFunction_<K>): Internal.Short2FloatFunction;
        andThenReference<T_>(arg0: Internal.Float2ReferenceFunction_<T_>): Internal.Object2ReferenceFunction<K, T_>;
        composeChar(arg0: Internal.Char2ObjectFunction_<K>): Internal.Char2FloatFunction;
        composeDouble(arg0: Internal.Double2ObjectFunction_<K>): Internal.Double2FloatFunction;
    }
    type Object2FloatFunction_<K> = ((arg0: any) => number) | Object2FloatFunction<K>;
    class BlockItemBuilder extends Internal.ItemBuilder {
        barWidth(barWidth: Internal.ToIntFunction_<Internal.ItemStackJS_>): Internal.ItemBuilder;
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        clientRegistry(minecraft: Internal.Minecraft_): void;
        maxStackSize(v: number): Internal.ItemBuilder;
        transformObject(obj: Internal.Item_): Internal.Item;
        translationKey(key: string): Internal.BuilderBase<Internal.Item>;
        color(callback: Internal.ItemBuilder$ItemColorJS_): Internal.ItemBuilder;
        color(index: number, c: Internal.Color_): Internal.ItemBuilder;
        newID(pre: string, post: string): ResourceLocation;
        displayName(name: string): Internal.BuilderBase<Internal.Item>;
        use(use: Internal.ItemBuilder$UseCallback_): Internal.ItemBuilder;
        notifyAll(): void;
        maxDamage(v: number): Internal.ItemBuilder;
        textureJson(json: Internal.JsonObject_): Internal.ItemBuilder;
        tooltip(text: Internal.Component_): Internal.ItemBuilder;
        type(type: string): Internal.BuilderBase<Internal.Item>;
        barColor(barColor: java_.util.function_.Function_<Internal.ItemStackJS_, Internal.Color_>): Internal.ItemBuilder;
        containerItem(id: string): Internal.ItemBuilder;
        notify(): void;
        createAdditionalObjects(): void;
        subtypes(fn: java_.util.function_.Function_<Internal.ItemStackJS_, Internal.Collection_<Internal.ItemStackJS_>>): Internal.ItemBuilder;
        modelJson(json: Internal.JsonObject_): Internal.ItemBuilder;
        hashCode(): number;
        burnTime(v: number): Internal.ItemBuilder;
        get(): Internal.Item;
        useDuration(useDuration: Internal.ToIntFunction_<Internal.ItemStackJS_>): Internal.ItemBuilder;
        tag(tag: ResourceLocation_): Internal.BuilderBase<Internal.Item>;
        parentModel(m: string): Internal.ItemBuilder;
        generateDataJsons(generator: Internal.DataJsonGenerator_): void;
        group(g: string): Internal.ItemBuilder;
        generateAssetJsons(generator: Internal.AssetJsonGenerator_): void;
        getTranslationKeyGroup(): string;
        texture(key: string, tex: string): Internal.ItemBuilder;
        texture(tex: string): Internal.ItemBuilder;
        generateLang(lang: Internal.Map_<string, string>): void;
        static ofArmorMaterial(o: any): Internal.ArmorMaterial;
        food(b: Internal.Consumer_<Internal.FoodBuilder_>): Internal.ItemBuilder;
        createObject(): Internal.Item;
        releaseUsing(releaseUsing: Internal.ItemBuilder$ReleaseUsingCallback_): Internal.ItemBuilder;
        unstackable(): Internal.ItemBuilder;
        addResourcePackLocations(path: string, list: Internal.List_<ResourceLocation_>, packType: Internal.PackType_): void;
        modifyAttribute(attribute: ResourceLocation_, identifier: string, d: number, operation: Internal.AttributeModifier$Operation_): Internal.ItemBuilder;
        equals(arg0: any): boolean;
        getRegistryType(): Internal.RegistryObjectBuilderTypes<Internal.Item>;
        toString(): string;
        finishUsing(finishUsing: Internal.ItemBuilder$FinishUsingCallback_): Internal.ItemBuilder;
        glow(v: boolean): Internal.ItemBuilder;
        useAnimation(animation: Internal.UseAnim_): Internal.ItemBuilder;
        rarity(v: Rarity_): Internal.ItemBuilder;
        createItemProperties(): Internal.Item$Properties;
        static readonly TOOL_TIERS : {"gold":any,"diamond":any,"iron":any,"wood":any,"stone":any,"netherite":any};
        static readonly ARMOR_TIERS : {"gold":any,"chain":any,"diamond":any,"turtle":any,"iron":any,"leather":any,"netherite":any};
        blockBuilder : Internal.BlockBuilder;
        readonly id : ResourceLocation;
        get registryType(): Internal.RegistryObjectBuilderTypes<Internal.Item>;
        get class(): Internal.Class<any>;
        get translationKeyGroup(): string;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    type BlockItemBuilder_ = BlockItemBuilder;
    interface MethodHandleInfo {
        getReferenceKind(): number;
        getDeclaringClass(): Internal.Class<any>;
        getName(): string;
        isVarArgs(): boolean;
        getMethodType(): Internal.MethodType;
        reflectAs<T>(arg0: Internal.Class_<T>, arg1: Internal.MethodHandles$Lookup_): T;
        getModifiers(): number;
    }
    type MethodHandleInfo_ = MethodHandleInfo;
    interface FuncSupplier {
        create(arg0: Internal.List_<dev.latvian.mods.rhino.util.unit.Unit_>): dev.latvian.mods.rhino.util.unit.Unit;
    }
    type FuncSupplier_ = ((arg0: Internal.List<dev.latvian.mods.rhino.util.unit.Unit>) => dev.latvian.mods.rhino.util.unit.Unit) | FuncSupplier;
    interface FloatBinaryOperator extends Internal.BinaryOperator<number>, Internal.DoubleBinaryOperator {
        applyAsDouble(arg0: number, arg1: number): number;
        apply(arg0: number, arg1: number): number;
        andThen<V_>(arg0: java_.util.function_.Function_<number, V_>): Internal.BiFunction<number, number, V_>;
    }
    type FloatBinaryOperator_ = ((arg0: number, arg1: number) => number) | FloatBinaryOperator;
    interface Member {
        getDeclaringClass(): Internal.Class<any>;
        getName(): string;
        isSynthetic(): boolean;
        getModifiers(): number;
    }
    type Member_ = Member;
    class BlockState extends Internal.BlockBehaviour$BlockStateBase implements Internal.IForgeBlockState, Internal.BlockStateFTBC {
        rotate(arg0: Internal.LevelAccessor_, arg1: BlockPos_, arg2: Internal.Rotation_): Internal.BlockState;
        getClass(): Internal.Class<any>;
        getStateAtViewpoint(arg0: Internal.BlockGetter_, arg1: BlockPos_, arg2: Vec3_): Internal.BlockState;
        onBlockExploded(arg0: Internal.Level_, arg1: BlockPos_, arg2: Internal.Explosion_): void;
        getBedDirection(arg0: Internal.LevelReader_, arg1: BlockPos_): Internal.Direction;
        isBed(arg0: Internal.BlockGetter_, arg1: BlockPos_, arg2: Internal.LivingEntity_): boolean;
        canHarvestBlock(arg0: Internal.BlockGetter_, arg1: BlockPos_, arg2: Internal.Player_): boolean;
        isLadder(arg0: Internal.LevelReader_, arg1: BlockPos_, arg2: Internal.LivingEntity_): boolean;
        shouldDisplayFluidOverlay(arg0: Internal.BlockAndTintGetter_, arg1: BlockPos_, arg2: Internal.FluidState_): boolean;
        getFTBCIsWater(): boolean;
        canStickTo(arg0: Internal.BlockState_): boolean;
        onNeighborChange(arg0: Internal.LevelReader_, arg1: BlockPos_, arg2: BlockPos_): void;
        getWeakChanges(arg0: Internal.LevelReader_, arg1: BlockPos_): boolean;
        canEntityDestroy(arg0: Internal.BlockGetter_, arg1: BlockPos_, arg2: Internal.Entity_): boolean;
        isBurning(arg0: Internal.BlockGetter_, arg1: BlockPos_): boolean;
        getFriction(arg0: Internal.LevelReader_, arg1: BlockPos_, arg2: Internal.Entity_): number;
        isValidSpawn(arg0: Internal.LevelReader_, arg1: BlockPos_, arg2: Internal.SpawnPlacements$Type_, arg3: Internal.EntityType_<any>): boolean;
        isPortalFrame(arg0: Internal.BlockGetter_, arg1: BlockPos_): boolean;
        getExplosionResistance(arg0: Internal.BlockGetter_, arg1: BlockPos_, arg2: Internal.Explosion_): number;
        canSustainPlant(arg0: Internal.BlockGetter_, arg1: BlockPos_, arg2: Internal.Direction_, arg3: Internal.IPlantable_): boolean;
        isScaffolding(arg0: Internal.LivingEntity_): boolean;
        canDropFromExplosion(arg0: Internal.BlockGetter_, arg1: BlockPos_, arg2: Internal.Explosion_): boolean;
        canRedstoneConnectTo(arg0: Internal.BlockGetter_, arg1: BlockPos_, arg2: Internal.Direction_): boolean;
        isStickyBlock(): boolean;
        isFertile(arg0: Internal.BlockGetter_, arg1: BlockPos_): boolean;
        isSlimeBlock(): boolean;
        getFireSpreadSpeed(arg0: Internal.BlockGetter_, arg1: BlockPos_, arg2: Internal.Direction_): number;
        getToolModifiedState(arg0: Internal.UseOnContext_, arg1: Internal.ToolAction_, arg2: boolean): Internal.BlockState;
        getToolModifiedState(arg0: Internal.Level_, arg1: BlockPos_, arg2: Internal.Player_, arg3: Internal.ItemStack_, arg4: Internal.ToolAction_): Internal.BlockState;
        getBeaconColorMultiplier(arg0: Internal.LevelReader_, arg1: BlockPos_, arg2: BlockPos_): number[];
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        getExpDrop(arg0: Internal.LevelReader_, arg1: BlockPos_, arg2: number, arg3: number): number;
        isConduitFrame(arg0: Internal.LevelReader_, arg1: BlockPos_, arg2: BlockPos_): boolean;
        notifyAll(): void;
        getLightEmission(arg0: Internal.BlockGetter_, arg1: BlockPos_): number;
        onDestroyedByPlayer(arg0: Internal.Level_, arg1: BlockPos_, arg2: Internal.Player_, arg3: boolean, arg4: Internal.FluidState_): boolean;
        shouldCheckWeakPower(arg0: Internal.LevelReader_, arg1: BlockPos_, arg2: Internal.Direction_): boolean;
        collisionExtendsVertically(arg0: Internal.BlockGetter_, arg1: BlockPos_, arg2: Internal.Entity_): boolean;
        notify(): void;
        supportsExternalFaceHiding(): boolean;
        addLandingEffects(arg0: Internal.ServerLevel_, arg1: BlockPos_, arg2: Internal.BlockState_, arg3: Internal.LivingEntity_, arg4: number): boolean;
        getSoundType(arg0: Internal.LevelReader_, arg1: BlockPos_, arg2: Internal.Entity_): Internal.SoundType;
        hashCode(): number;
        addRunningEffects(arg0: Internal.Level_, arg1: BlockPos_, arg2: Internal.Entity_): boolean;
        hidesNeighborFace(arg0: Internal.BlockGetter_, arg1: BlockPos_, arg2: Internal.BlockState_, arg3: Internal.Direction_): boolean;
        getCloneItemStack(arg0: Internal.HitResult_, arg1: Internal.BlockGetter_, arg2: BlockPos_, arg3: Internal.Player_): Internal.ItemStack;
        isFlammable(arg0: Internal.BlockGetter_, arg1: BlockPos_, arg2: Internal.Direction_): boolean;
        getBlockPathType(arg0: Internal.BlockGetter_, arg1: BlockPos_): Internal.BlockPathTypes;
        getBlockPathType(arg0: Internal.BlockGetter_, arg1: BlockPos_, arg2: Internal.Mob_): Internal.BlockPathTypes;
        onCaughtFire(arg0: Internal.Level_, arg1: BlockPos_, arg2: Internal.Direction_, arg3: Internal.LivingEntity_): void;
        getEnchantPowerBonus(arg0: Internal.LevelReader_, arg1: BlockPos_): number;
        setBedOccupied(arg0: Internal.Level_, arg1: BlockPos_, arg2: Internal.LivingEntity_, arg3: boolean): void;
        isFireSource(arg0: Internal.LevelReader_, arg1: BlockPos_, arg2: Internal.Direction_): boolean;
        getRespawnPosition(arg0: Internal.EntityType_<any>, arg1: Internal.LevelReader_, arg2: BlockPos_, arg3: number, arg4: Internal.LivingEntity_): Internal.Optional<Vec3>;
        equals(arg0: any): boolean;
        toString(): string;
        getFlammability(arg0: Internal.BlockGetter_, arg1: BlockPos_, arg2: Internal.Direction_): number;
        get stickyBlock(): boolean;
        get slimeBlock(): boolean;
        get fTBCIsWater(): boolean;
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    type BlockState_ = BlockState;
    interface ContainerEventHandler extends Internal.GuiEventListener {
    }
    type ContainerEventHandler_ = ContainerEventHandler;
    abstract class MappedByteBuffer extends Internal.ByteBuffer {
        asIntBuffer(): Internal.IntBuffer;
        getClass(): Internal.Class<any>;
        compact(): Internal.MappedByteBuffer;
        asLongBuffer(): Internal.LongBuffer;
        compareTo(arg0: Internal.ByteBuffer_): number;
        isLoaded(): boolean;
        put(arg0: Internal.ByteBuffer_): Internal.ByteBuffer;
        put(arg0: number, arg1: number): Internal.ByteBuffer;
        put(arg0: number[]): Internal.ByteBuffer;
        put(arg0: number, arg1: number[], arg2: number, arg3: number): Internal.ByteBuffer;
        put(arg0: number, arg1: number[]): Internal.ByteBuffer;
        put(arg0: number): Internal.ByteBuffer;
        put(arg0: number, arg1: Internal.ByteBuffer_, arg2: number, arg3: number): Internal.ByteBuffer;
        put(arg0: number[], arg1: number, arg2: number): Internal.ByteBuffer;
        slice(arg0: number, arg1: number): Internal.MappedByteBuffer;
        slice(): Internal.MappedByteBuffer;
        limit(arg0: number): Internal.MappedByteBuffer;
        limit(): number;
        order(arg0: Internal.ByteOrder_): Internal.ByteBuffer;
        order(): Internal.ByteOrder;
        asFloatBuffer(): Internal.FloatBuffer;
        asCharBuffer(): Internal.CharBuffer;
        static allocateDirect(arg0: number): Internal.ByteBuffer;
        putInt(arg0: number, arg1: number): Internal.ByteBuffer;
        putInt(arg0: number): Internal.ByteBuffer;
        duplicate(): Internal.MappedByteBuffer;
        remaining(): number;
        putFloat(arg0: number, arg1: number): Internal.ByteBuffer;
        putFloat(arg0: number): Internal.ByteBuffer;
        getInt(arg0: number): number;
        getInt(): number;
        getChar(): string;
        getChar(arg0: number): string;
        static allocate(arg0: number): Internal.ByteBuffer;
        reset(): Internal.MappedByteBuffer;
        force(): Internal.MappedByteBuffer;
        force(arg0: number, arg1: number): Internal.MappedByteBuffer;
        position(arg0: number): Internal.MappedByteBuffer;
        position(): number;
        asShortBuffer(): Internal.ShortBuffer;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        notifyAll(): void;
        putDouble(arg0: number, arg1: number): Internal.ByteBuffer;
        putDouble(arg0: number): Internal.ByteBuffer;
        getDouble(arg0: number): number;
        getDouble(): number;
        getFloat(): number;
        getFloat(arg0: number): number;
        putLong(arg0: number, arg1: number): Internal.ByteBuffer;
        putLong(arg0: number): Internal.ByteBuffer;
        notify(): void;
        asReadOnlyBuffer(): Internal.ByteBuffer;
        capacity(): number;
        isReadOnly(): boolean;
        load(): Internal.MappedByteBuffer;
        asDoubleBuffer(): Internal.DoubleBuffer;
        array(): number[];
        hashCode(): number;
        get(arg0: number): number;
        get(): number;
        get(arg0: number[], arg1: number, arg2: number): Internal.ByteBuffer;
        get(arg0: number, arg1: number[]): Internal.ByteBuffer;
        get(arg0: number, arg1: number[], arg2: number, arg3: number): Internal.ByteBuffer;
        get(arg0: number[]): Internal.ByteBuffer;
        arrayOffset(): number;
        putShort(arg0: number, arg1: number): Internal.ByteBuffer;
        putShort(arg0: number): Internal.ByteBuffer;
        flip(): Internal.MappedByteBuffer;
        hasArray(): boolean;
        getShort(): number;
        getShort(arg0: number): number;
        putChar(arg0: number, arg1: string): Internal.ByteBuffer;
        putChar(arg0: string): Internal.ByteBuffer;
        hasRemaining(): boolean;
        clear(): Internal.MappedByteBuffer;
        getLong(arg0: number): number;
        getLong(): number;
        alignmentOffset(arg0: number, arg1: number): number;
        rewind(): Internal.MappedByteBuffer;
        mismatch(arg0: Internal.ByteBuffer_): number;
        equals(arg0: any): boolean;
        toString(): string;
        alignedSlice(arg0: number): Internal.ByteBuffer;
        isDirect(): boolean;
        static wrap(arg0: number[], arg1: number, arg2: number): Internal.ByteBuffer;
        static wrap(arg0: number[]): Internal.ByteBuffer;
        mark(): Internal.MappedByteBuffer;
        get loaded(): boolean;
        get double(): number;
        get char(): string;
        get direct(): boolean;
        get short(): number;
        get readOnly(): boolean;
        get float(): number;
        get class(): Internal.Class<any>;
        get int(): number;
        get long(): number;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    type MappedByteBuffer_ = MappedByteBuffer;
    interface Hash {
    }
    type Hash_ = Hash;
    class GameProfile {
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        getName(): string;
        isLegacy(): boolean;
        hashCode(): number;
        notifyAll(): void;
        getProperties(): Internal.PropertyMap;
        equals(arg0: any): boolean;
        getId(): Internal.UUID;
        toString(): string;
        notify(): void;
        isComplete(): boolean;
        get legacy(): boolean;
        get name(): string;
        get id(): Internal.UUID;
        get complete(): boolean;
        get class(): Internal.Class<any>;
        get properties(): Internal.PropertyMap;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    type GameProfile_ = GameProfile;
    abstract class Mob extends Internal.LivingEntity implements Internal.AccessorMob, vazkii.botania.mixin.AccessorMob {
        getClass(): Internal.Class<any>;
        resetDynamicLight(): void;
        getCapability<T_>(arg0: Internal.Capability_<T_>, arg1: Internal.Direction_): Internal.LazyOptional<T_>;
        getCapability<T_>(arg0: Internal.Capability_<T_>): Internal.LazyOptional<T_>;
        captureDrops(arg0: Internal.Collection_<Internal.ItemEntity_>): Internal.Collection<Internal.ItemEntity>;
        captureDrops(): Internal.Collection<Internal.ItemEntity>;
        canBeRiddenInWater(arg0: Internal.Entity_): boolean;
        setCitadelEntityData(arg0: Internal.CompoundTag_): void;
        isDynamicLightEnabled(): boolean;
        changeDimension(arg0: Internal.ServerLevel_, arg1: Internal.ITeleporter_): Internal.Entity;
        serializeNBT(): Internal.CompoundTag;
        invalidateCaps(): void;
        setDynamicLightEnabled(arg0: boolean): void;
        shouldUpdateDynamicLight(): boolean;
        foodEatenKJS(is: Internal.ItemStack_): void;
        revive(): void;
        setVisualScale(arg0: number): void;
        dynamicLightTick(): void;
        getPersistentDataKJS(): Internal.CompoundTag;
        canUpdate(): boolean;
        canUpdate(arg0: boolean): void;
        getDynamicLightY(): number;
        getDynamicLightZ(): number;
        handler$zbj000$curio$canFreeze(arg0: Internal.CallbackInfoReturnable_<any>): void;
        getDynamicLightX(): number;
        areCapsCompatible(arg0: Internal.CapabilityProvider_<Internal.Entity_>): boolean;
        areCapsCompatible(arg0: Internal.CapabilityDispatcher_): boolean;
        redirect$bie002$elytraOverride(arg0: Internal.ItemStack_, arg1: Internal.LivingEntity_): boolean;
        getEyeHeightAccess(arg0: Internal.Pose_, arg1: Internal.EntityDimensions_): number;
        reviveCaps(): void;
        lambdynlights$updateDynamicLight(arg0: Internal.LevelRenderer_): boolean;
        handler$bih000$removed(arg0: Internal.CallbackInfo_): void;
        canRiderInteract(): boolean;
        lambdynlights$scheduleTrackedChunksRebuild(arg0: Internal.LevelRenderer_): void;
        handler$bih001$onTick(arg0: Internal.CallbackInfo_): void;
        onAddedToWorld(): void;
        canTrample(arg0: Internal.BlockState_, arg1: BlockPos_, arg2: number): boolean;
        getCitadelEntityData(): Internal.CompoundTag;
        getClassification(arg0: boolean): Internal.MobCategory;
        handler$bih000$onRemove(arg0: Internal.CallbackInfo_): void;
        shouldRiderSit(): boolean;
        getPickedResult(arg0: Internal.HitResult_): Internal.ItemStack;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        notifyAll(): void;
        isActuallyReallyBlocking(): boolean;
        getPersistentData(): Internal.CompoundTag;
        notify(): void;
        redirect$bie000$eytraValidOverride(arg0: Internal.ItemStack_, arg1: Internal.LivingEntity_, arg2: number): boolean;
        hashCode(): number;
        setDimension(arg0: Internal.EntityDimensions_): void;
        isAddedToWorld(): boolean;
        getParts(): any[];
        getDynamicLightWorld(): Internal.Level;
        onRemovedFromWorld(): void;
        getLuminance(): number;
        isMultipartEntity(): boolean;
        deserializeNBT(arg0: Internal.CompoundTag_): void;
        curePotionEffects(arg0: Internal.ItemStack_): boolean;
        asKJS(): any;
        shouldRiderFaceForward(arg0: Internal.Player_): boolean;
        equals(arg0: any): boolean;
        toString(): string;
        getVisualScale(): number;
        get luminance(): number;
        get dynamicLightEnabled(): boolean;
        get citadelEntityData(): Internal.CompoundTag;
        get persistentData(): Internal.CompoundTag;
        get multipartEntity(): boolean;
        get addedToWorld(): boolean;
        get dynamicLightY(): number;
        get dynamicLightZ(): number;
        get dynamicLightX(): number;
        get visualScale(): number;
        get persistentDataKJS(): Internal.CompoundTag;
        get actuallyReallyBlocking(): boolean;
        get parts(): any[];
        get class(): Internal.Class<any>;
        get dynamicLightWorld(): Internal.Level;
        set dynamicLightEnabled(arg0: boolean);
        set visualScale(arg0: number);
        set citadelEntityData(arg0: Internal.CompoundTag_);
        set dimension(arg0: Internal.EntityDimensions_);
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    type Mob_ = Mob;
    interface IntStream$Builder extends java_.util.function_.IntConsumer {
        add(arg0: number): Internal.IntStream$Builder;
        build(): Internal.IntStream;
        andThen(arg0: java_.util.function_.IntConsumer_): java_.util.function_.IntConsumer;
        accept(arg0: number): void;
    }
    type IntStream$Builder_ = IntStream$Builder;
    interface Kind1 <F, Mu> extends Internal.App<Mu, F> {
        group<T1_, T2_, T3_, T4_, T5_, T6_, T7_, T8_, T9_, T10_, T11_>(arg0: Internal.App_<Mu, T1_>, arg1: Internal.App_<Mu, T2_>, arg2: Internal.App_<Mu, T3_>, arg3: Internal.App_<Mu, T4_>, arg4: Internal.App_<Mu, T5_>, arg5: Internal.App_<Mu, T6_>, arg6: Internal.App_<Mu, T7_>, arg7: Internal.App_<Mu, T8_>, arg8: Internal.App_<Mu, T9_>, arg9: Internal.App_<Mu, T10_>, arg10: Internal.App_<Mu, T11_>): Internal.Products$P11<Mu, T1_, T2_, T3_, T4_, T5_, T6_, T7_, T8_, T9_, T10_, T11_>;
        group<T1_, T2_, T3_, T4_, T5_, T6_, T7_, T8_, T9_, T10_>(arg0: Internal.App_<Mu, T1_>, arg1: Internal.App_<Mu, T2_>, arg2: Internal.App_<Mu, T3_>, arg3: Internal.App_<Mu, T4_>, arg4: Internal.App_<Mu, T5_>, arg5: Internal.App_<Mu, T6_>, arg6: Internal.App_<Mu, T7_>, arg7: Internal.App_<Mu, T8_>, arg8: Internal.App_<Mu, T9_>, arg9: Internal.App_<Mu, T10_>): Internal.Products$P10<Mu, T1_, T2_, T3_, T4_, T5_, T6_, T7_, T8_, T9_, T10_>;
        group<T1_, T2_, T3_, T4_, T5_, T6_, T7_, T8_, T9_>(arg0: Internal.App_<Mu, T1_>, arg1: Internal.App_<Mu, T2_>, arg2: Internal.App_<Mu, T3_>, arg3: Internal.App_<Mu, T4_>, arg4: Internal.App_<Mu, T5_>, arg5: Internal.App_<Mu, T6_>, arg6: Internal.App_<Mu, T7_>, arg7: Internal.App_<Mu, T8_>, arg8: Internal.App_<Mu, T9_>): Internal.Products$P9<Mu, T1_, T2_, T3_, T4_, T5_, T6_, T7_, T8_, T9_>;
        group<T1_, T2_, T3_, T4_, T5_, T6_, T7_, T8_, T9_, T10_, T11_, T12_, T13_, T14_, T15_, T16_>(arg0: Internal.App_<Mu, T1_>, arg1: Internal.App_<Mu, T2_>, arg2: Internal.App_<Mu, T3_>, arg3: Internal.App_<Mu, T4_>, arg4: Internal.App_<Mu, T5_>, arg5: Internal.App_<Mu, T6_>, arg6: Internal.App_<Mu, T7_>, arg7: Internal.App_<Mu, T8_>, arg8: Internal.App_<Mu, T9_>, arg9: Internal.App_<Mu, T10_>, arg10: Internal.App_<Mu, T11_>, arg11: Internal.App_<Mu, T12_>, arg12: Internal.App_<Mu, T13_>, arg13: Internal.App_<Mu, T14_>, arg14: Internal.App_<Mu, T15_>, arg15: Internal.App_<Mu, T16_>): Internal.Products$P16<Mu, T1_, T2_, T3_, T4_, T5_, T6_, T7_, T8_, T9_, T10_, T11_, T12_, T13_, T14_, T15_, T16_>;
        group<T1_, T2_, T3_, T4_, T5_, T6_, T7_, T8_, T9_, T10_, T11_, T12_, T13_, T14_, T15_>(arg0: Internal.App_<Mu, T1_>, arg1: Internal.App_<Mu, T2_>, arg2: Internal.App_<Mu, T3_>, arg3: Internal.App_<Mu, T4_>, arg4: Internal.App_<Mu, T5_>, arg5: Internal.App_<Mu, T6_>, arg6: Internal.App_<Mu, T7_>, arg7: Internal.App_<Mu, T8_>, arg8: Internal.App_<Mu, T9_>, arg9: Internal.App_<Mu, T10_>, arg10: Internal.App_<Mu, T11_>, arg11: Internal.App_<Mu, T12_>, arg12: Internal.App_<Mu, T13_>, arg13: Internal.App_<Mu, T14_>, arg14: Internal.App_<Mu, T15_>): Internal.Products$P15<Mu, T1_, T2_, T3_, T4_, T5_, T6_, T7_, T8_, T9_, T10_, T11_, T12_, T13_, T14_, T15_>;
        group<T1_, T2_, T3_, T4_, T5_, T6_, T7_, T8_, T9_, T10_, T11_, T12_, T13_, T14_>(arg0: Internal.App_<Mu, T1_>, arg1: Internal.App_<Mu, T2_>, arg2: Internal.App_<Mu, T3_>, arg3: Internal.App_<Mu, T4_>, arg4: Internal.App_<Mu, T5_>, arg5: Internal.App_<Mu, T6_>, arg6: Internal.App_<Mu, T7_>, arg7: Internal.App_<Mu, T8_>, arg8: Internal.App_<Mu, T9_>, arg9: Internal.App_<Mu, T10_>, arg10: Internal.App_<Mu, T11_>, arg11: Internal.App_<Mu, T12_>, arg12: Internal.App_<Mu, T13_>, arg13: Internal.App_<Mu, T14_>): Internal.Products$P14<Mu, T1_, T2_, T3_, T4_, T5_, T6_, T7_, T8_, T9_, T10_, T11_, T12_, T13_, T14_>;
        group<T1_, T2_, T3_, T4_, T5_, T6_, T7_, T8_, T9_, T10_, T11_, T12_, T13_>(arg0: Internal.App_<Mu, T1_>, arg1: Internal.App_<Mu, T2_>, arg2: Internal.App_<Mu, T3_>, arg3: Internal.App_<Mu, T4_>, arg4: Internal.App_<Mu, T5_>, arg5: Internal.App_<Mu, T6_>, arg6: Internal.App_<Mu, T7_>, arg7: Internal.App_<Mu, T8_>, arg8: Internal.App_<Mu, T9_>, arg9: Internal.App_<Mu, T10_>, arg10: Internal.App_<Mu, T11_>, arg11: Internal.App_<Mu, T12_>, arg12: Internal.App_<Mu, T13_>): Internal.Products$P13<Mu, T1_, T2_, T3_, T4_, T5_, T6_, T7_, T8_, T9_, T10_, T11_, T12_, T13_>;
        group<T1_, T2_, T3_, T4_, T5_, T6_, T7_, T8_, T9_, T10_, T11_, T12_>(arg0: Internal.App_<Mu, T1_>, arg1: Internal.App_<Mu, T2_>, arg2: Internal.App_<Mu, T3_>, arg3: Internal.App_<Mu, T4_>, arg4: Internal.App_<Mu, T5_>, arg5: Internal.App_<Mu, T6_>, arg6: Internal.App_<Mu, T7_>, arg7: Internal.App_<Mu, T8_>, arg8: Internal.App_<Mu, T9_>, arg9: Internal.App_<Mu, T10_>, arg10: Internal.App_<Mu, T11_>, arg11: Internal.App_<Mu, T12_>): Internal.Products$P12<Mu, T1_, T2_, T3_, T4_, T5_, T6_, T7_, T8_, T9_, T10_, T11_, T12_>;
        group<T1_, T2_, T3_>(arg0: Internal.App_<Mu, T1_>, arg1: Internal.App_<Mu, T2_>, arg2: Internal.App_<Mu, T3_>): Internal.Products$P3<Mu, T1_, T2_, T3_>;
        group<T1_, T2_>(arg0: Internal.App_<Mu, T1_>, arg1: Internal.App_<Mu, T2_>): Internal.Products$P2<Mu, T1_, T2_>;
        group<T1_>(arg0: Internal.App_<Mu, T1_>): Internal.Products$P1<Mu, T1_>;
        group<T1_, T2_, T3_, T4_, T5_, T6_, T7_, T8_>(arg0: Internal.App_<Mu, T1_>, arg1: Internal.App_<Mu, T2_>, arg2: Internal.App_<Mu, T3_>, arg3: Internal.App_<Mu, T4_>, arg4: Internal.App_<Mu, T5_>, arg5: Internal.App_<Mu, T6_>, arg6: Internal.App_<Mu, T7_>, arg7: Internal.App_<Mu, T8_>): Internal.Products$P8<Mu, T1_, T2_, T3_, T4_, T5_, T6_, T7_, T8_>;
        group<T1_, T2_, T3_, T4_, T5_, T6_, T7_>(arg0: Internal.App_<Mu, T1_>, arg1: Internal.App_<Mu, T2_>, arg2: Internal.App_<Mu, T3_>, arg3: Internal.App_<Mu, T4_>, arg4: Internal.App_<Mu, T5_>, arg5: Internal.App_<Mu, T6_>, arg6: Internal.App_<Mu, T7_>): Internal.Products$P7<Mu, T1_, T2_, T3_, T4_, T5_, T6_, T7_>;
        group<T1_, T2_, T3_, T4_, T5_, T6_>(arg0: Internal.App_<Mu, T1_>, arg1: Internal.App_<Mu, T2_>, arg2: Internal.App_<Mu, T3_>, arg3: Internal.App_<Mu, T4_>, arg4: Internal.App_<Mu, T5_>, arg5: Internal.App_<Mu, T6_>): Internal.Products$P6<Mu, T1_, T2_, T3_, T4_, T5_, T6_>;
        group<T1_, T2_, T3_, T4_, T5_>(arg0: Internal.App_<Mu, T1_>, arg1: Internal.App_<Mu, T2_>, arg2: Internal.App_<Mu, T3_>, arg3: Internal.App_<Mu, T4_>, arg4: Internal.App_<Mu, T5_>): Internal.Products$P5<Mu, T1_, T2_, T3_, T4_, T5_>;
        group<T1_, T2_, T3_, T4_>(arg0: Internal.App_<Mu, T1_>, arg1: Internal.App_<Mu, T2_>, arg2: Internal.App_<Mu, T3_>, arg3: Internal.App_<Mu, T4_>): Internal.Products$P4<Mu, T1_, T2_, T3_, T4_>;
    }
    type Kind1_<F, Mu> = Kind1<F, Mu>;
    /**
    * Fired to register special handlers for tooltips on items.
    */
    class ItemTooltipEventJS extends Internal.EventJS {
        cancel(): void;
        /**
        *
        * Adds a line (or lines) to the end of tooltip.
        */
        add(item: internal.IngredientJS_, text: Internal.Component_ | Internal.Component_[]): void;
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        isCancelled(): boolean;
        isAlt(): boolean;
        notifyAll(): void;
        addAdvancedToAll(handler: Internal.ItemTooltipEventJS$StaticTooltipHandlerFromJS_): void;
        notify(): void;
        post(t: Internal.ScriptType_, id: string, sub: string): boolean;
        post(t: Internal.ScriptType_, id: string): boolean;
        isCtrl(): boolean;
        hashCode(): number;
        isShift(): boolean;
        /**
        * Adds a callback to the item, will be invoked when the tooltip is rendering.
        */
        addAdvanced(item: internal.IngredientJS_, handler: (itemstack: Internal.ItemStackJS, advanced: boolean, lines: Internal.List<string>) => void): void;
        equals(arg0: any): boolean;
        toString(): string;
        addToAll(text: any): void;
        canCancel(): boolean;
        get ctrl(): boolean;
        get shift(): boolean;
        get alt(): boolean;
        get cancelled(): boolean;
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    /**
    * Fired to register special handlers for tooltips on items.
    */
    type ItemTooltipEventJS_ = ItemTooltipEventJS;
    class MobEffectCategory extends Internal.Enum<Internal.MobEffectCategory> {
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        static valueOf(arg0: string): Internal.MobEffectCategory;
        static valueOf<T_>(arg0: Internal.Class_<T_>, arg1: string): T_;
        notifyAll(): void;
        static values(): Internal.MobEffectCategory[];
        compareTo(arg0: Internal.MobEffectCategory_): number;
        describeConstable(): Internal.Optional<Internal.Enum$EnumDesc<Internal.MobEffectCategory>>;
        notify(): void;
        getDeclaringClass(): Internal.Class<Internal.MobEffectCategory>;
        hashCode(): number;
        equals(arg0: any): boolean;
        name(): string;
        toString(): string;
        ordinal(): number;
        static readonly HARMFUL : Internal.MobEffectCategory;
        static readonly BENEFICIAL : Internal.MobEffectCategory;
        static readonly NEUTRAL : Internal.MobEffectCategory;
        get class(): Internal.Class<any>;
        get declaringClass(): Internal.Class<Internal.MobEffectCategory>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    type MobEffectCategory_ = "beneficial" | "neutral" | "harmful" | MobEffectCategory;
    class ScriptPackInfo {
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        hashCode(): number;
        notifyAll(): void;
        equals(arg0: any): boolean;
        toString(): string;
        notify(): void;
        readonly displayName : Internal.Component;
        readonly namespace : string;
        readonly pathStart : string;
        readonly scripts : Internal.List<Internal.ScriptFileInfo>;
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    type ScriptPackInfo_ = ScriptPackInfo;
    class SimpleCommandExceptionType implements Internal.CommandExceptionType {
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        createWithContext(arg0: Internal.ImmutableStringReader_): Internal.CommandSyntaxException;
        hashCode(): number;
        notifyAll(): void;
        equals(arg0: any): boolean;
        create(): Internal.CommandSyntaxException;
        toString(): string;
        notify(): void;
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    type SimpleCommandExceptionType_ = SimpleCommandExceptionType;
    class AWTKeyStroke implements Internal.Serializable {
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        notifyAll(): void;
        isOnKeyRelease(): boolean;
        static getAWTKeyStroke(arg0: number, arg1: number, arg2: boolean): Internal.AWTKeyStroke;
        static getAWTKeyStroke(arg0: string): Internal.AWTKeyStroke;
        static getAWTKeyStroke(arg0: number, arg1: number): Internal.AWTKeyStroke;
        static getAWTKeyStroke(arg0: string, arg1: number): Internal.AWTKeyStroke;
        notify(): void;
        getKeyChar(): string;
        hashCode(): number;
        equals(arg0: any): boolean;
        static getAWTKeyStrokeForEvent(arg0: Internal.KeyEvent_): Internal.AWTKeyStroke;
        toString(): string;
        getModifiers(): number;
        getKeyCode(): number;
        getKeyEventType(): number;
        get onKeyRelease(): boolean;
        get keyCode(): number;
        get keyEventType(): number;
        get keyChar(): string;
        get modifiers(): number;
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    type AWTKeyStroke_ = AWTKeyStroke;
    interface ContainerListener extends Internal.EventListener {
        componentRemoved(arg0: Internal.ContainerEvent_): void;
        componentAdded(arg0: Internal.ContainerEvent_): void;
    }
    type ContainerListener_ = ContainerListener;
    abstract class AWTEvent extends Internal.EventObject {
        getClass(): Internal.Class<any>;
        setSource(arg0: any): void;
        paramString(): string;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        hashCode(): number;
        getSource(): any;
        notifyAll(): void;
        equals(arg0: any): boolean;
        getID(): number;
        toString(): string;
        notify(): void;
        static readonly ADJUSTMENT_EVENT_MASK : 256;
        static readonly MOUSE_EVENT_MASK : 16;
        static readonly COMPONENT_EVENT_MASK : 1;
        static readonly PAINT_EVENT_MASK : 8192;
        static readonly INPUT_METHOD_EVENT_MASK : 2048;
        static readonly HIERARCHY_BOUNDS_EVENT_MASK : 65536;
        static readonly FOCUS_EVENT_MASK : 4;
        static readonly TEXT_EVENT_MASK : 1024;
        static readonly INVOCATION_EVENT_MASK : 16384;
        static readonly KEY_EVENT_MASK : 8;
        static readonly RESERVED_ID_MAX : 1999;
        static readonly ACTION_EVENT_MASK : 128;
        static readonly ITEM_EVENT_MASK : 512;
        static readonly CONTAINER_EVENT_MASK : 2;
        static readonly WINDOW_EVENT_MASK : 64;
        static readonly HIERARCHY_EVENT_MASK : 32768;
        static readonly WINDOW_STATE_EVENT_MASK : 262144;
        static readonly MOUSE_WHEEL_EVENT_MASK : 131072;
        static readonly MOUSE_MOTION_EVENT_MASK : 32;
        static readonly WINDOW_FOCUS_EVENT_MASK : 524288;
        get source(): any;
        get iD(): number;
        get class(): Internal.Class<any>;
        set source(arg0: any);
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    type AWTEvent_ = AWTEvent;
    interface ModifyRecipeResultCallback {
        modify(arg0: Internal.ModifyRecipeCraftingGrid_, arg1: Internal.ItemStackJS_): Internal.ItemStackJS;
    }
    type ModifyRecipeResultCallback_ = ((arg0: Internal.ModifyRecipeCraftingGrid, arg1: Internal.ItemStackJS) => Internal.ItemStackJS) | ModifyRecipeResultCallback;
    class ClickType extends Internal.Enum<Internal.ClickType> {
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        static valueOf(arg0: string): Internal.ClickType;
        static valueOf<T_>(arg0: Internal.Class_<T_>, arg1: string): T_;
        notifyAll(): void;
        static values(): Internal.ClickType[];
        compareTo(arg0: Internal.ClickType_): number;
        describeConstable(): Internal.Optional<Internal.Enum$EnumDesc<Internal.ClickType>>;
        notify(): void;
        getDeclaringClass(): Internal.Class<Internal.ClickType>;
        hashCode(): number;
        equals(arg0: any): boolean;
        name(): string;
        toString(): string;
        ordinal(): number;
        static readonly QUICK_MOVE : Internal.ClickType;
        static readonly SWAP : Internal.ClickType;
        static readonly PICKUP_ALL : Internal.ClickType;
        static readonly THROW : Internal.ClickType;
        static readonly QUICK_CRAFT : Internal.ClickType;
        static readonly PICKUP : Internal.ClickType;
        static readonly CLONE : Internal.ClickType;
        get class(): Internal.Class<any>;
        get declaringClass(): Internal.Class<Internal.ClickType>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    type ClickType_ = "swap" | "throw" | "quick_craft" | "clone" | "pickup" | "quick_move" | "pickup_all" | ClickType;
    interface ByteBufAllocator {
        directBuffer(): Internal.ByteBuf;
        directBuffer(arg0: number): Internal.ByteBuf;
        directBuffer(arg0: number, arg1: number): Internal.ByteBuf;
        isDirectBufferPooled(): boolean;
        calculateNewCapacity(arg0: number, arg1: number): number;
        compositeDirectBuffer(): Internal.CompositeByteBuf;
        compositeDirectBuffer(arg0: number): Internal.CompositeByteBuf;
        ioBuffer(): Internal.ByteBuf;
        ioBuffer(arg0: number): Internal.ByteBuf;
        ioBuffer(arg0: number, arg1: number): Internal.ByteBuf;
        compositeBuffer(arg0: number): Internal.CompositeByteBuf;
        compositeBuffer(): Internal.CompositeByteBuf;
        compositeHeapBuffer(): Internal.CompositeByteBuf;
        compositeHeapBuffer(arg0: number): Internal.CompositeByteBuf;
        buffer(): Internal.ByteBuf;
        buffer(arg0: number, arg1: number): Internal.ByteBuf;
        buffer(arg0: number): Internal.ByteBuf;
        heapBuffer(): Internal.ByteBuf;
        heapBuffer(arg0: number): Internal.ByteBuf;
        heapBuffer(arg0: number, arg1: number): Internal.ByteBuf;
    }
    type ByteBufAllocator_ = ByteBufAllocator;
    interface Byte2ObjectFunction <V> extends Internal.Function<number, V>, Internal.IntFunction<V> {
        getOrDefault(arg0: number, arg1: V): V;
        getOrDefault(arg0: any, arg1: V): V;
        andThenShort(arg0: Internal.Object2ShortFunction_<V>): Internal.Byte2ShortFunction;
        composeByte(arg0: Internal.Byte2ByteFunction_): Internal.Byte2ObjectFunction<V>;
        andThenInt(arg0: Internal.Object2IntFunction_<V>): Internal.Byte2IntFunction;
        andThen<V_>(arg0: java_.util.function_.Function_<V, V_>): java_.util.function_.Function<number, V_>;
        composeReference<T_>(arg0: Internal.Reference2ByteFunction_<T_>): Internal.Reference2ObjectFunction<T_, V>;
        put(arg0: number, arg1: V): V;
        remove(arg0: any): V;
        remove(arg0: number): V;
        defaultReturnValue(arg0: V): void;
        defaultReturnValue(): V;
        andThenDouble(arg0: Internal.Object2DoubleFunction_<V>): Internal.Byte2DoubleFunction;
        andThenObject<T_>(arg0: Internal.Object2ObjectFunction_<V, T_>): Internal.Byte2ObjectFunction<T_>;
        get(arg0: any): V;
        get(arg0: number): V;
        andThenLong(arg0: Internal.Object2LongFunction_<V>): Internal.Byte2LongFunction;
        composeLong(arg0: Internal.Long2ByteFunction_): Internal.Long2ObjectFunction<V>;
        andThenByte(arg0: Internal.Object2ByteFunction_<V>): Internal.Byte2ByteFunction;
        andThenFloat(arg0: Internal.Object2FloatFunction_<V>): Internal.Byte2FloatFunction;
        apply(arg0: number): V;
        containsKey(arg0: any): boolean;
        containsKey(arg0: number): boolean;
        composeInt(arg0: Internal.Int2ByteFunction_): Internal.Int2ObjectFunction<V>;
        clear(): void;
        composeFloat(arg0: Internal.Float2ByteFunction_): Internal.Float2ObjectFunction<V>;
        andThenChar(arg0: Internal.Object2CharFunction_<V>): Internal.Byte2CharFunction;
        composeObject<T_>(arg0: Internal.Object2ByteFunction_<T_>): Internal.Object2ObjectFunction<T_, V>;
        size(): number;
        compose<T_>(arg0: java_.util.function_.Function_<T_, number>): java_.util.function_.Function<T_, V>;
        composeShort(arg0: Internal.Short2ByteFunction_): Internal.Short2ObjectFunction<V>;
        andThenReference<T_>(arg0: Internal.Object2ReferenceFunction_<V, T_>): Internal.Byte2ReferenceFunction<T_>;
        composeChar(arg0: Internal.Char2ByteFunction_): Internal.Char2ObjectFunction<V>;
        composeDouble(arg0: Internal.Double2ByteFunction_): Internal.Double2ObjectFunction<V>;
    }
    type Byte2ObjectFunction_<V> = ((arg0: number) => V) | Byte2ObjectFunction<V>;
    class VariantBlockStateGenerator$Model {
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        toJson(): Internal.JsonObject;
        uvlock(): Internal.VariantBlockStateGenerator$Model;
        hashCode(): number;
        notifyAll(): void;
        equals(arg0: any): boolean;
        x(_x: number): Internal.VariantBlockStateGenerator$Model;
        y(_y: number): Internal.VariantBlockStateGenerator$Model;
        toString(): string;
        model(s: string): Internal.VariantBlockStateGenerator$Model;
        notify(): void;
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    type VariantBlockStateGenerator$Model_ = VariantBlockStateGenerator$Model;
    interface RenderTypeAccessor {
        shouldSortOnUpload(): boolean;
    }
    type RenderTypeAccessor_ = RenderTypeAccessor;
    abstract class Writer implements Internal.Appendable, Internal.Closeable, Internal.Flushable {
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        flush(): void;
        hashCode(): number;
        notifyAll(): void;
        equals(arg0: any): boolean;
        static nullWriter(): Internal.Writer;
        toString(): string;
        close(): void;
        write(arg0: string, arg1: number, arg2: number): void;
        write(arg0: number): void;
        write(arg0: string): void;
        write(arg0: string[], arg1: number, arg2: number): void;
        write(arg0: string[]): void;
        notify(): void;
        append(arg0: Internal.CharSequence_, arg1: number, arg2: number): Internal.Writer;
        append(arg0: string): Internal.Writer;
        append(arg0: Internal.CharSequence_): Internal.Writer;
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    type Writer_ = Writer;
    interface Stream$Builder <T> extends Internal.Consumer<T> {
        add(arg0: T): Internal.Stream$Builder<T>;
        build(): Internal.Stream<T>;
        andThen(arg0: Internal.Consumer_<T>): Internal.Consumer<T>;
        accept(arg0: T): void;
    }
    type Stream$Builder_<T> = Stream$Builder<T>;
    class FenceBlockBuilder extends Internal.ShapedBlockBuilder {
        noItem(): Internal.BlockBuilder;
        suffocating(b: boolean): Internal.BlockBuilder;
        getClass(): Internal.Class<any>;
        translationKey(key: string): Internal.BuilderBase<Internal.Block>;
        newID(pre: string, post: string): ResourceLocation;
        type(type: string): Internal.BuilderBase<Internal.Block>;
        unbreakable(): Internal.BlockBuilder;
        model(m: string): Internal.BlockBuilder;
        tag(tag: ResourceLocation_): Internal.BlockBuilder;
        generateDataJsons(generator: Internal.DataJsonGenerator_): void;
        tagBoth(tag: ResourceLocation_): Internal.BlockBuilder;
        defaultCutout(): Internal.BlockBuilder;
        item(i: Internal.Consumer_<Internal.BlockItemBuilder_>): Internal.BlockBuilder;
        resistance(r: number): Internal.BlockBuilder;
        hardness(h: number): Internal.BlockBuilder;
        slipperiness(f: number): Internal.BlockBuilder;
        getRegistryType(): Internal.RegistryObjectBuilderTypes<Internal.Block>;
        textureSide(direction: Internal.Direction_, tex: string): Internal.BlockBuilder;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        clientRegistry(minecraft: Internal.Minecraft_): void;
        waterlogged(): Internal.BlockBuilder;
        transformObject(obj: Internal.Block_): Internal.Block;
        color(index: number, c: Internal.Color_): Internal.BlockBuilder;
        textureAll(tex: string): Internal.BlockBuilder;
        displayName(name: string): Internal.BuilderBase<Internal.Block>;
        notifyAll(): void;
        box(x0: number, y0: number, z0: number, x1: number, y1: number, z1: number): Internal.BlockBuilder;
        box(x0: number, y0: number, z0: number, x1: number, y1: number, z1: number, scale16: boolean): Internal.BlockBuilder;
        viewBlocking(b: boolean): Internal.BlockBuilder;
        notify(): void;
        transparent(b: boolean): Internal.BlockBuilder;
        createAdditionalObjects(): void;
        tagBlock(tag: ResourceLocation_): Internal.BlockBuilder;
        fullBlock(f: boolean): Internal.BlockBuilder;
        createProperties(): Internal.BlockBehaviour$Properties;
        notSolid(): Internal.BlockBuilder;
        generateBlockModels(builder: Internal.BlockBuilder_): Internal.Map<ResourceLocation, Internal.JsonObject>;
        hashCode(): number;
        noCollission(): Internal.BlockBuilder;
        get(): Internal.Block;
        requiresTool(f: boolean): Internal.BlockBuilder;
        renderType(l: string): Internal.BlockBuilder;
        jumpFactor(f: number): Internal.BlockBuilder;
        createShape(): Internal.VoxelShape;
        generateAssetJsons(generator: Internal.AssetJsonGenerator_): void;
        noCollision(): Internal.BlockBuilder;
        opaque(o: boolean): Internal.BlockBuilder;
        randomTick(randomTickCallback: Internal.Consumer_<Internal.RandomTickCallbackJS_>): Internal.BlockBuilder;
        getTranslationKeyGroup(): string;
        texture(id: string, tex: string): Internal.BlockBuilder;
        noDrops(): Internal.BlockBuilder;
        generateLang(lang: Internal.Map_<string, string>): void;
        tagItem(tag: ResourceLocation_): Internal.BlockBuilder;
        speedFactor(f: number): Internal.BlockBuilder;
        noValidSpawns(b: boolean): Internal.BlockBuilder;
        createObject(): Internal.Block;
        lightLevel(light: number): Internal.BlockBuilder;
        addResourcePackLocations(path: string, list: Internal.List_<ResourceLocation_>, packType: Internal.PackType_): void;
        defaultTranslucent(): Internal.BlockBuilder;
        material(m: Internal.MaterialJS_): Internal.BlockBuilder;
        equals(arg0: any): boolean;
        toString(): string;
        redstoneConductor(b: boolean): Internal.BlockBuilder;
        lootTable : ((arg0: Internal.LootBuilder) => void);
        modelJson : Internal.JsonObject;
        blockstateJson : Internal.JsonObject;
        readonly id : ResourceLocation;
        randomTickCallback : ((arg0: Internal.RandomTickCallbackJS) => void);
        get registryType(): Internal.RegistryObjectBuilderTypes<Internal.Block>;
        get class(): Internal.Class<any>;
        get translationKeyGroup(): string;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    type FenceBlockBuilder_ = FenceBlockBuilder;
    abstract class DynamicLike <T> {
        createIntList(arg0: Internal.IntStream_): Internal.Dynamic<any>;
        createLong(arg0: number): Internal.Dynamic<T>;
        getClass(): Internal.Class<any>;
        getElementGeneric(arg0: T): Internal.DataResult<T>;
        getElementGeneric(arg0: T, arg1: T): T;
        createLongList(arg0: Internal.LongStream_): Internal.Dynamic<any>;
        readMap<K, V>(arg0: Internal.Decoder_<K>, arg1: Internal.Decoder_<V>): Internal.DataResult<Internal.List<Internal.Pair<K, V>>>;
        readMap<R>(arg0: Internal.DataResult_<R>, arg1: Internal.Function3_<R, Internal.Dynamic_<T>, Internal.Dynamic_<T>, Internal.DataResult_<R>>): Internal.DataResult<R>;
        readMap<K, V>(arg0: Internal.Decoder_<K>, arg1: java_.util.function_.Function_<K, Internal.Decoder_<V>>): Internal.DataResult<Internal.List<Internal.Pair<K, V>>>;
        asListOpt<U>(arg0: java_.util.function_.Function_<Internal.Dynamic_<T>, U>): Internal.DataResult<Internal.List<U>>;
        createShort(arg0: number): Internal.Dynamic<T>;
        decode<A>(arg0: Internal.Decoder_<A>): Internal.DataResult<Internal.Pair<A, T>>;
        asIntStreamOpt(): Internal.DataResult<Internal.IntStream>;
        asList<U>(arg0: java_.util.function_.Function_<Internal.Dynamic_<T>, U>): Internal.List<U>;
        readList<E>(arg0: Internal.Decoder_<E>): Internal.DataResult<Internal.List<E>>;
        readList<E>(arg0: java_.util.function_.Function_<Internal.Dynamic_<any>, Internal.DataResult_<E>>): Internal.DataResult<Internal.List<E>>;
        asString(): Internal.DataResult<string>;
        asString(arg0: string): string;
        asByte(arg0: number): number;
        createList(arg0: Internal.Stream_<Internal.Dynamic_<any>>): Internal.Dynamic<T>;
        asByteBufferOpt(): Internal.DataResult<Internal.ByteBuffer>;
        read<A>(arg0: Internal.Decoder_<A>): Internal.DataResult<A>;
        asMapOpt<K, V>(arg0: java_.util.function_.Function_<Internal.Dynamic_<T>, K>, arg1: java_.util.function_.Function_<Internal.Dynamic_<T>, V>): Internal.DataResult<Internal.Map<K, V>>;
        asMapOpt(): Internal.DataResult<Internal.Stream<Internal.Pair<Internal.Dynamic<T>, Internal.Dynamic<T>>>>;
        getGeneric(arg0: T): Internal.DataResult<T>;
        createString(arg0: string): Internal.Dynamic<T>;
        asStream(): Internal.Stream<Internal.Dynamic<T>>;
        asLong(arg0: number): number;
        createByte(arg0: number): Internal.Dynamic<T>;
        asDouble(arg0: number): number;
        asBoolean(arg0: boolean): boolean;
        asLongStreamOpt(): Internal.DataResult<Internal.LongStream>;
        createDouble(arg0: number): Internal.Dynamic<T>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        asStreamOpt(): Internal.DataResult<Internal.Stream<Internal.Dynamic<T>>>;
        asMap<K, V>(arg0: java_.util.function_.Function_<Internal.Dynamic_<T>, K>, arg1: java_.util.function_.Function_<Internal.Dynamic_<T>, V>): Internal.Map<K, V>;
        notifyAll(): void;
        asIntStream(): Internal.IntStream;
        createByteList(arg0: Internal.ByteBuffer_): Internal.Dynamic<any>;
        asByteBuffer(): Internal.ByteBuffer;
        asFloat(arg0: number): number;
        asLongStream(): Internal.LongStream;
        notify(): void;
        createBoolean(arg0: boolean): Internal.Dynamic<T>;
        asInt(arg0: number): number;
        emptyList(): Internal.Dynamic<T>;
        hashCode(): number;
        asShort(arg0: number): number;
        get(arg0: string): Internal.OptionalDynamic<T>;
        emptyMap(): Internal.Dynamic<T>;
        createNumeric(arg0: Internal.Number_): Internal.Dynamic<T>;
        asNumber(arg0: Internal.Number_): Internal.Number;
        asNumber(): Internal.DataResult<Internal.Number>;
        createMap(arg0: Internal.Map_<Internal.Dynamic_<any>, Internal.Dynamic_<any>>): Internal.Dynamic<T>;
        createFloat(arg0: number): Internal.Dynamic<T>;
        getOps(): Internal.DynamicOps<T>;
        getElement(arg0: string, arg1: T): T;
        getElement(arg0: string): Internal.DataResult<T>;
        equals(arg0: any): boolean;
        createInt(arg0: number): Internal.Dynamic<T>;
        toString(): string;
        get ops(): Internal.DynamicOps<T>;
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    type DynamicLike_<T> = DynamicLike<T>;
    interface Spliterator <T> {
        trySplit(): Internal.Spliterator<T>;
        tryAdvance(arg0: Internal.Consumer_<T>): boolean;
        characteristics(): number;
        getComparator(): Internal.Comparator<T>;
        getExactSizeIfKnown(): number;
        estimateSize(): number;
        hasCharacteristics(arg0: number): boolean;
        forEachRemaining(arg0: Internal.Consumer_<T>): void;
    }
    type Spliterator_<T> = Spliterator<T>;
    interface BlockEntityTypeAccess {
        byg_setValidBlocks(arg0: Internal.Set_<Internal.Block_>): void;
        byg_getValidBlocks(): Internal.Set<Internal.Block>;
    }
    type BlockEntityTypeAccess_ = BlockEntityTypeAccess;
    interface BlockStateFTBC {
        getFTBCIsWater(): boolean;
    }
    type BlockStateFTBC_ = BlockStateFTBC;
    interface TagType <T> {
    }
    type TagType_<T> = TagType<T>;
    class TeamMessage {
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        hashCode(): number;
        notifyAll(): void;
        equals(arg0: any): boolean;
        toString(): string;
        write(now: number, buffer: Internal.FriendlyByteBuf_): void;
        notify(): void;
        readonly date : number;
        readonly sender : Internal.UUID;
        readonly text : Internal.Component;
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    type TeamMessage_ = TeamMessage;
    abstract class AbstractInt2ObjectFunction <V> implements Internal.Int2ObjectFunction<V>, Internal.Serializable {
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        getOrDefault(arg0: number, arg1: V): V;
        getOrDefault(arg0: any, arg1: V): V;
        notifyAll(): void;
        andThenShort(arg0: Internal.Object2ShortFunction_<V>): Internal.Int2ShortFunction;
        composeByte(arg0: Internal.Byte2IntFunction_): Internal.Byte2ObjectFunction<V>;
        andThenInt(arg0: Internal.Object2IntFunction_<V>): Internal.Int2IntFunction;
        andThen<V_>(arg0: java_.util.function_.Function_<V, V_>): java_.util.function_.Function<number, V_>;
        composeReference<T_>(arg0: Internal.Reference2IntFunction_<T_>): Internal.Reference2ObjectFunction<T_, V>;
        put(arg0: number, arg1: V): V;
        remove(arg0: any): V;
        remove(arg0: number): V;
        notify(): void;
        defaultReturnValue(arg0: V): void;
        defaultReturnValue(): V;
        andThenDouble(arg0: Internal.Object2DoubleFunction_<V>): Internal.Int2DoubleFunction;
        andThenObject<T_>(arg0: Internal.Object2ObjectFunction_<V, T_>): Internal.Int2ObjectFunction<T_>;
        hashCode(): number;
        get(arg0: any): V;
        get(arg0: number): V;
        andThenLong(arg0: Internal.Object2LongFunction_<V>): Internal.Int2LongFunction;
        composeLong(arg0: Internal.Long2IntFunction_): Internal.Long2ObjectFunction<V>;
        andThenByte(arg0: Internal.Object2ByteFunction_<V>): Internal.Int2ByteFunction;
        andThenFloat(arg0: Internal.Object2FloatFunction_<V>): Internal.Int2FloatFunction;
        apply(arg0: number): V;
        containsKey(arg0: any): boolean;
        containsKey(arg0: number): boolean;
        composeInt(arg0: Internal.Int2IntFunction_): Internal.Int2ObjectFunction<V>;
        clear(): void;
        composeFloat(arg0: Internal.Float2IntFunction_): Internal.Float2ObjectFunction<V>;
        andThenChar(arg0: Internal.Object2CharFunction_<V>): Internal.Int2CharFunction;
        composeObject<T_>(arg0: Internal.Object2IntFunction_<T_>): Internal.Object2ObjectFunction<T_, V>;
        size(): number;
        compose<T_>(arg0: java_.util.function_.Function_<T_, number>): java_.util.function_.Function<T_, V>;
        composeShort(arg0: Internal.Short2IntFunction_): Internal.Short2ObjectFunction<V>;
        equals(arg0: any): boolean;
        andThenReference<T_>(arg0: Internal.Object2ReferenceFunction_<V, T_>): Internal.Int2ReferenceFunction<T_>;
        composeChar(arg0: Internal.Char2IntFunction_): Internal.Char2ObjectFunction<V>;
        toString(): string;
        composeDouble(arg0: Internal.Double2IntFunction_): Internal.Double2ObjectFunction<V>;
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    type AbstractInt2ObjectFunction_<V> = AbstractInt2ObjectFunction<V>;
    class BlockPattern {
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        autoBuild(arg0: Internal.Player_, arg1: Internal.MultiblockState_): void;
        getPreview(arg0: number[]): Internal.BlockInfo[][][];
        hashCode(): number;
        notifyAll(): void;
        equals(arg0: any): boolean;
        toString(): string;
        checkPatternAt(arg0: Internal.MultiblockState_, arg1: boolean): boolean;
        notify(): void;
        readonly aisleRepetitions : number[][];
        readonly structureDir : MbdRelativeDirection[];
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    type BlockPattern_ = BlockPattern;
    interface ITypedIngredient <T> {
        getIngredient(): T;
        getIngredient<V>(arg0: Internal.IIngredientType_<V>): Internal.Optional<V>;
        getType(): Internal.IIngredientType<T>;
    }
    type ITypedIngredient_<T> = ITypedIngredient<T>;
    interface ModifyLootAction$Callback {
        modify(arg0: Internal.ItemStack_): Internal.ItemStack;
    }
    type ModifyLootAction$Callback_ = ((arg0: Internal.ItemStack) => Internal.ItemStack) | ModifyLootAction$Callback;
    interface Short2ShortFunction extends Internal.Function<number, number>, Internal.IntUnaryOperator {
        getOrDefault(arg0: any, arg1: number): number;
        getOrDefault(arg0: number, arg1: number): number;
        andThenShort(arg0: Internal.Short2ShortFunction_): Internal.Short2ShortFunction;
        composeByte(arg0: Internal.Byte2ShortFunction_): Internal.Byte2ShortFunction;
        andThenInt(arg0: Internal.Short2IntFunction_): Internal.Short2IntFunction;
        composeReference<T_>(arg0: Internal.Reference2ShortFunction_<T_>): Internal.Reference2ShortFunction<T_>;
        andThen<T_>(arg0: java_.util.function_.Function_<number, T_>): java_.util.function_.Function<number, T_>;
        andThen(arg0: Internal.IntUnaryOperator_): Internal.IntUnaryOperator;
        put(arg0: number, arg1: number): number;
        remove(arg0: number): number;
        remove(arg0: any): number;
        defaultReturnValue(): number;
        defaultReturnValue(arg0: number): void;
        andThenDouble(arg0: Internal.Short2DoubleFunction_): Internal.Short2DoubleFunction;
        andThenObject<T_>(arg0: Internal.Short2ObjectFunction_<T_>): Internal.Short2ObjectFunction<T_>;
        get(arg0: any): number;
        get(arg0: number): number;
        andThenLong(arg0: Internal.Short2LongFunction_): Internal.Short2LongFunction;
        composeLong(arg0: Internal.Long2ShortFunction_): Internal.Long2ShortFunction;
        andThenByte(arg0: Internal.Short2ByteFunction_): Internal.Short2ByteFunction;
        andThenFloat(arg0: Internal.Short2FloatFunction_): Internal.Short2FloatFunction;
        applyAsInt(arg0: number): number;
        apply(arg0: number): number;
        containsKey(arg0: any): boolean;
        containsKey(arg0: number): boolean;
        composeInt(arg0: Internal.Int2ShortFunction_): Internal.Int2ShortFunction;
        clear(): void;
        composeFloat(arg0: Internal.Float2ShortFunction_): Internal.Float2ShortFunction;
        andThenChar(arg0: Internal.Short2CharFunction_): Internal.Short2CharFunction;
        composeObject<T_>(arg0: Internal.Object2ShortFunction_<T_>): Internal.Object2ShortFunction<T_>;
        size(): number;
        compose<T_>(arg0: java_.util.function_.Function_<T_, number>): java_.util.function_.Function<T_, number>;
        compose(arg0: Internal.IntUnaryOperator_): Internal.IntUnaryOperator;
        composeShort(arg0: Internal.Short2ShortFunction_): Internal.Short2ShortFunction;
        andThenReference<T_>(arg0: Internal.Short2ReferenceFunction_<T_>): Internal.Short2ReferenceFunction<T_>;
        composeChar(arg0: Internal.Char2ShortFunction_): Internal.Char2ShortFunction;
        composeDouble(arg0: Internal.Double2ShortFunction_): Internal.Double2ShortFunction;
    }
    type Short2ShortFunction_ = ((arg0: number) => number) | Short2ShortFunction;
    /**
    * Fired by different tag everytime when a player:
    * - ticks
    * - logged in
    * - logged out
    */
    class SimplePlayerEventJS extends Internal.PlayerEventJS {
        cancel(): void;
        getServer(): Internal.ServerJS;
        getClass(): Internal.Class<any>;
        addGameStage(stage: string): void;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        isCancelled(): boolean;
        getPlayer(): Internal.PlayerJS<any>;
        notifyAll(): void;
        getEntity(): Internal.EntityJS;
        notify(): void;
        getLevel(): Internal.LevelJS;
        getMinecraftPlayer(): Internal.Player;
        post(id: string): boolean;
        post(id: string, sub: string): boolean;
        post(t: Internal.ScriptType_, id: string, sub: string): boolean;
        post(t: Internal.ScriptType_, id: string): boolean;
        hasGameStage(stage: string): boolean;
        hashCode(): number;
        equals(arg0: any): boolean;
        removeGameStage(stage: string): void;
        toString(): string;
        canCancel(): boolean;
        get server(): Internal.ServerJS;
        get level(): Internal.LevelJS;
        get minecraftPlayer(): Internal.Player;
        get cancelled(): boolean;
        get class(): Internal.Class<any>;
        get entity(): Internal.EntityJS;
        get player(): Internal.PlayerJS<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    /**
    * Fired by different tag everytime when a player:
    * - ticks
    * - logged in
    * - logged out
    */
    type SimplePlayerEventJS_ = SimplePlayerEventJS;
    abstract class AbstractByte2DoubleMap extends Internal.AbstractByte2DoubleFunction implements Internal.Byte2DoubleMap, Internal.Serializable {
        getClass(): Internal.Class<any>;
        getOrDefault(arg0: any, arg1: number): number;
        getOrDefault(arg0: number, arg1: number): number;
        applyAsDouble(arg0: number): number;
        replace(arg0: number, arg1: number, arg2: number): boolean;
        replace(arg0: number, arg1: number): number;
        composeByte(arg0: Internal.Byte2ByteFunction_): Internal.Byte2DoubleFunction;
        composeReference<T_>(arg0: Internal.Reference2ByteFunction_<T_>): Internal.Reference2DoubleFunction<T_>;
        andThen<T_>(arg0: java_.util.function_.Function_<number, T_>): java_.util.function_.Function<number, T_>;
        put(arg0: number, arg1: number): number;
        containsValue(arg0: number): boolean;
        containsValue(arg0: any): boolean;
        compute(arg0: number, arg1: Internal.BiFunction_<number, number, number>): number;
        defaultReturnValue(arg0: number): void;
        defaultReturnValue(): number;
        andThenObject<T_>(arg0: Internal.Double2ObjectFunction_<T_>): Internal.Byte2ObjectFunction<T_>;
        merge(arg0: number, arg1: number, arg2: Internal.BiFunction_<number, number, number>): number;
        composeLong(arg0: Internal.Long2ByteFunction_): Internal.Long2DoubleFunction;
        entrySet(): Internal.ObjectSet<Internal.Map$Entry<number, number>>;
        containsKey(arg0: number): boolean;
        containsKey(arg0: any): boolean;
        composeObject<T_>(arg0: Internal.Object2ByteFunction_<T_>): Internal.Object2DoubleFunction<T_>;
        size(): number;
        compose<T_>(arg0: java_.util.function_.Function_<T_, number>): java_.util.function_.Function<T_, number>;
        composeShort(arg0: Internal.Short2ByteFunction_): Internal.Short2DoubleFunction;
        mergeDouble(arg0: number, arg1: number, arg2: it.unimi.dsi.fastutil.doubles.DoubleBinaryOperator_): number;
        mergeDouble(arg0: number, arg1: number, arg2: Internal.DoubleBinaryOperator_): number;
        composeChar(arg0: Internal.Char2ByteFunction_): Internal.Char2DoubleFunction;
        composeDouble(arg0: Internal.Double2ByteFunction_): Internal.Double2DoubleFunction;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        byte2DoubleEntrySet(): Internal.ObjectSet<Internal.Byte2DoubleMap$Entry>;
        computeIfAbsent(arg0: number, arg1: Internal.IntToDoubleFunction_): number;
        computeIfAbsent(arg0: number, arg1: java_.util.function_.Function_<number, number>): number;
        computeIfAbsent(arg0: number, arg1: Internal.Byte2DoubleFunction_): number;
        notifyAll(): void;
        values(): Internal.DoubleCollection;
        andThenShort(arg0: Internal.Double2ShortFunction_): Internal.Byte2ShortFunction;
        computeIfAbsentPartial(arg0: number, arg1: Internal.Byte2DoubleFunction_): number;
        replaceAll(arg0: Internal.BiFunction_<number, number, number>): void;
        andThenInt(arg0: Internal.Double2IntFunction_): Internal.Byte2IntFunction;
        remove(arg0: number): number;
        remove(arg0: any): number;
        remove(arg0: number, arg1: number): boolean;
        remove(arg0: any, arg1: any): boolean;
        notify(): void;
        andThenDouble(arg0: Internal.Double2DoubleFunction_): Internal.Byte2DoubleFunction;
        hashCode(): number;
        get(arg0: any): number;
        get(arg0: number): number;
        putAll(arg0: Internal.Map_<number, number>): void;
        andThenLong(arg0: Internal.Double2LongFunction_): Internal.Byte2LongFunction;
        keySet(): Internal.ByteSet;
        andThenByte(arg0: Internal.Double2ByteFunction_): Internal.Byte2ByteFunction;
        andThenFloat(arg0: Internal.Double2FloatFunction_): Internal.Byte2FloatFunction;
        computeIfAbsentNullable(arg0: number, arg1: Internal.IntFunction_<number>): number;
        apply(arg0: number): number;
        forEach(arg0: Internal.BiConsumer_<number, number>): void;
        composeInt(arg0: Internal.Int2ByteFunction_): Internal.Int2DoubleFunction;
        clear(): void;
        isEmpty(): boolean;
        composeFloat(arg0: Internal.Float2ByteFunction_): Internal.Float2DoubleFunction;
        andThenChar(arg0: Internal.Double2CharFunction_): Internal.Byte2CharFunction;
        computeIfPresent(arg0: number, arg1: Internal.BiFunction_<number, number, number>): number;
        equals(arg0: any): boolean;
        andThenReference<T_>(arg0: Internal.Double2ReferenceFunction_<T_>): Internal.Byte2ReferenceFunction<T_>;
        toString(): string;
        putIfAbsent(arg0: number, arg1: number): number;
        get class(): Internal.Class<any>;
        get empty(): boolean;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    type AbstractByte2DoubleMap_ = AbstractByte2DoubleMap;
    interface ArgumentType <T> {
        listSuggestions<S>(arg0: Internal.CommandContext_<S>, arg1: Internal.SuggestionsBuilder_): Internal.CompletableFuture<Internal.Suggestions>;
        getExamples(): Internal.Collection<string>;
        parse(arg0: Internal.StringReader_): T;
    }
    type ArgumentType_<T> = ArgumentType<T>;
    interface Object2DoubleFunction <K> extends Internal.Function<K, number>, Internal.ToDoubleFunction<K> {
        getOrDefault(arg0: any, arg1: number): number;
        applyAsDouble(arg0: K): number;
        andThenShort(arg0: Internal.Double2ShortFunction_): Internal.Object2ShortFunction<K>;
        getDouble(arg0: any): number;
        composeByte(arg0: Internal.Byte2ObjectFunction_<K>): Internal.Byte2DoubleFunction;
        andThenInt(arg0: Internal.Double2IntFunction_): Internal.Object2IntFunction<K>;
        composeReference<T_>(arg0: Internal.Reference2ObjectFunction_<T_, K>): Internal.Reference2DoubleFunction<T_>;
        andThen<T_>(arg0: java_.util.function_.Function_<number, T_>): java_.util.function_.Function<K, T_>;
        put(arg0: K, arg1: number): number;
        remove(arg0: any): number;
        defaultReturnValue(): number;
        defaultReturnValue(arg0: number): void;
        andThenDouble(arg0: Internal.Double2DoubleFunction_): Internal.Object2DoubleFunction<K>;
        andThenObject<T_>(arg0: Internal.Double2ObjectFunction_<T_>): Internal.Object2ObjectFunction<K, T_>;
        get(arg0: any): number;
        andThenLong(arg0: Internal.Double2LongFunction_): Internal.Object2LongFunction<K>;
        composeLong(arg0: Internal.Long2ObjectFunction_<K>): Internal.Long2DoubleFunction;
        andThenByte(arg0: Internal.Double2ByteFunction_): Internal.Object2ByteFunction<K>;
        andThenFloat(arg0: Internal.Double2FloatFunction_): Internal.Object2FloatFunction<K>;
        apply(arg0: K): number;
        containsKey(arg0: any): boolean;
        composeInt(arg0: Internal.Int2ObjectFunction_<K>): Internal.Int2DoubleFunction;
        clear(): void;
        composeFloat(arg0: Internal.Float2ObjectFunction_<K>): Internal.Float2DoubleFunction;
        andThenChar(arg0: Internal.Double2CharFunction_): Internal.Object2CharFunction<K>;
        composeObject<T_>(arg0: Internal.Object2ObjectFunction_<T_, K>): Internal.Object2DoubleFunction<T_>;
        size(): number;
        compose<V_>(arg0: java_.util.function_.Function_<V_, K>): java_.util.function_.Function<V_, number>;
        removeDouble(arg0: any): number;
        composeShort(arg0: Internal.Short2ObjectFunction_<K>): Internal.Short2DoubleFunction;
        andThenReference<T_>(arg0: Internal.Double2ReferenceFunction_<T_>): Internal.Object2ReferenceFunction<K, T_>;
        composeChar(arg0: Internal.Char2ObjectFunction_<K>): Internal.Char2DoubleFunction;
        composeDouble(arg0: Internal.Double2ObjectFunction_<K>): Internal.Double2DoubleFunction;
    }
    type Object2DoubleFunction_<K> = ((arg0: any) => number) | Object2DoubleFunction<K>;
    interface IntSet extends Internal.IntCollection, Internal.Set<number> {
        intIterator(): Internal.IntIterator;
        intSpliterator(): Internal.IntSpliterator;
        remove(arg0: number): boolean;
        remove(arg0: any): boolean;
        intStream(): Internal.IntStream;
        removeAll(arg0: Internal.IntCollection_): boolean;
        removeAll(arg0: Internal.Collection_<any>): boolean;
        iterator(): Internal.IntIterator;
        stream(): Internal.Stream<number>;
        hashCode(): number;
        toIntArray(arg0: number[]): number[];
        toIntArray(): number[];
        toArray(arg0: number[]): number[];
        toArray<T_>(arg0: T_[]): T_[];
        toArray<T_>(arg0: Internal.IntFunction_<T_[]>): T_[];
        toArray(): any[];
        parallelStream(): Internal.Stream<number>;
        rem(arg0: number): boolean;
        add(arg0: number): boolean;
        spliterator(): Internal.IntSpliterator;
        forEach(arg0: Internal.Consumer_<number>): void;
        forEach(arg0: java_.util.function_.IntConsumer_): void;
        forEach(arg0: Internal.IntConsumer_): void;
        containsAll(arg0: Internal.IntCollection_): boolean;
        containsAll(arg0: Internal.Collection_<any>): boolean;
        isEmpty(): boolean;
        clear(): void;
        removeIf(arg0: Internal.Predicate_<number>): boolean;
        removeIf(arg0: java_.util.function_.IntPredicate_): boolean;
        removeIf(arg0: Internal.IntPredicate_): boolean;
        contains(arg0: any): boolean;
        contains(arg0: number): boolean;
        size(): number;
        addAll(arg0: Internal.IntCollection_): boolean;
        addAll(arg0: Internal.Collection_<number>): boolean;
        equals(arg0: any): boolean;
        intParallelStream(): Internal.IntStream;
        retainAll(arg0: Internal.IntCollection_): boolean;
        retainAll(arg0: Internal.Collection_<any>): boolean;
    }
    type IntSet_ = IntSet;
    abstract class LootEventJS extends Internal.EventJS {
        cancel(): void;
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        isCancelled(): boolean;
        notifyAll(): void;
        addJson(id: ResourceLocation_, json: Internal.JsonObject_): void;
        notify(): void;
        modify(id: ResourceLocation_, b: Internal.Consumer_<Internal.LootBuilder_>): void;
        removeAll(): void;
        post(t: Internal.ScriptType_, id: string, sub: string): boolean;
        post(t: Internal.ScriptType_, id: string): boolean;
        getType(): string;
        hashCode(): number;
        equals(arg0: any): boolean;
        toString(): string;
        getDirectory(): string;
        canCancel(): boolean;
        get cancelled(): boolean;
        get type(): string;
        get class(): Internal.Class<any>;
        get directory(): string;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    type LootEventJS_ = LootEventJS;
    interface ChangeListener <T> {
        onChanged(arg0: T): void;
    }
    type ChangeListener_<T> = ((arg0: T) => void) | ChangeListener<T>;
    interface BlockGetter extends Internal.LevelHeightAccessor, Internal.IForgeBlockGetter {
        getExistingBlockEntity(arg0: BlockPos_): Internal.BlockEntity;
    }
    type BlockGetter_ = BlockGetter;
    class LongConfig extends Internal.NumberConfig<number> {
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        getName(): string;
        setCanEdit(e: boolean): Internal.ConfigValue<number>;
        notifyAll(): void;
        isEqual(v1: number, v2: number): boolean;
        compareTo(o: Internal.ConfigValue_<number>): number;
        notify(): void;
        getCanEdit(): boolean;
        getStringFromValue(v: number): string;
        getTooltip(): string;
        hashCode(): number;
        getStringForGUI(v: number): Internal.Component;
        getPath(): string;
        copy(value: number): number;
        static info(key: string, value: any): Internal.Component;
        init(g: Internal.ConfigGroup_, i: string, v: number, c: Internal.Consumer_<number>, def: number): Internal.ConfigValue<number>;
        getColor(v: number): Internal.Color4I;
        addInfo(list: Internal.TooltipList_): void;
        parse(callback: Internal.Consumer_<number>, string: string): boolean;
        getIcon(v: number): Internal.Icon;
        setIcon(i: Internal.Icon_): Internal.ConfigValue<number>;
        setOrder(o: number): Internal.ConfigValue<number>;
        getNameKey(): string;
        setNameKey(key: string): Internal.ConfigValue<number>;
        equals(arg0: any): boolean;
        onClicked(button: Internal.MouseButton_, callback: Internal.ConfigCallback_): void;
        toString(): string;
        setCurrentValue(v: number): boolean;
        fader(v: boolean): Internal.NumberConfig<number>;
        readonly min : number;
        readonly max : number;
        static readonly COLOR : Internal.Color4I;
        defaultValue : number;
        id : string;
        static readonly NULL_TEXT : Internal.TextComponent;
        setter : ((arg0: number) => void);
        value : number;
        group : Internal.ConfigGroup;
        get path(): string;
        get nameKey(): string;
        get canEdit(): boolean;
        get name(): string;
        get tooltip(): string;
        get class(): Internal.Class<any>;
        set nameKey(key: string);
        set canEdit(e: boolean);
        set icon(i: Internal.Icon_);
        set currentValue(v: number);
        set order(o: number);
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    type LongConfig_ = LongConfig;
    class Block extends Internal.BlockBehaviour implements Internal.ItemLike, Internal.IForgeBlock {
        rotate(arg0: Internal.BlockState_, arg1: Internal.LevelAccessor_, arg2: BlockPos_, arg3: Internal.Rotation_): Internal.BlockState;
        getClass(): Internal.Class<any>;
        getStateAtViewpoint(arg0: Internal.BlockState_, arg1: Internal.BlockGetter_, arg2: BlockPos_, arg3: Vec3_): Internal.BlockState;
        onBlockExploded(arg0: Internal.BlockState_, arg1: Internal.Level_, arg2: BlockPos_, arg3: Internal.Explosion_): void;
        getBedDirection(arg0: Internal.BlockState_, arg1: Internal.LevelReader_, arg2: BlockPos_): Internal.Direction;
        isBed(arg0: Internal.BlockState_, arg1: Internal.BlockGetter_, arg2: BlockPos_, arg3: Internal.Entity_): boolean;
        canHarvestBlock(arg0: Internal.BlockState_, arg1: Internal.BlockGetter_, arg2: BlockPos_, arg3: Internal.Player_): boolean;
        makesOpenTrapdoorAboveClimbable(arg0: Internal.BlockState_, arg1: Internal.LevelReader_, arg2: BlockPos_, arg3: Internal.BlockState_): boolean;
        isLadder(arg0: Internal.BlockState_, arg1: Internal.LevelReader_, arg2: BlockPos_, arg3: Internal.LivingEntity_): boolean;
        shouldDisplayFluidOverlay(arg0: Internal.BlockState_, arg1: Internal.BlockAndTintGetter_, arg2: BlockPos_, arg3: Internal.FluidState_): boolean;
        canStickTo(arg0: Internal.BlockState_, arg1: Internal.BlockState_): boolean;
        onNeighborChange(arg0: Internal.BlockState_, arg1: Internal.LevelReader_, arg2: BlockPos_, arg3: BlockPos_): void;
        getWeakChanges(arg0: Internal.BlockState_, arg1: Internal.LevelReader_, arg2: BlockPos_): boolean;
        canEntityDestroy(arg0: Internal.BlockState_, arg1: Internal.BlockGetter_, arg2: BlockPos_, arg3: Internal.Entity_): boolean;
        isBurning(arg0: Internal.BlockState_, arg1: Internal.BlockGetter_, arg2: BlockPos_): boolean;
        getFriction(arg0: Internal.BlockState_, arg1: Internal.LevelReader_, arg2: BlockPos_, arg3: Internal.Entity_): number;
        isValidSpawn(arg0: Internal.BlockState_, arg1: Internal.BlockGetter_, arg2: BlockPos_, arg3: Internal.SpawnPlacements$Type_, arg4: Internal.EntityType_<any>): boolean;
        isPortalFrame(arg0: Internal.BlockState_, arg1: Internal.BlockGetter_, arg2: BlockPos_): boolean;
        getExplosionResistance(arg0: Internal.BlockState_, arg1: Internal.BlockGetter_, arg2: BlockPos_, arg3: Internal.Explosion_): number;
        isScaffolding(arg0: Internal.BlockState_, arg1: Internal.LevelReader_, arg2: BlockPos_, arg3: Internal.LivingEntity_): boolean;
        canSustainPlant(arg0: Internal.BlockState_, arg1: Internal.BlockGetter_, arg2: BlockPos_, arg3: Internal.Direction_, arg4: Internal.IPlantable_): boolean;
        canDropFromExplosion(arg0: Internal.BlockState_, arg1: Internal.BlockGetter_, arg2: BlockPos_, arg3: Internal.Explosion_): boolean;
        isStickyBlock(arg0: Internal.BlockState_): boolean;
        isFertile(arg0: Internal.BlockState_, arg1: Internal.BlockGetter_, arg2: BlockPos_): boolean;
        getAiPathNodeType(arg0: Internal.BlockState_, arg1: Internal.BlockGetter_, arg2: BlockPos_, arg3: Internal.Mob_): Internal.BlockPathTypes;
        getBlockBuilderKJS(): Internal.BlockBuilder;
        isSlimeBlock(arg0: Internal.BlockState_): boolean;
        getRegistryType(): Internal.Class<Internal.Block>;
        getFireSpreadSpeed(arg0: Internal.BlockState_, arg1: Internal.BlockGetter_, arg2: BlockPos_, arg3: Internal.Direction_): number;
        getToolModifiedState(arg0: Internal.BlockState_, arg1: Internal.Level_, arg2: BlockPos_, arg3: Internal.Player_, arg4: Internal.ItemStack_, arg5: Internal.ToolAction_): Internal.BlockState;
        getToolModifiedState(arg0: Internal.BlockState_, arg1: Internal.UseOnContext_, arg2: Internal.ToolAction_, arg3: boolean): Internal.BlockState;
        getBeaconColorMultiplier(arg0: Internal.BlockState_, arg1: Internal.LevelReader_, arg2: BlockPos_, arg3: BlockPos_): number[];
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        getExpDrop(arg0: Internal.BlockState_, arg1: Internal.LevelReader_, arg2: BlockPos_, arg3: number, arg4: number): number;
        isConduitFrame(arg0: Internal.BlockState_, arg1: Internal.LevelReader_, arg2: BlockPos_, arg3: BlockPos_): boolean;
        notifyAll(): void;
        getLightEmission(arg0: Internal.BlockState_, arg1: Internal.BlockGetter_, arg2: BlockPos_): number;
        onDestroyedByPlayer(arg0: Internal.BlockState_, arg1: Internal.Level_, arg2: BlockPos_, arg3: Internal.Player_, arg4: boolean, arg5: Internal.FluidState_): boolean;
        getId(): string;
        shouldCheckWeakPower(arg0: Internal.BlockState_, arg1: Internal.LevelReader_, arg2: BlockPos_, arg3: Internal.Direction_): boolean;
        collisionExtendsVertically(arg0: Internal.BlockState_, arg1: Internal.BlockGetter_, arg2: BlockPos_, arg3: Internal.Entity_): boolean;
        notify(): void;
        supportsExternalFaceHiding(arg0: Internal.BlockState_): boolean;
        addLandingEffects(arg0: Internal.BlockState_, arg1: Internal.ServerLevel_, arg2: BlockPos_, arg3: Internal.BlockState_, arg4: Internal.LivingEntity_, arg5: number): boolean;
        getRenderPropertiesInternal(): any;
        getSoundType(arg0: Internal.BlockState_, arg1: Internal.LevelReader_, arg2: BlockPos_, arg3: Internal.Entity_): Internal.SoundType;
        hashCode(): number;
        addRunningEffects(arg0: Internal.BlockState_, arg1: Internal.Level_, arg2: BlockPos_, arg3: Internal.Entity_): boolean;
        hidesNeighborFace(arg0: Internal.BlockGetter_, arg1: BlockPos_, arg2: Internal.BlockState_, arg3: Internal.BlockState_, arg4: Internal.Direction_): boolean;
        initializeClient(arg0: Internal.Consumer_<Internal.IBlockRenderProperties_>): void;
        getCloneItemStack(arg0: Internal.BlockState_, arg1: Internal.HitResult_, arg2: Internal.BlockGetter_, arg3: BlockPos_, arg4: Internal.Player_): Internal.ItemStack;
        getBlockStatesKJS(): Internal.List<Internal.BlockState>;
        isFlammable(arg0: Internal.BlockState_, arg1: Internal.BlockGetter_, arg2: BlockPos_, arg3: Internal.Direction_): boolean;
        onCaughtFire(arg0: Internal.BlockState_, arg1: Internal.Level_, arg2: BlockPos_, arg3: Internal.Direction_, arg4: Internal.LivingEntity_): void;
        getEnchantPowerBonus(arg0: Internal.BlockState_, arg1: Internal.LevelReader_, arg2: BlockPos_): number;
        getRegistryName(): ResourceLocation;
        setBedOccupied(arg0: Internal.BlockState_, arg1: Internal.Level_, arg2: BlockPos_, arg3: Internal.LivingEntity_, arg4: boolean): void;
        setRegistryName(arg0: ResourceLocation_): Internal.Block;
        setRegistryName(arg0: string): Internal.Block;
        setRegistryName(arg0: string, arg1: string): Internal.Block;
        isFireSource(arg0: Internal.BlockState_, arg1: Internal.LevelReader_, arg2: BlockPos_, arg3: Internal.Direction_): boolean;
        getRespawnPosition(arg0: Internal.BlockState_, arg1: Internal.EntityType_<any>, arg2: Internal.LevelReader_, arg3: BlockPos_, arg4: number, arg5: Internal.LivingEntity_): Internal.Optional<Vec3>;
        equals(arg0: any): boolean;
        canConnectRedstone(arg0: Internal.BlockState_, arg1: Internal.BlockGetter_, arg2: BlockPos_, arg3: Internal.Direction_): boolean;
        setBlockBuilderKJS(b: Internal.BlockBuilder_): void;
        getTypeData(): Internal.CompoundTag;
        toString(): string;
        getFlammability(arg0: Internal.BlockState_, arg1: Internal.BlockGetter_, arg2: BlockPos_, arg3: Internal.Direction_): number;
        readonly delegate : Internal.IRegistryDelegate<Internal.Block>;
        get registryType(): Internal.Class<Internal.Block>;
        get blockBuilderKJS(): Internal.BlockBuilder;
        get renderPropertiesInternal(): any;
        get blockStatesKJS(): Internal.List<Internal.BlockState>;
        get id(): string;
        get registryName(): ResourceLocation;
        get typeData(): Internal.CompoundTag;
        get class(): Internal.Class<any>;
        set blockBuilderKJS(b: Internal.BlockBuilder_);
        set registryName(arg0: ResourceLocation_);
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    type Block_ = Block;
    class RegistryObjectBuilderTypes$BuilderType <T> extends Internal.Record {
        getClass(): Internal.Class<any>;
        factory(): Internal.RegistryObjectBuilderTypes$BuilderFactory<T>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        builderClass(): Internal.Class<Internal.BuilderBase<T>>;
        hashCode(): number;
        notifyAll(): void;
        equals(o: any): boolean;
        toString(): string;
        type(): string;
        notify(): void;
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    type RegistryObjectBuilderTypes$BuilderType_<T> = RegistryObjectBuilderTypes$BuilderType<T>;
    interface Executor {
        execute(arg0: Internal.Runnable_): void;
    }
    type Executor_ = Executor;
    abstract class Reward extends Internal.QuestObjectBase {
        getClass(): Internal.Class<any>;
        getMutableTitle(): Internal.MutableComponent;
        isTeamReward(): boolean;
        getTags(): Internal.Set<string>;
        automatedClaimPre(tileEntity: Internal.BlockEntity_, items: Internal.List_<Internal.ItemStack_>, random: Internal.Random_, playerId: Internal.UUID_, player: Internal.ServerPlayer_): boolean;
        static getCodeString(object: Internal.QuestObjectBase_): string;
        getCodeString(): string;
        static getCodeString(id: number): string;
        writeData(nbt: Internal.CompoundTag_): void;
        editedFromGUIOnServer(): void;
        createSubGroup(group: Internal.ConfigGroup_): Internal.ConfigGroup;
        forceProgress(teamData: Internal.TeamData_, progressChange: Internal.ProgressChange_): void;
        getTitle(): Internal.Component;
        getPath(): string;
        claim(arg0: Internal.ServerPlayer_, arg1: boolean): void;
        clearCachedData(): void;
        static parseCodeString(id: string): number;
        readData(nbt: Internal.CompoundTag_): void;
        editedFromGUI(): void;
        hasTag(tag: string): boolean;
        static getID(object: Internal.QuestObjectBase_): number;
        onEditButtonClicked(gui: Internal.Runnable_): void;
        addMouseOverText(list: Internal.TooltipList_): void;
        getIngredient(): any;
        getAltTitle(): Internal.Component;
        getType(): Internal.RewardType;
        automatedClaimPost(tileEntity: Internal.BlockEntity_, playerId: Internal.UUID_, player: Internal.ServerPlayer_): void;
        onButtonClicked(button: Internal.Button_, canClick: boolean): void;
        deleteSelf(): void;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        addTitleInMouseOverText(): boolean;
        getExcludeFromClaimAll(): boolean;
        deleteChildren(): void;
        readNetData(buffer: Internal.FriendlyByteBuf_): void;
        notifyAll(): void;
        notify(): void;
        hashCode(): number;
        getAltIcon(): Internal.Icon;
        getObjectType(): Internal.QuestObjectType;
        getAutoClaimType(): Internal.RewardAutoClaim;
        getParentID(): number;
        refreshJEI(): number;
        getQuestChapter(): Internal.Chapter;
        getButtonText(): string;
        getQuestFile(): Internal.QuestFile;
        writeNetData(buffer: Internal.FriendlyByteBuf_): void;
        getConfig(config: Internal.ConfigGroup_): void;
        getIcon(): Internal.Icon;
        forceProgressRaw(teamData: Internal.TeamData_, progressChange: Internal.ProgressChange_): void;
        claimAutomated(tileEntity: Internal.BlockEntity_, playerId: Internal.UUID_, player: Internal.ServerPlayer_, simulate: boolean): Internal.Optional<Internal.ItemStack>;
        static isNull(object: Internal.QuestObjectBase_): boolean;
        equals(object: any): boolean;
        toString(): string;
        static titleToID(s: string): Internal.Optional<string>;
        onCreated(): void;
        autoclaim : Internal.RewardAutoClaim;
        invalid : boolean;
        icon : Internal.ItemStack;
        team : Internal.Tristate;
        static sendNotifications : Internal.Tristate;
        id : number;
        title : string;
        quest : Internal.Quest;
        get buttonText(): string;
        get ingredient(): any;
        get codeString(): string;
        get questFile(): Internal.QuestFile;
        get type(): Internal.RewardType;
        get excludeFromClaimAll(): boolean;
        get parentID(): number;
        get mutableTitle(): Internal.MutableComponent;
        get tags(): Internal.Set<string>;
        get altIcon(): Internal.Icon;
        get objectType(): Internal.QuestObjectType;
        get autoClaimType(): Internal.RewardAutoClaim;
        get path(): string;
        get teamReward(): boolean;
        get altTitle(): Internal.Component;
        get class(): Internal.Class<any>;
        get questChapter(): Internal.Chapter;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    type Reward_ = Reward;
    interface EntityBlock {
    }
    type EntityBlock_ = EntityBlock;
    interface ConfigCallback {
        save(arg0: boolean): void;
    }
    type ConfigCallback_ = ConfigCallback;
    class FieldAttributes {
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        getName(): string;
        notifyAll(): void;
        getDeclaredClass(): Internal.Class<any>;
        getAnnotations(): Internal.Collection<Internal.Annotation>;
        notify(): void;
        getDeclaringClass(): Internal.Class<any>;
        hasModifier(arg0: number): boolean;
        getAnnotation<T>(arg0: Internal.Class_<T>): T;
        hashCode(): number;
        equals(arg0: any): boolean;
        getDeclaredType(): java_.lang.reflect.Type;
        toString(): string;
        get name(): string;
        get annotations(): Internal.Collection<Internal.Annotation>;
        get declaredType(): java_.lang.reflect.Type;
        get declaredClass(): Internal.Class<any>;
        get class(): Internal.Class<any>;
        get declaringClass(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    type FieldAttributes_ = FieldAttributes;
    abstract class FTBQuestsKubeJSTeamData {
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        getRelativeProgress(id: any): number;
        notifyAll(): void;
        getTaskProgress(id: any): number;
        isStarted(id: any): boolean;
        addProgress(id: any, progress: number): boolean;
        getLocked(): boolean;
        getFile(): Internal.QuestFile;
        notify(): void;
        setLocked(v: boolean): void;
        changeProgress(id: any, consumer: Internal.Consumer_<Internal.ProgressChange_>): void;
        getOnlineMembers(): Internal.EntityArrayList;
        hashCode(): number;
        equals(arg0: any): boolean;
        canStartQuest(id: any): boolean;
        reset(id: any): void;
        toString(): string;
        complete(id: any): void;
        getData(): Internal.TeamData;
        isCompleted(id: any): boolean;
        get file(): Internal.QuestFile;
        get onlineMembers(): Internal.EntityArrayList;
        get data(): Internal.TeamData;
        get locked(): boolean;
        get class(): Internal.Class<any>;
        set locked(v: boolean);
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    type FTBQuestsKubeJSTeamData_ = FTBQuestsKubeJSTeamData;
    interface ChannelProgressiveFuture extends Internal.ChannelFuture, Internal.ProgressiveFuture<void> {
        cancel(arg0: boolean): boolean;
        isCancelled(): boolean;
        removeListeners(arg0: Internal.GenericFutureListener_<io.netty.util.concurrent.Future_<void>>[]): Internal.ChannelProgressiveFuture;
        removeListeners(arg0: Internal.GenericFutureListener_<io.netty.util.concurrent.Future_<void>>[]): Internal.ChannelFuture;
        removeListeners(arg0: Internal.GenericFutureListener_<io.netty.util.concurrent.Future_<void>>[]): io.netty.util.concurrent.Future<void>;
        removeListeners(arg0: Internal.GenericFutureListener_<io.netty.util.concurrent.Future_<void>>[]): Internal.ProgressiveFuture<void>;
        getNow(): void;
        channel(): io.netty.channel.Channel;
        cause(): Internal.Throwable;
        awaitUninterruptibly(): Internal.ChannelProgressiveFuture;
        awaitUninterruptibly(): Internal.ChannelFuture;
        awaitUninterruptibly(): io.netty.util.concurrent.Future<void>;
        awaitUninterruptibly(): Internal.ProgressiveFuture<void>;
        awaitUninterruptibly(arg0: number, arg1: Internal.TimeUnit_): boolean;
        awaitUninterruptibly(arg0: number): boolean;
        removeListener(arg0: Internal.GenericFutureListener_<io.netty.util.concurrent.Future_<void>>): Internal.ChannelProgressiveFuture;
        removeListener(arg0: Internal.GenericFutureListener_<io.netty.util.concurrent.Future_<void>>): Internal.ChannelFuture;
        removeListener(arg0: Internal.GenericFutureListener_<io.netty.util.concurrent.Future_<void>>): io.netty.util.concurrent.Future<void>;
        removeListener(arg0: Internal.GenericFutureListener_<io.netty.util.concurrent.Future_<void>>): Internal.ProgressiveFuture<void>;
        isDone(): boolean;
        sync(): Internal.ChannelProgressiveFuture;
        sync(): Internal.ChannelFuture;
        sync(): io.netty.util.concurrent.Future<void>;
        sync(): Internal.ProgressiveFuture<void>;
        isVoid(): boolean;
        syncUninterruptibly(): Internal.ChannelProgressiveFuture;
        syncUninterruptibly(): Internal.ChannelFuture;
        syncUninterruptibly(): io.netty.util.concurrent.Future<void>;
        syncUninterruptibly(): Internal.ProgressiveFuture<void>;
        get(arg0: number, arg1: Internal.TimeUnit_): void;
        get(): void;
        isCancellable(): boolean;
        await(): Internal.ChannelProgressiveFuture;
        await(): Internal.ChannelFuture;
        await(): io.netty.util.concurrent.Future<void>;
        await(): Internal.ProgressiveFuture<void>;
        await(arg0: number, arg1: Internal.TimeUnit_): boolean;
        await(arg0: number): boolean;
        addListeners(arg0: Internal.GenericFutureListener_<io.netty.util.concurrent.Future_<void>>[]): Internal.ChannelProgressiveFuture;
        addListeners(arg0: Internal.GenericFutureListener_<io.netty.util.concurrent.Future_<void>>[]): Internal.ChannelFuture;
        addListeners(arg0: Internal.GenericFutureListener_<io.netty.util.concurrent.Future_<void>>[]): io.netty.util.concurrent.Future<void>;
        addListeners(arg0: Internal.GenericFutureListener_<io.netty.util.concurrent.Future_<void>>[]): Internal.ProgressiveFuture<void>;
        isSuccess(): boolean;
        addListener(arg0: Internal.GenericFutureListener_<io.netty.util.concurrent.Future_<void>>): Internal.ChannelProgressiveFuture;
        addListener(arg0: Internal.GenericFutureListener_<io.netty.util.concurrent.Future_<void>>): Internal.ChannelFuture;
        addListener(arg0: Internal.GenericFutureListener_<io.netty.util.concurrent.Future_<void>>): io.netty.util.concurrent.Future<void>;
        addListener(arg0: Internal.GenericFutureListener_<io.netty.util.concurrent.Future_<void>>): Internal.ProgressiveFuture<void>;
    }
    type ChannelProgressiveFuture_ = ChannelProgressiveFuture;
    interface AbstractContainerScreenAccessor {
        setSkipNextRelease(arg0: boolean): void;
        setIsQuickCrafting(arg0: boolean): void;
        getQuickCraftingButton(): number;
        getIsQuickCrafting(): boolean;
        invokeSlotClicked(arg0: Internal.Slot_, arg1: number, arg2: number, arg3: Internal.ClickType_): void;
        invokeFindSlot(arg0: number, arg1: number): Internal.Slot;
    }
    type AbstractContainerScreenAccessor_ = AbstractContainerScreenAccessor;
    interface Function10 <T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, R> {
        curry9(): Internal.Function9<T1, T2, T3, T4, T5, T6, T7, T8, T9, java_.util.function_.Function<T10, R>>;
        apply(arg0: T1, arg1: T2, arg2: T3, arg3: T4, arg4: T5, arg5: T6, arg6: T7, arg7: T8, arg8: T9, arg9: T10): R;
        curry7(): Internal.Function7<T1, T2, T3, T4, T5, T6, T7, Internal.Function3<T8, T9, T10, R>>;
        curry8(): Internal.Function8<T1, T2, T3, T4, T5, T6, T7, T8, Internal.BiFunction<T9, T10, R>>;
        curry5(): Internal.Function5<T1, T2, T3, T4, T5, Internal.Function5<T6, T7, T8, T9, T10, R>>;
        curry6(): Internal.Function6<T1, T2, T3, T4, T5, T6, Internal.Function4<T7, T8, T9, T10, R>>;
        curry3(): Internal.Function3<T1, T2, T3, Internal.Function7<T4, T5, T6, T7, T8, T9, T10, R>>;
        curry4(): Internal.Function4<T1, T2, T3, T4, Internal.Function6<T5, T6, T7, T8, T9, T10, R>>;
        curry2(): Internal.BiFunction<T1, T2, Internal.Function8<T3, T4, T5, T6, T7, T8, T9, T10, R>>;
        curry(): java_.util.function_.Function<T1, Internal.Function9<T2, T3, T4, T5, T6, T7, T8, T9, T10, R>>;
    }
    type Function10_<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, R> = Function10<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, R>;
    class RecordItemJS$Builder extends Internal.ItemBuilder {
        barWidth(barWidth: Internal.ToIntFunction_<Internal.ItemStackJS_>): Internal.ItemBuilder;
        getClass(): Internal.Class<any>;
        maxStackSize(v: number): Internal.ItemBuilder;
        translationKey(key: string): Internal.BuilderBase<Internal.Item>;
        newID(pre: string, post: string): ResourceLocation;
        use(use: Internal.ItemBuilder$UseCallback_): Internal.ItemBuilder;
        maxDamage(v: number): Internal.ItemBuilder;
        textureJson(json: Internal.JsonObject_): Internal.ItemBuilder;
        tooltip(text: Internal.Component_): Internal.ItemBuilder;
        type(type: string): Internal.BuilderBase<Internal.Item>;
        containerItem(id: string): Internal.ItemBuilder;
        subtypes(fn: java_.util.function_.Function_<Internal.ItemStackJS_, Internal.Collection_<Internal.ItemStackJS_>>): Internal.ItemBuilder;
        analogOutput(o: number): Internal.RecordItemJS$Builder;
        modelJson(json: Internal.JsonObject_): Internal.ItemBuilder;
        burnTime(v: number): Internal.ItemBuilder;
        useDuration(useDuration: Internal.ToIntFunction_<Internal.ItemStackJS_>): Internal.ItemBuilder;
        tag(tag: ResourceLocation_): Internal.BuilderBase<Internal.Item>;
        parentModel(m: string): Internal.ItemBuilder;
        generateDataJsons(generator: Internal.DataJsonGenerator_): void;
        group(g: string): Internal.ItemBuilder;
        song(s: ResourceLocation_): Internal.RecordItemJS$Builder;
        static ofArmorMaterial(o: any): Internal.ArmorMaterial;
        modifyAttribute(attribute: ResourceLocation_, identifier: string, d: number, operation: Internal.AttributeModifier$Operation_): Internal.ItemBuilder;
        getRegistryType(): Internal.RegistryObjectBuilderTypes<Internal.Item>;
        glow(v: boolean): Internal.ItemBuilder;
        useAnimation(animation: Internal.UseAnim_): Internal.ItemBuilder;
        rarity(v: Rarity_): Internal.ItemBuilder;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        clientRegistry(minecraft: Internal.Minecraft_): void;
        transformObject(obj: Internal.Item_): Internal.Item;
        color(callback: Internal.ItemBuilder$ItemColorJS_): Internal.ItemBuilder;
        color(index: number, c: Internal.Color_): Internal.ItemBuilder;
        displayName(name: string): Internal.BuilderBase<Internal.Item>;
        notifyAll(): void;
        barColor(barColor: java_.util.function_.Function_<Internal.ItemStackJS_, Internal.Color_>): Internal.ItemBuilder;
        notify(): void;
        createAdditionalObjects(): void;
        hashCode(): number;
        get(): Internal.Item;
        generateAssetJsons(generator: Internal.AssetJsonGenerator_): void;
        getTranslationKeyGroup(): string;
        texture(key: string, tex: string): Internal.ItemBuilder;
        texture(tex: string): Internal.ItemBuilder;
        generateLang(lang: Internal.Map_<string, string>): void;
        food(b: Internal.Consumer_<Internal.FoodBuilder_>): Internal.ItemBuilder;
        createObject(): Internal.Item;
        releaseUsing(releaseUsing: Internal.ItemBuilder$ReleaseUsingCallback_): Internal.ItemBuilder;
        unstackable(): Internal.ItemBuilder;
        addResourcePackLocations(path: string, list: Internal.List_<ResourceLocation_>, packType: Internal.PackType_): void;
        equals(arg0: any): boolean;
        toString(): string;
        finishUsing(finishUsing: Internal.ItemBuilder$FinishUsingCallback_): Internal.ItemBuilder;
        createItemProperties(): Internal.Item$Properties;
        static readonly TOOL_TIERS : {"gold":any,"diamond":any,"iron":any,"wood":any,"stone":any,"netherite":any};
        static readonly ARMOR_TIERS : {"gold":any,"chain":any,"diamond":any,"turtle":any,"iron":any,"leather":any,"netherite":any};
        readonly id : ResourceLocation;
        get registryType(): Internal.RegistryObjectBuilderTypes<Internal.Item>;
        get class(): Internal.Class<any>;
        get translationKeyGroup(): string;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    type RecordItemJS$Builder_ = RecordItemJS$Builder;
    abstract class Reader implements Internal.Readable, Internal.Closeable {
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        read(arg0: string[]): number;
        read(arg0: string[], arg1: number, arg2: number): number;
        read(arg0: Internal.CharBuffer_): number;
        read(): number;
        markSupported(): boolean;
        notifyAll(): void;
        skip(arg0: number): number;
        transferTo(arg0: Internal.Writer_): number;
        notify(): void;
        static nullReader(): Internal.Reader;
        hashCode(): number;
        ready(): boolean;
        equals(arg0: any): boolean;
        reset(): void;
        toString(): string;
        close(): void;
        mark(arg0: number): void;
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    type Reader_ = Reader;
    interface DuneCache {
        getBiomeAt(): Internal.Long2ObjectOpenHashMap<Internal.Byte2ObjectOpenHashMap<Internal.ResourceKey<Internal.Biome>>>;
        getDensityAt(): Internal.Long2ObjectOpenHashMap<Internal.Byte2DoubleOpenHashMap>;
    }
    type DuneCache_ = DuneCache;
    interface GroupPrincipal extends Internal.UserPrincipal {
        getName(): string;
        hashCode(): number;
        equals(arg0: any): boolean;
        toString(): string;
        implies(arg0: Internal.Subject_): boolean;
    }
    type GroupPrincipal_ = GroupPrincipal;
    abstract class Monster extends Internal.PathfinderMob implements Internal.Enemy {
        getClass(): Internal.Class<any>;
        resetDynamicLight(): void;
        getCapability<T_>(arg0: Internal.Capability_<T_>, arg1: Internal.Direction_): Internal.LazyOptional<T_>;
        getCapability<T_>(arg0: Internal.Capability_<T_>): Internal.LazyOptional<T_>;
        captureDrops(arg0: Internal.Collection_<Internal.ItemEntity_>): Internal.Collection<Internal.ItemEntity>;
        captureDrops(): Internal.Collection<Internal.ItemEntity>;
        canBeRiddenInWater(arg0: Internal.Entity_): boolean;
        setCitadelEntityData(arg0: Internal.CompoundTag_): void;
        isDynamicLightEnabled(): boolean;
        changeDimension(arg0: Internal.ServerLevel_, arg1: Internal.ITeleporter_): Internal.Entity;
        serializeNBT(): Internal.CompoundTag;
        invalidateCaps(): void;
        setDynamicLightEnabled(arg0: boolean): void;
        shouldUpdateDynamicLight(): boolean;
        foodEatenKJS(is: Internal.ItemStack_): void;
        revive(): void;
        setVisualScale(arg0: number): void;
        dynamicLightTick(): void;
        getPersistentDataKJS(): Internal.CompoundTag;
        canUpdate(): boolean;
        canUpdate(arg0: boolean): void;
        getDynamicLightY(): number;
        getDynamicLightZ(): number;
        handler$zbj000$curio$canFreeze(arg0: Internal.CallbackInfoReturnable_<any>): void;
        getDynamicLightX(): number;
        areCapsCompatible(arg0: Internal.CapabilityProvider_<Internal.Entity_>): boolean;
        areCapsCompatible(arg0: Internal.CapabilityDispatcher_): boolean;
        redirect$bie002$elytraOverride(arg0: Internal.ItemStack_, arg1: Internal.LivingEntity_): boolean;
        getEyeHeightAccess(arg0: Internal.Pose_, arg1: Internal.EntityDimensions_): number;
        reviveCaps(): void;
        lambdynlights$updateDynamicLight(arg0: Internal.LevelRenderer_): boolean;
        handler$bih000$removed(arg0: Internal.CallbackInfo_): void;
        canRiderInteract(): boolean;
        lambdynlights$scheduleTrackedChunksRebuild(arg0: Internal.LevelRenderer_): void;
        handler$bih001$onTick(arg0: Internal.CallbackInfo_): void;
        onAddedToWorld(): void;
        canTrample(arg0: Internal.BlockState_, arg1: BlockPos_, arg2: number): boolean;
        getCitadelEntityData(): Internal.CompoundTag;
        getClassification(arg0: boolean): Internal.MobCategory;
        handler$bih000$onRemove(arg0: Internal.CallbackInfo_): void;
        shouldRiderSit(): boolean;
        getPickedResult(arg0: Internal.HitResult_): Internal.ItemStack;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        notifyAll(): void;
        isActuallyReallyBlocking(): boolean;
        getPersistentData(): Internal.CompoundTag;
        notify(): void;
        redirect$bie000$eytraValidOverride(arg0: Internal.ItemStack_, arg1: Internal.LivingEntity_, arg2: number): boolean;
        hashCode(): number;
        setDimension(arg0: Internal.EntityDimensions_): void;
        isAddedToWorld(): boolean;
        getParts(): any[];
        getDynamicLightWorld(): Internal.Level;
        onRemovedFromWorld(): void;
        getLuminance(): number;
        isMultipartEntity(): boolean;
        deserializeNBT(arg0: Internal.CompoundTag_): void;
        curePotionEffects(arg0: Internal.ItemStack_): boolean;
        asKJS(): any;
        shouldRiderFaceForward(arg0: Internal.Player_): boolean;
        equals(arg0: any): boolean;
        toString(): string;
        getVisualScale(): number;
        get luminance(): number;
        get dynamicLightEnabled(): boolean;
        get citadelEntityData(): Internal.CompoundTag;
        get persistentData(): Internal.CompoundTag;
        get multipartEntity(): boolean;
        get addedToWorld(): boolean;
        get dynamicLightY(): number;
        get dynamicLightZ(): number;
        get dynamicLightX(): number;
        get visualScale(): number;
        get persistentDataKJS(): Internal.CompoundTag;
        get actuallyReallyBlocking(): boolean;
        get parts(): any[];
        get class(): Internal.Class<any>;
        get dynamicLightWorld(): Internal.Level;
        set dynamicLightEnabled(arg0: boolean);
        set visualScale(arg0: number);
        set citadelEntityData(arg0: Internal.CompoundTag_);
        set dimension(arg0: Internal.EntityDimensions_);
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    type Monster_ = Monster;
    interface VillagerTypeAccess {
    }
    type VillagerTypeAccess_ = VillagerTypeAccess;
    class ConstantUnit extends Internal.FixedUnit {
        getClass(): Internal.Class<any>;
        mod(with_: dev.latvian.mods.rhino.util.unit.Unit_): dev.latvian.mods.rhino.util.unit.Unit;
        log1p(): dev.latvian.mods.rhino.util.unit.Unit;
        cos(): dev.latvian.mods.rhino.util.unit.Unit;
        deg(): dev.latvian.mods.rhino.util.unit.Unit;
        lt(with_: dev.latvian.mods.rhino.util.unit.Unit_): dev.latvian.mods.rhino.util.unit.Unit;
        atan(): dev.latvian.mods.rhino.util.unit.Unit;
        getAsInt(): number;
        div(with_: dev.latvian.mods.rhino.util.unit.Unit_): dev.latvian.mods.rhino.util.unit.Unit;
        neg(): dev.latvian.mods.rhino.util.unit.Unit;
        shiftLeft(with_: dev.latvian.mods.rhino.util.unit.Unit_): dev.latvian.mods.rhino.util.unit.Unit;
        rad(): dev.latvian.mods.rhino.util.unit.Unit;
        sqrt(): dev.latvian.mods.rhino.util.unit.Unit;
        gte(with_: dev.latvian.mods.rhino.util.unit.Unit_): dev.latvian.mods.rhino.util.unit.Unit;
        neq(with_: dev.latvian.mods.rhino.util.unit.Unit_): dev.latvian.mods.rhino.util.unit.Unit;
        atan2(with_: dev.latvian.mods.rhino.util.unit.Unit_): dev.latvian.mods.rhino.util.unit.Unit;
        tan(): dev.latvian.mods.rhino.util.unit.Unit;
        add(with_: dev.latvian.mods.rhino.util.unit.Unit_): dev.latvian.mods.rhino.util.unit.Unit;
        newValue(v: number): dev.latvian.mods.rhino.util.unit.Unit;
        toBool(): dev.latvian.mods.rhino.util.unit.Unit;
        ceil(): dev.latvian.mods.rhino.util.unit.Unit;
        eq(with_: dev.latvian.mods.rhino.util.unit.Unit_): dev.latvian.mods.rhino.util.unit.Unit;
        shiftRight(with_: dev.latvian.mods.rhino.util.unit.Unit_): dev.latvian.mods.rhino.util.unit.Unit;
        sub(with_: dev.latvian.mods.rhino.util.unit.Unit_): dev.latvian.mods.rhino.util.unit.Unit;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        mul(with_: dev.latvian.mods.rhino.util.unit.Unit_): dev.latvian.mods.rhino.util.unit.Unit;
        log(): dev.latvian.mods.rhino.util.unit.Unit;
        log10(): dev.latvian.mods.rhino.util.unit.Unit;
        notifyAll(): void;
        notify(): void;
        not(): dev.latvian.mods.rhino.util.unit.Unit;
        min(with_: dev.latvian.mods.rhino.util.unit.Unit_): dev.latvian.mods.rhino.util.unit.Unit;
        hashCode(): number;
        and(with_: dev.latvian.mods.rhino.util.unit.Unit_): dev.latvian.mods.rhino.util.unit.Unit;
        static of(value: number): Internal.FixedUnit;
        get(): number;
        pow(with_: dev.latvian.mods.rhino.util.unit.Unit_): dev.latvian.mods.rhino.util.unit.Unit;
        sin(): dev.latvian.mods.rhino.util.unit.Unit;
        xor(with_: dev.latvian.mods.rhino.util.unit.Unit_): dev.latvian.mods.rhino.util.unit.Unit;
        lte(with_: dev.latvian.mods.rhino.util.unit.Unit_): dev.latvian.mods.rhino.util.unit.Unit;
        floor(): dev.latvian.mods.rhino.util.unit.Unit;
        isFixed(): boolean;
        sq(): dev.latvian.mods.rhino.util.unit.Unit;
        or(with_: dev.latvian.mods.rhino.util.unit.Unit_): dev.latvian.mods.rhino.util.unit.Unit;
        max(with_: dev.latvian.mods.rhino.util.unit.Unit_): dev.latvian.mods.rhino.util.unit.Unit;
        gt(with_: dev.latvian.mods.rhino.util.unit.Unit_): dev.latvian.mods.rhino.util.unit.Unit;
        abs(): dev.latvian.mods.rhino.util.unit.Unit;
        getAsBoolean(): boolean;
        equals(arg0: any): boolean;
        toString(): string;
        append(sb: Internal.StringBuilder_): void;
        static readonly ZERO : Internal.FixedUnit;
        static readonly ONE : Internal.FixedUnit;
        static readonly POS_INFINITY : Internal.FixedUnit;
        static readonly NEG_INFINITY : Internal.FixedUnit;
        readonly name : string;
        static readonly NAN : Internal.FixedUnit;
        get asInt(): number;
        get fixed(): boolean;
        get class(): Internal.Class<any>;
        get asBoolean(): boolean;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    type ConstantUnit_ = ConstantUnit;
    class ReadInitialDataEvent extends Internal.EventJS {
        cancel(): void;
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        isCancelled(): boolean;
        getPacketBuffer(): Internal.FriendlyByteBuf;
        post(t: Internal.ScriptType_, id: string, sub: string): boolean;
        post(t: Internal.ScriptType_, id: string): boolean;
        hashCode(): number;
        notifyAll(): void;
        equals(arg0: any): boolean;
        toString(): string;
        getComponent(): Internal.ComponentTileEntity<any>;
        notify(): void;
        canCancel(): boolean;
        static readonly ID : "mbd.read_initial_data";
        get component(): Internal.ComponentTileEntity<any>;
        get packetBuffer(): Internal.FriendlyByteBuf;
        get cancelled(): boolean;
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    type ReadInitialDataEvent_ = ReadInitialDataEvent;
    interface Spliterator$OfLong extends Internal.Spliterator$OfPrimitive<number, java_.util.function_.LongConsumer, Internal.Spliterator$OfLong> {
        trySplit(): Internal.Spliterator$OfLong;
        characteristics(): number;
        tryAdvance(arg0: Internal.Consumer_<number>): boolean;
        tryAdvance(arg0: java_.util.function_.LongConsumer_): boolean;
        getComparator(): Internal.Comparator<number>;
        getExactSizeIfKnown(): number;
        estimateSize(): number;
        hasCharacteristics(arg0: number): boolean;
        forEachRemaining(arg0: java_.util.function_.LongConsumer_): void;
        forEachRemaining(arg0: Internal.Consumer_<number>): void;
    }
    type Spliterator$OfLong_ = Spliterator$OfLong;
    class HideCustomJEIEventJS extends Internal.EventJS {
        cancel(): void;
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        isCancelled(): boolean;
        post(t: Internal.ScriptType_, id: string, sub: string): boolean;
        post(t: Internal.ScriptType_, id: string): boolean;
        hashCode(): number;
        notifyAll(): void;
        equals(arg0: any): boolean;
        get(s: Internal.IIngredientType_<any>): Internal.HideJEIEventJS<any>;
        toString(): string;
        notify(): void;
        canCancel(): boolean;
        get cancelled(): boolean;
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    type HideCustomJEIEventJS_ = HideCustomJEIEventJS;
    interface IBlockRendererProvider extends Internal.IForgeBlock {
        rotate(arg0: Internal.BlockState_, arg1: Internal.LevelAccessor_, arg2: BlockPos_, arg3: Internal.Rotation_): Internal.BlockState;
        getStateAtViewpoint(arg0: Internal.BlockState_, arg1: Internal.BlockGetter_, arg2: BlockPos_, arg3: Vec3_): Internal.BlockState;
        onBlockExploded(arg0: Internal.BlockState_, arg1: Internal.Level_, arg2: BlockPos_, arg3: Internal.Explosion_): void;
        getBedDirection(arg0: Internal.BlockState_, arg1: Internal.LevelReader_, arg2: BlockPos_): Internal.Direction;
        isBed(arg0: Internal.BlockState_, arg1: Internal.BlockGetter_, arg2: BlockPos_, arg3: Internal.Entity_): boolean;
        canHarvestBlock(arg0: Internal.BlockState_, arg1: Internal.BlockGetter_, arg2: BlockPos_, arg3: Internal.Player_): boolean;
        makesOpenTrapdoorAboveClimbable(arg0: Internal.BlockState_, arg1: Internal.LevelReader_, arg2: BlockPos_, arg3: Internal.BlockState_): boolean;
        isLadder(arg0: Internal.BlockState_, arg1: Internal.LevelReader_, arg2: BlockPos_, arg3: Internal.LivingEntity_): boolean;
        shouldDisplayFluidOverlay(arg0: Internal.BlockState_, arg1: Internal.BlockAndTintGetter_, arg2: BlockPos_, arg3: Internal.FluidState_): boolean;
        canStickTo(arg0: Internal.BlockState_, arg1: Internal.BlockState_): boolean;
        onNeighborChange(arg0: Internal.BlockState_, arg1: Internal.LevelReader_, arg2: BlockPos_, arg3: BlockPos_): void;
        getWeakChanges(arg0: Internal.BlockState_, arg1: Internal.LevelReader_, arg2: BlockPos_): boolean;
        canEntityDestroy(arg0: Internal.BlockState_, arg1: Internal.BlockGetter_, arg2: BlockPos_, arg3: Internal.Entity_): boolean;
        isBurning(arg0: Internal.BlockState_, arg1: Internal.BlockGetter_, arg2: BlockPos_): boolean;
        getFriction(arg0: Internal.BlockState_, arg1: Internal.LevelReader_, arg2: BlockPos_, arg3: Internal.Entity_): number;
        isValidSpawn(arg0: Internal.BlockState_, arg1: Internal.BlockGetter_, arg2: BlockPos_, arg3: Internal.SpawnPlacements$Type_, arg4: Internal.EntityType_<any>): boolean;
        isPortalFrame(arg0: Internal.BlockState_, arg1: Internal.BlockGetter_, arg2: BlockPos_): boolean;
        getExplosionResistance(arg0: Internal.BlockState_, arg1: Internal.BlockGetter_, arg2: BlockPos_, arg3: Internal.Explosion_): number;
        canSustainPlant(arg0: Internal.BlockState_, arg1: Internal.BlockGetter_, arg2: BlockPos_, arg3: Internal.Direction_, arg4: Internal.IPlantable_): boolean;
        isScaffolding(arg0: Internal.BlockState_, arg1: Internal.LevelReader_, arg2: BlockPos_, arg3: Internal.LivingEntity_): boolean;
        canDropFromExplosion(arg0: Internal.BlockState_, arg1: Internal.BlockGetter_, arg2: BlockPos_, arg3: Internal.Explosion_): boolean;
        isStickyBlock(arg0: Internal.BlockState_): boolean;
        isFertile(arg0: Internal.BlockState_, arg1: Internal.BlockGetter_, arg2: BlockPos_): boolean;
        getAiPathNodeType(arg0: Internal.BlockState_, arg1: Internal.BlockGetter_, arg2: BlockPos_, arg3: Internal.Mob_): Internal.BlockPathTypes;
        isSlimeBlock(arg0: Internal.BlockState_): boolean;
        getFireSpreadSpeed(arg0: Internal.BlockState_, arg1: Internal.BlockGetter_, arg2: BlockPos_, arg3: Internal.Direction_): number;
        getToolModifiedState(arg0: Internal.BlockState_, arg1: Internal.Level_, arg2: BlockPos_, arg3: Internal.Player_, arg4: Internal.ItemStack_, arg5: Internal.ToolAction_): Internal.BlockState;
        getToolModifiedState(arg0: Internal.BlockState_, arg1: Internal.UseOnContext_, arg2: Internal.ToolAction_, arg3: boolean): Internal.BlockState;
        getBeaconColorMultiplier(arg0: Internal.BlockState_, arg1: Internal.LevelReader_, arg2: BlockPos_, arg3: BlockPos_): number[];
        getExpDrop(arg0: Internal.BlockState_, arg1: Internal.LevelReader_, arg2: BlockPos_, arg3: number, arg4: number): number;
        isConduitFrame(arg0: Internal.BlockState_, arg1: Internal.LevelReader_, arg2: BlockPos_, arg3: BlockPos_): boolean;
        getLightEmission(arg0: Internal.BlockState_, arg1: Internal.BlockGetter_, arg2: BlockPos_): number;
        onDestroyedByPlayer(arg0: Internal.BlockState_, arg1: Internal.Level_, arg2: BlockPos_, arg3: Internal.Player_, arg4: boolean, arg5: Internal.FluidState_): boolean;
        getLightingMap(arg0: Internal.BlockAndTintGetter_, arg1: Internal.BlockState_, arg2: BlockPos_): number;
        shouldCheckWeakPower(arg0: Internal.BlockState_, arg1: Internal.LevelReader_, arg2: BlockPos_, arg3: Internal.Direction_): boolean;
        collisionExtendsVertically(arg0: Internal.BlockState_, arg1: Internal.BlockGetter_, arg2: BlockPos_, arg3: Internal.Entity_): boolean;
        supportsExternalFaceHiding(arg0: Internal.BlockState_): boolean;
        addLandingEffects(arg0: Internal.BlockState_, arg1: Internal.ServerLevel_, arg2: BlockPos_, arg3: Internal.BlockState_, arg4: Internal.LivingEntity_, arg5: number): boolean;
        getSoundType(arg0: Internal.BlockState_, arg1: Internal.LevelReader_, arg2: BlockPos_, arg3: Internal.Entity_): Internal.SoundType;
        addRunningEffects(arg0: Internal.BlockState_, arg1: Internal.Level_, arg2: BlockPos_, arg3: Internal.Entity_): boolean;
        hidesNeighborFace(arg0: Internal.BlockGetter_, arg1: BlockPos_, arg2: Internal.BlockState_, arg3: Internal.BlockState_, arg4: Internal.Direction_): boolean;
        getCloneItemStack(arg0: Internal.BlockState_, arg1: Internal.HitResult_, arg2: Internal.BlockGetter_, arg3: BlockPos_, arg4: Internal.Player_): Internal.ItemStack;
        isFlammable(arg0: Internal.BlockState_, arg1: Internal.BlockGetter_, arg2: BlockPos_, arg3: Internal.Direction_): boolean;
        getRenderer(arg0: Internal.BlockState_, arg1: BlockPos_, arg2: Internal.BlockAndTintGetter_): Internal.IRenderer;
        onCaughtFire(arg0: Internal.BlockState_, arg1: Internal.Level_, arg2: BlockPos_, arg3: Internal.Direction_, arg4: Internal.LivingEntity_): void;
        getEnchantPowerBonus(arg0: Internal.BlockState_, arg1: Internal.LevelReader_, arg2: BlockPos_): number;
        setBedOccupied(arg0: Internal.BlockState_, arg1: Internal.Level_, arg2: BlockPos_, arg3: Internal.LivingEntity_, arg4: boolean): void;
        isFireSource(arg0: Internal.BlockState_, arg1: Internal.LevelReader_, arg2: BlockPos_, arg3: Internal.Direction_): boolean;
        getRespawnPosition(arg0: Internal.BlockState_, arg1: Internal.EntityType_<any>, arg2: Internal.LevelReader_, arg3: BlockPos_, arg4: number, arg5: Internal.LivingEntity_): Internal.Optional<Vec3>;
        canConnectRedstone(arg0: Internal.BlockState_, arg1: Internal.BlockGetter_, arg2: BlockPos_, arg3: Internal.Direction_): boolean;
        getFlammability(arg0: Internal.BlockState_, arg1: Internal.BlockGetter_, arg2: BlockPos_, arg3: Internal.Direction_): number;
    }
    type IBlockRendererProvider_ = IBlockRendererProvider;
    class AccessibleRelation extends Internal.AccessibleBundle {
        getClass(): Internal.Class<any>;
        getKey(): string;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        getTarget(): any[];
        toDisplayString(): string;
        toDisplayString(arg0: Internal.Locale_): string;
        hashCode(): number;
        notifyAll(): void;
        equals(arg0: any): boolean;
        setTarget(arg0: any): void;
        setTarget(arg0: any[]): void;
        toString(): string;
        notify(): void;
        static readonly EMBEDS : "embeds";
        static readonly EMBEDDED_BY : "embeddedBy";
        static readonly FLOWS_FROM_PROPERTY : "flowsFromProperty";
        static readonly LABELED_BY : "labeledBy";
        static readonly MEMBER_OF : "memberOf";
        static readonly SUBWINDOW_OF : "subwindowOf";
        static readonly LABELED_BY_PROPERTY : "labeledByProperty";
        static readonly CHILD_NODE_OF : "childNodeOf";
        static readonly SUBWINDOW_OF_PROPERTY : "subwindowOfProperty";
        static readonly CONTROLLED_BY : "controlledBy";
        static readonly EMBEDDED_BY_PROPERTY : "embeddedByProperty";
        static readonly LABEL_FOR : "labelFor";
        static readonly CONTROLLER_FOR : "controllerFor";
        static readonly PARENT_WINDOW_OF : "parentWindowOf";
        static readonly EMBEDS_PROPERTY : "embedsProperty";
        static readonly CONTROLLER_FOR_PROPERTY : "controllerForProperty";
        static readonly FLOWS_TO_PROPERTY : "flowsToProperty";
        static readonly CONTROLLED_BY_PROPERTY : "controlledByProperty";
        static readonly FLOWS_FROM : "flowsFrom";
        static readonly LABEL_FOR_PROPERTY : "labelForProperty";
        static readonly CHILD_NODE_OF_PROPERTY : "childNodeOfProperty";
        static readonly PARENT_WINDOW_OF_PROPERTY : "parentWindowOfProperty";
        static readonly FLOWS_TO : "flowsTo";
        static readonly MEMBER_OF_PROPERTY : "memberOfProperty";
        get class(): Internal.Class<any>;
        get key(): string;
        get target(): any[];
        set target(arg0: any[]);
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    type AccessibleRelation_ = AccessibleRelation;
    interface Long2ShortFunction extends Internal.Function<number, number>, Internal.LongToIntFunction {
        getOrDefault(arg0: any, arg1: number): number;
        getOrDefault(arg0: number, arg1: number): number;
        andThenShort(arg0: Internal.Short2ShortFunction_): Internal.Long2ShortFunction;
        composeByte(arg0: Internal.Byte2LongFunction_): Internal.Byte2ShortFunction;
        andThenInt(arg0: Internal.Short2IntFunction_): Internal.Long2IntFunction;
        composeReference<T_>(arg0: Internal.Reference2LongFunction_<T_>): Internal.Reference2ShortFunction<T_>;
        andThen<T_>(arg0: java_.util.function_.Function_<number, T_>): java_.util.function_.Function<number, T_>;
        put(arg0: number, arg1: number): number;
        remove(arg0: number): number;
        remove(arg0: any): number;
        defaultReturnValue(): number;
        defaultReturnValue(arg0: number): void;
        andThenDouble(arg0: Internal.Short2DoubleFunction_): Internal.Long2DoubleFunction;
        andThenObject<T_>(arg0: Internal.Short2ObjectFunction_<T_>): Internal.Long2ObjectFunction<T_>;
        get(arg0: any): number;
        get(arg0: number): number;
        andThenLong(arg0: Internal.Short2LongFunction_): Internal.Long2LongFunction;
        composeLong(arg0: Internal.Long2LongFunction_): Internal.Long2ShortFunction;
        andThenByte(arg0: Internal.Short2ByteFunction_): Internal.Long2ByteFunction;
        andThenFloat(arg0: Internal.Short2FloatFunction_): Internal.Long2FloatFunction;
        applyAsInt(arg0: number): number;
        apply(arg0: number): number;
        containsKey(arg0: any): boolean;
        containsKey(arg0: number): boolean;
        composeInt(arg0: Internal.Int2LongFunction_): Internal.Int2ShortFunction;
        clear(): void;
        composeFloat(arg0: Internal.Float2LongFunction_): Internal.Float2ShortFunction;
        andThenChar(arg0: Internal.Short2CharFunction_): Internal.Long2CharFunction;
        composeObject<T_>(arg0: Internal.Object2LongFunction_<T_>): Internal.Object2ShortFunction<T_>;
        size(): number;
        compose<T_>(arg0: java_.util.function_.Function_<T_, number>): java_.util.function_.Function<T_, number>;
        composeShort(arg0: Internal.Short2LongFunction_): Internal.Short2ShortFunction;
        andThenReference<T_>(arg0: Internal.Short2ReferenceFunction_<T_>): Internal.Long2ReferenceFunction<T_>;
        composeChar(arg0: Internal.Char2LongFunction_): Internal.Char2ShortFunction;
        composeDouble(arg0: Internal.Double2LongFunction_): Internal.Double2ShortFunction;
    }
    type Long2ShortFunction_ = ((arg0: number) => number) | Long2ShortFunction;
    class Painter {
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        getObject(key: string): Internal.PainterObject;
        hashCode(): number;
        notifyAll(): void;
        equals(arg0: any): boolean;
        clear(): void;
        paint(root: Internal.CompoundTag_): void;
        setVariable(key: string, variable: dev.latvian.mods.rhino.util.unit.Unit_): void;
        toString(): string;
        make(type: string): Internal.PainterObject;
        notify(): void;
        readonly unitStorage : Internal.UnitStorage;
        static readonly LEFT : -1;
        static readonly RANDOM : Internal.Random;
        static readonly DRAW_INGAME : 1;
        static readonly BOTTOM : 1;
        readonly screenHeightUnit : Internal.MutableUnit;
        static readonly DRAW_GUI : 2;
        static readonly CENTER : 0;
        readonly screenWidthUnit : Internal.MutableUnit;
        static readonly DRAW_ALWAYS : 0;
        static readonly TOP : -1;
        readonly mouseXUnit : Internal.MutableUnit;
        readonly mouseYUnit : Internal.MutableUnit;
        readonly deltaUnit : Internal.MutableUnit;
        static readonly RIGHT : 1;
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    type Painter_ = Painter;
    class Env extends Internal.Enum<Internal.Env> {
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        toPlatform(): Internal.Dist;
        static valueOf(name: string): Internal.Env;
        static valueOf<T_>(arg0: Internal.Class_<T_>, arg1: string): T_;
        notifyAll(): void;
        static values(): Internal.Env[];
        compareTo(arg0: Internal.Env_): number;
        describeConstable(): Internal.Optional<Internal.Enum$EnumDesc<Internal.Env>>;
        notify(): void;
        static fromPlatform(type: any): Internal.Env;
        getDeclaringClass(): Internal.Class<Internal.Env>;
        hashCode(): number;
        equals(arg0: any): boolean;
        name(): string;
        toString(): string;
        ordinal(): number;
        static readonly SERVER : Internal.Env;
        static readonly CLIENT : Internal.Env;
        get class(): Internal.Class<any>;
        get declaringClass(): Internal.Class<Internal.Env>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    type Env_ = "server" | "client" | Env;
    class DistancePredicate {
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        hashCode(): number;
        notifyAll(): void;
        equals(arg0: any): boolean;
        toString(): string;
        notify(): void;
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    type DistancePredicate_ = DistancePredicate;
    interface IIngredientSlot {
        getIngredientOverMouse(arg0: number, arg1: number): any;
    }
    type IIngredientSlot_ = IIngredientSlot;
    /**
    * Fired when the block loot table is registering.
    */
    class BlockLootEventJS extends Internal.LootEventJS {
        cancel(): void;
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        isCancelled(): boolean;
        addSimpleBlock(blocks: BlockStatePredicate_, item: Internal.ItemStack_): void;
        addSimpleBlock(blocks: BlockStatePredicate_): void;
        notifyAll(): void;
        modifyBlock(blocks: BlockStatePredicate_, b: Internal.Consumer_<Internal.LootBuilder_>): void;
        addJson(id: ResourceLocation_, json: Internal.JsonObject_): void;
        notify(): void;
        modify(id: ResourceLocation_, b: Internal.Consumer_<Internal.LootBuilder_>): void;
        removeAll(): void;
        post(t: Internal.ScriptType_, id: string, sub: string): boolean;
        post(t: Internal.ScriptType_, id: string): boolean;
        build(blocks: BlockStatePredicate_, b: Internal.Consumer_<Internal.LootBuilder_>): void;
        getType(): string;
        hashCode(): number;
        addBlock(blocks: BlockStatePredicate_, b: Internal.Consumer_<Internal.LootBuilder_>): void;
        equals(arg0: any): boolean;
        toString(): string;
        getDirectory(): string;
        canCancel(): boolean;
        get cancelled(): boolean;
        get type(): string;
        get class(): Internal.Class<any>;
        get directory(): string;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    /**
    * Fired when the block loot table is registering.
    */
    type BlockLootEventJS_ = BlockLootEventJS;
    interface IRenderer {
        hasTESR(arg0: Internal.BlockEntity_): boolean;
        isRaw(): boolean;
        registerTextureSwitchEvent(): void;
        render(arg0: Internal.BlockEntity_, arg1: number, arg2: Internal.PoseStack_, arg3: Internal.MultiBufferSource_, arg4: number, arg5: number): void;
        renderModel(arg0: Internal.BlockAndTintGetter_, arg1: BlockPos_, arg2: Internal.BlockState_, arg3: Internal.Direction_, arg4: Internal.Random_, arg5: Internal.IModelData_): Internal.List<Internal.BakedQuad>;
        renderItem(arg0: Internal.ItemStack_, arg1: Internal.ItemTransforms$TransformType_, arg2: boolean, arg3: Internal.PoseStack_, arg4: Internal.MultiBufferSource_, arg5: number, arg6: number, arg7: Internal.BakedModel_): void;
        getParticleTexture(): Internal.TextureAtlasSprite;
        onTextureSwitchEvent(arg0: Internal.TextureStitchEvent$Pre_): void;
        isGlobalRenderer(arg0: Internal.BlockEntity_): boolean;
    }
    type IRenderer_ = IRenderer;
    class CompositeByteBuf extends Internal.AbstractReferenceCountedByteBuf implements Internal.Iterable<Internal.ByteBuf> {
        asReadOnly(): Internal.ByteBuf;
        markReaderIndex(): Internal.CompositeByteBuf;
        getByte(arg0: number): number;
        release(): boolean;
        release(arg0: number): boolean;
        readDoubleLE(): number;
        writeZero(arg0: number): Internal.CompositeByteBuf;
        addComponent(arg0: boolean, arg1: number, arg2: Internal.ByteBuf_): Internal.CompositeByteBuf;
        addComponent(arg0: boolean, arg1: Internal.ByteBuf_): Internal.CompositeByteBuf;
        addComponent(arg0: number, arg1: Internal.ByteBuf_): Internal.CompositeByteBuf;
        addComponent(arg0: Internal.ByteBuf_): Internal.CompositeByteBuf;
        resetReaderIndex(): Internal.CompositeByteBuf;
        writeFloat(arg0: number): Internal.CompositeByteBuf;
        setLongLE(arg0: number, arg1: number): Internal.ByteBuf;
        addComponents(arg0: Internal.Iterable_<Internal.ByteBuf_>): Internal.CompositeByteBuf;
        addComponents(arg0: Internal.ByteBuf_[]): Internal.CompositeByteBuf;
        addComponents(arg0: boolean, arg1: Internal.Iterable_<Internal.ByteBuf_>): Internal.CompositeByteBuf;
        addComponents(arg0: number, arg1: Internal.Iterable_<Internal.ByteBuf_>): Internal.CompositeByteBuf;
        addComponents(arg0: number, arg1: Internal.ByteBuf_[]): Internal.CompositeByteBuf;
        addComponents(arg0: boolean, arg1: Internal.ByteBuf_[]): Internal.CompositeByteBuf;
        iterator(): Internal.Iterator<Internal.ByteBuf>;
        readRetainedSlice(arg0: number): Internal.ByteBuf;
        slice(): Internal.ByteBuf;
        slice(arg0: number, arg1: number): Internal.ByteBuf;
        setDoubleLE(arg0: number, arg1: number): Internal.ByteBuf;
        getMediumLE(arg0: number): number;
        readUnsignedIntLE(): number;
        writeFloatLE(arg0: number): Internal.ByteBuf;
        readInt(): number;
        toByteIndex(arg0: number): number;
        order(): Internal.ByteOrder;
        order(arg0: Internal.ByteOrder_): Internal.ByteBuf;
        writeMedium(arg0: number): Internal.CompositeByteBuf;
        resetWriterIndex(): Internal.CompositeByteBuf;
        spliterator(): Internal.Spliterator<Internal.ByteBuf>;
        writableBytes(): number;
        maxCapacity(): number;
        getUnsignedShort(arg0: number): number;
        internalComponentAtOffset(arg0: number): Internal.ByteBuf;
        bytesBefore(arg0: number): number;
        bytesBefore(arg0: number, arg1: number, arg2: number): number;
        bytesBefore(arg0: number, arg1: number): number;
        nioBufferCount(): number;
        discardReadComponents(): Internal.CompositeByteBuf;
        setInt(arg0: number, arg1: number): Internal.CompositeByteBuf;
        getInt(arg0: number): number;
        markWriterIndex(): Internal.CompositeByteBuf;
        isReadable(arg0: number): boolean;
        isReadable(): boolean;
        writeBoolean(arg0: boolean): Internal.CompositeByteBuf;
        numComponents(): number;
        setIntLE(arg0: number, arg1: number): Internal.ByteBuf;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        writeLongLE(arg0: number): Internal.ByteBuf;
        setShortLE(arg0: number, arg1: number): Internal.ByteBuf;
        retain(arg0: number): Internal.CompositeByteBuf;
        retain(): Internal.CompositeByteBuf;
        isWritable(): boolean;
        isWritable(arg0: number): boolean;
        notify(): void;
        readChar(): string;
        hasMemoryAddress(): boolean;
        capacity(arg0: number): Internal.CompositeByteBuf;
        capacity(): number;
        readCharSequence(arg0: number, arg1: Internal.Charset_): Internal.CharSequence;
        isReadOnly(): boolean;
        readUnsignedShortLE(): number;
        readDouble(): number;
        readFloat(): number;
        internalComponent(arg0: number): Internal.ByteBuf;
        getLongLE(arg0: number): number;
        getBoolean(arg0: number): boolean;
        copy(arg0: number, arg1: number): Internal.ByteBuf;
        copy(): Internal.ByteBuf;
        readShortLE(): number;
        readUnsignedMedium(): number;
        ensureWritable(arg0: number): Internal.CompositeByteBuf;
        ensureWritable(arg0: number, arg1: boolean): number;
        writeInt(arg0: number): Internal.CompositeByteBuf;
        readFloatLE(): number;
        getDoubleLE(arg0: number): number;
        hasArray(): boolean;
        memoryAddress(): number;
        maxFastWritableBytes(): number;
        consolidate(arg0: number, arg1: number): Internal.CompositeByteBuf;
        consolidate(): Internal.CompositeByteBuf;
        readableBytes(): number;
        readSlice(arg0: number): Internal.ByteBuf;
        getIntLE(arg0: number): number;
        forEachByteDesc(arg0: Internal.ByteProcessor_): number;
        forEachByteDesc(arg0: number, arg1: number, arg2: Internal.ByteProcessor_): number;
        nioBuffers(): Internal.ByteBuffer[];
        nioBuffers(arg0: number, arg1: number): Internal.ByteBuffer[];
        skipBytes(arg0: number): Internal.CompositeByteBuf;
        getLong(arg0: number): number;
        component(arg0: number): Internal.ByteBuf;
        readLong(): number;
        readShort(): number;
        equals(arg0: any): boolean;
        getUnsignedMedium(arg0: number): number;
        setZero(arg0: number, arg1: number): Internal.CompositeByteBuf;
        readBytes(arg0: Internal.OutputStream_, arg1: number): Internal.CompositeByteBuf;
        readBytes(arg0: number[]): Internal.CompositeByteBuf;
        readBytes(arg0: Internal.ByteBuf_, arg1: number, arg2: number): Internal.CompositeByteBuf;
        readBytes(arg0: number[], arg1: number, arg2: number): Internal.CompositeByteBuf;
        readBytes(arg0: Internal.ByteBuffer_): Internal.CompositeByteBuf;
        readBytes(arg0: Internal.ByteBuf_, arg1: number): Internal.CompositeByteBuf;
        readBytes(arg0: Internal.ByteBuf_): Internal.CompositeByteBuf;
        readBytes(arg0: number): Internal.ByteBuf;
        readBytes(arg0: Internal.GatheringByteChannel_, arg1: number): number;
        readBytes(arg0: Internal.FileChannel_, arg1: number, arg2: number): number;
        readBoolean(): boolean;
        toString(): string;
        toString(arg0: number, arg1: number, arg2: Internal.Charset_): string;
        toString(arg0: Internal.Charset_): string;
        retainedSlice(arg0: number, arg1: number): Internal.ByteBuf;
        retainedSlice(): Internal.ByteBuf;
        readMediumLE(): number;
        setMedium(arg0: number, arg1: number): Internal.CompositeByteBuf;
        isDirect(): boolean;
        setBoolean(arg0: number, arg1: boolean): Internal.CompositeByteBuf;
        getClass(): Internal.Class<any>;
        getFloatLE(arg0: number): number;
        readerIndex(arg0: number): Internal.CompositeByteBuf;
        readerIndex(): number;
        getCharSequence(arg0: number, arg1: number, arg2: Internal.Charset_): Internal.CharSequence;
        compareTo(arg0: Internal.ByteBuf_): number;
        setShort(arg0: number, arg1: number): Internal.CompositeByteBuf;
        getBytes(arg0: number, arg1: Internal.OutputStream_, arg2: number): Internal.CompositeByteBuf;
        getBytes(arg0: number, arg1: Internal.ByteBuf_, arg2: number): Internal.CompositeByteBuf;
        getBytes(arg0: number, arg1: number[]): Internal.CompositeByteBuf;
        getBytes(arg0: number, arg1: Internal.ByteBuf_): Internal.CompositeByteBuf;
        getBytes(arg0: number, arg1: number[], arg2: number, arg3: number): Internal.CompositeByteBuf;
        getBytes(arg0: number, arg1: Internal.ByteBuffer_): Internal.CompositeByteBuf;
        getBytes(arg0: number, arg1: Internal.ByteBuf_, arg2: number, arg3: number): Internal.CompositeByteBuf;
        getBytes(arg0: number, arg1: Internal.GatheringByteChannel_, arg2: number): number;
        getBytes(arg0: number, arg1: Internal.FileChannel_, arg2: number, arg3: number): number;
        unwrap(): Internal.ByteBuf;
        setDouble(arg0: number, arg1: number): Internal.CompositeByteBuf;
        setChar(arg0: number, arg1: number): Internal.CompositeByteBuf;
        refCnt(): number;
        getUnsignedIntLE(arg0: number): number;
        setFloatLE(arg0: number, arg1: number): Internal.ByteBuf;
        getUnsignedInt(arg0: number): number;
        indexOf(arg0: number, arg1: number, arg2: number): number;
        writeByte(arg0: number): Internal.CompositeByteBuf;
        nioBuffer(arg0: number, arg1: number): Internal.ByteBuffer;
        nioBuffer(): Internal.ByteBuffer;
        discardSomeReadBytes(): Internal.CompositeByteBuf;
        touch(arg0: any): Internal.CompositeByteBuf;
        touch(): Internal.CompositeByteBuf;
        duplicate(): Internal.ByteBuf;
        writerIndex(arg0: number): Internal.CompositeByteBuf;
        writerIndex(): number;
        writeCharSequence(arg0: Internal.CharSequence_, arg1: Internal.Charset_): number;
        readUnsignedInt(): number;
        getUnsignedShortLE(arg0: number): number;
        retainedDuplicate(): Internal.ByteBuf;
        getChar(arg0: number): string;
        removeComponent(arg0: number): Internal.CompositeByteBuf;
        setLong(arg0: number, arg1: number): Internal.CompositeByteBuf;
        readMedium(): number;
        componentAtOffset(arg0: number): Internal.ByteBuf;
        writeBytes(arg0: Internal.ByteBuf_): Internal.CompositeByteBuf;
        writeBytes(arg0: Internal.ByteBuffer_): Internal.CompositeByteBuf;
        writeBytes(arg0: Internal.ByteBuf_, arg1: number, arg2: number): Internal.CompositeByteBuf;
        writeBytes(arg0: Internal.ByteBuf_, arg1: number): Internal.CompositeByteBuf;
        writeBytes(arg0: number[], arg1: number, arg2: number): Internal.CompositeByteBuf;
        writeBytes(arg0: number[]): Internal.CompositeByteBuf;
        writeBytes(arg0: Internal.ScatteringByteChannel_, arg1: number): number;
        writeBytes(arg0: Internal.InputStream_, arg1: number): number;
        writeBytes(arg0: Internal.FileChannel_, arg1: number, arg2: number): number;
        forEachByte(arg0: Internal.ByteProcessor_): number;
        forEachByte(arg0: number, arg1: number, arg2: Internal.ByteProcessor_): number;
        setIndex(arg0: number, arg1: number): Internal.CompositeByteBuf;
        writeShort(arg0: number): Internal.CompositeByteBuf;
        getShortLE(arg0: number): number;
        alloc(): Internal.ByteBufAllocator;
        removeComponents(arg0: number, arg1: number): Internal.CompositeByteBuf;
        getMedium(arg0: number): number;
        readUnsignedShort(): number;
        addFlattenedComponents(arg0: boolean, arg1: Internal.ByteBuf_): Internal.CompositeByteBuf;
        setByte(arg0: number, arg1: number): Internal.CompositeByteBuf;
        writeShortLE(arg0: number): Internal.ByteBuf;
        maxWritableBytes(): number;
        notifyAll(): void;
        toComponentIndex(arg0: number): number;
        decompose(arg0: number, arg1: number): Internal.List<Internal.ByteBuf>;
        getDouble(arg0: number): number;
        getFloat(arg0: number): number;
        writeLong(arg0: number): Internal.CompositeByteBuf;
        writeIntLE(arg0: number): Internal.ByteBuf;
        array(): number[];
        setCharSequence(arg0: number, arg1: Internal.CharSequence_, arg2: Internal.Charset_): number;
        hashCode(): number;
        internalNioBuffer(arg0: number, arg1: number): Internal.ByteBuffer;
        arrayOffset(): number;
        readIntLE(): number;
        setMediumLE(arg0: number, arg1: number): Internal.ByteBuf;
        readUnsignedByte(): number;
        readUnsignedMediumLE(): number;
        readLongLE(): number;
        writeDouble(arg0: number): Internal.CompositeByteBuf;
        setBytes(arg0: number, arg1: Internal.ByteBuffer_): Internal.CompositeByteBuf;
        setBytes(arg0: number, arg1: Internal.ByteBuf_, arg2: number): Internal.CompositeByteBuf;
        setBytes(arg0: number, arg1: number[], arg2: number, arg3: number): Internal.CompositeByteBuf;
        setBytes(arg0: number, arg1: number[]): Internal.CompositeByteBuf;
        setBytes(arg0: number, arg1: Internal.ByteBuf_): Internal.CompositeByteBuf;
        setBytes(arg0: number, arg1: Internal.ByteBuf_, arg2: number, arg3: number): Internal.CompositeByteBuf;
        setBytes(arg0: number, arg1: Internal.FileChannel_, arg2: number, arg3: number): number;
        setBytes(arg0: number, arg1: Internal.ScatteringByteChannel_, arg2: number): number;
        setBytes(arg0: number, arg1: Internal.InputStream_, arg2: number): number;
        maxNumComponents(): number;
        setFloat(arg0: number, arg1: number): Internal.CompositeByteBuf;
        getShort(arg0: number): number;
        forEach(arg0: Internal.Consumer_<Internal.ByteBuf_>): void;
        writeMediumLE(arg0: number): Internal.ByteBuf;
        clear(): Internal.CompositeByteBuf;
        getUnsignedByte(arg0: number): number;
        discardReadBytes(): Internal.CompositeByteBuf;
        writeChar(arg0: number): Internal.CompositeByteBuf;
        isContiguous(): boolean;
        writeDoubleLE(arg0: number): Internal.ByteBuf;
        getUnsignedMediumLE(arg0: number): number;
        readByte(): number;
        get readable(): boolean;
        get direct(): boolean;
        get readOnly(): boolean;
        get class(): Internal.Class<any>;
        get contiguous(): boolean;
        get writable(): boolean;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    type CompositeByteBuf_ = CompositeByteBuf;
    class MutableToolTier implements Internal.Tier {
        getClass(): Internal.Class<any>;
        setRepairIngredient(in_: Internal.IngredientJS_): void;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        getUses(): number;
        notifyAll(): void;
        getTag(): Internal.TagKey<Internal.Block>;
        notify(): void;
        setLevel(i: number): void;
        setSpeed(f: number): void;
        getLevel(): number;
        hashCode(): number;
        equals(arg0: any): boolean;
        getSpeed(): number;
        getAttackDamageBonus(): number;
        toString(): string;
        setEnchantmentValue(i: number): void;
        getEnchantmentValue(): number;
        setAttackDamageBonus(f: number): void;
        getVanillaRepairIngredient(): Internal.Ingredient;
        setUses(i: number): void;
        readonly parent : Internal.Tier;
        get level(): number;
        get vanillaRepairIngredient(): Internal.Ingredient;
        get attackDamageBonus(): number;
        get enchantmentValue(): number;
        get uses(): number;
        get tag(): Internal.TagKey<Internal.Block>;
        get class(): Internal.Class<any>;
        get speed(): number;
        set repairIngredient(in_: Internal.IngredientJS_);
        set level(i: number);
        set attackDamageBonus(f: number);
        set enchantmentValue(i: number);
        set uses(i: number);
        set speed(f: number);
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    type MutableToolTier_ = MutableToolTier;
    interface Short2IntFunction extends Internal.Function<number, number>, Internal.IntUnaryOperator {
        getOrDefault(arg0: any, arg1: number): number;
        getOrDefault(arg0: number, arg1: number): number;
        andThenShort(arg0: Internal.Int2ShortFunction_): Internal.Short2ShortFunction;
        composeByte(arg0: Internal.Byte2ShortFunction_): Internal.Byte2IntFunction;
        andThenInt(arg0: Internal.Int2IntFunction_): Internal.Short2IntFunction;
        composeReference<T_>(arg0: Internal.Reference2ShortFunction_<T_>): Internal.Reference2IntFunction<T_>;
        andThen<T_>(arg0: java_.util.function_.Function_<number, T_>): java_.util.function_.Function<number, T_>;
        andThen(arg0: Internal.IntUnaryOperator_): Internal.IntUnaryOperator;
        put(arg0: number, arg1: number): number;
        remove(arg0: number): number;
        remove(arg0: any): number;
        defaultReturnValue(): number;
        defaultReturnValue(arg0: number): void;
        andThenDouble(arg0: Internal.Int2DoubleFunction_): Internal.Short2DoubleFunction;
        andThenObject<T_>(arg0: Internal.Int2ObjectFunction_<T_>): Internal.Short2ObjectFunction<T_>;
        get(arg0: any): number;
        get(arg0: number): number;
        andThenLong(arg0: Internal.Int2LongFunction_): Internal.Short2LongFunction;
        composeLong(arg0: Internal.Long2ShortFunction_): Internal.Long2IntFunction;
        andThenByte(arg0: Internal.Int2ByteFunction_): Internal.Short2ByteFunction;
        andThenFloat(arg0: Internal.Int2FloatFunction_): Internal.Short2FloatFunction;
        applyAsInt(arg0: number): number;
        apply(arg0: number): number;
        containsKey(arg0: any): boolean;
        containsKey(arg0: number): boolean;
        composeInt(arg0: Internal.Int2ShortFunction_): Internal.Int2IntFunction;
        clear(): void;
        composeFloat(arg0: Internal.Float2ShortFunction_): Internal.Float2IntFunction;
        andThenChar(arg0: Internal.Int2CharFunction_): Internal.Short2CharFunction;
        composeObject<T_>(arg0: Internal.Object2ShortFunction_<T_>): Internal.Object2IntFunction<T_>;
        size(): number;
        compose<T_>(arg0: java_.util.function_.Function_<T_, number>): java_.util.function_.Function<T_, number>;
        compose(arg0: Internal.IntUnaryOperator_): Internal.IntUnaryOperator;
        composeShort(arg0: Internal.Short2ShortFunction_): Internal.Short2IntFunction;
        andThenReference<T_>(arg0: Internal.Int2ReferenceFunction_<T_>): Internal.Short2ReferenceFunction<T_>;
        composeChar(arg0: Internal.Char2ShortFunction_): Internal.Char2IntFunction;
        composeDouble(arg0: Internal.Double2ShortFunction_): Internal.Double2IntFunction;
    }
    type Short2IntFunction_ = ((arg0: number) => number) | Short2IntFunction;
    interface SlotAccessor {
        setY(arg0: number): void;
        setX(arg0: number): void;
    }
    type SlotAccessor_ = SlotAccessor;
    class BakedQuad implements Internal.IVertexProducer, Internal.ModelQuadView {
        getNormal(idx: number): number;
        getTexV(idx: number): number;
        getLight(idx: number): number;
        getClass(): Internal.Class<any>;
        getTexU(idx: number): number;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        getColorIndex(): number;
        notifyAll(): void;
        getColor(idx: number): number;
        notify(): void;
        getSprite(): Internal.TextureAtlasSprite;
        getX(idx: number): number;
        getY(idx: number): number;
        getZ(idx: number): number;
        hashCode(): number;
        equals(arg0: any): boolean;
        toString(): string;
        pipe(arg0: Internal.IVertexConsumer_): void;
        getFlags(): number;
        get sprite(): Internal.TextureAtlasSprite;
        get flags(): number;
        get colorIndex(): number;
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    type BakedQuad_ = BakedQuad;
    class Event {
        setCanceled(arg0: boolean): void;
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        isCanceled(): boolean;
        setResult(arg0: Internal.Event$Result_): void;
        notifyAll(): void;
        hasResult(): boolean;
        notify(): void;
        getListenerList(): Internal.ListenerList;
        hashCode(): number;
        equals(arg0: any): boolean;
        getResult(): Internal.Event$Result;
        toString(): string;
        isCancelable(): boolean;
        getPhase(): Internal.EventPriority;
        setPhase(arg0: Internal.EventPriority_): void;
        get result(): Internal.Event$Result;
        get phase(): Internal.EventPriority;
        get canceled(): boolean;
        get cancelable(): boolean;
        get listenerList(): Internal.ListenerList;
        get class(): Internal.Class<any>;
        set phase(arg0: Internal.EventPriority_);
        set result(arg0: Internal.Event$Result_);
        set canceled(arg0: boolean);
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    type Event_ = Event;
    interface IUIHolder {
        createUI(arg0: Internal.Player_): Internal.ModularUI;
        isRemote(): boolean;
        isInvalid(): boolean;
        markAsDirty(): void;
    }
    type IUIHolder_ = IUIHolder;
    interface FileFilter {
        accept(arg0: Internal.File_): boolean;
    }
    type FileFilter_ = ((arg0: Internal.File) => boolean) | FileFilter;
    interface LevelHeightAccessor {
    }
    type LevelHeightAccessor_ = LevelHeightAccessor;
    abstract class CollectionTag <T> extends Internal.AbstractList<T> implements net.minecraft.nbt.Tag {
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        notifyAll(): void;
        replaceAll(arg0: Internal.UnaryOperator_<T>): void;
        notify(): void;
        remove(arg0: number): T;
        remove(arg0: any): boolean;
        removeAll(arg0: Internal.Collection_<any>): boolean;
        iterator(): Internal.Iterator<T>;
        stream(): Internal.Stream<T>;
        hashCode(): number;
        get(arg0: number): T;
        toArray(): any[];
        toArray<T_>(arg0: T_[]): T_[];
        toArray<T_>(arg0: Internal.IntFunction_<T_[]>): T_[];
        parallelStream(): Internal.Stream<T>;
        indexOf(arg0: any): number;
        add(arg0: number, arg1: T): void;
        add(arg0: T): boolean;
        subList(arg0: number, arg1: number): Internal.List<T>;
        set(arg0: number, arg1: T): T;
        spliterator(): Internal.Spliterator<T>;
        forEach(arg0: Internal.Consumer_<T>): void;
        containsAll(arg0: Internal.Collection_<any>): boolean;
        isEmpty(): boolean;
        clear(): void;
        sort(arg0: Internal.Comparator_<T>): void;
        removeIf(arg0: Internal.Predicate_<T>): boolean;
        lastIndexOf(arg0: any): number;
        contains(arg0: any): boolean;
        size(): number;
        addAll(arg0: number, arg1: Internal.Collection_<T>): boolean;
        addAll(arg0: Internal.Collection_<T>): boolean;
        equals(arg0: any): boolean;
        listIterator(): Internal.ListIterator<T>;
        listIterator(arg0: number): Internal.ListIterator<T>;
        toString(): string;
        retainAll(arg0: Internal.Collection_<any>): boolean;
        get class(): Internal.Class<any>;
        get empty(): boolean;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    type CollectionTag_<T> = CollectionTag<T>;
    class Products$P11 <F, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11> {
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        apply<R>(arg0: Internal.Applicative_<F, any>, arg1: Internal.Function11_<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, R>): Internal.App<F, R>;
        apply<R>(arg0: Internal.Applicative_<F, any>, arg1: Internal.App_<F, Internal.Function11_<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, R>>): Internal.App<F, R>;
        hashCode(): number;
        notifyAll(): void;
        equals(arg0: any): boolean;
        toString(): string;
        notify(): void;
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    type Products$P11_<F, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11> = Products$P11<F, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11>;
    class TextComponent extends Internal.BaseComponent {
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        hashCode(): number;
        notifyAll(): void;
        equals(arg0: any): boolean;
        toString(): string;
        getString(): string;
        notify(): void;
        get string(): string;
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    type TextComponent_ = TextComponent;
    class AddAttributesFunction$Modifier {
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        hashCode(): number;
        notifyAll(): void;
        equals(arg0: any): boolean;
        toString(): string;
        notify(): void;
        createAttributeModifier(arg0: Internal.LootContext_): Internal.AttributeModifier;
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    type AddAttributesFunction$Modifier_ = AddAttributesFunction$Modifier;
    class ImmutableSet$Builder <E> extends Internal.ImmutableCollection$Builder<E> {
        add(arg0: E): Internal.ImmutableSet$Builder<E>;
        add(arg0: E[]): Internal.ImmutableSet$Builder<E>;
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        build(): Internal.ImmutableSet<E>;
        addAll(arg0: Internal.Iterator_<E>): Internal.ImmutableSet$Builder<E>;
        addAll(arg0: Internal.Iterable_<E>): Internal.ImmutableSet$Builder<E>;
        hashCode(): number;
        notifyAll(): void;
        equals(arg0: any): boolean;
        toString(): string;
        notify(): void;
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    type ImmutableSet$Builder_<E> = ImmutableSet$Builder<E>;
    class GsonBuilder {
        setFieldNamingPolicy(arg0: Internal.FieldNamingPolicy_): Internal.GsonBuilder;
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        enableComplexMapKeySerialization(): Internal.GsonBuilder;
        notifyAll(): void;
        disableInnerClassSerialization(): Internal.GsonBuilder;
        excludeFieldsWithModifiers(arg0: number[]): Internal.GsonBuilder;
        setLenient(): Internal.GsonBuilder;
        notify(): void;
        serializeNulls(): Internal.GsonBuilder;
        addSerializationExclusionStrategy(arg0: Internal.ExclusionStrategy_): Internal.GsonBuilder;
        generateNonExecutableJson(): Internal.GsonBuilder;
        registerTypeHierarchyAdapter(arg0: Internal.Class_<any>, arg1: any): Internal.GsonBuilder;
        addDeserializationExclusionStrategy(arg0: Internal.ExclusionStrategy_): Internal.GsonBuilder;
        hashCode(): number;
        setLongSerializationPolicy(arg0: Internal.LongSerializationPolicy_): Internal.GsonBuilder;
        registerTypeAdapterFactory(arg0: Internal.TypeAdapterFactory_): Internal.GsonBuilder;
        create(): Internal.Gson;
        disableHtmlEscaping(): Internal.GsonBuilder;
        setDateFormat(arg0: number): Internal.GsonBuilder;
        setDateFormat(arg0: string): Internal.GsonBuilder;
        setDateFormat(arg0: number, arg1: number): Internal.GsonBuilder;
        setObjectToNumberStrategy(arg0: Internal.ToNumberStrategy_): Internal.GsonBuilder;
        setNumberToNumberStrategy(arg0: Internal.ToNumberStrategy_): Internal.GsonBuilder;
        setVersion(arg0: number): Internal.GsonBuilder;
        setFieldNamingStrategy(arg0: Internal.FieldNamingStrategy_): Internal.GsonBuilder;
        serializeSpecialFloatingPointValues(): Internal.GsonBuilder;
        registerTypeAdapter(arg0: java_.lang.reflect.Type_, arg1: any): Internal.GsonBuilder;
        setPrettyPrinting(): Internal.GsonBuilder;
        equals(arg0: any): boolean;
        toString(): string;
        setExclusionStrategies(arg0: Internal.ExclusionStrategy_[]): Internal.GsonBuilder;
        excludeFieldsWithoutExposeAnnotation(): Internal.GsonBuilder;
        get class(): Internal.Class<any>;
        set exclusionStrategies(arg0: Internal.ExclusionStrategy_[]);
        set fieldNamingStrategy(arg0: Internal.FieldNamingStrategy_);
        set fieldNamingPolicy(arg0: Internal.FieldNamingPolicy_);
        set numberToNumberStrategy(arg0: Internal.ToNumberStrategy_);
        set dateFormat(arg0: number);
        set longSerializationPolicy(arg0: Internal.LongSerializationPolicy_);
        set objectToNumberStrategy(arg0: Internal.ToNumberStrategy_);
        set version(arg0: number);
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    type GsonBuilder_ = GsonBuilder;
    interface ContentHandlerFactory {
        createContentHandler(arg0: string): Internal.ContentHandler;
    }
    type ContentHandlerFactory_ = ContentHandlerFactory;
    interface Byte2DoubleMap$FastEntrySet extends Internal.ObjectSet<Internal.Byte2DoubleMap$Entry> {
        add(arg0: Internal.Byte2DoubleMap$Entry_): boolean;
        spliterator(): Internal.ObjectSpliterator<Internal.Byte2DoubleMap$Entry>;
        forEach(arg0: Internal.Consumer_<Internal.Byte2DoubleMap$Entry_>): void;
        containsAll(arg0: Internal.Collection_<any>): boolean;
        isEmpty(): boolean;
        clear(): void;
        fastIterator(): Internal.ObjectIterator<Internal.Byte2DoubleMap$Entry>;
        remove(arg0: any): boolean;
        removeIf(arg0: Internal.Predicate_<Internal.Byte2DoubleMap$Entry_>): boolean;
        fastForEach(arg0: Internal.Consumer_<Internal.Byte2DoubleMap$Entry_>): void;
        removeAll(arg0: Internal.Collection_<any>): boolean;
        contains(arg0: any): boolean;
        iterator(): Internal.ObjectIterator<Internal.Byte2DoubleMap$Entry>;
        size(): number;
        addAll(arg0: Internal.Collection_<Internal.Byte2DoubleMap$Entry_>): boolean;
        stream(): Internal.Stream<Internal.Byte2DoubleMap$Entry>;
        hashCode(): number;
        equals(arg0: any): boolean;
        toArray<T_>(arg0: T_[]): T_[];
        toArray<T_>(arg0: Internal.IntFunction_<T_[]>): T_[];
        toArray(): any[];
        parallelStream(): Internal.Stream<Internal.Byte2DoubleMap$Entry>;
        retainAll(arg0: Internal.Collection_<any>): boolean;
    }
    type Byte2DoubleMap$FastEntrySet_ = Byte2DoubleMap$FastEntrySet;
    abstract class EntityModel <T> extends Internal.Model {
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        hashCode(): number;
        notifyAll(): void;
        equals(arg0: any): boolean;
        toString(): string;
        notify(): void;
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    type EntityModel_<T> = EntityModel<T>;
    class ServerLevelJS extends Internal.LevelJS {
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        getPlayer(entity: Internal.Entity_): Internal.PlayerJS<any>;
        getEntitiesWithin(aabb: Internal.AABB_): Internal.EntityArrayList;
        getPlayerData(player: Internal.Player_): Internal.ServerPlayerDataJS;
        spawnFireworks(x: number, y: number, z: number, f: Internal.FireworksJS_): void;
        getTime(): number;
        notifyAll(): void;
        getSide(): Internal.ScriptType;
        getGameRules(): Internal.GameRulesJS;
        notify(): void;
        setRainStrength(strength: number): void;
        hashCode(): number;
        getDimension(): string;
        isDaytime(): boolean;
        createEntityList(entities: Internal.Collection_<Internal.Entity_>): Internal.EntityArrayList;
        getPlayers(): Internal.EntityArrayList;
        getData(): Internal.AttachedData;
        getMinecraftLevel(): Internal.ServerLevel;
        setTime(time: number): void;
        getServer(): Internal.ServerJS;
        getLivingEntity(entity: Internal.Entity_): Internal.LivingEntityJS;
        getBlock(x: number, y: number, z: number): Internal.BlockContainerJS;
        getBlock(pos: BlockPos_): Internal.BlockContainerJS;
        getBlock(blockEntity: Internal.BlockEntity_): Internal.BlockContainerJS;
        getSeed(): number;
        isOverworld(): boolean;
        createExplosion(x: number, y: number, z: number): Internal.ExplosionJS;
        getEntity(e: Internal.Entity_): Internal.EntityJS;
        createEntity(id: ResourceLocation_): Internal.EntityJS;
        spawnLightning(x: number, y: number, z: number, effectOnly: boolean, player: Internal.EntityJS_): void;
        spawnLightning(x: number, y: number, z: number, effectOnly: boolean): void;
        getLocalTime(): number;
        equals(arg0: any): boolean;
        isThundering(): boolean;
        getEntities(): Internal.EntityArrayList;
        getEntities(filter: string): Internal.EntityArrayList;
        toString(): string;
        isRaining(): boolean;
        setLocalTime(time: number): void;
        readonly persistentData : Internal.CompoundTag;
        readonly minecraftLevel : Internal.Level;
        get server(): Internal.ServerJS;
        get side(): Internal.ScriptType;
        get data(): Internal.AttachedData;
        get seed(): number;
        get players(): Internal.EntityArrayList;
        get raining(): boolean;
        get thundering(): boolean;
        get overworld(): boolean;
        get gameRules(): Internal.GameRulesJS;
        get localTime(): number;
        get entities(): Internal.EntityArrayList;
        get time(): number;
        get class(): Internal.Class<any>;
        get dimension(): string;
        get daytime(): boolean;
        set localTime(time: number);
        set time(time: number);
        set rainStrength(strength: number);
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    type ServerLevelJS_ = ServerLevelJS;
    interface HolderSet <T> extends Internal.Iterable<Internal.Holder<T>> {
        iterator(): Internal.Iterator<Internal.Holder<Internal.Holder<T>>>;
        spliterator(): Internal.Spliterator<Internal.Holder<Internal.Holder<T>>>;
        forEach(arg0: Internal.Consumer_<Internal.Holder_<Internal.Holder_<T>>>): void;
    }
    type HolderSet_<T> = HolderSet<T>;
    abstract class IntBuffer extends Internal.Buffer implements Internal.Comparable<Internal.IntBuffer> {
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        compact(): Internal.IntBuffer;
        notifyAll(): void;
        compareTo(arg0: Internal.IntBuffer_): number;
        notify(): void;
        asReadOnlyBuffer(): Internal.IntBuffer;
        put(arg0: number[]): Internal.IntBuffer;
        put(arg0: number, arg1: number[], arg2: number, arg3: number): Internal.IntBuffer;
        put(arg0: number, arg1: number[]): Internal.IntBuffer;
        put(arg0: number[], arg1: number, arg2: number): Internal.IntBuffer;
        put(arg0: number, arg1: Internal.IntBuffer_, arg2: number, arg3: number): Internal.IntBuffer;
        put(arg0: Internal.IntBuffer_): Internal.IntBuffer;
        put(arg0: number, arg1: number): Internal.IntBuffer;
        put(arg0: number): Internal.IntBuffer;
        capacity(): number;
        isReadOnly(): boolean;
        slice(arg0: number, arg1: number): Internal.IntBuffer;
        slice(): Internal.IntBuffer;
        array(): number[];
        hashCode(): number;
        get(): number;
        get(arg0: number, arg1: number[]): Internal.IntBuffer;
        get(arg0: number): number;
        get(arg0: number, arg1: number[], arg2: number, arg3: number): Internal.IntBuffer;
        get(arg0: number[], arg1: number, arg2: number): Internal.IntBuffer;
        get(arg0: number[]): Internal.IntBuffer;
        limit(arg0: number): Internal.IntBuffer;
        limit(): number;
        arrayOffset(): number;
        flip(): Internal.IntBuffer;
        order(): Internal.ByteOrder;
        hasArray(): boolean;
        hasRemaining(): boolean;
        clear(): Internal.IntBuffer;
        duplicate(): Internal.IntBuffer;
        remaining(): number;
        static allocate(arg0: number): Internal.IntBuffer;
        rewind(): Internal.IntBuffer;
        mismatch(arg0: Internal.IntBuffer_): number;
        equals(arg0: any): boolean;
        reset(): Internal.IntBuffer;
        toString(): string;
        position(arg0: number): Internal.IntBuffer;
        position(): number;
        isDirect(): boolean;
        static wrap(arg0: number[]): Internal.IntBuffer;
        static wrap(arg0: number[], arg1: number, arg2: number): Internal.IntBuffer;
        mark(): Internal.IntBuffer;
        get direct(): boolean;
        get readOnly(): boolean;
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    type IntBuffer_ = IntBuffer;
    class LogicalSide extends Internal.Enum<Internal.LogicalSide> {
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        isServer(): boolean;
        static valueOf(arg0: string): Internal.LogicalSide;
        static valueOf<T_>(arg0: Internal.Class_<T_>, arg1: string): T_;
        notifyAll(): void;
        static values(): Internal.LogicalSide[];
        isClient(): boolean;
        compareTo(arg0: Internal.LogicalSide_): number;
        describeConstable(): Internal.Optional<Internal.Enum$EnumDesc<Internal.LogicalSide>>;
        notify(): void;
        getDeclaringClass(): Internal.Class<Internal.LogicalSide>;
        hashCode(): number;
        equals(arg0: any): boolean;
        name(): string;
        toString(): string;
        ordinal(): number;
        static readonly SERVER : Internal.LogicalSide;
        static readonly CLIENT : Internal.LogicalSide;
        get server(): boolean;
        get client(): boolean;
        get class(): Internal.Class<any>;
        get declaringClass(): Internal.Class<Internal.LogicalSide>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    type LogicalSide_ = "server" | "client" | LogicalSide;
    class UpdateTickEvent extends Internal.EventJS {
        cancel(): void;
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        isCancelled(): boolean;
        post(t: Internal.ScriptType_, id: string, sub: string): boolean;
        post(t: Internal.ScriptType_, id: string): boolean;
        hashCode(): number;
        notifyAll(): void;
        equals(arg0: any): boolean;
        toString(): string;
        getComponent(): Internal.ComponentTileEntity<any>;
        notify(): void;
        canCancel(): boolean;
        static readonly ID : "mbd.update_tick";
        get component(): Internal.ComponentTileEntity<any>;
        get cancelled(): boolean;
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    type UpdateTickEvent_ = UpdateTickEvent;
    class ModularUIGuiContainer extends Internal.AbstractContainerScreen<Internal.ModularUIContainer> {
        renderComponentTooltip(arg0: Internal.PoseStack_, arg1: Internal.List_<Internal.FormattedText_>, arg2: number, arg3: number, arg4: net.minecraft.client.gui.Font_): void;
        renderComponentTooltip(arg0: Internal.PoseStack_, arg1: Internal.List_<Internal.FormattedText_>, arg2: number, arg3: number, arg4: Internal.ItemStack_): void;
        renderComponentTooltip(arg0: Internal.PoseStack_, arg1: Internal.List_<Internal.FormattedText_>, arg2: number, arg3: number, arg4: net.minecraft.client.gui.Font_, arg5: Internal.ItemStack_): void;
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        superMouseReleased(arg0: number, arg1: number, arg2: number): void;
        notifyAll(): void;
        handler$bmc000$renderSlot(arg0: Internal.PoseStack_, arg1: Internal.Slot_, arg2: Internal.CallbackInfo_): void;
        getYSize(): number;
        superMouseClicked(arg0: number, arg1: number, arg2: number): void;
        switchFocus(arg0: com.lowdragmc.lowdraglib.gui.widget.Widget_): boolean;
        notify(): void;
        superMouseDragged(arg0: number, arg1: number, arg2: number, arg3: number, arg4: number): void;
        static renderSlotHighlight(arg0: Internal.PoseStack_, arg1: number, arg2: number, arg3: number, arg4: number): void;
        handleWidgetUpdate(arg0: Internal.SPacketUIWidgetUpdate_): void;
        setHoveredSlot(arg0: Internal.Slot_): void;
        superCharTyped(arg0: string, arg1: number): boolean;
        superMouseScrolled(arg0: number, arg1: number, arg2: number): boolean;
        hashCode(): number;
        getQuickCraftSlots(): Internal.Set<Internal.Slot>;
        getQuickCrafting(): boolean;
        getSlotColor(arg0: number): number;
        setHoverTooltip(arg0: Internal.List_<Internal.Component_>): void;
        renderTooltip(arg0: Internal.PoseStack_, arg1: Internal.List_<Internal.Component_>, arg2: Internal.Optional_<Internal.TooltipComponent_>, arg3: number, arg4: number, arg5: Internal.ItemStack_): void;
        renderTooltip(arg0: Internal.PoseStack_, arg1: Internal.List_<Internal.Component_>, arg2: Internal.Optional_<Internal.TooltipComponent_>, arg3: number, arg4: number, arg5: net.minecraft.client.gui.Font_): void;
        renderTooltip(arg0: Internal.PoseStack_, arg1: Internal.List_<Internal.Component_>, arg2: Internal.Optional_<Internal.TooltipComponent_>, arg3: number, arg4: number, arg5: net.minecraft.client.gui.Font_, arg6: Internal.ItemStack_): void;
        renderTooltip(arg0: Internal.PoseStack_, arg1: Internal.List_<Internal.FormattedCharSequence_>, arg2: number, arg3: number, arg4: net.minecraft.client.gui.Font_): void;
        getMinecraft(): Internal.Minecraft;
        getGuiTop(): number;
        getGuiLeft(): number;
        superKeyReleased(arg0: number, arg1: number, arg2: number): boolean;
        equals(arg0: any): boolean;
        getSlotUnderMouse(): Internal.Slot;
        toString(): string;
        superMouseMoved(arg0: number, arg1: number): void;
        getXSize(): number;
        superKeyPressed(arg0: number, arg1: number, arg2: number): boolean;
        dragSplittingButton : number;
        readonly modularUI : Internal.ModularUI;
        tooltipTexts : Internal.List<Internal.Component>;
        dragSplittingLimit : number;
        tooltipFont : net.minecraft.client.gui.Font;
        lastFocus : com.lowdragmc.lowdraglib.gui.widget.Widget;
        get minecraft(): Internal.Minecraft;
        get slotUnderMouse(): Internal.Slot;
        get quickCraftSlots(): Internal.Set<Internal.Slot>;
        get guiLeft(): number;
        get ySize(): number;
        get xSize(): number;
        get quickCrafting(): boolean;
        get class(): Internal.Class<any>;
        get guiTop(): number;
        set hoveredSlot(arg0: Internal.Slot_);
        set hoverTooltip(arg0: Internal.List_<Internal.Component_>);
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    type ModularUIGuiContainer_ = ModularUIGuiContainer;
    interface HeadedModel {
    }
    type HeadedModel_ = HeadedModel;
    interface BYGPlayerTrackedData$Access {
        setPlayerTrackedData(arg0: Internal.BYGPlayerTrackedData_): Internal.BYGPlayerTrackedData;
        getPlayerTrackedData(): Internal.BYGPlayerTrackedData;
    }
    type BYGPlayerTrackedData$Access_ = BYGPlayerTrackedData$Access;
    abstract class URLConnection {
        getClass(): Internal.Class<any>;
        setConnectTimeout(arg0: number): void;
        getHeaderFieldLong(arg0: string, arg1: number): number;
        setUseCaches(arg0: boolean): void;
        setRequestProperty(arg0: string, arg1: string): void;
        getDoInput(): boolean;
        getIfModifiedSince(): number;
        getPermission(): Internal.Permission;
        static getDefaultAllowUserInteraction(): boolean;
        static getDefaultUseCaches(arg0: string): boolean;
        getDefaultUseCaches(): boolean;
        getAllowUserInteraction(): boolean;
        getConnectTimeout(): number;
        getContentLength(): number;
        getInputStream(): Internal.InputStream;
        setAllowUserInteraction(arg0: boolean): void;
        getRequestProperties(): Internal.Map<string, Internal.List<string>>;
        getURL(): Internal.URL;
        getHeaderField(arg0: number): string;
        getHeaderField(arg0: string): string;
        getHeaderFields(): Internal.Map<string, Internal.List<string>>;
        getContentLengthLong(): number;
        static setDefaultAllowUserInteraction(arg0: boolean): void;
        getContentType(): string;
        setDefaultUseCaches(arg0: boolean): void;
        static setDefaultUseCaches(arg0: string, arg1: boolean): void;
        setDoOutput(arg0: boolean): void;
        static guessContentTypeFromName(arg0: string): string;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        getLastModified(): number;
        setIfModifiedSince(arg0: number): void;
        notifyAll(): void;
        getReadTimeout(): number;
        getContent(arg0: Internal.Class_<any>[]): any;
        getContent(): any;
        notify(): void;
        getHeaderFieldInt(arg0: string, arg1: number): number;
        getRequestProperty(arg0: string): string;
        static guessContentTypeFromStream(arg0: Internal.InputStream_): string;
        hashCode(): number;
        static setDefaultRequestProperty(arg0: string, arg1: string): void;
        getHeaderFieldDate(arg0: string, arg1: number): number;
        static getFileNameMap(): Internal.FileNameMap;
        getDate(): number;
        getHeaderFieldKey(arg0: number): string;
        connect(): void;
        static setContentHandlerFactory(arg0: Internal.ContentHandlerFactory_): void;
        getContentEncoding(): string;
        getUseCaches(): boolean;
        setDoInput(arg0: boolean): void;
        addRequestProperty(arg0: string, arg1: string): void;
        setReadTimeout(arg0: number): void;
        getExpiration(): number;
        static getDefaultRequestProperty(arg0: string): string;
        equals(arg0: any): boolean;
        static setFileNameMap(arg0: Internal.FileNameMap_): void;
        getOutputStream(): Internal.OutputStream;
        toString(): string;
        getDoOutput(): boolean;
        get date(): number;
        get contentLengthLong(): number;
        get defaultUseCaches(): boolean;
        get requestProperties(): Internal.Map<string, Internal.List<string>>;
        get useCaches(): boolean;
        get ifModifiedSince(): number;
        get content(): any;
        get doOutput(): boolean;
        get connectTimeout(): number;
        get contentEncoding(): string;
        get headerFields(): Internal.Map<string, Internal.List<string>>;
        get outputStream(): Internal.OutputStream;
        get class(): Internal.Class<any>;
        get contentType(): string;
        get defaultAllowUserInteraction(): boolean;
        get inputStream(): Internal.InputStream;
        get permission(): Internal.Permission;
        get doInput(): boolean;
        get uRL(): Internal.URL;
        get allowUserInteraction(): boolean;
        get readTimeout(): number;
        get contentLength(): number;
        get fileNameMap(): Internal.FileNameMap;
        get expiration(): number;
        get lastModified(): number;
        set doOutput(arg0: boolean);
        set defaultUseCaches(arg0: boolean);
        set defaultAllowUserInteraction(arg0: boolean);
        set useCaches(arg0: boolean);
        set readTimeout(arg0: number);
        set connectTimeout(arg0: number);
        set fileNameMap(arg0: Internal.FileNameMap_);
        set ifModifiedSince(arg0: number);
        set doInput(arg0: boolean);
        set contentHandlerFactory(arg0: Internal.ContentHandlerFactory_);
        set allowUserInteraction(arg0: boolean);
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    type URLConnection_ = URLConnection;
    class PaintEventJS extends Internal.ClientEventJS {
        cancel(): void;
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        getPlayer(): Internal.ClientPlayerJS;
        vertex(m: Internal.Matrix4f_, x: number, y: number, z: number, col: number): void;
        vertex(m: Internal.Matrix4f_, x: number, y: number, z: number, col: number, u: number, v: number): void;
        notifyAll(): void;
        scale(x: number, y: number, z: number): void;
        notify(): void;
        translate(x: number, y: number, z: number): void;
        setShaderColor(r: number, g: number, b: number, a: number): void;
        pop(): void;
        setPositionColorShader(): void;
        getMatrix(): Internal.Matrix4f;
        post(id: string): boolean;
        post(id: string, sub: string): boolean;
        post(t: Internal.ScriptType_, id: string, sub: string): boolean;
        post(t: Internal.ScriptType_, id: string): boolean;
        hashCode(): number;
        resetShaderColor(): void;
        end(): void;
        isCancelled(): boolean;
        setShaderTexture(tex: ResourceLocation_): void;
        beginQuads(texture: boolean): void;
        beginQuads(format: Internal.VertexFormat_): void;
        bindTextureForSetup(tex: ResourceLocation_): void;
        getEntity(): Internal.EntityJS;
        push(): void;
        setShaderInstance(shader: Internal.Supplier_<Internal.ShaderInstance_>): void;
        getLevel(): Internal.ClientLevelJS;
        equals(arg0: any): boolean;
        toString(): string;
        setPositionColorTextureShader(): void;
        begin(type: Internal.VertexFormat$Mode_, format: Internal.VertexFormat_): void;
        canCancel(): boolean;
        readonly mc : Internal.Minecraft;
        readonly delta : number;
        readonly screen : Internal.Screen;
        readonly tesselator : Internal.Tesselator;
        readonly buffer : Internal.BufferBuilder;
        readonly matrices : Internal.PoseStack;
        readonly font : net.minecraft.client.gui.Font;
        get level(): Internal.ClientLevelJS;
        get cancelled(): boolean;
        get matrix(): Internal.Matrix4f;
        get class(): Internal.Class<any>;
        get entity(): Internal.EntityJS;
        get player(): Internal.ClientPlayerJS;
        set shaderTexture(tex: ResourceLocation_);
        set shaderInstance(shader: Internal.Supplier_<Internal.ShaderInstance_>);
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    type PaintEventJS_ = PaintEventJS;
    class DataResult <R> implements Internal.App<Internal.DataResult$Mu, R> {
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        static instance(): Internal.DataResult$Instance;
        setPartial(arg0: Internal.Supplier_<R>): Internal.DataResult<R>;
        setPartial(arg0: R): Internal.DataResult<R>;
        notifyAll(): void;
        addLifecycle(arg0: Internal.Lifecycle_): Internal.DataResult<R>;
        static partialGet<K_, V_>(arg0: java_.util.function_.Function_<K_, V_>, arg1: Internal.Supplier_<string>): java_.util.function_.Function<K_, Internal.DataResult<V_>>;
        static error<R_>(arg0: string, arg1: R_): Internal.DataResult<R_>;
        error(): Internal.Optional<Internal.DataResult$PartialResult<R>>;
        static error<R_>(arg0: string, arg1: R_, arg2: Internal.Lifecycle_): Internal.DataResult<R_>;
        static error<R_>(arg0: string): Internal.DataResult<R_>;
        static error<R_>(arg0: string, arg1: Internal.Lifecycle_): Internal.DataResult<R_>;
        notify(): void;
        promotePartial(arg0: Internal.Consumer_<string>): Internal.DataResult<R>;
        lifecycle(): Internal.Lifecycle;
        result(): Internal.Optional<R>;
        setLifecycle(arg0: Internal.Lifecycle_): Internal.DataResult<R>;
        hashCode(): number;
        get(): Internal.Either<R, Internal.DataResult$PartialResult<R>>;
        map<T_>(arg0: java_.util.function_.Function_<R, T_>): Internal.DataResult<T_>;
        resultOrPartial(arg0: Internal.Consumer_<string>): Internal.Optional<R>;
        apply2<R2_, S_>(arg0: Internal.BiFunction_<R, R2_, S_>, arg1: Internal.DataResult_<R2_>): Internal.DataResult<S_>;
        apply3<R2_, R3_, S_>(arg0: Internal.Function3_<R, R2_, R3_, S_>, arg1: Internal.DataResult_<R2_>, arg2: Internal.DataResult_<R3_>): Internal.DataResult<S_>;
        apply2stable<R2_, S_>(arg0: Internal.BiFunction_<R, R2_, S_>, arg1: Internal.DataResult_<R2_>): Internal.DataResult<S_>;
        ap<R2_>(arg0: Internal.DataResult_<java_.util.function_.Function_<R, R2_>>): Internal.DataResult<R2_>;
        flatMap<R2_>(arg0: java_.util.function_.Function_<R, Internal.DataResult_<R2_>>): Internal.DataResult<R2_>;
        mapError(arg0: Internal.UnaryOperator_<string>): Internal.DataResult<R>;
        static success<R_>(arg0: R_): Internal.DataResult<R_>;
        static success<R_>(arg0: R_, arg1: Internal.Lifecycle_): Internal.DataResult<R_>;
        static unbox<R_>(arg0: Internal.App_<Internal.DataResult$Mu_, R_>): Internal.DataResult<R_>;
        getOrThrow(arg0: boolean, arg1: Internal.Consumer_<string>): R;
        equals(arg0: any): boolean;
        toString(): string;
        get class(): Internal.Class<any>;
        set partial(arg0: Internal.Supplier_<R>);
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    type DataResult_<R> = DataResult<R>;
    class Frame extends java_.awt.Window implements Internal.MenuContainer {
        requestFocusInWindow(): boolean;
        requestFocusInWindow(arg0: Internal.FocusEvent$Cause_): boolean;
        getLocation(arg0: Internal.Point_): Internal.Point;
        getLocation(): Internal.Point;
        isOpaque(): boolean;
        static getFrames(): Internal.Frame[];
        setModalExclusionType(arg0: Internal.Dialog$ModalExclusionType_): void;
        paint(arg0: Internal.Graphics_): void;
        removeWindowListener(arg0: Internal.WindowListener_): void;
        getInputMethodListeners(): Internal.InputMethodListener[];
        setLayout(arg0: Internal.LayoutManager_): void;
        mouseDown(arg0: java_.awt.Event_, arg1: number, arg2: number): boolean;
        getOwner(): java_.awt.Window;
        getInputMethodRequests(): Internal.InputMethodRequests;
        addHierarchyBoundsListener(arg0: Internal.HierarchyBoundsListener_): void;
        removeAll(): void;
        getMinimumSize(): Internal.Dimension;
        getAlignmentY(): number;
        getWindowStateListeners(): Internal.WindowStateListener[];
        getAlignmentX(): number;
        dispatchEvent(arg0: Internal.AWTEvent_): void;
        setFocusableWindowState(arg0: boolean): void;
        getMostRecentFocusOwner(): java_.awt.Component;
        reshape(arg0: number, arg1: number, arg2: number, arg3: number): void;
        pack(): void;
        postEvent(arg0: java_.awt.Event_): boolean;
        toBack(): void;
        createBufferStrategy(arg0: number, arg1: Internal.BufferCapabilities_): void;
        createBufferStrategy(arg0: number): void;
        contains(arg0: Internal.Point_): boolean;
        contains(arg0: number, arg1: number): boolean;
        size(): Internal.Dimension;
        getType(): Internal.Window$Type;
        enableInputMethods(arg0: boolean): void;
        mouseUp(arg0: java_.awt.Event_, arg1: number, arg2: number): boolean;
        removeContainerListener(arg0: Internal.ContainerListener_): void;
        addComponentListener(arg0: Internal.ComponentListener_): void;
        setName(arg0: string): void;
        removeInputMethodListener(arg0: Internal.InputMethodListener_): void;
        getMaximizedBounds(): Internal.Rectangle;
        removeHierarchyListener(arg0: Internal.HierarchyListener_): void;
        removeWindowFocusListener(arg0: Internal.WindowFocusListener_): void;
        getFontMetrics(arg0: Internal.Font_): Internal.FontMetrics;
        getHeight(): number;
        getIgnoreRepaint(): boolean;
        getBaselineResizeBehavior(): Internal.Component$BaselineResizeBehavior;
        removeMouseWheelListener(arg0: Internal.MouseWheelListener_): void;
        applyComponentOrientation(arg0: Internal.ComponentOrientation_): void;
        isAlwaysOnTopSupported(): boolean;
        validate(): void;
        getParent(): Internal.Container;
        isMinimumSizeSet(): boolean;
        getWindowFocusListeners(): Internal.WindowFocusListener[];
        setComponentOrientation(arg0: Internal.ComponentOrientation_): void;
        setBounds(arg0: number, arg1: number, arg2: number, arg3: number): void;
        setBounds(arg0: Internal.Rectangle_): void;
        static getWindows(): java_.awt.Window[];
        isValidateRoot(): boolean;
        addNotify(): void;
        addInputMethodListener(arg0: Internal.InputMethodListener_): void;
        toString(): string;
        getFocusCycleRootAncestor(): Internal.Container;
        setFocusTraversalPolicyProvider(arg0: boolean): void;
        addWindowFocusListener(arg0: Internal.WindowFocusListener_): void;
        getName(): string;
        countComponents(): number;
        isFocusTraversable(): boolean;
        inside(arg0: number, arg1: number): boolean;
        nextFocus(): void;
        getFocusTraversalKeys(arg0: number): Internal.Set<Internal.AWTKeyStroke>;
        getInputContext(): Internal.InputContext;
        isCursorSet(): boolean;
        setMenuBar(arg0: Internal.MenuBar_): void;
        getMouseWheelListeners(): Internal.MouseWheelListener[];
        getComponents(): java_.awt.Component[];
        removeMouseMotionListener(arg0: Internal.MouseMotionListener_): void;
        doLayout(): void;
        isLocationByPlatform(): boolean;
        add(arg0: java_.awt.Component_): java_.awt.Component;
        add(arg0: string, arg1: java_.awt.Component_): java_.awt.Component;
        add(arg0: java_.awt.Component_, arg1: any): void;
        add(arg0: java_.awt.Component_, arg1: number): java_.awt.Component;
        add(arg0: java_.awt.Component_, arg1: any, arg2: number): void;
        add(arg0: Internal.PopupMenu_): void;
        setVisible(arg0: boolean): void;
        removeKeyListener(arg0: Internal.KeyListener_): void;
        setFocusCycleRoot(arg0: boolean): void;
        setTitle(arg0: string): void;
        isResizable(): boolean;
        isVisible(): boolean;
        removePropertyChangeListener(arg0: string, arg1: Internal.PropertyChangeListener_): void;
        removePropertyChangeListener(arg0: Internal.PropertyChangeListener_): void;
        setDropTarget(arg0: Internal.DropTarget_): void;
        list(arg0: Internal.PrintWriter_, arg1: number): void;
        list(arg0: Internal.PrintStream_, arg1: number): void;
        list(arg0: Internal.PrintStream_): void;
        list(): void;
        list(arg0: Internal.PrintWriter_): void;
        isFocused(): boolean;
        revalidate(): void;
        removeWindowStateListener(arg0: Internal.WindowStateListener_): void;
        removeNotify(): void;
        getWarningString(): string;
        static getOwnerlessWindows(): java_.awt.Window[];
        gotFocus(arg0: java_.awt.Event_, arg1: any): boolean;
        handleEvent(arg0: java_.awt.Event_): boolean;
        notifyAll(): void;
        isForegroundSet(): boolean;
        show(): void;
        show(arg0: boolean): void;
        update(arg0: Internal.Graphics_): void;
        getShape(): Internal.Shape;
        isFocusTraversalPolicySet(): boolean;
        setMaximumSize(arg0: Internal.Dimension_): void;
        remove(arg0: Internal.MenuComponent_): void;
        remove(arg0: java_.awt.Component_): void;
        remove(arg0: number): void;
        imageUpdate(arg0: Internal.Image_, arg1: number, arg2: number, arg3: number, arg4: number, arg5: number): boolean;
        addMouseWheelListener(arg0: Internal.MouseWheelListener_): void;
        checkImage(arg0: Internal.Image_, arg1: Internal.ImageObserver_): number;
        checkImage(arg0: Internal.Image_, arg1: number, arg2: number, arg3: Internal.ImageObserver_): number;
        getLayout(): Internal.LayoutManager;
        addKeyListener(arg0: Internal.KeyListener_): void;
        getContainerListeners(): Internal.ContainerListener[];
        hashCode(): number;
        getComponentListeners(): Internal.ComponentListener[];
        isMaximumSizeSet(): boolean;
        addPropertyChangeListener(arg0: string, arg1: Internal.PropertyChangeListener_): void;
        addPropertyChangeListener(arg0: Internal.PropertyChangeListener_): void;
        getWindowListeners(): Internal.WindowListener[];
        getCursorType(): number;
        getCursor(): Internal.Cursor;
        createImage(arg0: number, arg1: number): Internal.Image;
        createImage(arg0: Internal.ImageProducer_): Internal.Image;
        mouseMove(arg0: java_.awt.Event_, arg1: number, arg2: number): boolean;
        areFocusTraversalKeysSet(arg0: number): boolean;
        getKeyListeners(): Internal.KeyListener[];
        setType(arg0: Internal.Window$Type_): void;
        layout(): void;
        setExtendedState(arg0: number): void;
        getBaseline(arg0: number, arg1: number): number;
        print(arg0: Internal.Graphics_): void;
        paintComponents(arg0: Internal.Graphics_): void;
        getFocusListeners(): Internal.FocusListener[];
        createVolatileImage(arg0: number, arg1: number, arg2: Internal.ImageCapabilities_): Internal.VolatileImage;
        createVolatileImage(arg0: number, arg1: number): Internal.VolatileImage;
        resize(arg0: Internal.Dimension_): void;
        resize(arg0: number, arg1: number): void;
        isAutoRequestFocus(): boolean;
        setState(arg0: number): void;
        lostFocus(arg0: java_.awt.Event_, arg1: any): boolean;
        location(): Internal.Point;
        keyDown(arg0: java_.awt.Event_, arg1: number): boolean;
        getDropTarget(): Internal.DropTarget;
        getLocale(): Internal.Locale;
        getIconImage(): Internal.Image;
        setOpacity(arg0: number): void;
        getHierarchyBoundsListeners(): Internal.HierarchyBoundsListener[];
        getBounds(): Internal.Rectangle;
        getBounds(arg0: Internal.Rectangle_): Internal.Rectangle;
        setPreferredSize(arg0: Internal.Dimension_): void;
        enable(arg0: boolean): void;
        enable(): void;
        getMousePosition(arg0: boolean): Internal.Point;
        getMousePosition(): Internal.Point;
        action(arg0: java_.awt.Event_, arg1: any): boolean;
        setIconImages(arg0: Internal.List_<Internal.Image_>): void;
        addContainerListener(arg0: Internal.ContainerListener_): void;
        setComponentZOrder(arg0: java_.awt.Component_, arg1: number): void;
        firePropertyChange(arg0: string, arg1: number, arg2: number): void;
        firePropertyChange(arg0: string, arg1: string, arg2: string): void;
        addMouseMotionListener(arg0: Internal.MouseMotionListener_): void;
        getComponentOrientation(): Internal.ComponentOrientation;
        setFocusable(arg0: boolean): void;
        getTreeLock(): any;
        isBackgroundSet(): boolean;
        addHierarchyListener(arg0: Internal.HierarchyListener_): void;
        findComponentAt(arg0: number, arg1: number): java_.awt.Component;
        findComponentAt(arg0: Internal.Point_): java_.awt.Component;
        setLocationByPlatform(arg0: boolean): void;
        setEnabled(arg0: boolean): void;
        isLightweight(): boolean;
        isEnabled(): boolean;
        minimumSize(): Internal.Dimension;
        bounds(): Internal.Rectangle;
        repaint(arg0: number, arg1: number, arg2: number, arg3: number): void;
        repaint(arg0: number): void;
        repaint(): void;
        repaint(arg0: number, arg1: number, arg2: number, arg3: number, arg4: number): void;
        getMouseMotionListeners(): Internal.MouseMotionListener[];
        getModalExclusionType(): Internal.Dialog$ModalExclusionType;
        setMinimumSize(arg0: Internal.Dimension_): void;
        transferFocus(): void;
        printComponents(arg0: Internal.Graphics_): void;
        getListeners<T_>(arg0: Internal.Class_<T_>): T_[];
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        getMaximumSize(): Internal.Dimension;
        getLocationOnScreen(): Internal.Point;
        keyUp(arg0: java_.awt.Event_, arg1: number): boolean;
        getWidth(): number;
        notify(): void;
        setFocusTraversalPolicy(arg0: Internal.FocusTraversalPolicy_): void;
        addWindowListener(arg0: Internal.WindowListener_): void;
        paintAll(arg0: Internal.Graphics_): void;
        setFocusTraversalKeys(arg0: number, arg1: Internal.Set_<Internal.AWTKeyStroke_>): void;
        hasFocus(): boolean;
        isPreferredSizeSet(): boolean;
        addWindowStateListener(arg0: Internal.WindowStateListener_): void;
        getIconImages(): Internal.List<Internal.Image>;
        getFocusableWindowState(): boolean;
        isDoubleBuffered(): boolean;
        getColorModel(): Internal.ColorModel;
        getPropertyChangeListeners(arg0: string): Internal.PropertyChangeListener[];
        getPropertyChangeListeners(): Internal.PropertyChangeListener[];
        isValid(): boolean;
        getInsets(): Internal.Insets;
        getFocusTraversalKeysEnabled(): boolean;
        hide(): void;
        getPreferredSize(): Internal.Dimension;
        setUndecorated(arg0: boolean): void;
        disable(): void;
        isUndecorated(): boolean;
        equals(arg0: any): boolean;
        prepareImage(arg0: Internal.Image_, arg1: Internal.ImageObserver_): boolean;
        prepareImage(arg0: Internal.Image_, arg1: number, arg2: number, arg3: Internal.ImageObserver_): boolean;
        isFocusableWindow(): boolean;
        isFocusable(): boolean;
        setLocationRelativeTo(arg0: java_.awt.Component_): void;
        getClass(): Internal.Class<any>;
        insets(): Internal.Insets;
        setIconImage(arg0: Internal.Image_): void;
        setMixingCutoutShape(arg0: Internal.Shape_): void;
        isActive(): boolean;
        getMenuBar(): Internal.MenuBar;
        mouseExit(arg0: java_.awt.Event_, arg1: number, arg2: number): boolean;
        getHierarchyListeners(): Internal.HierarchyListener[];
        getOpacity(): number;
        isShowing(): boolean;
        mouseEnter(arg0: java_.awt.Event_, arg1: number, arg2: number): boolean;
        getTitle(): string;
        mouseDrag(arg0: java_.awt.Event_, arg1: number, arg2: number): boolean;
        preferredSize(): Internal.Dimension;
        getMouseListeners(): Internal.MouseListener[];
        setFont(arg0: Internal.Font_): void;
        setAutoRequestFocus(arg0: boolean): void;
        toFront(): void;
        deliverEvent(arg0: java_.awt.Event_): void;
        getForeground(): java_.awt.Color;
        isAncestorOf(arg0: java_.awt.Component_): boolean;
        getComponentCount(): number;
        getExtendedState(): number;
        getFont(): Internal.Font;
        dispose(): void;
        setCursor(arg0: number): void;
        setCursor(arg0: Internal.Cursor_): void;
        isDisplayable(): boolean;
        getGraphicsConfiguration(): Internal.GraphicsConfiguration;
        getComponent(arg0: number): java_.awt.Component;
        setLocale(arg0: Internal.Locale_): void;
        removeComponentListener(arg0: Internal.ComponentListener_): void;
        requestFocus(): void;
        requestFocus(arg0: Internal.FocusEvent$Cause_): void;
        locate(arg0: number, arg1: number): java_.awt.Component;
        addFocusListener(arg0: Internal.FocusListener_): void;
        getComponentAt(arg0: Internal.Point_): java_.awt.Component;
        getComponentAt(arg0: number, arg1: number): java_.awt.Component;
        isAlwaysOnTop(): boolean;
        isFocusCycleRoot(): boolean;
        isFocusCycleRoot(arg0: Internal.Container_): boolean;
        setFocusTraversalKeysEnabled(arg0: boolean): void;
        getComponentZOrder(arg0: java_.awt.Component_): number;
        setBackground(arg0: java_.awt.Color_): void;
        printAll(arg0: Internal.Graphics_): void;
        getToolkit(): Internal.Toolkit;
        transferFocusUpCycle(): void;
        isFontSet(): boolean;
        setSize(arg0: number, arg1: number): void;
        setSize(arg0: Internal.Dimension_): void;
        isFocusTraversalPolicyProvider(): boolean;
        setLocation(arg0: Internal.Point_): void;
        setLocation(arg0: number, arg1: number): void;
        getGraphics(): Internal.Graphics;
        removeFocusListener(arg0: Internal.FocusListener_): void;
        setIgnoreRepaint(arg0: boolean): void;
        transferFocusBackward(): void;
        getOwnedWindows(): java_.awt.Window[];
        setMaximizedBounds(arg0: Internal.Rectangle_): void;
        move(arg0: number, arg1: number): void;
        transferFocusDownCycle(): void;
        applyResourceBundle(arg0: string): void;
        applyResourceBundle(arg0: Internal.ResourceBundle_): void;
        setResizable(arg0: boolean): void;
        setForeground(arg0: java_.awt.Color_): void;
        invalidate(): void;
        getBufferStrategy(): Internal.BufferStrategy;
        getAccessibleContext(): Internal.AccessibleContext;
        setShape(arg0: Internal.Shape_): void;
        isFocusOwner(): boolean;
        getX(): number;
        getSize(arg0: Internal.Dimension_): Internal.Dimension;
        getSize(): Internal.Dimension;
        getY(): number;
        removeHierarchyBoundsListener(arg0: Internal.HierarchyBoundsListener_): void;
        getState(): number;
        getFocusTraversalPolicy(): Internal.FocusTraversalPolicy;
        setAlwaysOnTop(arg0: boolean): void;
        getFocusOwner(): java_.awt.Component;
        removeMouseListener(arg0: Internal.MouseListener_): void;
        getBackground(): java_.awt.Color;
        addMouseListener(arg0: Internal.MouseListener_): void;
        static readonly PROPERTIES : 4;
        static readonly BOTTOM_ALIGNMENT : 1.0;
        static readonly MAXIMIZED_HORIZ : 2;
        static readonly WIDTH : 1;
        static readonly FRAMEBITS : 16;
        static readonly MAXIMIZED_BOTH : 6;
        static readonly NW_RESIZE_CURSOR : 6;
        static readonly SE_RESIZE_CURSOR : 5;
        static readonly NE_RESIZE_CURSOR : 7;
        static readonly SW_RESIZE_CURSOR : 4;
        static readonly RIGHT_ALIGNMENT : 1.0;
        static readonly MAXIMIZED_VERT : 4;
        static readonly ERROR : 64;
        static readonly CROSSHAIR_CURSOR : 1;
        static readonly HAND_CURSOR : 12;
        static readonly N_RESIZE_CURSOR : 8;
        static readonly ABORT : 128;
        static readonly CENTER_ALIGNMENT : 0.5;
        static readonly SOMEBITS : 8;
        static readonly ICONIFIED : 1;
        static readonly HEIGHT : 2;
        static readonly S_RESIZE_CURSOR : 9;
        static readonly TEXT_CURSOR : 2;
        static readonly W_RESIZE_CURSOR : 10;
        static readonly LEFT_ALIGNMENT : 0.0;
        static readonly ALLBITS : 32;
        static readonly TOP_ALIGNMENT : 0.0;
        static readonly DEFAULT_CURSOR : 0;
        static readonly E_RESIZE_CURSOR : 11;
        static readonly WAIT_CURSOR : 3;
        static readonly NORMAL : 0;
        static readonly MOVE_CURSOR : 13;
        get parent(): Internal.Container;
        get inputContext(): Internal.InputContext;
        get dropTarget(): Internal.DropTarget;
        get graphicsConfiguration(): Internal.GraphicsConfiguration;
        get foreground(): java_.awt.Color;
        get type(): Internal.Window$Type;
        get baselineResizeBehavior(): Internal.Component$BaselineResizeBehavior;
        get mouseWheelListeners(): Internal.MouseWheelListener[];
        get state(): number;
        get propertyChangeListeners(): Internal.PropertyChangeListener[];
        get height(): number;
        get frames(): Internal.Frame[];
        get shape(): Internal.Shape;
        get displayable(): boolean;
        get active(): boolean;
        get maximumSizeSet(): boolean;
        get autoRequestFocus(): boolean;
        get focusable(): boolean;
        get mousePosition(): Internal.Point;
        get focusTraversalPolicySet(): boolean;
        get componentCount(): number;
        get toolkit(): Internal.Toolkit;
        get focusCycleRootAncestor(): Internal.Container;
        get focusCycleRoot(): boolean;
        get focusTraversable(): boolean;
        get focusTraversalPolicyProvider(): boolean;
        get maximumSize(): Internal.Dimension;
        get alwaysOnTopSupported(): boolean;
        get hierarchyListeners(): Internal.HierarchyListener[];
        get accessibleContext(): Internal.AccessibleContext;
        get alignmentX(): number;
        get alignmentY(): number;
        get components(): java_.awt.Component[];
        get alwaysOnTop(): boolean;
        get ownerlessWindows(): java_.awt.Window[];
        get enabled(): boolean;
        get valid(): boolean;
        get locationOnScreen(): Internal.Point;
        get cursorSet(): boolean;
        get locationByPlatform(): boolean;
        get colorModel(): Internal.ColorModel;
        get bufferStrategy(): Internal.BufferStrategy;
        get keyListeners(): Internal.KeyListener[];
        get resizable(): boolean;
        get validateRoot(): boolean;
        get hierarchyBoundsListeners(): Internal.HierarchyBoundsListener[];
        get preferredSizeSet(): boolean;
        get treeLock(): any;
        get focusListeners(): Internal.FocusListener[];
        get backgroundSet(): boolean;
        get width(): number;
        get x(): number;
        get y(): number;
        get opacity(): number;
        get maximizedBounds(): Internal.Rectangle;
        get font(): Internal.Font;
        get warningString(): string;
        get iconImage(): Internal.Image;
        get cursorType(): number;
        get modalExclusionType(): Internal.Dialog$ModalExclusionType;
        get windowFocusListeners(): Internal.WindowFocusListener[];
        get graphics(): Internal.Graphics;
        get foregroundSet(): boolean;
        get menuBar(): Internal.MenuBar;
        get doubleBuffered(): boolean;
        get ownedWindows(): java_.awt.Window[];
        get visible(): boolean;
        get focusTraversalKeysEnabled(): boolean;
        get focusOwner(): java_.awt.Component;
        get iconImages(): Internal.List<Internal.Image>;
        get focusTraversalPolicy(): Internal.FocusTraversalPolicy;
        get background(): java_.awt.Color;
        get name(): string;
        get focused(): boolean;
        get focusableWindow(): boolean;
        get containerListeners(): Internal.ContainerListener[];
        get minimumSizeSet(): boolean;
        get cursor(): Internal.Cursor;
        get mostRecentFocusOwner(): java_.awt.Component;
        get componentOrientation(): Internal.ComponentOrientation;
        get locale(): Internal.Locale;
        get title(): string;
        get ignoreRepaint(): boolean;
        get lightweight(): boolean;
        get componentListeners(): Internal.ComponentListener[];
        get focusableWindowState(): boolean;
        get windowStateListeners(): Internal.WindowStateListener[];
        get class(): Internal.Class<any>;
        get owner(): java_.awt.Window;
        get inputMethodListeners(): Internal.InputMethodListener[];
        get opaque(): boolean;
        get extendedState(): number;
        get mouseListeners(): Internal.MouseListener[];
        get inputMethodRequests(): Internal.InputMethodRequests;
        get windows(): java_.awt.Window[];
        get windowListeners(): Internal.WindowListener[];
        get undecorated(): boolean;
        get fontSet(): boolean;
        get showing(): boolean;
        get mouseMotionListeners(): Internal.MouseMotionListener[];
        set cursor(arg0: Internal.Cursor_);
        set iconImage(arg0: Internal.Image_);
        set locationRelativeTo(arg0: java_.awt.Component_);
        set alwaysOnTop(arg0: boolean);
        set componentOrientation(arg0: Internal.ComponentOrientation_);
        set dropTarget(arg0: Internal.DropTarget_);
        set modalExclusionType(arg0: Internal.Dialog$ModalExclusionType_);
        set foreground(arg0: java_.awt.Color_);
        set locale(arg0: Internal.Locale_);
        set type(arg0: Internal.Window$Type_);
        set title(arg0: string);
        set ignoreRepaint(arg0: boolean);
        set enabled(arg0: boolean);
        set menuBar(arg0: Internal.MenuBar_);
        set focusableWindowState(arg0: boolean);
        set locationByPlatform(arg0: boolean);
        set state(arg0: number);
        set visible(arg0: boolean);
        set shape(arg0: Internal.Shape_);
        set resizable(arg0: boolean);
        set extendedState(arg0: number);
        set autoRequestFocus(arg0: boolean);
        set focusable(arg0: boolean);
        set focusTraversalKeysEnabled(arg0: boolean);
        set mixingCutoutShape(arg0: Internal.Shape_);
        set undecorated(arg0: boolean);
        set focusTraversalPolicy(arg0: Internal.FocusTraversalPolicy_);
        set iconImages(arg0: Internal.List_<Internal.Image_>);
        set background(arg0: java_.awt.Color_);
        set focusCycleRoot(arg0: boolean);
        set focusTraversalPolicyProvider(arg0: boolean);
        set name(arg0: string);
        set maximumSize(arg0: Internal.Dimension_);
        set opacity(arg0: number);
        set maximizedBounds(arg0: Internal.Rectangle_);
        set font(arg0: Internal.Font_);
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    type Frame_ = Frame;
    class RemoveSpawnsProperties {
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        hashCode(): number;
        notifyAll(): void;
        equals(arg0: any): boolean;
        toString(): string;
        notify(): void;
        mobs : ((arg0: Internal.MobCategory, arg1: Internal.MobSpawnSettings$SpawnerData) => boolean);
        biomes : ((arg0: Internal.BiomeModifications$BiomeContext) => boolean);
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    type RemoveSpawnsProperties_ = RemoveSpawnsProperties;
    abstract class ParticleType <T> extends Internal.ForgeRegistryEntry<Internal.ParticleType<any>> {
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        hashCode(): number;
        notifyAll(): void;
        equals(arg0: any): boolean;
        getRegistryType(): Internal.Class<Internal.ParticleType<any>>;
        getRegistryName(): ResourceLocation;
        toString(): string;
        setRegistryName(arg0: ResourceLocation_): Internal.ParticleType<any>;
        setRegistryName(arg0: string): Internal.ParticleType<any>;
        setRegistryName(arg0: string, arg1: string): Internal.ParticleType<any>;
        notify(): void;
        readonly delegate : Internal.IRegistryDelegate<Internal.ParticleType<any>>;
        get registryType(): Internal.Class<Internal.ParticleType<any>>;
        get registryName(): ResourceLocation;
        get class(): Internal.Class<any>;
        set registryName(arg0: ResourceLocation_);
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    type ParticleType_<T> = ParticleType<T>;
    interface Consumer <T> {
        andThen(arg0: Internal.Consumer_<T>): Internal.Consumer<T>;
        accept(arg0: T): void;
    }
    type Consumer_<T> = ((arg0: T) => void) | Consumer<T>;
    class Capability <T> {
        getClass(): Internal.Class<any>;
        orEmpty<R>(arg0: Internal.Capability_<R>, arg1: Internal.LazyOptional_<T>): Internal.LazyOptional<R>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        getName(): string;
        hashCode(): number;
        notifyAll(): void;
        equals(arg0: any): boolean;
        toString(): string;
        isRegistered(): boolean;
        notify(): void;
        addListener(arg0: Internal.Consumer_<Internal.Capability_<T>>): Internal.Capability<T>;
        get name(): string;
        get registered(): boolean;
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    type Capability_<T> = Capability<T>;
    class RecipeManager extends Internal.SimpleJsonResourceReloadListener implements snownee.kiwi.mixin.RecipeManagerAccess, vectorwing.farmersdelight.common.mixin.accessor.RecipeManagerAccessor, Internal.RecipeManagerMixin, Internal.AccessorRecipeManager, Internal.RecipeManagerAccessor, Internal.RecipeManagerAccess {
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        hashCode(): number;
        notifyAll(): void;
        equals(arg0: any): boolean;
        static fromJson(arg0: ResourceLocation_, arg1: Internal.JsonObject_, arg2: Internal.ICondition$IContext_): Internal.Recipe<any>;
        toString(): string;
        notify(): void;
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    type RecipeManager_ = RecipeManager;
    interface HierarchyListener extends Internal.EventListener {
        hierarchyChanged(arg0: Internal.HierarchyEvent_): void;
    }
    type HierarchyListener_ = HierarchyListener;
    interface LongSpliterator extends Internal.Spliterator$OfLong {
        trySplit(): Internal.LongSpliterator;
        characteristics(): number;
        tryAdvance(arg0: Internal.Consumer_<number>): boolean;
        tryAdvance(arg0: Internal.LongConsumer_): boolean;
        tryAdvance(arg0: java_.util.function_.LongConsumer_): boolean;
        getComparator(): Internal.LongComparator;
        getExactSizeIfKnown(): number;
        estimateSize(): number;
        skip(arg0: number): number;
        hasCharacteristics(arg0: number): boolean;
        forEachRemaining(arg0: Internal.Consumer_<number>): void;
        forEachRemaining(arg0: Internal.LongConsumer_): void;
        forEachRemaining(arg0: java_.util.function_.LongConsumer_): void;
    }
    type LongSpliterator_ = LongSpliterator;
    interface BiomeModifications$BiomeContext {
        getKey(): ResourceLocation;
        getProperties(): Internal.BiomeProperties;
    }
    type BiomeModifications$BiomeContext_ = BiomeModifications$BiomeContext;
    class UnmodifiableCommentedConfig$CommentNode {
        getClass(): Internal.Class<any>;
        getChildren(): Internal.Map<string, Internal.UnmodifiableCommentedConfig$CommentNode>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        hashCode(): number;
        notifyAll(): void;
        equals(arg0: any): boolean;
        toString(): string;
        getComment(): string;
        notify(): void;
        get children(): Internal.Map<string, Internal.UnmodifiableCommentedConfig$CommentNode>;
        get comment(): string;
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    type UnmodifiableCommentedConfig$CommentNode_ = UnmodifiableCommentedConfig$CommentNode;
    interface Frustum {
        isBoxVisible(minX: number, minY: number, minZ: number, maxX: number, maxY: number, maxZ: number): boolean;
        testBox(arg0: number, arg1: number, arg2: number, arg3: number, arg4: number, arg5: number): Internal.Frustum$Visibility;
    }
    type Frustum_ = Frustum;
    abstract class RecipeCondition {
        getValidTexture(): Internal.IGuiTexture;
        getClass(): Internal.Class<any>;
        openConfigurator(arg0: Internal.WidgetGroup_): void;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        test(arg0: com.lowdragmc.multiblocked.api.recipe.Recipe_, arg1: Internal.RecipeLogic_): boolean;
        getTranlationKey(): string;
        notifyAll(): void;
        isReverse(): boolean;
        setReverse(arg0: boolean): Internal.RecipeCondition;
        toNetwork(arg0: Internal.FriendlyByteBuf_): void;
        notify(): void;
        createTemplate(): Internal.RecipeCondition;
        getTooltips(): Internal.Component;
        getInValidTexture(): Internal.IGuiTexture;
        serialize(): Internal.JsonObject;
        getType(): string;
        hashCode(): number;
        equals(arg0: any): boolean;
        toString(): string;
        fromNetwork(arg0: Internal.FriendlyByteBuf_): Internal.RecipeCondition;
        deserialize(arg0: Internal.JsonObject_): Internal.RecipeCondition;
        get inValidTexture(): Internal.IGuiTexture;
        get tranlationKey(): string;
        get validTexture(): Internal.IGuiTexture;
        get reverse(): boolean;
        get type(): string;
        get class(): Internal.Class<any>;
        get tooltips(): Internal.Component;
        set reverse(arg0: boolean);
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    type RecipeCondition_ = RecipeCondition;
    class AccessibleRelationSet {
        add(arg0: Internal.AccessibleRelation_): boolean;
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        notifyAll(): void;
        clear(): void;
        notify(): void;
        remove(arg0: Internal.AccessibleRelation_): boolean;
        contains(arg0: string): boolean;
        size(): number;
        addAll(arg0: Internal.AccessibleRelation_[]): void;
        hashCode(): number;
        equals(arg0: any): boolean;
        get(arg0: string): Internal.AccessibleRelation;
        toArray(): Internal.AccessibleRelation[];
        toString(): string;
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    type AccessibleRelationSet_ = AccessibleRelationSet;
    class OptionalInt {
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        notifyAll(): void;
        isEmpty(): boolean;
        isPresent(): boolean;
        orElse(arg0: number): number;
        notify(): void;
        getAsInt(): number;
        orElseThrow<X>(arg0: Internal.Supplier_<X>): number;
        orElseThrow(): number;
        static empty(): Internal.OptionalInt;
        orElseGet(arg0: Internal.IntSupplier_): number;
        stream(): Internal.IntStream;
        hashCode(): number;
        ifPresentOrElse(arg0: java_.util.function_.IntConsumer_, arg1: Internal.Runnable_): void;
        ifPresent(arg0: java_.util.function_.IntConsumer_): void;
        static of(arg0: number): Internal.OptionalInt;
        equals(arg0: any): boolean;
        toString(): string;
        get asInt(): number;
        get present(): boolean;
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    type OptionalInt_ = OptionalInt;
    class RegistryObjectBuilderTypes$RegistryEventJS <T> extends Internal.StartupEventJS {
        cancel(): void;
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        isCancelled(): boolean;
        post(id: string): boolean;
        post(id: string, sub: string): boolean;
        post(t: Internal.ScriptType_, id: string, sub: string): boolean;
        post(t: Internal.ScriptType_, id: string): boolean;
        hashCode(): number;
        notifyAll(): void;
        equals(arg0: any): boolean;
        create(id: string, type: string): Internal.BuilderBase<T>;
        create(id: string): Internal.BuilderBase<T>;
        toString(): string;
        notify(): void;
        canCancel(): boolean;
        get cancelled(): boolean;
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    type RegistryObjectBuilderTypes$RegistryEventJS_<T> = RegistryObjectBuilderTypes$RegistryEventJS<T>;
    class ContainerEvent extends Internal.ComponentEvent {
        getClass(): Internal.Class<any>;
        setSource(arg0: any): void;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        getContainer(): Internal.Container;
        notifyAll(): void;
        getChild(): java_.awt.Component;
        getID(): number;
        notify(): void;
        paramString(): string;
        hashCode(): number;
        getSource(): any;
        equals(arg0: any): boolean;
        toString(): string;
        getComponent(): java_.awt.Component;
        static readonly ADJUSTMENT_EVENT_MASK : 256;
        static readonly MOUSE_EVENT_MASK : 16;
        static readonly COMPONENT_EVENT_MASK : 1;
        static readonly PAINT_EVENT_MASK : 8192;
        static readonly CONTAINER_FIRST : 300;
        static readonly COMPONENT_HIDDEN : 103;
        static readonly INPUT_METHOD_EVENT_MASK : 2048;
        static readonly HIERARCHY_BOUNDS_EVENT_MASK : 65536;
        static readonly COMPONENT_LAST : 103;
        static readonly FOCUS_EVENT_MASK : 4;
        static readonly INVOCATION_EVENT_MASK : 16384;
        static readonly KEY_EVENT_MASK : 8;
        static readonly RESERVED_ID_MAX : 1999;
        static readonly CONTAINER_EVENT_MASK : 2;
        static readonly WINDOW_EVENT_MASK : 64;
        static readonly COMPONENT_ADDED : 300;
        static readonly MOUSE_WHEEL_EVENT_MASK : 131072;
        static readonly MOUSE_MOTION_EVENT_MASK : 32;
        static readonly COMPONENT_FIRST : 100;
        static readonly WINDOW_FOCUS_EVENT_MASK : 524288;
        static readonly COMPONENT_REMOVED : 301;
        static readonly COMPONENT_MOVED : 100;
        static readonly COMPONENT_SHOWN : 102;
        static readonly TEXT_EVENT_MASK : 1024;
        static readonly CONTAINER_LAST : 301;
        static readonly ACTION_EVENT_MASK : 128;
        static readonly ITEM_EVENT_MASK : 512;
        static readonly HIERARCHY_EVENT_MASK : 32768;
        static readonly WINDOW_STATE_EVENT_MASK : 262144;
        static readonly COMPONENT_RESIZED : 101;
        get container(): Internal.Container;
        get component(): java_.awt.Component;
        get iD(): number;
        get source(): any;
        get class(): Internal.Class<any>;
        get child(): java_.awt.Component;
        set source(arg0: any);
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    type ContainerEvent_ = ContainerEvent;
    class OrderedCompoundTag extends Internal.CompoundTag {
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        hashCode(): number;
        notifyAll(): void;
        merge(arg0: Internal.CompoundTag_): Internal.CompoundTag;
        equals(arg0: any): boolean;
        toString(): string;
        notify(): void;
        readonly tagMap : Internal.Map<string, net.minecraft.nbt.Tag>;
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    type OrderedCompoundTag_ = OrderedCompoundTag;
    interface AccessInputConstantsKey {
    }
    type AccessInputConstantsKey_ = AccessInputConstantsKey;
    interface ChannelHandler {
        exceptionCaught(arg0: Internal.ChannelHandlerContext_, arg1: Internal.Throwable_): void;
        handlerAdded(arg0: Internal.ChannelHandlerContext_): void;
        handlerRemoved(arg0: Internal.ChannelHandlerContext_): void;
    }
    type ChannelHandler_ = ChannelHandler;
    interface GenericDeclaration extends Internal.AnnotatedElement {
        getAnnotationsByType<T_>(arg0: Internal.Class_<T_>): T_[];
        getDeclaredAnnotationsByType<T_>(arg0: Internal.Class_<T_>): T_[];
        getAnnotation<T_>(arg0: Internal.Class_<T_>): T_;
        isAnnotationPresent(arg0: Internal.Class_<Internal.Annotation_>): boolean;
        getDeclaredAnnotation<T_>(arg0: Internal.Class_<T_>): T_;
        getTypeParameters(): any[];
        getAnnotations(): Internal.Annotation[];
        getDeclaredAnnotations(): Internal.Annotation[];
    }
    type GenericDeclaration_ = GenericDeclaration;
    interface Flushable {
        flush(): void;
    }
    type Flushable_ = Flushable;
    interface LongBinaryOperator {
        applyAsLong(arg0: number, arg1: number): number;
    }
    type LongBinaryOperator_ = ((arg0: number, arg1: number) => number) | LongBinaryOperator;
    abstract class Charset implements Internal.Comparable<Internal.Charset> {
        encode(arg0: string): Internal.ByteBuffer;
        encode(arg0: Internal.CharBuffer_): Internal.ByteBuffer;
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        aliases(): Internal.Set<string>;
        static forName(arg0: string, arg1: Internal.Charset_): Internal.Charset;
        static forName(arg0: string): Internal.Charset;
        displayName(): string;
        displayName(arg0: Internal.Locale_): string;
        newDecoder(): Internal.CharsetDecoder;
        notifyAll(): void;
        static defaultCharset(): Internal.Charset;
        static isSupported(arg0: string): boolean;
        compareTo(arg0: Internal.Charset_): number;
        decode(arg0: Internal.ByteBuffer_): Internal.CharBuffer;
        notify(): void;
        contains(arg0: Internal.Charset_): boolean;
        hashCode(): number;
        canEncode(): boolean;
        equals(arg0: any): boolean;
        newEncoder(): Internal.CharsetEncoder;
        name(): string;
        isRegistered(): boolean;
        toString(): string;
        static availableCharsets(): Internal.SortedMap<string, Internal.Charset>;
        get registered(): boolean;
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    type Charset_ = Charset;
    class Products$P16 <F, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16> {
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        apply<R>(arg0: Internal.Applicative_<F, any>, arg1: Internal.Function16_<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, R>): Internal.App<F, R>;
        apply<R>(arg0: Internal.Applicative_<F, any>, arg1: Internal.App_<F, Internal.Function16_<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, R>>): Internal.App<F, R>;
        hashCode(): number;
        notifyAll(): void;
        equals(arg0: any): boolean;
        toString(): string;
        notify(): void;
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    type Products$P16_<F, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16> = Products$P16<F, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16>;
    class FocusEvent extends Internal.ComponentEvent {
        getClass(): Internal.Class<any>;
        setSource(arg0: any): void;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        notifyAll(): void;
        getID(): number;
        isTemporary(): boolean;
        getOppositeComponent(): java_.awt.Component;
        getCause(): Internal.FocusEvent$Cause;
        notify(): void;
        paramString(): string;
        hashCode(): number;
        getSource(): any;
        equals(arg0: any): boolean;
        toString(): string;
        getComponent(): java_.awt.Component;
        static readonly ADJUSTMENT_EVENT_MASK : 256;
        static readonly MOUSE_EVENT_MASK : 16;
        static readonly COMPONENT_EVENT_MASK : 1;
        static readonly PAINT_EVENT_MASK : 8192;
        static readonly COMPONENT_HIDDEN : 103;
        static readonly INPUT_METHOD_EVENT_MASK : 2048;
        static readonly HIERARCHY_BOUNDS_EVENT_MASK : 65536;
        static readonly COMPONENT_LAST : 103;
        static readonly FOCUS_EVENT_MASK : 4;
        static readonly INVOCATION_EVENT_MASK : 16384;
        static readonly KEY_EVENT_MASK : 8;
        static readonly RESERVED_ID_MAX : 1999;
        static readonly FOCUS_FIRST : 1004;
        static readonly CONTAINER_EVENT_MASK : 2;
        static readonly WINDOW_EVENT_MASK : 64;
        static readonly MOUSE_WHEEL_EVENT_MASK : 131072;
        static readonly MOUSE_MOTION_EVENT_MASK : 32;
        static readonly COMPONENT_FIRST : 100;
        static readonly FOCUS_LOST : 1005;
        static readonly WINDOW_FOCUS_EVENT_MASK : 524288;
        static readonly FOCUS_GAINED : 1004;
        static readonly COMPONENT_MOVED : 100;
        static readonly COMPONENT_SHOWN : 102;
        static readonly FOCUS_LAST : 1005;
        static readonly TEXT_EVENT_MASK : 1024;
        static readonly ACTION_EVENT_MASK : 128;
        static readonly ITEM_EVENT_MASK : 512;
        static readonly HIERARCHY_EVENT_MASK : 32768;
        static readonly WINDOW_STATE_EVENT_MASK : 262144;
        static readonly COMPONENT_RESIZED : 101;
        get temporary(): boolean;
        get component(): java_.awt.Component;
        get oppositeComponent(): java_.awt.Component;
        get cause(): Internal.FocusEvent$Cause;
        get iD(): number;
        get source(): any;
        get class(): Internal.Class<any>;
        set source(arg0: any);
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    type FocusEvent_ = FocusEvent;
    class BiomeDictionary$Type {
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        static getAll(): Internal.Collection<Internal.BiomeDictionary$Type>;
        getName(): string;
        static getType(arg0: string, arg1: Internal.BiomeDictionary$Type_[]): Internal.BiomeDictionary$Type;
        hashCode(): number;
        notifyAll(): void;
        equals(arg0: any): boolean;
        toString(): string;
        static fromVanilla(arg0: Internal.Biome$BiomeCategory_): Internal.BiomeDictionary$Type;
        notify(): void;
        static hasType(arg0: string): boolean;
        static readonly SNOWY : Internal.BiomeDictionary$Type;
        static readonly BEACH : Internal.BiomeDictionary$Type;
        static readonly UNDERGROUND : Internal.BiomeDictionary$Type;
        static readonly SAVANNA : Internal.BiomeDictionary$Type;
        static readonly MESA : Internal.BiomeDictionary$Type;
        static readonly RARE : Internal.BiomeDictionary$Type;
        static readonly SPOOKY : Internal.BiomeDictionary$Type;
        static readonly WET : Internal.BiomeDictionary$Type;
        static readonly SPARSE : Internal.BiomeDictionary$Type;
        static readonly MOUNTAIN : Internal.BiomeDictionary$Type;
        static readonly DRY : Internal.BiomeDictionary$Type;
        static readonly RIVER : Internal.BiomeDictionary$Type;
        static readonly MAGICAL : Internal.BiomeDictionary$Type;
        static readonly NETHER : Internal.BiomeDictionary$Type;
        static readonly WATER : Internal.BiomeDictionary$Type;
        static readonly DENSE : Internal.BiomeDictionary$Type;
        static readonly JUNGLE : Internal.BiomeDictionary$Type;
        static readonly SANDY : Internal.BiomeDictionary$Type;
        static readonly OCEAN : Internal.BiomeDictionary$Type;
        static readonly HILLS : Internal.BiomeDictionary$Type;
        static readonly HOT : Internal.BiomeDictionary$Type;
        static readonly FOREST : Internal.BiomeDictionary$Type;
        static readonly MUSHROOM : Internal.BiomeDictionary$Type;
        static readonly OVERWORLD : Internal.BiomeDictionary$Type;
        static readonly PLATEAU : Internal.BiomeDictionary$Type;
        static readonly PLAINS : Internal.BiomeDictionary$Type;
        static readonly SWAMP : Internal.BiomeDictionary$Type;
        static readonly PEAK : Internal.BiomeDictionary$Type;
        static readonly END : Internal.BiomeDictionary$Type;
        static readonly COLD : Internal.BiomeDictionary$Type;
        static readonly DEAD : Internal.BiomeDictionary$Type;
        static readonly MODIFIED : Internal.BiomeDictionary$Type;
        static readonly VOID : Internal.BiomeDictionary$Type;
        static readonly LUSH : Internal.BiomeDictionary$Type;
        static readonly CONIFEROUS : Internal.BiomeDictionary$Type;
        static readonly SLOPE : Internal.BiomeDictionary$Type;
        static readonly WASTELAND : Internal.BiomeDictionary$Type;
        get all(): Internal.Collection<Internal.BiomeDictionary$Type>;
        get name(): string;
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    type BiomeDictionary$Type_ = BiomeDictionary$Type;
    interface Int2ObjectFunction <V> extends Internal.Function<number, V>, Internal.IntFunction<V> {
        getOrDefault(arg0: number, arg1: V): V;
        getOrDefault(arg0: any, arg1: V): V;
        andThenShort(arg0: Internal.Object2ShortFunction_<V>): Internal.Int2ShortFunction;
        composeByte(arg0: Internal.Byte2IntFunction_): Internal.Byte2ObjectFunction<V>;
        andThenInt(arg0: Internal.Object2IntFunction_<V>): Internal.Int2IntFunction;
        andThen<V_>(arg0: java_.util.function_.Function_<V, V_>): java_.util.function_.Function<number, V_>;
        composeReference<T_>(arg0: Internal.Reference2IntFunction_<T_>): Internal.Reference2ObjectFunction<T_, V>;
        put(arg0: number, arg1: V): V;
        remove(arg0: any): V;
        remove(arg0: number): V;
        defaultReturnValue(arg0: V): void;
        defaultReturnValue(): V;
        andThenDouble(arg0: Internal.Object2DoubleFunction_<V>): Internal.Int2DoubleFunction;
        andThenObject<T_>(arg0: Internal.Object2ObjectFunction_<V, T_>): Internal.Int2ObjectFunction<T_>;
        get(arg0: any): V;
        get(arg0: number): V;
        andThenLong(arg0: Internal.Object2LongFunction_<V>): Internal.Int2LongFunction;
        composeLong(arg0: Internal.Long2IntFunction_): Internal.Long2ObjectFunction<V>;
        andThenByte(arg0: Internal.Object2ByteFunction_<V>): Internal.Int2ByteFunction;
        andThenFloat(arg0: Internal.Object2FloatFunction_<V>): Internal.Int2FloatFunction;
        apply(arg0: number): V;
        containsKey(arg0: any): boolean;
        containsKey(arg0: number): boolean;
        composeInt(arg0: Internal.Int2IntFunction_): Internal.Int2ObjectFunction<V>;
        clear(): void;
        composeFloat(arg0: Internal.Float2IntFunction_): Internal.Float2ObjectFunction<V>;
        andThenChar(arg0: Internal.Object2CharFunction_<V>): Internal.Int2CharFunction;
        composeObject<T_>(arg0: Internal.Object2IntFunction_<T_>): Internal.Object2ObjectFunction<T_, V>;
        size(): number;
        compose<T_>(arg0: java_.util.function_.Function_<T_, number>): java_.util.function_.Function<T_, V>;
        composeShort(arg0: Internal.Short2IntFunction_): Internal.Short2ObjectFunction<V>;
        andThenReference<T_>(arg0: Internal.Object2ReferenceFunction_<V, T_>): Internal.Int2ReferenceFunction<T_>;
        composeChar(arg0: Internal.Char2IntFunction_): Internal.Char2ObjectFunction<V>;
        composeDouble(arg0: Internal.Double2IntFunction_): Internal.Double2ObjectFunction<V>;
    }
    type Int2ObjectFunction_<V> = ((arg0: number) => V) | Int2ObjectFunction<V>;
    interface RewardType$GuiProvider {
        openCreationGui(arg0: Internal.Runnable_, arg1: Internal.Quest_, arg2: Internal.Consumer_<Internal.Reward_>): void;
    }
    type RewardType$GuiProvider_ = RewardType$GuiProvider;
    class TextureAtlasSprite implements Internal.AutoCloseable, Internal.SpriteExtended {
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        getPixelRGBA(arg0: number, arg1: number, arg2: number): number;
        setActive(active: boolean): void;
        hashCode(): number;
        notifyAll(): void;
        equals(arg0: any): boolean;
        toString(): string;
        isActive(): boolean;
        close(): void;
        notify(): void;
        get active(): boolean;
        get class(): Internal.Class<any>;
        set active(active: boolean);
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    type TextureAtlasSprite_ = TextureAtlasSprite;
    class IntConfig extends Internal.NumberConfig<number> {
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        getName(): string;
        setCanEdit(e: boolean): Internal.ConfigValue<number>;
        notifyAll(): void;
        isEqual(v1: number, v2: number): boolean;
        compareTo(o: Internal.ConfigValue_<number>): number;
        notify(): void;
        getCanEdit(): boolean;
        getStringFromValue(v: number): string;
        getTooltip(): string;
        hashCode(): number;
        getStringForGUI(v: number): Internal.Component;
        getPath(): string;
        copy(value: number): number;
        static info(key: string, value: any): Internal.Component;
        init(g: Internal.ConfigGroup_, i: string, v: number, c: Internal.Consumer_<number>, def: number): Internal.ConfigValue<number>;
        getColor(v: number): Internal.Color4I;
        addInfo(list: Internal.TooltipList_): void;
        parse(callback: Internal.Consumer_<number>, string: string): boolean;
        getIcon(v: number): Internal.Icon;
        setIcon(i: Internal.Icon_): Internal.ConfigValue<number>;
        setOrder(o: number): Internal.ConfigValue<number>;
        getNameKey(): string;
        setNameKey(key: string): Internal.ConfigValue<number>;
        equals(arg0: any): boolean;
        onClicked(button: Internal.MouseButton_, callback: Internal.ConfigCallback_): void;
        toString(): string;
        setCurrentValue(v: number): boolean;
        fader(v: boolean): Internal.NumberConfig<number>;
        readonly min : number;
        readonly max : number;
        static readonly COLOR : Internal.Color4I;
        defaultValue : number;
        id : string;
        static readonly NULL_TEXT : Internal.TextComponent;
        setter : ((arg0: number) => void);
        value : number;
        group : Internal.ConfigGroup;
        get path(): string;
        get nameKey(): string;
        get canEdit(): boolean;
        get name(): string;
        get tooltip(): string;
        get class(): Internal.Class<any>;
        set nameKey(key: string);
        set canEdit(e: boolean);
        set icon(i: Internal.Icon_);
        set currentValue(v: number);
        set order(o: number);
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    type IntConfig_ = IntConfig;
    class LootContextParamSet {
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        hashCode(): number;
        notifyAll(): void;
        equals(arg0: any): boolean;
        toString(): string;
        notify(): void;
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    type LootContextParamSet_ = LootContextParamSet;
    class MutableArmorTier implements Internal.ArmorMaterial {
        setName(name: string): void;
        getClass(): Internal.Class<any>;
        setRepairIngredient(in_: Internal.IngredientJS_): void;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        getKnockbackResistance(): number;
        notifyAll(): void;
        getToughness(): number;
        setKnockbackResistance(f: number): void;
        notify(): void;
        setEquipSound(e: Internal.SoundEvent_): void;
        setDurabilityMultiplier(m: number): void;
        hashCode(): number;
        equals(arg0: any): boolean;
        setSlotProtections(p: number[]): void;
        toString(): string;
        setEnchantmentValue(i: number): void;
        getEnchantmentValue(): number;
        getEquipSound(): Internal.SoundEvent;
        getVanillaRepairIngredient(): Internal.Ingredient;
        setToughness(f: number): void;
        readonly parent : Internal.ArmorMaterial;
        get equipSound(): Internal.SoundEvent;
        get vanillaRepairIngredient(): Internal.Ingredient;
        get enchantmentValue(): number;
        get toughness(): number;
        get class(): Internal.Class<any>;
        get knockbackResistance(): number;
        set repairIngredient(in_: Internal.IngredientJS_);
        set equipSound(e: Internal.SoundEvent_);
        set durabilityMultiplier(m: number);
        set slotProtections(p: number[]);
        set enchantmentValue(i: number);
        set name(name: string);
        set toughness(f: number);
        set knockbackResistance(f: number);
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    type MutableArmorTier_ = MutableArmorTier;
    /**
    */
    class EntityType <T> extends Internal.ForgeRegistryEntry<Internal.EntityType<any>> implements Internal.EntityTypeTest<Internal.Entity, T> {
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        hashCode(): number;
        notifyAll(): void;
        equals(arg0: any): boolean;
        getRegistryType(): Internal.Class<Internal.EntityType<any>>;
        getRegistryName(): ResourceLocation;
        setRegistryName(arg0: ResourceLocation_): Internal.EntityType<any>;
        setRegistryName(arg0: string): Internal.EntityType<any>;
        setRegistryName(arg0: string, arg1: string): Internal.EntityType<any>;
        getTags(): Internal.Stream<Internal.TagKey<Internal.EntityType<any>>>;
        toString(): string;
        customClientSpawn(arg0: Internal.PlayMessages$SpawnEntity_, arg1: Internal.Level_): T;
        notify(): void;
        readonly delegate : Internal.IRegistryDelegate<Internal.EntityType<any>>;
        get registryType(): Internal.Class<Internal.EntityType<any>>;
        get registryName(): ResourceLocation;
        get class(): Internal.Class<any>;
        get tags(): Internal.Stream<Internal.TagKey<Internal.EntityType<any>>>;
        set registryName(arg0: ResourceLocation_);
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    /**
    */
    type EntityType_<T> = string | EntityType<T>;
    interface Watchable {
        register(arg0: Internal.WatchService_, arg1: Internal.WatchEvent$Kind_<any>[], arg2: any_[]): Internal.WatchKey;
        register(arg0: Internal.WatchService_, arg1: Internal.WatchEvent$Kind_<any>[]): Internal.WatchKey;
    }
    type Watchable_ = Watchable;
    class EnumGetMethod extends Internal.Enum<Internal.EnumGetMethod> {
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        isCaseSensitive(): boolean;
        isOrdinalOk(): boolean;
        static valueOf(arg0: string): Internal.EnumGetMethod;
        static valueOf<T_>(arg0: Internal.Class_<T_>, arg1: string): T_;
        notifyAll(): void;
        static values(): Internal.EnumGetMethod[];
        compareTo(arg0: Internal.EnumGetMethod_): number;
        describeConstable(): Internal.Optional<Internal.Enum$EnumDesc<Internal.EnumGetMethod>>;
        notify(): void;
        getDeclaringClass(): Internal.Class<Internal.EnumGetMethod>;
        hashCode(): number;
        equals(arg0: any): boolean;
        get<T_>(arg0: any, arg1: Internal.Class_<T_>): T_;
        name(): string;
        toString(): string;
        ordinal(): number;
        validate<T_>(arg0: any, arg1: Internal.Class_<T_>): boolean;
        static readonly NAME_IGNORECASE : Internal.EnumGetMethod;
        static readonly ORDINAL_OR_NAME : Internal.EnumGetMethod;
        static readonly ORDINAL_OR_NAME_IGNORECASE : Internal.EnumGetMethod;
        static readonly NAME : Internal.EnumGetMethod;
        get ordinalOk(): boolean;
        get caseSensitive(): boolean;
        get class(): Internal.Class<any>;
        get declaringClass(): Internal.Class<Internal.EnumGetMethod>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    type EnumGetMethod_ = "name_ignorecase" | "name" | "ordinal_or_name" | "ordinal_or_name_ignorecase" | EnumGetMethod;
    interface Function14 <T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, R> {
        curry12(): Internal.Function12<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, Internal.BiFunction<T13, T14, R>>;
        curry9(): Internal.Function9<T1, T2, T3, T4, T5, T6, T7, T8, T9, Internal.Function5<T10, T11, T12, T13, T14, R>>;
        curry13(): Internal.Function13<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, java_.util.function_.Function<T14, R>>;
        apply(arg0: T1, arg1: T2, arg2: T3, arg3: T4, arg4: T5, arg5: T6, arg6: T7, arg7: T8, arg8: T9, arg9: T10, arg10: T11, arg11: T12, arg12: T13, arg13: T14): R;
        curry7(): Internal.Function7<T1, T2, T3, T4, T5, T6, T7, Internal.Function7<T8, T9, T10, T11, T12, T13, T14, R>>;
        curry8(): Internal.Function8<T1, T2, T3, T4, T5, T6, T7, T8, Internal.Function6<T9, T10, T11, T12, T13, T14, R>>;
        curry10(): Internal.Function10<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, Internal.Function4<T11, T12, T13, T14, R>>;
        curry11(): Internal.Function11<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, Internal.Function3<T12, T13, T14, R>>;
        curry(): java_.util.function_.Function<T1, Internal.Function13<T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, R>>;
        curry5(): Internal.Function5<T1, T2, T3, T4, T5, Internal.Function9<T6, T7, T8, T9, T10, T11, T12, T13, T14, R>>;
        curry6(): Internal.Function6<T1, T2, T3, T4, T5, T6, Internal.Function8<T7, T8, T9, T10, T11, T12, T13, T14, R>>;
        curry3(): Internal.Function3<T1, T2, T3, Internal.Function11<T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, R>>;
        curry4(): Internal.Function4<T1, T2, T3, T4, Internal.Function10<T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, R>>;
        curry2(): Internal.BiFunction<T1, T2, Internal.Function12<T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, R>>;
    }
    type Function14_<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, R> = Function14<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, R>;
    class StonecuttingRecipeJS extends Internal.RecipeJS {
        parseResultItemList(o: any): Internal.List<Internal.ItemStackJS>;
        getClass(): Internal.Class<any>;
        ingredientAction(filter: Internal.IngredientActionFilter_, action: Internal.IngredientAction_): Internal.RecipeJS;
        convertReplacedInput(index: number, oldIngredient: Internal.IngredientJS_, newIngredient: Internal.IngredientJS_): Internal.IngredientJS;
        getUniqueId(): string;
        replaceOutput(i: Internal.IngredientJS_, with_: Internal.ItemStackJS_, exact: boolean): boolean;
        replaceOutput(i: Internal.IngredientJS_, with_: Internal.ItemStackJS_, exact: boolean, func: Internal.BiFunction_<Internal.ItemStackJS_, Internal.ItemStackJS_, Internal.ItemStackJS_>): boolean;
        parseIngredientItemList(o: any): Internal.List<Internal.IngredientJS>;
        merge(data: any): Internal.RecipeJS;
        getPath(): string;
        create(args: Internal.ListJS_): void;
        parseIngredientItemStackList(o: any): Internal.List<Internal.IngredientStackJS>;
        id(_id: ResourceLocation_): Internal.RecipeJS;
        parseIngredientItem(o: any, key: string): Internal.IngredientJS;
        parseIngredientItem(o: any): Internal.IngredientJS;
        group(g: string): Internal.RecipeJS;
        getOriginalRecipeResult(): Internal.ItemStackJS;
        getOriginalRecipeIngredients(): Internal.List<Internal.IngredientJS>;
        getInputIndex(ingredient: Internal.IngredientJS_, exact: boolean): number;
        setGroup(g: string): void;
        serialize(): void;
        replaceInput(i: Internal.IngredientJS_, with_: Internal.IngredientJS_, exact: boolean, func: Internal.BiFunction_<Internal.IngredientJS_, Internal.IngredientJS_, Internal.IngredientJS_>): boolean;
        replaceInput(i: Internal.IngredientJS_, with_: Internal.IngredientJS_, exact: boolean): boolean;
        getType(): string;
        getGroup(): string;
        hasOutput(ingredient: Internal.IngredientJS_, exact: boolean): boolean;
        keepIngredient(filter: Internal.IngredientActionFilter_): Internal.RecipeJS;
        customIngredientAction(filter: Internal.IngredientActionFilter_, id: string): Internal.RecipeJS;
        modifyResult(callback: Internal.ModifyRecipeResultCallback_): Internal.RecipeJS;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        getMod(): string;
        notifyAll(): void;
        convertReplacedOutput(index: number, oldStack: Internal.ItemStackJS_, newStack: Internal.ItemStackJS_): Internal.ItemStackJS;
        save(): void;
        damageIngredient(filter: Internal.IngredientActionFilter_): Internal.RecipeJS;
        damageIngredient(filter: Internal.IngredientActionFilter_, damage: number): Internal.RecipeJS;
        getId(): string;
        dontAdd(): void;
        notify(): void;
        serializeJson(): void;
        createRecipe(): Internal.Recipe<any>;
        getFromToString(): string;
        hashCode(): number;
        deserializeJson(): void;
        getOrCreateId(): ResourceLocation;
        deserialize(): void;
        serializeNBTAsJson(): boolean;
        getOutputIndex(ingredient: Internal.IngredientJS_, exact: boolean): number;
        serializeIngredientStack(in_: Internal.IngredientStackJS_): Internal.JsonElement;
        resultFromRecipeJson(json: Internal.JsonObject_): Internal.ItemStackJS;
        stage(s: string): Internal.RecipeJS;
        equals(arg0: any): boolean;
        serializeItemStack(stack: Internal.ItemStackJS_): Internal.JsonElement;
        toString(): string;
        hasInput(ingredient: Internal.IngredientJS_, exact: boolean): boolean;
        parseResultItem(o: any): Internal.ItemStackJS;
        replaceIngredient(filter: Internal.IngredientActionFilter_, item: Internal.ItemStackJS_): Internal.RecipeJS;
        static currentRecipe : Internal.RecipeJS;
        originalJson : Internal.JsonObject;
        serializeOutputs : boolean;
        originalRecipe : Internal.Recipe<any>;
        readonly inputItems : Internal.List<((arg0: Internal.ItemStackJS) => boolean)>;
        static itemErrors : false;
        json : Internal.JsonObject;
        readonly outputItems : Internal.List<Internal.ItemStackJS>;
        type : Internal.RecipeTypeJS;
        serializeInputs : boolean;
        get path(): string;
        get originalRecipeIngredients(): Internal.List<Internal.IngredientJS>;
        get mod(): string;
        get originalRecipeResult(): Internal.ItemStackJS;
        get orCreateId(): ResourceLocation;
        get class(): Internal.Class<any>;
        get fromToString(): string;
        get uniqueId(): string;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    type StonecuttingRecipeJS_ = StonecuttingRecipeJS;
    interface Int2ShortFunction extends Internal.Function<number, number>, Internal.IntUnaryOperator {
        getOrDefault(arg0: any, arg1: number): number;
        getOrDefault(arg0: number, arg1: number): number;
        andThenShort(arg0: Internal.Short2ShortFunction_): Internal.Int2ShortFunction;
        composeByte(arg0: Internal.Byte2IntFunction_): Internal.Byte2ShortFunction;
        andThenInt(arg0: Internal.Short2IntFunction_): Internal.Int2IntFunction;
        composeReference<T_>(arg0: Internal.Reference2IntFunction_<T_>): Internal.Reference2ShortFunction<T_>;
        andThen<T_>(arg0: java_.util.function_.Function_<number, T_>): java_.util.function_.Function<number, T_>;
        andThen(arg0: Internal.IntUnaryOperator_): Internal.IntUnaryOperator;
        put(arg0: number, arg1: number): number;
        remove(arg0: number): number;
        remove(arg0: any): number;
        defaultReturnValue(): number;
        defaultReturnValue(arg0: number): void;
        andThenDouble(arg0: Internal.Short2DoubleFunction_): Internal.Int2DoubleFunction;
        andThenObject<T_>(arg0: Internal.Short2ObjectFunction_<T_>): Internal.Int2ObjectFunction<T_>;
        get(arg0: any): number;
        get(arg0: number): number;
        andThenLong(arg0: Internal.Short2LongFunction_): Internal.Int2LongFunction;
        composeLong(arg0: Internal.Long2IntFunction_): Internal.Long2ShortFunction;
        andThenByte(arg0: Internal.Short2ByteFunction_): Internal.Int2ByteFunction;
        andThenFloat(arg0: Internal.Short2FloatFunction_): Internal.Int2FloatFunction;
        applyAsInt(arg0: number): number;
        apply(arg0: number): number;
        containsKey(arg0: any): boolean;
        containsKey(arg0: number): boolean;
        composeInt(arg0: Internal.Int2IntFunction_): Internal.Int2ShortFunction;
        clear(): void;
        composeFloat(arg0: Internal.Float2IntFunction_): Internal.Float2ShortFunction;
        andThenChar(arg0: Internal.Short2CharFunction_): Internal.Int2CharFunction;
        composeObject<T_>(arg0: Internal.Object2IntFunction_<T_>): Internal.Object2ShortFunction<T_>;
        size(): number;
        compose<T_>(arg0: java_.util.function_.Function_<T_, number>): java_.util.function_.Function<T_, number>;
        compose(arg0: Internal.IntUnaryOperator_): Internal.IntUnaryOperator;
        composeShort(arg0: Internal.Short2IntFunction_): Internal.Short2ShortFunction;
        andThenReference<T_>(arg0: Internal.Short2ReferenceFunction_<T_>): Internal.Int2ReferenceFunction<T_>;
        composeChar(arg0: Internal.Char2IntFunction_): Internal.Char2ShortFunction;
        composeDouble(arg0: Internal.Double2IntFunction_): Internal.Double2ShortFunction;
    }
    type Int2ShortFunction_ = ((arg0: number) => number) | Int2ShortFunction;
    interface App <F, A> {
    }
    type App_<F, A> = App<F, A>;
    class BaseFunction extends Internal.IdScriptableObject implements dev.latvian.mods.rhino.Function {
        getClass(): Internal.Class<any>;
        isSealed(): boolean;
        setParentScope(m: Internal.Scriptable_): void;
        static redefineProperty(obj: Internal.Scriptable_, name: string, isConst: boolean): void;
        putConst(name: string, start: Internal.Scriptable_, value: any): void;
        static getTypedProperty<T_>(s: Internal.Scriptable_, name: string, type: Internal.Class_<T_>): T_;
        static getTypedProperty<T_>(s: Internal.Scriptable_, index: number, type: Internal.Class_<T_>): T_;
        getIds(): any[];
        static getArrayPrototype(scope: Internal.Scriptable_): Internal.Scriptable;
        construct(cx: Internal.Context_, scope: Internal.Scriptable_, args: any[]): Internal.Scriptable;
        getAllIds(): any[];
        put(key: Internal.Symbol_, start: Internal.Scriptable_, value: any): void;
        put(name: string, start: Internal.Scriptable_, value: any): void;
        put(index: number, start: Internal.Scriptable_, value: any): void;
        getArity(): number;
        static getDefaultValue(object: Internal.Scriptable_, typeHint: Internal.Class_<any>): any;
        getDefaultValue(typeHint: Internal.Class_<any>): any;
        defineOwnProperties(cx: Internal.Context_, props: Internal.ScriptableObject_): void;
        defineProperty(key: Internal.Symbol_, value: any, attributes: number): void;
        defineProperty(propertyName: string, clazz: Internal.Class_<any>, attributes: number): void;
        defineProperty(propertyName: string, delegateTo: any, getter: Internal.Method_, setter: Internal.Method_, attributes: number): void;
        defineProperty(propertyName: string, value: any, attributes: number): void;
        static defineProperty(destination: Internal.Scriptable_, propertyName: string, value: any, attributes: number): void;
        hasPrototypeMap(): boolean;
        setGetterOrSetter(name: string, index: number, getterOrSetter: Internal.Callable_, isSetter: boolean): void;
        avoidObjectDetection(): boolean;
        has(key: Internal.Symbol_, start: Internal.Scriptable_): boolean;
        has(name: string, start: Internal.Scriptable_): boolean;
        has(index: number, start: Internal.Scriptable_): boolean;
        getFunctionName(): string;
        getExternalArrayLength(): any;
        getAttributes(name: string): number;
        getAttributes(key: Internal.Symbol_): number;
        getAttributes(index: number): number;
        setImmunePrototypeProperty(value: any): void;
        hasInstance(instance: Internal.Scriptable_): boolean;
        getAssociatedValue(key: any): any;
        execIdCall(f: Internal.IdFunctionObject_, cx: Internal.Context_, scope: Internal.Scriptable_, thisObj: Internal.Scriptable_, args: any[]): any;
        static getPropertyIds(obj: Internal.Scriptable_): any[];
        static hasProperty(obj: Internal.Scriptable_, name: string): boolean;
        static hasProperty(obj: Internal.Scriptable_, key: Internal.Symbol_): boolean;
        static hasProperty(obj: Internal.Scriptable_, index: number): boolean;
        getExternalArrayData(): Internal.ExternalArrayData;
        size(): number;
        initPrototypeMethod(tag: any, id: number, propertyName: string, functionName: string, arity: number): Internal.IdFunctionObject;
        initPrototypeMethod(tag: any, id: number, key: Internal.Symbol_, functionName: string, arity: number): Internal.IdFunctionObject;
        initPrototypeMethod(tag: any, id: number, name: string, arity: number): Internal.IdFunctionObject;
        defineOwnProperty(cx: Internal.Context_, key: any, desc: Internal.ScriptableObject_): void;
        initPrototypeValue(id: number, name: string, value: any, attributes: number): void;
        initPrototypeValue(id: number, key: Internal.Symbol_, value: any, attributes: number): void;
        static getFunctionPrototype(scope: Internal.Scriptable_): Internal.Scriptable;
        getClassName(): string;
        getParentScope(): Internal.Scriptable;
        preventExtensions(): void;
        setExternalArrayData(array: Internal.ExternalArrayData_): void;
        static callMethod(cx: Internal.Context_, obj: Internal.Scriptable_, methodName: string, args: any[]): any;
        static callMethod(obj: Internal.Scriptable_, methodName: string, args: any[]): any;
        enumerationIteratorNext(cx: Internal.Context_, currentId: Internal.Consumer_<any>): boolean;
        getTypeOf(): string;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        static getTopScopeValue(scope: Internal.Scriptable_, key: any): any;
        initPrototypeConstructor(f: Internal.IdFunctionObject_): void;
        notifyAll(): void;
        sealObject(): void;
        setAttributes(name: string, attributes: number): void;
        setAttributes(key: Internal.Symbol_, attributes: number): void;
        setAttributes(index: number, attributes: number): void;
        static putProperty(obj: Internal.Scriptable_, name: string, value: any): void;
        static putProperty(obj: Internal.Scriptable_, index: number, value: any): void;
        static putProperty(obj: Internal.Scriptable_, key: Internal.Symbol_, value: any): void;
        delete(key: Internal.Symbol_): void;
        delete(name: string): void;
        delete(index: number): void;
        notify(): void;
        associateValue(key: any, value: any): any;
        static deleteProperty(obj: Internal.Scriptable_, name: string): boolean;
        static deleteProperty(obj: Internal.Scriptable_, index: number): boolean;
        getPrototype(): Internal.Scriptable;
        static getObjectPrototype(scope: Internal.Scriptable_): Internal.Scriptable;
        isExtensible(): boolean;
        hashCode(): number;
        isConst(name: string): boolean;
        get(name: string, start: Internal.Scriptable_): any;
        get(key: Internal.Symbol_, start: Internal.Scriptable_): any;
        get(index: number, start: Internal.Scriptable_): any;
        get(key: any): any;
        static putConstProperty(obj: Internal.Scriptable_, name: string, value: any): void;
        getGetterOrSetter(name: string, index: number, isSetter: boolean): any;
        static getTopLevelScope(obj: Internal.Scriptable_): Internal.Scriptable;
        static getProperty(obj: Internal.Scriptable_, name: string): any;
        static getProperty(obj: Internal.Scriptable_, key: Internal.Symbol_): any;
        static getProperty(obj: Internal.Scriptable_, index: number): any;
        static defineClass<T_>(scope: Internal.Scriptable_, clazz: Internal.Class_<T_>, sealed: boolean): void;
        static defineClass<T_>(scope: Internal.Scriptable_, clazz: Internal.Class_<T_>): void;
        static defineClass<T_>(scope: Internal.Scriptable_, clazz: Internal.Class_<T_>, sealed: boolean, mapInheritance: boolean): string;
        activatePrototypeMap(maxPrototypeId: number): void;
        isEmpty(): boolean;
        defineFunctionProperties(names: string[], clazz: Internal.Class_<any>, attributes: number): void;
        static getClassPrototype(scope: Internal.Scriptable_, className: string): Internal.Scriptable;
        createObject(cx: Internal.Context_, scope: Internal.Scriptable_): Internal.Scriptable;
        setPrototype(m: Internal.Scriptable_): void;
        exportAsJSClass(maxPrototypeId: number, scope: Internal.Scriptable_, sealed: boolean): Internal.IdFunctionObject;
        call(cx: Internal.Context_, scope: Internal.Scriptable_, thisObj: Internal.Scriptable_, args: any[]): any;
        defineConst(name: string, start: Internal.Scriptable_): void;
        equals(arg0: any): boolean;
        static defineConstProperty(destination: Internal.Scriptable_, propertyName: string): void;
        getLength(): number;
        toString(): string;
        enumerationIteratorHasNext(cx: Internal.Context_, currentId: Internal.Consumer_<any>): boolean;
        static getGeneratorFunctionPrototype(scope: Internal.Scriptable_): Internal.Scriptable;
        static readonly DONTENUM : 2;
        static readonly CONST : 13;
        static readonly NOT_FOUND : any;
        static readonly UNINITIALIZED_CONST : 8;
        static readonly EMPTY : 0;
        static readonly READONLY : 1;
        static readonly PERMANENT : 4;
        get functionName(): string;
        get sealed(): boolean;
        get externalArrayData(): Internal.ExternalArrayData;
        get length(): number;
        get className(): string;
        get prototype(): Internal.Scriptable;
        get empty(): boolean;
        get arity(): number;
        get parentScope(): Internal.Scriptable;
        get ids(): any[];
        get externalArrayLength(): any;
        get class(): Internal.Class<any>;
        get allIds(): any[];
        get extensible(): boolean;
        get typeOf(): string;
        set immunePrototypeProperty(value: any);
        set externalArrayData(array: Internal.ExternalArrayData_);
        set parentScope(m: Internal.Scriptable_);
        set prototype(m: Internal.Scriptable_);
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    type BaseFunction_ = BaseFunction;
    abstract class BlockEntity extends Internal.CapabilityProvider<Internal.BlockEntity> implements Internal.IForgeBlockEntity {
        requestModelDataUpdate(): void;
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        getCapability<T_>(arg0: Internal.Capability_<T_>, arg1: Internal.Direction_): Internal.LazyOptional<T_>;
        getCapability<T_>(arg0: Internal.Capability_<T_>): Internal.LazyOptional<T_>;
        getTileData(): Internal.CompoundTag;
        notifyAll(): void;
        areCapsCompatible(arg0: Internal.CapabilityProvider_<Internal.BlockEntity_>): boolean;
        areCapsCompatible(arg0: Internal.CapabilityDispatcher_): boolean;
        deserializeNBT(arg0: Internal.CompoundTag_): void;
        notify(): void;
        reviveCaps(): void;
        getModelData(): Internal.IModelData;
        serializeNBT(): Internal.CompoundTag;
        invalidateCaps(): void;
        getRenderBoundingBox(): Internal.AABB;
        hashCode(): number;
        onChunkUnloaded(): void;
        equals(arg0: any): boolean;
        onDataPacket(arg0: Internal.Connection_, arg1: Internal.ClientboundBlockEntityDataPacket_): void;
        onLoad(): void;
        toString(): string;
        handleUpdateTag(arg0: Internal.CompoundTag_): void;
        static readonly INFINITE_EXTENT_AABB : Internal.AABB;
        get modelData(): Internal.IModelData;
        get renderBoundingBox(): Internal.AABB;
        get tileData(): Internal.CompoundTag;
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    type BlockEntity_ = BlockEntity;
    interface Spliterator$OfPrimitive <T, T_CONS, T_SPLITR> extends Internal.Spliterator<T> {
        trySplit(): T_SPLITR;
        characteristics(): number;
        tryAdvance(arg0: T_CONS): boolean;
        tryAdvance(arg0: Internal.Consumer_<T>): boolean;
        getComparator(): Internal.Comparator<T>;
        getExactSizeIfKnown(): number;
        estimateSize(): number;
        hasCharacteristics(arg0: number): boolean;
        forEachRemaining(arg0: T_CONS): void;
        forEachRemaining(arg0: Internal.Consumer_<T>): void;
    }
    type Spliterator$OfPrimitive_<T, T_CONS, T_SPLITR> = Spliterator$OfPrimitive<T, T_CONS, T_SPLITR>;
    interface RecipeManagerMixin {
        mbd_byType<C, T>(arg0: Internal.RecipeType_<T>): Internal.Map<ResourceLocation, Internal.Recipe<C>>;
    }
    type RecipeManagerMixin_ = RecipeManagerMixin;
    class KeyCompressor <T> {
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        decompress(arg0: number): T;
        size(): number;
        compress(arg0: T): number;
        compress(arg0: string): number;
        hashCode(): number;
        notifyAll(): void;
        equals(arg0: any): boolean;
        toString(): string;
        notify(): void;
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    type KeyCompressor_<T> = KeyCompressor<T>;
    interface LevelSimulatedRW extends Internal.LevelSimulatedReader, Internal.LevelWriter {
    }
    type LevelSimulatedRW_ = LevelSimulatedRW;
    interface JsonReloadListenerAccess {
        byg_getGson(): Internal.Gson;
    }
    type JsonReloadListenerAccess_ = JsonReloadListenerAccess;
    class Minecraft extends Internal.ReentrantBlockableEventLoop<Internal.Runnable> implements Internal.WindowEventHandler, Internal.IForgeMinecraft, Internal.AccessorMinecraft, vazkii.botania.mixin.client.AccessorMinecraft {
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        getSearchTreeManager(): Internal.SearchRegistry;
        hashCode(): number;
        notifyAll(): void;
        equals(arg0: any): boolean;
        popGuiLayer(): void;
        toString(): string;
        execute(arg0: Internal.Runnable_): void;
        close(): void;
        notify(): void;
        pushGuiLayer(arg0: Internal.Screen_): void;
        get searchTreeManager(): Internal.SearchRegistry;
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    type Minecraft_ = Minecraft;
    abstract class MapCodec <A> extends Internal.CompressorHolder implements Internal.MapDecoder<A>, Internal.MapEncoder<A> {
        encode<T_>(arg0: A, arg1: Internal.DynamicOps_<T_>, arg2: Internal.RecordBuilder_<T_>): Internal.RecordBuilder<T_>;
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        setPartial(arg0: Internal.Supplier_<A>): Internal.MapCodec<A>;
        keys<T_>(arg0: Internal.DynamicOps_<T_>): Internal.Stream<T_>;
        notifyAll(): void;
        deprecated(arg0: number): Internal.MapCodec<A>;
        decode<T_>(arg0: Internal.DynamicOps_<T_>, arg1: Internal.MapLike_<T_>): Internal.DataResult<A>;
        notify(): void;
        hashCode(): number;
        flatXmap<S_>(arg0: java_.util.function_.Function_<A, Internal.DataResult_<S_>>, arg1: java_.util.function_.Function_<S_, Internal.DataResult_<A>>): Internal.MapCodec<S_>;
        comap<B_>(arg0: java_.util.function_.Function_<B_, A>): Internal.MapEncoder<B_>;
        static of<A_>(arg0: Internal.MapEncoder_<A_>, arg1: Internal.MapDecoder_<A_>, arg2: Internal.Supplier_<string>): Internal.MapCodec<A_>;
        static of<A_>(arg0: Internal.MapEncoder_<A_>, arg1: Internal.MapDecoder_<A_>): Internal.MapCodec<A_>;
        fieldOf(arg0: string): Internal.MapCodec<A>;
        xmap<S_>(arg0: java_.util.function_.Function_<A, S_>, arg1: java_.util.function_.Function_<S_, A>): Internal.MapCodec<S_>;
        map<B_>(arg0: java_.util.function_.Function_<A, B_>): Internal.MapDecoder<B_>;
        dependent<E_>(arg0: Internal.MapCodec_<E_>, arg1: java_.util.function_.Function_<A, Internal.Pair_<E_, Internal.MapCodec_<E_>>>, arg2: Internal.BiFunction_<A, E_, A>): Internal.MapCodec<A>;
        flatComap<B_>(arg0: java_.util.function_.Function_<B_, Internal.DataResult_<A>>): Internal.MapEncoder<B_>;
        compressedDecode<T_>(arg0: Internal.DynamicOps_<T_>, arg1: T_): Internal.DataResult<A>;
        compressedBuilder<T_>(arg0: Internal.DynamicOps_<T_>): Internal.RecordBuilder<T_>;
        decoder(): Internal.Decoder<A>;
        withLifecycle(arg0: Internal.Lifecycle_): Internal.MapCodec<A>;
        encoder(): Internal.Encoder<A>;
        orElse(arg0: A): Internal.MapCodec<A>;
        orElse(arg0: Internal.Consumer_<string>, arg1: A): Internal.MapCodec<A>;
        orElse(arg0: Internal.UnaryOperator_<string>, arg1: A): Internal.MapCodec<A>;
        forGetter<O_>(arg0: java_.util.function_.Function_<O_, A>): Internal.RecordCodecBuilder<O_, A>;
        ap<E_>(arg0: Internal.MapDecoder_<java_.util.function_.Function_<A, E_>>): Internal.MapDecoder<E_>;
        flatMap<B_>(arg0: java_.util.function_.Function_<A, Internal.DataResult_<B_>>): Internal.MapDecoder<B_>;
        codec(): Internal.Codec<A>;
        static unit<A_>(arg0: Internal.Supplier_<A_>): Internal.MapCodec<A_>;
        static unit<A_>(arg0: A_): Internal.MapCodec<A_>;
        orElseGet(arg0: Internal.UnaryOperator_<string>, arg1: Internal.Supplier_<A>): Internal.MapCodec<A>;
        orElseGet(arg0: Internal.Consumer_<string>, arg1: Internal.Supplier_<A>): Internal.MapCodec<A>;
        orElseGet(arg0: Internal.Supplier_<A>): Internal.MapCodec<A>;
        stable(): Internal.MapCodec<A>;
        equals(arg0: any): boolean;
        mapResult(arg0: Internal.MapCodec$ResultFunction_<A>): Internal.MapCodec<A>;
        toString(): string;
        compressor<T_>(arg0: Internal.DynamicOps_<T_>): Internal.KeyCompressor<T_>;
        get class(): Internal.Class<any>;
        set partial(arg0: Internal.Supplier_<A>);
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    type MapCodec_<A> = MapCodec<A>;
    interface ChunkAccessAccess {
        byg_getLevelHeightAccessor(): Internal.LevelHeightAccessor;
        byg_getNoiseChunk(): Internal.NoiseChunk;
    }
    type ChunkAccessAccess_ = ChunkAccessAccess;
    class SodiumWorldRenderer {
        static instanceNullable(): Internal.SodiumWorldRenderer;
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        static instance(): Internal.SodiumWorldRenderer;
        isEntityVisible(entity: Internal.Entity_): boolean;
        doesChunkHaveFlag(x: number, z: number, status: number): boolean;
        notifyAll(): void;
        isTerrainRenderComplete(): boolean;
        notify(): void;
        onChunkAdded(x: number, z: number): void;
        reload(): void;
        hashCode(): number;
        onChunkRenderUpdated(x: number, y: number, z: number, meshBefore: Internal.ChunkRenderData_, meshAfter: Internal.ChunkRenderData_): void;
        iris$restoreStateIfShadowsWereBeingRendered(): void;
        renderTileEntities(matrices: Internal.PoseStack_, bufferBuilders: Internal.RenderBuffers_, blockBreakingProgressions: Internal.Long2ObjectMap_<Internal.SortedSet_<Internal.BlockDestructionProgress_>>, camera: Internal.Camera_, tickDelta: number): void;
        scheduleRebuildForChunks(minX: number, minY: number, minZ: number, maxX: number, maxY: number, maxZ: number, important: boolean): void;
        drawChunkLayer(renderLayer: Internal.RenderType_, matrixStack: Internal.PoseStack_, x: number, y: number, z: number): void;
        scheduleTerrainUpdate(): void;
        getMemoryDebugStrings(): Internal.Collection<string>;
        onChunkLightAdded(x: number, z: number): void;
        scheduleRebuildForBlockArea(minX: number, minY: number, minZ: number, maxX: number, maxY: number, maxZ: number, important: boolean): void;
        scheduleRebuildForChunk(x: number, y: number, z: number, important: boolean): void;
        updateChunks(camera: Internal.Camera_, frustum: Internal.Frustum_, frame: number, spectator: boolean): void;
        onChunkRemoved(x: number, z: number): void;
        getChunksDebugString(): string;
        equals(arg0: any): boolean;
        getVisibleChunkCount(): number;
        toString(): string;
        isBoxVisible(x1: number, y1: number, z1: number, x2: number, y2: number, z2: number): boolean;
        getChunkTracker(): Internal.ChunkTracker;
        setWorld(world: Internal.ClientLevel_): void;
        get chunkTracker(): Internal.ChunkTracker;
        get visibleChunkCount(): number;
        get terrainRenderComplete(): boolean;
        get chunksDebugString(): string;
        get memoryDebugStrings(): Internal.Collection<string>;
        get class(): Internal.Class<any>;
        set world(world: Internal.ClientLevel_);
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    type SodiumWorldRenderer_ = SodiumWorldRenderer;
    interface MatchResult {
        groupCount(): number;
        start(arg0: number): number;
        start(): number;
        end(arg0: number): number;
        end(): number;
        group(): string;
        group(arg0: number): string;
    }
    type MatchResult_ = MatchResult;
    interface IChunkTimeSave {
        getNextSaveTime(): number;
        setSaveTimePoint(arg0: number): void;
    }
    type IChunkTimeSave_ = IChunkTimeSave;
    interface Object2ByteFunction <K> extends Internal.Function<K, number>, Internal.ToIntFunction<K> {
        getOrDefault(arg0: any, arg1: number): number;
        getByte(arg0: any): number;
        andThenShort(arg0: Internal.Byte2ShortFunction_): Internal.Object2ShortFunction<K>;
        composeByte(arg0: Internal.Byte2ObjectFunction_<K>): Internal.Byte2ByteFunction;
        andThenInt(arg0: Internal.Byte2IntFunction_): Internal.Object2IntFunction<K>;
        composeReference<T_>(arg0: Internal.Reference2ObjectFunction_<T_, K>): Internal.Reference2ByteFunction<T_>;
        andThen<T_>(arg0: java_.util.function_.Function_<number, T_>): java_.util.function_.Function<K, T_>;
        put(arg0: K, arg1: number): number;
        remove(arg0: any): number;
        defaultReturnValue(): number;
        defaultReturnValue(arg0: number): void;
        andThenDouble(arg0: Internal.Byte2DoubleFunction_): Internal.Object2DoubleFunction<K>;
        andThenObject<T_>(arg0: Internal.Byte2ObjectFunction_<T_>): Internal.Object2ObjectFunction<K, T_>;
        get(arg0: any): number;
        andThenLong(arg0: Internal.Byte2LongFunction_): Internal.Object2LongFunction<K>;
        composeLong(arg0: Internal.Long2ObjectFunction_<K>): Internal.Long2ByteFunction;
        removeByte(arg0: any): number;
        andThenByte(arg0: Internal.Byte2ByteFunction_): Internal.Object2ByteFunction<K>;
        andThenFloat(arg0: Internal.Byte2FloatFunction_): Internal.Object2FloatFunction<K>;
        applyAsInt(arg0: K): number;
        apply(arg0: K): number;
        containsKey(arg0: any): boolean;
        composeInt(arg0: Internal.Int2ObjectFunction_<K>): Internal.Int2ByteFunction;
        clear(): void;
        composeFloat(arg0: Internal.Float2ObjectFunction_<K>): Internal.Float2ByteFunction;
        andThenChar(arg0: Internal.Byte2CharFunction_): Internal.Object2CharFunction<K>;
        composeObject<T_>(arg0: Internal.Object2ObjectFunction_<T_, K>): Internal.Object2ByteFunction<T_>;
        size(): number;
        compose<V_>(arg0: java_.util.function_.Function_<V_, K>): java_.util.function_.Function<V_, number>;
        composeShort(arg0: Internal.Short2ObjectFunction_<K>): Internal.Short2ByteFunction;
        andThenReference<T_>(arg0: Internal.Byte2ReferenceFunction_<T_>): Internal.Object2ReferenceFunction<K, T_>;
        composeChar(arg0: Internal.Char2ObjectFunction_<K>): Internal.Char2ByteFunction;
        composeDouble(arg0: Internal.Double2ObjectFunction_<K>): Internal.Double2ByteFunction;
    }
    type Object2ByteFunction_<K> = ((arg0: any) => number) | Object2ByteFunction<K>;
    interface DoubleIterator extends Internal.PrimitiveIterator$OfDouble {
        next(): number;
        hasNext(): boolean;
        skip(arg0: number): number;
        forEachRemaining(arg0: Internal.Consumer_<number>): void;
        forEachRemaining(arg0: Internal.DoubleConsumer_): void;
        forEachRemaining(arg0: java_.util.function_.DoubleConsumer_): void;
        remove(): void;
        nextDouble(): number;
    }
    type DoubleIterator_ = DoubleIterator;
    class EventsJS$ScriptEventHandler {
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        hashCode(): number;
        notifyAll(): void;
        equals(arg0: any): boolean;
        toString(): string;
        notify(): void;
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    type EventsJS$ScriptEventHandler_ = EventsJS$ScriptEventHandler;
    /**
    */
    interface Component extends Internal.Message, Internal.FormattedText {
        getString(): string;
    }
    /**
    */
    type Component_ = Internal.Text_ | Component;
    interface WorldGenLevel extends Internal.ServerLevelAccessor {
        getExistingBlockEntity(arg0: BlockPos_): Internal.BlockEntity;
        isAreaLoaded(arg0: BlockPos_, arg1: number): boolean;
    }
    type WorldGenLevel_ = WorldGenLevel;
    abstract class Fluid extends Internal.ForgeRegistryEntry<Internal.Fluid> implements Internal.IForgeFluid {
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        getAttributes(): Internal.FluidAttributes;
        getExplosionResistance(arg0: Internal.FluidState_, arg1: Internal.BlockGetter_, arg2: BlockPos_, arg3: Internal.Explosion_): number;
        notifyAll(): void;
        getRegistryName(): ResourceLocation;
        setRegistryName(arg0: ResourceLocation_): Internal.Fluid;
        setRegistryName(arg0: string): Internal.Fluid;
        setRegistryName(arg0: string, arg1: string): Internal.Fluid;
        isEntityInside(arg0: Internal.FluidState_, arg1: Internal.LevelReader_, arg2: BlockPos_, arg3: Internal.Entity_, arg4: number, arg5: Internal.HolderSet_<Internal.Fluid_>, arg6: boolean): boolean;
        isAABBInsideMaterial(arg0: Internal.FluidState_, arg1: Internal.LevelReader_, arg2: BlockPos_, arg3: Internal.AABB_, arg4: Internal.Material_): boolean;
        notify(): void;
        isAABBInsideLiquid(arg0: Internal.FluidState_, arg1: Internal.LevelReader_, arg2: BlockPos_, arg3: Internal.AABB_): boolean;
        hashCode(): number;
        equals(arg0: any): boolean;
        getRegistryType(): Internal.Class<Internal.Fluid>;
        toString(): string;
        readonly delegate : Internal.IRegistryDelegate<Internal.Fluid>;
        get registryType(): Internal.Class<Internal.Fluid>;
        get attributes(): Internal.FluidAttributes;
        get registryName(): ResourceLocation;
        get class(): Internal.Class<any>;
        set registryName(arg0: ResourceLocation_);
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    type Fluid_ = Fluid;
    interface IForgeVertexConsumer {
        applyBakedLighting(arg0: number, arg1: Internal.ByteBuffer_): number;
        putBulkData(arg0: Internal.PoseStack$Pose_, arg1: Internal.BakedQuad_, arg2: number[], arg3: number, arg4: number, arg5: number, arg6: number, arg7: number[], arg8: number, arg9: boolean): void;
        putBulkData(arg0: Internal.PoseStack$Pose_, arg1: Internal.BakedQuad_, arg2: number, arg3: number, arg4: number, arg5: number, arg6: number, arg7: number, arg8: boolean): void;
        putBulkData(arg0: Internal.PoseStack$Pose_, arg1: Internal.BakedQuad_, arg2: number, arg3: number, arg4: number, arg5: number, arg6: number, arg7: number): void;
        putBulkData(arg0: Internal.PoseStack$Pose_, arg1: Internal.BakedQuad_, arg2: number, arg3: number, arg4: number, arg5: number, arg6: number, arg7: boolean): void;
        applyBakedNormals(arg0: Internal.Vector3f_, arg1: Internal.ByteBuffer_, arg2: Internal.Matrix3f_): void;
    }
    type IForgeVertexConsumer_ = IForgeVertexConsumer;
    interface Shader {
    }
    type Shader_ = Shader;
    abstract class BlockBehaviour extends Internal.ForgeRegistryEntry<Internal.Block> implements Internal.BlockAccess, Internal.BlockKJS {
        getBlockStatesKJS(): Internal.List<Internal.BlockState>;
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        notifyAll(): void;
        getRegistryName(): ResourceLocation;
        setRegistryName(arg0: ResourceLocation_): Internal.Block;
        setRegistryName(arg0: string): Internal.Block;
        setRegistryName(arg0: string, arg1: string): Internal.Block;
        notify(): void;
        hashCode(): number;
        getBlockBuilderKJS(): Internal.BlockBuilder;
        equals(arg0: any): boolean;
        getRegistryType(): Internal.Class<Internal.Block>;
        setBlockBuilderKJS(b: Internal.BlockBuilder_): void;
        getTypeData(): Internal.CompoundTag;
        toString(): string;
        readonly delegate : Internal.IRegistryDelegate<Internal.Block>;
        get registryType(): Internal.Class<Internal.Block>;
        get blockBuilderKJS(): Internal.BlockBuilder;
        get blockStatesKJS(): Internal.List<Internal.BlockState>;
        get registryName(): ResourceLocation;
        get typeData(): Internal.CompoundTag;
        get class(): Internal.Class<any>;
        set blockBuilderKJS(b: Internal.BlockBuilder_);
        set registryName(arg0: ResourceLocation_);
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    type BlockBehaviour_ = BlockBehaviour;
    abstract class Point2D implements Internal.Cloneable {
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        getX(): number;
        getY(): number;
        static distance(arg0: number, arg1: number, arg2: number, arg3: number): number;
        distance(arg0: Internal.Point2D_): number;
        distance(arg0: number, arg1: number): number;
        setLocation(arg0: number, arg1: number): void;
        setLocation(arg0: Internal.Point2D_): void;
        hashCode(): number;
        notifyAll(): void;
        equals(arg0: any): boolean;
        clone(): any;
        toString(): string;
        distanceSq(arg0: number, arg1: number): number;
        distanceSq(arg0: Internal.Point2D_): number;
        static distanceSq(arg0: number, arg1: number, arg2: number, arg3: number): number;
        notify(): void;
        get x(): number;
        get y(): number;
        get class(): Internal.Class<any>;
        set location(arg0: Internal.Point2D_);
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    type Point2D_ = Point2D;
    interface ByteSpliterator extends Internal.Spliterator$OfPrimitive<number, Internal.ByteConsumer, Internal.ByteSpliterator> {
        trySplit(): Internal.ByteSpliterator;
        characteristics(): number;
        tryAdvance(arg0: Internal.Consumer_<number>): boolean;
        tryAdvance(arg0: Internal.ByteConsumer_): boolean;
        getComparator(): Internal.ByteComparator;
        getExactSizeIfKnown(): number;
        estimateSize(): number;
        skip(arg0: number): number;
        hasCharacteristics(arg0: number): boolean;
        forEachRemaining(arg0: Internal.Consumer_<number>): void;
        forEachRemaining(arg0: Internal.ByteConsumer_): void;
    }
    type ByteSpliterator_ = ByteSpliterator;
    interface ByteComparator extends Internal.Comparator<number> {
        compare(arg0: number, arg1: number): number;
        thenComparingLong(arg0: Internal.ToLongFunction_<number>): Internal.Comparator<number>;
        thenComparingInt(arg0: Internal.ToIntFunction_<number>): Internal.Comparator<number>;
        thenComparing(arg0: Internal.Comparator_<number>): Internal.Comparator<number>;
        thenComparing(arg0: Internal.ByteComparator_): Internal.ByteComparator;
        thenComparing<U_>(arg0: java_.util.function_.Function_<number, U_>, arg1: Internal.Comparator_<U_>): Internal.Comparator<number>;
        thenComparing<U_>(arg0: java_.util.function_.Function_<number, U_>): Internal.Comparator<number>;
        thenComparingDouble(arg0: Internal.ToDoubleFunction_<number>): Internal.Comparator<number>;
        equals(arg0: any): boolean;
        reversed(): Internal.ByteComparator;
    }
    type ByteComparator_ = ((arg0: number, arg1: number) => number) | ByteComparator;
    abstract class ClassLoader {
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        getResource(arg0: string): Internal.URL;
        getName(): string;
        notifyAll(): void;
        setDefaultAssertionStatus(arg0: boolean): void;
        setPackageAssertionStatus(arg0: string, arg1: boolean): void;
        notify(): void;
        setClassAssertionStatus(arg0: string, arg1: boolean): void;
        getDefinedPackage(arg0: string): Internal.Package;
        clearAssertionStatus(): void;
        isRegisteredAsParallelCapable(): boolean;
        getResources(arg0: string): Internal.Enumeration<Internal.URL>;
        hashCode(): number;
        getDefinedPackages(): Internal.Package[];
        getUnnamedModule(): Internal.Module;
        static getSystemResources(arg0: string): Internal.Enumeration<Internal.URL>;
        getParent(): Internal.ClassLoader;
        static getPlatformClassLoader(): Internal.ClassLoader;
        getResourceAsStream(arg0: string): Internal.InputStream;
        resources(arg0: string): Internal.Stream<Internal.URL>;
        static getSystemClassLoader(): Internal.ClassLoader;
        static getSystemResource(arg0: string): Internal.URL;
        static getSystemResourceAsStream(arg0: string): Internal.InputStream;
        equals(arg0: any): boolean;
        loadClass(arg0: string): Internal.Class<any>;
        toString(): string;
        get parent(): Internal.ClassLoader;
        get systemClassLoader(): Internal.ClassLoader;
        get unnamedModule(): Internal.Module;
        get name(): string;
        get registeredAsParallelCapable(): boolean;
        get platformClassLoader(): Internal.ClassLoader;
        get definedPackages(): Internal.Package[];
        get class(): Internal.Class<any>;
        set defaultAssertionStatus(arg0: boolean);
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    type ClassLoader_ = ClassLoader;
    interface GenericFutureListener <F> extends Internal.EventListener {
        operationComplete(arg0: F): void;
    }
    type GenericFutureListener_<F> = GenericFutureListener<F>;
    class ForgeConfigSpec$IntValue extends Internal.ForgeConfigSpec$ConfigValue<number> {
        next(): Internal.ForgeConfigSpec$Builder;
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        set(arg0: number): void;
        hashCode(): number;
        notifyAll(): void;
        equals(arg0: any): boolean;
        get(): number;
        getPath(): Internal.List<string>;
        save(): void;
        toString(): string;
        clearCache(): void;
        notify(): void;
        get path(): Internal.List<string>;
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    type ForgeConfigSpec$IntValue_ = ForgeConfigSpec$IntValue;
    abstract class ImmutableCollection <E> extends Internal.AbstractCollection<E> implements Internal.Serializable {
        add(arg0: E): boolean;
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        spliterator(): Internal.Spliterator<E>;
        forEach(arg0: Internal.Consumer_<E>): void;
        notifyAll(): void;
        containsAll(arg0: Internal.Collection_<any>): boolean;
        isEmpty(): boolean;
        clear(): void;
        notify(): void;
        asList(): Internal.ImmutableList<E>;
        remove(arg0: any): boolean;
        removeIf(arg0: Internal.Predicate_<E>): boolean;
        removeAll(arg0: Internal.Collection_<any>): boolean;
        contains(arg0: any): boolean;
        iterator(): Internal.UnmodifiableIterator<E>;
        size(): number;
        stream(): Internal.Stream<E>;
        addAll(arg0: Internal.Collection_<E>): boolean;
        hashCode(): number;
        equals(arg0: any): boolean;
        toArray(): any[];
        toArray<T_>(arg0: T_[]): T_[];
        toArray<T_>(arg0: Internal.IntFunction_<T_[]>): T_[];
        parallelStream(): Internal.Stream<E>;
        toString(): string;
        retainAll(arg0: Internal.Collection_<any>): boolean;
        get class(): Internal.Class<any>;
        get empty(): boolean;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    type ImmutableCollection_<E> = ImmutableCollection<E>;
    interface BinaryOperator <T> extends Internal.BiFunction<T, T, T> {
        apply(arg0: T, arg1: T): T;
        andThen<V_>(arg0: java_.util.function_.Function_<T, V_>): Internal.BiFunction<T, T, V_>;
    }
    type BinaryOperator_<T> = ((arg0: T, arg1: T) => T) | BinaryOperator<T>;
    class PlantType {
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        getName(): string;
        hashCode(): number;
        notifyAll(): void;
        equals(arg0: any): boolean;
        static get(arg0: string): Internal.PlantType;
        toString(): string;
        notify(): void;
        static readonly BEACH : Internal.PlantType;
        static readonly CAVE : Internal.PlantType;
        static readonly NETHER : Internal.PlantType;
        static readonly PLAINS : Internal.PlantType;
        static readonly DESERT : Internal.PlantType;
        static readonly WATER : Internal.PlantType;
        static readonly CROP : Internal.PlantType;
        get name(): string;
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    type PlantType_ = PlantType;
    interface ChronoPeriod extends Internal.TemporalAmount {
        minus(arg0: Internal.TemporalAmount_): Internal.ChronoPeriod;
        isNegative(): boolean;
        negated(): Internal.ChronoPeriod;
        normalized(): Internal.ChronoPeriod;
        plus(arg0: Internal.TemporalAmount_): Internal.ChronoPeriod;
        multipliedBy(arg0: number): Internal.ChronoPeriod;
        subtractFrom(arg0: Internal.Temporal_): Internal.Temporal;
        hashCode(): number;
        equals(arg0: any): boolean;
        get(arg0: Internal.TemporalUnit_): number;
        getUnits(): Internal.List<Internal.TemporalUnit>;
        addTo(arg0: Internal.Temporal_): Internal.Temporal;
        isZero(): boolean;
        toString(): string;
        getChronology(): Internal.Chronology;
    }
    type ChronoPeriod_ = ChronoPeriod;
    /**
    * Fired when the chest loot table is registering.
    */
    class ChestLootEventJS extends Internal.LootEventJS {
        cancel(): void;
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        isCancelled(): boolean;
        addChest(id: ResourceLocation_, b: Internal.Consumer_<Internal.LootBuilder_>): void;
        notifyAll(): void;
        addJson(id: ResourceLocation_, json: Internal.JsonObject_): void;
        notify(): void;
        modify(id: ResourceLocation_, b: Internal.Consumer_<Internal.LootBuilder_>): void;
        removeAll(): void;
        post(t: Internal.ScriptType_, id: string, sub: string): boolean;
        post(t: Internal.ScriptType_, id: string): boolean;
        getType(): string;
        hashCode(): number;
        equals(arg0: any): boolean;
        toString(): string;
        getDirectory(): string;
        canCancel(): boolean;
        get cancelled(): boolean;
        get type(): string;
        get class(): Internal.Class<any>;
        get directory(): string;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    /**
    * Fired when the chest loot table is registering.
    */
    type ChestLootEventJS_ = ChestLootEventJS;
    interface Nameable {
    }
    type Nameable_ = Nameable;
    class ImmutableSetMultimap <K, V> extends Internal.ImmutableMultimap<K, V> implements Internal.SetMultimap<K, V> {
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        asMap(): Internal.ImmutableMap<K, Internal.Collection<V>>;
        keys(): Internal.ImmutableMultiset<K>;
        notifyAll(): void;
        values(): Internal.ImmutableCollection<V>;
        notify(): void;
        containsValue(arg0: any): boolean;
        put(arg0: K, arg1: V): boolean;
        remove(arg0: any, arg1: any): boolean;
        static flatteningToImmutableSetMultimap<T_, K_, V_>(arg0: java_.util.function_.Function_<T_, K_>, arg1: java_.util.function_.Function_<T_, Internal.Stream_<V_>>): Internal.Collector<T_, any, Internal.ImmutableSetMultimap<K_, V_>>;
        removeAll(arg0: any): Internal.ImmutableSet<V>;
        putAll(arg0: K, arg1: Internal.Iterable_<V>): boolean;
        putAll(arg0: Internal.Multimap_<K, V>): boolean;
        static of<K_, V_>(arg0: K_, arg1: V_): Internal.ImmutableSetMultimap<K_, V_>;
        static of<K_, V_>(arg0: K_, arg1: V_): Internal.ImmutableMultimap<K_, V_>;
        static of<K_, V_>(arg0: K_, arg1: V_, arg2: K_, arg3: V_): Internal.ImmutableSetMultimap<K_, V_>;
        static of<K_, V_>(arg0: K_, arg1: V_, arg2: K_, arg3: V_): Internal.ImmutableMultimap<K_, V_>;
        static of<K_, V_>(arg0: K_, arg1: V_, arg2: K_, arg3: V_, arg4: K_, arg5: V_): Internal.ImmutableSetMultimap<K_, V_>;
        static of<K_, V_>(arg0: K_, arg1: V_, arg2: K_, arg3: V_, arg4: K_, arg5: V_): Internal.ImmutableMultimap<K_, V_>;
        static of<K_, V_>(): Internal.ImmutableSetMultimap<K_, V_>;
        static of<K_, V_>(): Internal.ImmutableMultimap<K_, V_>;
        static of<K_, V_>(arg0: K_, arg1: V_, arg2: K_, arg3: V_, arg4: K_, arg5: V_, arg6: K_, arg7: V_, arg8: K_, arg9: V_): Internal.ImmutableSetMultimap<K_, V_>;
        static of<K_, V_>(arg0: K_, arg1: V_, arg2: K_, arg3: V_, arg4: K_, arg5: V_, arg6: K_, arg7: V_, arg8: K_, arg9: V_): Internal.ImmutableMultimap<K_, V_>;
        static of<K_, V_>(arg0: K_, arg1: V_, arg2: K_, arg3: V_, arg4: K_, arg5: V_, arg6: K_, arg7: V_): Internal.ImmutableSetMultimap<K_, V_>;
        static of<K_, V_>(arg0: K_, arg1: V_, arg2: K_, arg3: V_, arg4: K_, arg5: V_, arg6: K_, arg7: V_): Internal.ImmutableMultimap<K_, V_>;
        get(arg0: K): Internal.ImmutableSet<V>;
        static builder<K_, V_>(): Internal.ImmutableSetMultimap$Builder<K_, V_>;
        static builder<K_, V_>(): Internal.ImmutableMultimap$Builder<K_, V_>;
        keySet(): Internal.ImmutableSet<K>;
        inverse(): Internal.ImmutableSetMultimap<V, K>;
        containsKey(arg0: any): boolean;
        forEach(arg0: Internal.BiConsumer_<K, V>): void;
        clear(): void;
        static copyOf<K_, V_>(arg0: Internal.Multimap_<K_, V_>): Internal.ImmutableSetMultimap<K_, V_>;
        static copyOf<K_, V_>(arg0: Internal.Multimap_<K_, V_>): Internal.ImmutableMultimap<K_, V_>;
        static copyOf<K_, V_>(arg0: Internal.Iterable_<Internal.Map$Entry_<K_, V_>>): Internal.ImmutableSetMultimap<K_, V_>;
        static copyOf<K_, V_>(arg0: Internal.Iterable_<Internal.Map$Entry_<K_, V_>>): Internal.ImmutableMultimap<K_, V_>;
        replaceValues(arg0: K, arg1: Internal.Iterable_<V>): Internal.ImmutableSet<V>;
        static toImmutableSetMultimap<T_, K_, V_>(arg0: java_.util.function_.Function_<T_, K_>, arg1: java_.util.function_.Function_<T_, V_>): Internal.Collector<T_, any, Internal.ImmutableSetMultimap<K_, V_>>;
        entries(): Internal.ImmutableSet<Internal.Map$Entry<K, V>>;
        size(): number;
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    type ImmutableSetMultimap_<K, V> = ImmutableSetMultimap<K, V>;
    class DamageSourcePredicateBuilderJS implements Internal.LootItemCondition$Builder {
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        isFire(arg0: boolean): Internal.DamageSourcePredicateBuilderJS;
        anyType(arg0: string[]): Internal.DamageSourcePredicateBuilderJS;
        notifyAll(): void;
        isLightning(arg0: boolean): Internal.DamageSourcePredicateBuilderJS;
        isExplosion(arg0: boolean): Internal.DamageSourcePredicateBuilderJS;
        isProjectile(arg0: boolean): Internal.DamageSourcePredicateBuilderJS;
        notify(): void;
        matchDirectEntity(arg0: Internal.Consumer_<Internal.EntityPredicateBuilderJS_>): Internal.DamageSourcePredicateBuilderJS;
        doesBypassMagic(arg0: boolean): Internal.DamageSourcePredicateBuilderJS;
        doesBypassInvulnerability(arg0: boolean): Internal.DamageSourcePredicateBuilderJS;
        isMagic(arg0: boolean): Internal.DamageSourcePredicateBuilderJS;
        hashCode(): number;
        equals(arg0: any): boolean;
        toString(): string;
        matchSourceEntity(arg0: Internal.Consumer_<Internal.EntityPredicateBuilderJS_>): Internal.DamageSourcePredicateBuilderJS;
        doesBypassArmor(arg0: boolean): Internal.DamageSourcePredicateBuilderJS;
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    type DamageSourcePredicateBuilderJS_ = DamageSourcePredicateBuilderJS;
    interface FlavorListener extends Internal.EventListener {
        flavorsChanged(arg0: Internal.FlavorEvent_): void;
    }
    type FlavorListener_ = FlavorListener;
    interface Long2IntFunction extends Internal.Function<number, number>, Internal.LongToIntFunction {
        getOrDefault(arg0: any, arg1: number): number;
        getOrDefault(arg0: number, arg1: number): number;
        andThenShort(arg0: Internal.Int2ShortFunction_): Internal.Long2ShortFunction;
        composeByte(arg0: Internal.Byte2LongFunction_): Internal.Byte2IntFunction;
        andThenInt(arg0: Internal.Int2IntFunction_): Internal.Long2IntFunction;
        composeReference<T_>(arg0: Internal.Reference2LongFunction_<T_>): Internal.Reference2IntFunction<T_>;
        andThen<T_>(arg0: java_.util.function_.Function_<number, T_>): java_.util.function_.Function<number, T_>;
        put(arg0: number, arg1: number): number;
        remove(arg0: number): number;
        remove(arg0: any): number;
        defaultReturnValue(): number;
        defaultReturnValue(arg0: number): void;
        andThenDouble(arg0: Internal.Int2DoubleFunction_): Internal.Long2DoubleFunction;
        andThenObject<T_>(arg0: Internal.Int2ObjectFunction_<T_>): Internal.Long2ObjectFunction<T_>;
        get(arg0: any): number;
        get(arg0: number): number;
        andThenLong(arg0: Internal.Int2LongFunction_): Internal.Long2LongFunction;
        composeLong(arg0: Internal.Long2LongFunction_): Internal.Long2IntFunction;
        andThenByte(arg0: Internal.Int2ByteFunction_): Internal.Long2ByteFunction;
        andThenFloat(arg0: Internal.Int2FloatFunction_): Internal.Long2FloatFunction;
        applyAsInt(arg0: number): number;
        apply(arg0: number): number;
        containsKey(arg0: any): boolean;
        containsKey(arg0: number): boolean;
        composeInt(arg0: Internal.Int2LongFunction_): Internal.Int2IntFunction;
        clear(): void;
        composeFloat(arg0: Internal.Float2LongFunction_): Internal.Float2IntFunction;
        andThenChar(arg0: Internal.Int2CharFunction_): Internal.Long2CharFunction;
        composeObject<T_>(arg0: Internal.Object2LongFunction_<T_>): Internal.Object2IntFunction<T_>;
        size(): number;
        compose<T_>(arg0: java_.util.function_.Function_<T_, number>): java_.util.function_.Function<T_, number>;
        composeShort(arg0: Internal.Short2LongFunction_): Internal.Short2IntFunction;
        andThenReference<T_>(arg0: Internal.Int2ReferenceFunction_<T_>): Internal.Long2ReferenceFunction<T_>;
        composeChar(arg0: Internal.Char2LongFunction_): Internal.Char2IntFunction;
        composeDouble(arg0: Internal.Double2LongFunction_): Internal.Double2IntFunction;
    }
    type Long2IntFunction_ = ((arg0: number) => number) | Long2IntFunction;
    abstract class ZoneId implements Internal.Serializable {
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        normalized(): Internal.ZoneId;
        notifyAll(): void;
        getId(): string;
        notify(): void;
        static ofOffset(arg0: string, arg1: Internal.ZoneOffset_): Internal.ZoneId;
        static systemDefault(): Internal.ZoneId;
        static getAvailableZoneIds(): Internal.Set<string>;
        getDisplayName(arg0: Internal.TextStyle_, arg1: Internal.Locale_): string;
        hashCode(): number;
        static of(arg0: string, arg1: Internal.Map_<string, string>): Internal.ZoneId;
        static of(arg0: string): Internal.ZoneId;
        equals(arg0: any): boolean;
        static from(arg0: Internal.TemporalAccessor_): Internal.ZoneId;
        toString(): string;
        getRules(): Internal.ZoneRules;
        static readonly SHORT_IDS : {"EAT":"Africa/Addis_Ababa","EST":"-05:00","PNT":"America/Phoenix","PLT":"Asia/Karachi","CNT":"America/St_Johns","IET":"America/Indiana/Indianapolis","VST":"Asia/Ho_Chi_Minh","JST":"Asia/Tokyo","ART":"Africa/Cairo","PST":"America/Los_Angeles","BET":"America/Sao_Paulo","MIT":"Pacific/Apia","CAT":"Africa/Harare","AGT":"America/Argentina/Buenos_Aires","NET":"Asia/Yerevan","CST":"America/Chicago","IST":"Asia/Kolkata","AET":"Australia/Sydney","BST":"Asia/Dhaka","ACT":"Australia/Darwin","HST":"-10:00","NST":"Pacific/Auckland","AST":"America/Anchorage","MST":"-07:00","SST":"Pacific/Guadalcanal","CTT":"Asia/Shanghai","PRT":"America/Puerto_Rico","ECT":"Europe/Paris"};
        get availableZoneIds(): Internal.Set<string>;
        get rules(): Internal.ZoneRules;
        get id(): string;
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    type ZoneId_ = ZoneId;
    interface DoubleToIntFunction {
        applyAsInt(arg0: number): number;
    }
    type DoubleToIntFunction_ = ((arg0: number) => number) | DoubleToIntFunction;
    class DataResult$PartialResult <R> {
        flatMap<R2>(arg0: java_.util.function_.Function_<R, Internal.DataResult$PartialResult_<R2>>): Internal.DataResult$PartialResult<R2>;
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        hashCode(): number;
        notifyAll(): void;
        equals(arg0: any): boolean;
        toString(): string;
        message(): string;
        map<R2>(arg0: java_.util.function_.Function_<R, R2>): Internal.DataResult$PartialResult<R2>;
        notify(): void;
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    type DataResult$PartialResult_<R> = DataResult$PartialResult<R>;
    class MobSpawnSettings$SpawnerData extends Internal.WeightedEntry$IntrusiveBase {
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        hashCode(): number;
        notifyAll(): void;
        equals(arg0: any): boolean;
        toString(): string;
        notify(): void;
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    type MobSpawnSettings$SpawnerData_ = MobSpawnSettings$SpawnerData;
    abstract class Stages {
        add(stage: string): boolean;
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        getAll(): Internal.Collection<string>;
        set(stage: string, enabled: boolean): boolean;
        static added(event: Internal.Consumer_<Internal.StageChangeEvent_>): void;
        notifyAll(): void;
        static invokeAdded(stages: Internal.Stages_, stage: string): void;
        replace(stages: Internal.Collection_<string>): void;
        clear(): boolean;
        toggle(stage: string): boolean;
        addNoUpdate(arg0: string): boolean;
        sync(): void;
        notify(): void;
        remove(stage: string): boolean;
        static removed(event: Internal.Consumer_<Internal.StageChangeEvent_>): void;
        hashCode(): number;
        equals(arg0: any): boolean;
        static get(player: Internal.Player_): Internal.Stages;
        toString(): string;
        static invokeRemoved(stages: Internal.Stages_, stage: string): void;
        static overrideCreation(event: Internal.Consumer_<Internal.StageCreationEvent_>): void;
        has(stage: string): boolean;
        removeNoUpdate(arg0: string): boolean;
        readonly player : Internal.Player;
        get all(): Internal.Collection<string>;
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    type Stages_ = Stages;
    interface Guard {
        checkGuard(arg0: any): void;
    }
    type Guard_ = Guard;
    class Event$Result extends Internal.Enum<Internal.Event$Result> {
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        static valueOf(arg0: string): Internal.Event$Result;
        static valueOf<T_>(arg0: Internal.Class_<T_>, arg1: string): T_;
        notifyAll(): void;
        static values(): Internal.Event$Result[];
        compareTo(arg0: Internal.Event$Result_): number;
        describeConstable(): Internal.Optional<Internal.Enum$EnumDesc<Internal.Event$Result>>;
        notify(): void;
        getDeclaringClass(): Internal.Class<Internal.Event$Result>;
        hashCode(): number;
        equals(arg0: any): boolean;
        name(): string;
        toString(): string;
        ordinal(): number;
        static readonly DENY : Internal.Event$Result;
        static readonly DEFAULT : Internal.Event$Result;
        static readonly ALLOW : Internal.Event$Result;
        get class(): Internal.Class<any>;
        get declaringClass(): Internal.Class<Internal.Event$Result>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    type Event$Result_ = "allow" | "deny" | "default" | Event$Result;
    interface UnmodifiableCommentedConfig$Entry extends Internal.UnmodifiableConfig$Entry {
        getShortOrElse(arg0: number): number;
        getKey(): string;
        getByte(): number;
        getShort(): number;
        getOptionalInt(): Internal.OptionalInt;
        getRawValue<T_>(): T_;
        getCharOrElse(arg0: string): string;
        getLongOrElse(arg0: number): number;
        getByteOrElse(arg0: number): number;
        getLong(): number;
        getValue<T_>(): T_;
        getInt(): number;
        getChar(): string;
        getOptional<T_>(): Internal.Optional<T_>;
        isNull(): boolean;
        getOrElse<T_>(arg0: T_): T_;
        getComment(): string;
        getIntOrElse(arg0: number): number;
        getOptionalLong(): Internal.OptionalLong;
    }
    type UnmodifiableCommentedConfig$Entry_ = UnmodifiableCommentedConfig$Entry;
    class SoundType implements Internal.AccessorSoundType {
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        hashCode(): number;
        notifyAll(): void;
        equals(arg0: any): boolean;
        toString(): string;
        notify(): void;
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    type SoundType_ = SoundType;
    class PackType extends Internal.Enum<Internal.PackType> {
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        static valueOf(arg0: string): Internal.PackType;
        static valueOf<T_>(arg0: Internal.Class_<T_>, arg1: string): T_;
        notifyAll(): void;
        static values(): Internal.PackType[];
        compareTo(arg0: Internal.PackType_): number;
        describeConstable(): Internal.Optional<Internal.Enum$EnumDesc<Internal.PackType>>;
        notify(): void;
        getDeclaringClass(): Internal.Class<Internal.PackType>;
        hashCode(): number;
        equals(arg0: any): boolean;
        name(): string;
        toString(): string;
        ordinal(): number;
        static readonly CLIENT_RESOURCES : Internal.PackType;
        static readonly SERVER_DATA : Internal.PackType;
        get class(): Internal.Class<any>;
        get declaringClass(): Internal.Class<Internal.PackType>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    type PackType_ = "client_resources" | "server_data" | PackType;
    interface KeyListener extends Internal.EventListener {
        keyPressed(arg0: Internal.KeyEvent_): void;
        keyReleased(arg0: Internal.KeyEvent_): void;
        keyTyped(arg0: Internal.KeyEvent_): void;
    }
    type KeyListener_ = KeyListener;
    interface Enumeration <E> {
        hasMoreElements(): boolean;
        asIterator(): Internal.Iterator<E>;
        nextElement(): E;
    }
    type Enumeration_<E> = Enumeration<E>;
    class WidgetType extends Internal.Enum<Internal.WidgetType> {
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        static valueOf(name: string): Internal.WidgetType;
        static valueOf<T_>(arg0: Internal.Class_<T_>, arg1: string): T_;
        notifyAll(): void;
        static values(): Internal.WidgetType[];
        static mouseOver(mouseOver: boolean): Internal.WidgetType;
        compareTo(arg0: Internal.WidgetType_): number;
        describeConstable(): Internal.Optional<Internal.Enum$EnumDesc<Internal.WidgetType>>;
        notify(): void;
        getDeclaringClass(): Internal.Class<Internal.WidgetType>;
        hashCode(): number;
        equals(arg0: any): boolean;
        name(): string;
        toString(): string;
        ordinal(): number;
        static readonly DISABLED : Internal.WidgetType;
        static readonly MOUSE_OVER : Internal.WidgetType;
        static readonly NORMAL : Internal.WidgetType;
        get class(): Internal.Class<any>;
        get declaringClass(): Internal.Class<Internal.WidgetType>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    type WidgetType_ = "normal" | "mouse_over" | "disabled" | WidgetType;
    class Proxy$Type extends Internal.Enum<Internal.Proxy$Type> {
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        static valueOf(arg0: string): Internal.Proxy$Type;
        static valueOf<T_>(arg0: Internal.Class_<T_>, arg1: string): T_;
        notifyAll(): void;
        static values(): Internal.Proxy$Type[];
        compareTo(arg0: Internal.Proxy$Type_): number;
        describeConstable(): Internal.Optional<Internal.Enum$EnumDesc<Internal.Proxy$Type>>;
        notify(): void;
        getDeclaringClass(): Internal.Class<Internal.Proxy$Type>;
        hashCode(): number;
        equals(arg0: any): boolean;
        name(): string;
        toString(): string;
        ordinal(): number;
        static readonly SOCKS : Internal.Proxy$Type;
        static readonly HTTP : Internal.Proxy$Type;
        static readonly DIRECT : Internal.Proxy$Type;
        get class(): Internal.Class<any>;
        get declaringClass(): Internal.Class<Internal.Proxy$Type>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    type Proxy$Type_ = "socks" | "direct" | "http" | Proxy$Type;
    class BigInteger extends Internal.Number implements Internal.Comparable<Internal.BigInteger> {
        bitLength(): number;
        getClass(): Internal.Class<any>;
        getLowestSetBit(): number;
        mod(arg0: Internal.BigInteger_): Internal.BigInteger;
        byteValueExact(): number;
        gcd(arg0: Internal.BigInteger_): Internal.BigInteger;
        compareTo(arg0: Internal.BigInteger_): number;
        sqrtAndRemainder(): Internal.BigInteger[];
        shiftLeft(arg0: number): Internal.BigInteger;
        sqrt(): Internal.BigInteger;
        shortValue(): number;
        clearBit(arg0: number): Internal.BigInteger;
        signum(): number;
        add(arg0: Internal.BigInteger_): Internal.BigInteger;
        subtract(arg0: Internal.BigInteger_): Internal.BigInteger;
        floatValue(): number;
        isProbablePrime(arg0: number): boolean;
        doubleValue(): number;
        nextProbablePrime(): Internal.BigInteger;
        testBit(arg0: number): boolean;
        shiftRight(arg0: number): Internal.BigInteger;
        divideAndRemainder(arg0: Internal.BigInteger_): Internal.BigInteger[];
        modPow(arg0: Internal.BigInteger_, arg1: Internal.BigInteger_): Internal.BigInteger;
        intValueExact(): number;
        andNot(arg0: Internal.BigInteger_): Internal.BigInteger;
        modInverse(arg0: Internal.BigInteger_): Internal.BigInteger;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        longValueExact(): number;
        notifyAll(): void;
        setBit(arg0: number): Internal.BigInteger;
        shortValueExact(): number;
        notify(): void;
        longValue(): number;
        not(): Internal.BigInteger;
        min(arg0: Internal.BigInteger_): Internal.BigInteger;
        and(arg0: Internal.BigInteger_): Internal.BigInteger;
        hashCode(): number;
        pow(arg0: number): Internal.BigInteger;
        xor(arg0: Internal.BigInteger_): Internal.BigInteger;
        divide(arg0: Internal.BigInteger_): Internal.BigInteger;
        multiply(arg0: Internal.BigInteger_): Internal.BigInteger;
        flipBit(arg0: number): Internal.BigInteger;
        or(arg0: Internal.BigInteger_): Internal.BigInteger;
        max(arg0: Internal.BigInteger_): Internal.BigInteger;
        static valueOf(arg0: number): Internal.BigInteger;
        intValue(): number;
        abs(): Internal.BigInteger;
        negate(): Internal.BigInteger;
        toByteArray(): number[];
        equals(arg0: any): boolean;
        toString(arg0: number): string;
        toString(): string;
        bitCount(): number;
        static probablePrime(arg0: number, arg1: Internal.Random_): Internal.BigInteger;
        remainder(arg0: Internal.BigInteger_): Internal.BigInteger;
        byteValue(): number;
        static readonly ZERO : Internal.BigInteger;
        static readonly ONE : Internal.BigInteger;
        static readonly TEN : Internal.BigInteger;
        static readonly TWO : Internal.BigInteger;
        get lowestSetBit(): number;
        get class(): Internal.Class<any>;
        set bit(arg0: number);
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    type BigInteger_ = BigInteger;
    interface Byte2ByteFunction extends Internal.Function<number, number>, Internal.IntUnaryOperator {
        getOrDefault(arg0: any, arg1: number): number;
        getOrDefault(arg0: number, arg1: number): number;
        andThenShort(arg0: Internal.Byte2ShortFunction_): Internal.Byte2ShortFunction;
        composeByte(arg0: Internal.Byte2ByteFunction_): Internal.Byte2ByteFunction;
        andThenInt(arg0: Internal.Byte2IntFunction_): Internal.Byte2IntFunction;
        composeReference<T_>(arg0: Internal.Reference2ByteFunction_<T_>): Internal.Reference2ByteFunction<T_>;
        andThen<T_>(arg0: java_.util.function_.Function_<number, T_>): java_.util.function_.Function<number, T_>;
        andThen(arg0: Internal.IntUnaryOperator_): Internal.IntUnaryOperator;
        put(arg0: number, arg1: number): number;
        remove(arg0: number): number;
        remove(arg0: any): number;
        defaultReturnValue(): number;
        defaultReturnValue(arg0: number): void;
        andThenDouble(arg0: Internal.Byte2DoubleFunction_): Internal.Byte2DoubleFunction;
        andThenObject<T_>(arg0: Internal.Byte2ObjectFunction_<T_>): Internal.Byte2ObjectFunction<T_>;
        get(arg0: any): number;
        get(arg0: number): number;
        andThenLong(arg0: Internal.Byte2LongFunction_): Internal.Byte2LongFunction;
        composeLong(arg0: Internal.Long2ByteFunction_): Internal.Long2ByteFunction;
        andThenByte(arg0: Internal.Byte2ByteFunction_): Internal.Byte2ByteFunction;
        andThenFloat(arg0: Internal.Byte2FloatFunction_): Internal.Byte2FloatFunction;
        applyAsInt(arg0: number): number;
        apply(arg0: number): number;
        containsKey(arg0: any): boolean;
        containsKey(arg0: number): boolean;
        composeInt(arg0: Internal.Int2ByteFunction_): Internal.Int2ByteFunction;
        clear(): void;
        composeFloat(arg0: Internal.Float2ByteFunction_): Internal.Float2ByteFunction;
        andThenChar(arg0: Internal.Byte2CharFunction_): Internal.Byte2CharFunction;
        composeObject<T_>(arg0: Internal.Object2ByteFunction_<T_>): Internal.Object2ByteFunction<T_>;
        size(): number;
        compose<T_>(arg0: java_.util.function_.Function_<T_, number>): java_.util.function_.Function<T_, number>;
        compose(arg0: Internal.IntUnaryOperator_): Internal.IntUnaryOperator;
        composeShort(arg0: Internal.Short2ByteFunction_): Internal.Short2ByteFunction;
        andThenReference<T_>(arg0: Internal.Byte2ReferenceFunction_<T_>): Internal.Byte2ReferenceFunction<T_>;
        composeChar(arg0: Internal.Char2ByteFunction_): Internal.Char2ByteFunction;
        composeDouble(arg0: Internal.Double2ByteFunction_): Internal.Double2ByteFunction;
    }
    type Byte2ByteFunction_ = ((arg0: number) => number) | Byte2ByteFunction;
    interface ServerLevelAccessor extends Internal.LevelAccessor {
        getExistingBlockEntity(arg0: BlockPos_): Internal.BlockEntity;
        isAreaLoaded(arg0: BlockPos_, arg1: number): boolean;
    }
    type ServerLevelAccessor_ = ServerLevelAccessor;
    class LevelStorageSource$LevelStorageAccess implements Internal.AutoCloseable, Internal.LevelStorageSourceLevelStorageAccessAccess {
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        getWorldDir(): Internal.Path;
        hashCode(): number;
        notifyAll(): void;
        equals(arg0: any): boolean;
        toString(): string;
        close(): void;
        notify(): void;
        readAdditionalLevelSaveData(): void;
        get worldDir(): Internal.Path;
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    type LevelStorageSource$LevelStorageAccess_ = LevelStorageSource$LevelStorageAccess;
    abstract class PlayerJS <E> extends Internal.LivingEntityJS implements Internal.WithAttachedData {
        getXpLevel(): number;
        getLastAttackedEntity(): Internal.LivingEntityJS;
        setY(y: number): void;
        setX(x: number): void;
        isOnScoreboardTeam(teamID: string): boolean;
        isLiving(): boolean;
        isSprinting(): boolean;
        getItem(): Internal.ItemStackJS;
        paint(arg0: Internal.CompoundTag_): void;
        getOffHandItem(): Internal.ItemStackJS;
        setGlowing(glowing: boolean): void;
        setZ(z: number): void;
        setXpLevel(l: number): void;
        getHasCustomName(): boolean;
        runCommandSilent(command: string): number;
        setSelectedSlot(index: number): void;
        getDistanceSq(pos: BlockPos_): number;
        getDistanceSq(x: number, y: number, z: number): number;
        isBoss(): boolean;
        setMovementSpeedAddition(speed: number): void;
        isGlowing(): boolean;
        getHorizontalFacing(): Internal.Direction;
        setLegsArmorItem(item: Internal.ItemStackJS_): void;
        setMotion(x: number, y: number, z: number): void;
        getProfile(): Internal.GameProfile;
        setRotation(yaw: number, pitch: number): void;
        isMiningBlock(): boolean;
        setAbsorptionAmount(amount: number): void;
        isOnSameTeam(e: Internal.EntityJS_): boolean;
        isAnimal(): boolean;
        getType(): string;
        setCustomNameAlwaysVisible(b: boolean): void;
        addMotion(x: number, y: number, z: number): void;
        isFake(): boolean;
        getFallDistance(): number;
        damageHeldItem(hand: Hand_, amount: number): void;
        damageHeldItem(hand: Hand_, amount: number, onBroken: Internal.Consumer_<Internal.ItemStackJS_>): void;
        damageHeldItem(): void;
        setOnFire(seconds: number): void;
        attack(source: string, hp: number): void;
        attack(hp: number): void;
        isUndead(): boolean;
        getInventory(): Internal.InventoryJS;
        getDistance(x: number, y: number, z: number): number;
        getDistance(pos: BlockPos_): number;
        getReachDistance(): number;
        getCustomName(): Internal.Text;
        getStepHeight(): number;
        getDefaultMovementSpeed(): number;
        getRidingEntity(): Internal.EntityJS;
        setPositionAndRotation(x: number, y: number, z: number, yaw: number, pitch: number): void;
        getLastAttackedEntityTime(): number;
        isMonster(): boolean;
        addItemCooldown(item: Internal.Item_, ticks: number): void;
        setPitch(pitch: number): void;
        getFacing(): Internal.Direction;
        isOnGround(): boolean;
        toString(): string;
        isSilent(): boolean;
        setXp(xp: number): void;
        getMaxAirSupply(): number;
        getName(): Internal.Text;
        getFeetArmorItem(): Internal.ItemStackJS;
        setStepHeight(stepHeight: number): void;
        isWaterCreature(): boolean;
        setPosition(x: number, y: number, z: number): void;
        setPosition(block: Internal.BlockContainerJS_): void;
        closeInventory(): void;
        extinguish(): void;
        setInvulnerable(invulnerable: boolean): void;
        setMovementSpeed(speed: number): void;
        isChild(): boolean;
        setDefaultMovementSpeed(speed: number): void;
        setEquipment(slot: EquipmentSlot_, item: Internal.ItemStackJS_): void;
        giveInHand(item: Internal.ItemStackJS_): void;
        getLegsArmorItem(): Internal.ItemStackJS;
        isCreativeMode(): boolean;
        getFullNBT(): Internal.CompoundTag;
        getNoClip(): boolean;
        setYaw(yaw: number): void;
        getYaw(): number;
        getTotalMovementSpeed(): number;
        setNoGravity(noGravity: boolean): void;
        setHeldItem(hand: Hand_, item: Internal.ItemStackJS_): void;
        getRevengeTimer(): number;
        notifyAll(): void;
        getId(): Internal.UUID;
        addXPLevels(l: number): void;
        getOpenInventory(): Internal.AbstractContainerMenu;
        hashCode(): number;
        getChestArmorItem(): Internal.ItemStackJS;
        isFrame(): boolean;
        startRiding(e: Internal.EntityJS_, force: boolean): boolean;
        runCommand(command: string): number;
        setChestArmorItem(item: Internal.ItemStackJS_): void;
        getCustomNameAlwaysVisible(): boolean;
        removeAttribute(attribute: Internal.Attribute_, identifier: string): void;
        addXP(xp: number): void;
        getMainHandItem(): Internal.ItemStackJS;
        setHealth(hp: number): void;
        getBlock(): Internal.BlockContainerJS;
        isElytraFlying(): boolean;
        isInWater(): boolean;
        dismountRidingEntity(): void;
        isSleeping(): boolean;
        swingArm(hand: Hand_): void;
        getPotionEffects(): Internal.EntityPotionEffectsJS;
        isInvulnerable(): boolean;
        setHeadArmorItem(item: Internal.ItemStackJS_): void;
        isPeacefulCreature(): boolean;
        getMouseItem(): Internal.ItemStackJS;
        getMotionZ(): number;
        getMotionX(): number;
        getMotionY(): number;
        sendData(channel: string, data: Internal.CompoundTag_): void;
        getRevengeTarget(): Internal.LivingEntityJS;
        getTags(): Internal.Set<string>;
        setInvisible(invisible: boolean): void;
        getIdleTime(): number;
        getMovementSpeed(): number;
        setDefaultMovementSpeedMultiplier(speed: number): void;
        addFood(f: number, m: number): void;
        getHealth(): number;
        getServer(): Internal.ServerJS;
        setFeetArmorItem(item: Internal.ItemStackJS_): void;
        getAttributeBaseValue(attribute: Internal.Attribute_): number;
        give(item: Internal.ItemStackJS_): void;
        setMaxHealth(hp: number): void;
        isSpectator(): boolean;
        getDisplayName(): Internal.Text;
        getXp(): number;
        addExhaustion(exhaustion: number): void;
        setOffHandItem(item: Internal.ItemStackJS_): void;
        getFoodLevel(): number;
        isInvisible(): boolean;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        getMaxHealth(): number;
        isUnderWater(): boolean;
        getHeldItem(hand: Hand_): Internal.ItemStackJS;
        getEyeHeight(): number;
        getEquipment(slot: EquipmentSlot_): Internal.ItemStackJS;
        notify(): void;
        setAirSupply(air: number): void;
        setTotalMovementSpeedMultiplier(speed: number): void;
        removePassengers(): void;
        isOnLadder(): boolean;
        playSound(id: Internal.SoundEvent_, volume: number, pitch: number): void;
        playSound(id: Internal.SoundEvent_): void;
        boostElytraFlight(): void;
        getData(): Internal.AttachedData;
        getLastDamageSource(): Internal.DamageSource;
        setStatusMessage(message: Internal.Component_): void;
        isSwimming(): boolean;
        mergeFullNBT(tag: Internal.CompoundTag_): Internal.EntityJS;
        kill(): void;
        getLevel(): Internal.LevelJS;
        getPitch(): number;
        getPassengers(): Internal.EntityArrayList;
        equals(arg0: any): boolean;
        isPassenger(e: Internal.EntityJS_): boolean;
        getClass(): Internal.Class<any>;
        getRecursivePassengers(): Internal.EntityArrayList;
        getNbt(): Internal.CompoundTag;
        setFallDistance(fallDistance: number): void;
        sendInventoryUpdate(): void;
        setCustomName(name: Internal.Component_): void;
        setMainHandItem(item: Internal.ItemStackJS_): void;
        tell(message: Internal.Component_): void;
        getTeamId(): string;
        setNoClip(noClip: boolean): void;
        getAttributeTotalValue(attribute: Internal.Attribute_): number;
        setRevengeTarget(target: Internal.LivingEntityJS_): void;
        getAirSupply(): number;
        setFullNBT(nbt: Internal.CompoundTag_): void;
        getAttackingEntity(): Internal.LivingEntityJS;
        isHoldingInAnyHand(ingredient: any): boolean;
        damageEquipment(slot: EquipmentSlot_): void;
        damageEquipment(slot: EquipmentSlot_, amount: number, onBroken: Internal.Consumer_<Internal.ItemStackJS_>): void;
        damageEquipment(slot: EquipmentSlot_, amount: number): void;
        isAlive(): boolean;
        modifyAttribute(attribute: Internal.Attribute_, identifier: string, d: number, operation: Internal.AttributeModifier$Operation_): void;
        getHeadArmorItem(): Internal.ItemStackJS;
        setMouseItem(item: Internal.ItemStackJS_): void;
        setAttributeBaseValue(attribute: Internal.Attribute_, value: number): void;
        isPlayer(): boolean;
        getStats(): Internal.PlayerStatsJS;
        getAbsorptionAmount(): number;
        isCrouching(): boolean;
        getTicksExisted(): number;
        getStages(): Internal.Stages;
        setSilent(isSilent: boolean): void;
        heal(hp: number): void;
        setMotionZ(z: number): void;
        setMotionY(y: number): void;
        setMotionX(x: number): void;
        isAmbientCreature(): boolean;
        rayTrace(): Internal.RayTraceResultJS;
        rayTrace(distance: number): Internal.RayTraceResultJS;
        getSelectedSlot(): number;
        canEntityBeSeen(entity: Internal.LivingEntityJS_): boolean;
        getX(): number;
        getY(): number;
        spawn(): void;
        getZ(): number;
        setFoodLevel(foodLevel: number): void;
        getNoGravity(): boolean;
        static readonly PLAYER_CUSTOM_SPEED : Internal.UUID;
        static readonly PLAYER_CUSTOM_SPEED_NAME : "kubejs.player.speed.modifier";
        readonly persistentData : Internal.CompoundTag;
        readonly minecraftPlayer : E;
        readonly minecraftEntity : Internal.Entity;
        readonly minecraftLivingEntity : Internal.LivingEntity;
        get xpLevel(): number;
        get invisible(): boolean;
        get creativeMode(): boolean;
        get customNameAlwaysVisible(): boolean;
        get type(): string;
        get defaultMovementSpeed(): number;
        get movementSpeed(): number;
        get stats(): Internal.PlayerStatsJS;
        get revengeTarget(): Internal.LivingEntityJS;
        get hasCustomName(): boolean;
        get block(): Internal.BlockContainerJS;
        get maxHealth(): number;
        get id(): Internal.UUID;
        get pitch(): number;
        get item(): Internal.ItemStackJS;
        get passengers(): Internal.EntityArrayList;
        get profile(): Internal.GameProfile;
        get onLadder(): boolean;
        get offHandItem(): Internal.ItemStackJS;
        get customName(): Internal.Text;
        get lastAttackedEntityTime(): number;
        get tags(): Internal.Set<string>;
        get crouching(): boolean;
        get animal(): boolean;
        get lastDamageSource(): Internal.DamageSource;
        get stepHeight(): number;
        get noClip(): boolean;
        get server(): Internal.ServerJS;
        get nbt(): Internal.CompoundTag;
        get boss(): boolean;
        get alive(): boolean;
        get revengeTimer(): number;
        get displayName(): Internal.Text;
        get mainHandItem(): Internal.ItemStackJS;
        get facing(): Internal.Direction;
        get ambientCreature(): boolean;
        get swimming(): boolean;
        get selectedSlot(): number;
        get eyeHeight(): number;
        get underWater(): boolean;
        get openInventory(): Internal.AbstractContainerMenu;
        get motionZ(): number;
        get silent(): boolean;
        get motionY(): number;
        get motionX(): number;
        get health(): number;
        get chestArmorItem(): Internal.ItemStackJS;
        get yaw(): number;
        get monster(): boolean;
        get glowing(): boolean;
        get onGround(): boolean;
        get spectator(): boolean;
        get x(): number;
        get y(): number;
        get fake(): boolean;
        get z(): number;
        get foodLevel(): number;
        get data(): Internal.AttachedData;
        get idleTime(): number;
        get legsArmorItem(): Internal.ItemStackJS;
        get maxAirSupply(): number;
        get undead(): boolean;
        get lastAttackedEntity(): Internal.LivingEntityJS;
        get potionEffects(): Internal.EntityPotionEffectsJS;
        get level(): Internal.LevelJS;
        get feetArmorItem(): Internal.ItemStackJS;
        get horizontalFacing(): Internal.Direction;
        get sprinting(): boolean;
        get mouseItem(): Internal.ItemStackJS;
        get noGravity(): boolean;
        get fullNBT(): Internal.CompoundTag;
        get name(): Internal.Text;
        get peacefulCreature(): boolean;
        get child(): boolean;
        get frame(): boolean;
        get ticksExisted(): number;
        get fallDistance(): number;
        get elytraFlying(): boolean;
        get inventory(): Internal.InventoryJS;
        get sleeping(): boolean;
        get airSupply(): number;
        get waterCreature(): boolean;
        get invulnerable(): boolean;
        get miningBlock(): boolean;
        get headArmorItem(): Internal.ItemStackJS;
        get class(): Internal.Class<any>;
        get reachDistance(): number;
        get player(): boolean;
        get absorptionAmount(): number;
        get living(): boolean;
        get ridingEntity(): Internal.EntityJS;
        get inWater(): boolean;
        get recursivePassengers(): Internal.EntityArrayList;
        get attackingEntity(): Internal.LivingEntityJS;
        get totalMovementSpeed(): number;
        get teamId(): string;
        get xp(): number;
        get stages(): Internal.Stages;
        set noClip(noClip: boolean);
        set xpLevel(l: number);
        set fallDistance(fallDistance: number);
        set mainHandItem(item: Internal.ItemStackJS_);
        set invisible(invisible: boolean);
        set customNameAlwaysVisible(b: boolean);
        set defaultMovementSpeed(speed: number);
        set movementSpeed(speed: number);
        set airSupply(air: number);
        set invulnerable(invulnerable: boolean);
        set legsArmorItem(item: Internal.ItemStackJS_);
        set totalMovementSpeedMultiplier(speed: number);
        set selectedSlot(index: number);
        set revengeTarget(target: Internal.LivingEntityJS_);
        set maxHealth(hp: number);
        set headArmorItem(item: Internal.ItemStackJS_);
        set pitch(pitch: number);
        set movementSpeedAddition(speed: number);
        set motionZ(z: number);
        set absorptionAmount(amount: number);
        set silent(isSilent: boolean);
        set motionY(y: number);
        set motionX(x: number);
        set feetArmorItem(item: Internal.ItemStackJS_);
        set health(hp: number);
        set offHandItem(item: Internal.ItemStackJS_);
        set chestArmorItem(item: Internal.ItemStackJS_);
        set defaultMovementSpeedMultiplier(speed: number);
        set onFire(seconds: number);
        set statusMessage(message: Internal.Component_);
        set yaw(yaw: number);
        set glowing(glowing: boolean);
        set mouseItem(item: Internal.ItemStackJS_);
        set noGravity(noGravity: boolean);
        set fullNBT(nbt: Internal.CompoundTag_);
        set xp(xp: number);
        set x(x: number);
        set y(y: number);
        set z(z: number);
        set foodLevel(foodLevel: number);
        set position(block: Internal.BlockContainerJS_);
        set stepHeight(stepHeight: number);
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    type PlayerJS_<E> = PlayerJS<E>;
    interface IntFunction <R> {
        apply(arg0: number): R;
    }
    type IntFunction_<R> = ((arg0: number) => R) | IntFunction<R>;
    interface Drawable {
        drawStatic(matrixStack: Internal.PoseStack_, x: number, y: number, w: number, h: number): void;
        draw(arg0: Internal.PoseStack_, arg1: number, arg2: number, arg3: number, arg4: number): void;
        draw3D(matrixStack: Internal.PoseStack_): void;
    }
    type Drawable_ = Drawable;
    class ImageCapabilities implements Internal.Cloneable {
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        isAccelerated(): boolean;
        isTrueVolatile(): boolean;
        hashCode(): number;
        notifyAll(): void;
        equals(arg0: any): boolean;
        clone(): any;
        toString(): string;
        notify(): void;
        get trueVolatile(): boolean;
        get class(): Internal.Class<any>;
        get accelerated(): boolean;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    type ImageCapabilities_ = ImageCapabilities;
    interface AccessorMob {
        bookshelf$getAmbientSound(): Internal.SoundEvent;
    }
    type AccessorMob_ = AccessorMob;
    class Container extends java_.awt.Component {
        requestFocusInWindow(): boolean;
        requestFocusInWindow(arg0: Internal.FocusEvent$Cause_): boolean;
        getLocation(arg0: Internal.Point_): Internal.Point;
        getLocation(): Internal.Point;
        isOpaque(): boolean;
        paint(arg0: Internal.Graphics_): void;
        getInputMethodListeners(): Internal.InputMethodListener[];
        setLayout(arg0: Internal.LayoutManager_): void;
        mouseDown(arg0: java_.awt.Event_, arg1: number, arg2: number): boolean;
        getInputMethodRequests(): Internal.InputMethodRequests;
        addHierarchyBoundsListener(arg0: Internal.HierarchyBoundsListener_): void;
        removeAll(): void;
        getMinimumSize(): Internal.Dimension;
        getAlignmentY(): number;
        getAlignmentX(): number;
        dispatchEvent(arg0: Internal.AWTEvent_): void;
        reshape(arg0: number, arg1: number, arg2: number, arg3: number): void;
        postEvent(arg0: java_.awt.Event_): boolean;
        contains(arg0: Internal.Point_): boolean;
        contains(arg0: number, arg1: number): boolean;
        size(): Internal.Dimension;
        enableInputMethods(arg0: boolean): void;
        mouseUp(arg0: java_.awt.Event_, arg1: number, arg2: number): boolean;
        removeContainerListener(arg0: Internal.ContainerListener_): void;
        addComponentListener(arg0: Internal.ComponentListener_): void;
        setName(arg0: string): void;
        removeInputMethodListener(arg0: Internal.InputMethodListener_): void;
        removeHierarchyListener(arg0: Internal.HierarchyListener_): void;
        getFontMetrics(arg0: Internal.Font_): Internal.FontMetrics;
        getHeight(): number;
        getIgnoreRepaint(): boolean;
        getBaselineResizeBehavior(): Internal.Component$BaselineResizeBehavior;
        removeMouseWheelListener(arg0: Internal.MouseWheelListener_): void;
        applyComponentOrientation(arg0: Internal.ComponentOrientation_): void;
        validate(): void;
        getParent(): Internal.Container;
        isMinimumSizeSet(): boolean;
        setComponentOrientation(arg0: Internal.ComponentOrientation_): void;
        setBounds(arg0: Internal.Rectangle_): void;
        setBounds(arg0: number, arg1: number, arg2: number, arg3: number): void;
        isValidateRoot(): boolean;
        addNotify(): void;
        addInputMethodListener(arg0: Internal.InputMethodListener_): void;
        getFocusCycleRootAncestor(): Internal.Container;
        toString(): string;
        setFocusTraversalPolicyProvider(arg0: boolean): void;
        getName(): string;
        countComponents(): number;
        isFocusTraversable(): boolean;
        inside(arg0: number, arg1: number): boolean;
        nextFocus(): void;
        getInputContext(): Internal.InputContext;
        getFocusTraversalKeys(arg0: number): Internal.Set<Internal.AWTKeyStroke>;
        isCursorSet(): boolean;
        getMouseWheelListeners(): Internal.MouseWheelListener[];
        getComponents(): java_.awt.Component[];
        removeMouseMotionListener(arg0: Internal.MouseMotionListener_): void;
        doLayout(): void;
        setVisible(arg0: boolean): void;
        add(arg0: java_.awt.Component_): java_.awt.Component;
        add(arg0: string, arg1: java_.awt.Component_): java_.awt.Component;
        add(arg0: java_.awt.Component_, arg1: any): void;
        add(arg0: java_.awt.Component_, arg1: number): java_.awt.Component;
        add(arg0: java_.awt.Component_, arg1: any, arg2: number): void;
        add(arg0: Internal.PopupMenu_): void;
        removeKeyListener(arg0: Internal.KeyListener_): void;
        setFocusCycleRoot(arg0: boolean): void;
        isVisible(): boolean;
        removePropertyChangeListener(arg0: string, arg1: Internal.PropertyChangeListener_): void;
        removePropertyChangeListener(arg0: Internal.PropertyChangeListener_): void;
        setDropTarget(arg0: Internal.DropTarget_): void;
        list(arg0: Internal.PrintWriter_, arg1: number): void;
        list(arg0: Internal.PrintStream_, arg1: number): void;
        list(arg0: Internal.PrintStream_): void;
        list(): void;
        list(arg0: Internal.PrintWriter_): void;
        revalidate(): void;
        removeNotify(): void;
        gotFocus(arg0: java_.awt.Event_, arg1: any): boolean;
        handleEvent(arg0: java_.awt.Event_): boolean;
        notifyAll(): void;
        isForegroundSet(): boolean;
        show(): void;
        show(arg0: boolean): void;
        update(arg0: Internal.Graphics_): void;
        isFocusTraversalPolicySet(): boolean;
        setMaximumSize(arg0: Internal.Dimension_): void;
        remove(arg0: java_.awt.Component_): void;
        remove(arg0: number): void;
        remove(arg0: Internal.MenuComponent_): void;
        imageUpdate(arg0: Internal.Image_, arg1: number, arg2: number, arg3: number, arg4: number, arg5: number): boolean;
        addMouseWheelListener(arg0: Internal.MouseWheelListener_): void;
        checkImage(arg0: Internal.Image_, arg1: Internal.ImageObserver_): number;
        checkImage(arg0: Internal.Image_, arg1: number, arg2: number, arg3: Internal.ImageObserver_): number;
        getLayout(): Internal.LayoutManager;
        addKeyListener(arg0: Internal.KeyListener_): void;
        getContainerListeners(): Internal.ContainerListener[];
        hashCode(): number;
        getComponentListeners(): Internal.ComponentListener[];
        isMaximumSizeSet(): boolean;
        addPropertyChangeListener(arg0: string, arg1: Internal.PropertyChangeListener_): void;
        addPropertyChangeListener(arg0: Internal.PropertyChangeListener_): void;
        getCursor(): Internal.Cursor;
        createImage(arg0: number, arg1: number): Internal.Image;
        createImage(arg0: Internal.ImageProducer_): Internal.Image;
        mouseMove(arg0: java_.awt.Event_, arg1: number, arg2: number): boolean;
        areFocusTraversalKeysSet(arg0: number): boolean;
        getKeyListeners(): Internal.KeyListener[];
        layout(): void;
        getBaseline(arg0: number, arg1: number): number;
        print(arg0: Internal.Graphics_): void;
        paintComponents(arg0: Internal.Graphics_): void;
        getFocusListeners(): Internal.FocusListener[];
        createVolatileImage(arg0: number, arg1: number, arg2: Internal.ImageCapabilities_): Internal.VolatileImage;
        createVolatileImage(arg0: number, arg1: number): Internal.VolatileImage;
        resize(arg0: Internal.Dimension_): void;
        resize(arg0: number, arg1: number): void;
        lostFocus(arg0: java_.awt.Event_, arg1: any): boolean;
        location(): Internal.Point;
        keyDown(arg0: java_.awt.Event_, arg1: number): boolean;
        getDropTarget(): Internal.DropTarget;
        getLocale(): Internal.Locale;
        getHierarchyBoundsListeners(): Internal.HierarchyBoundsListener[];
        getBounds(): Internal.Rectangle;
        getBounds(arg0: Internal.Rectangle_): Internal.Rectangle;
        setPreferredSize(arg0: Internal.Dimension_): void;
        enable(arg0: boolean): void;
        enable(): void;
        getMousePosition(arg0: boolean): Internal.Point;
        getMousePosition(): Internal.Point;
        action(arg0: java_.awt.Event_, arg1: any): boolean;
        addContainerListener(arg0: Internal.ContainerListener_): void;
        setComponentZOrder(arg0: java_.awt.Component_, arg1: number): void;
        firePropertyChange(arg0: string, arg1: number, arg2: number): void;
        firePropertyChange(arg0: string, arg1: string, arg2: string): void;
        addMouseMotionListener(arg0: Internal.MouseMotionListener_): void;
        getComponentOrientation(): Internal.ComponentOrientation;
        setFocusable(arg0: boolean): void;
        getTreeLock(): any;
        isBackgroundSet(): boolean;
        addHierarchyListener(arg0: Internal.HierarchyListener_): void;
        findComponentAt(arg0: number, arg1: number): java_.awt.Component;
        findComponentAt(arg0: Internal.Point_): java_.awt.Component;
        setEnabled(arg0: boolean): void;
        isLightweight(): boolean;
        isEnabled(): boolean;
        minimumSize(): Internal.Dimension;
        bounds(): Internal.Rectangle;
        repaint(arg0: number, arg1: number, arg2: number, arg3: number): void;
        repaint(arg0: number): void;
        repaint(): void;
        repaint(arg0: number, arg1: number, arg2: number, arg3: number, arg4: number): void;
        getMouseMotionListeners(): Internal.MouseMotionListener[];
        setMinimumSize(arg0: Internal.Dimension_): void;
        transferFocus(): void;
        printComponents(arg0: Internal.Graphics_): void;
        getListeners<T_>(arg0: Internal.Class_<T_>): T_[];
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        getMaximumSize(): Internal.Dimension;
        getLocationOnScreen(): Internal.Point;
        keyUp(arg0: java_.awt.Event_, arg1: number): boolean;
        getWidth(): number;
        notify(): void;
        setFocusTraversalPolicy(arg0: Internal.FocusTraversalPolicy_): void;
        paintAll(arg0: Internal.Graphics_): void;
        setFocusTraversalKeys(arg0: number, arg1: Internal.Set_<Internal.AWTKeyStroke_>): void;
        hasFocus(): boolean;
        isPreferredSizeSet(): boolean;
        isDoubleBuffered(): boolean;
        getColorModel(): Internal.ColorModel;
        getPropertyChangeListeners(arg0: string): Internal.PropertyChangeListener[];
        getPropertyChangeListeners(): Internal.PropertyChangeListener[];
        isValid(): boolean;
        getInsets(): Internal.Insets;
        getFocusTraversalKeysEnabled(): boolean;
        hide(): void;
        getPreferredSize(): Internal.Dimension;
        disable(): void;
        equals(arg0: any): boolean;
        prepareImage(arg0: Internal.Image_, arg1: Internal.ImageObserver_): boolean;
        prepareImage(arg0: Internal.Image_, arg1: number, arg2: number, arg3: Internal.ImageObserver_): boolean;
        isFocusable(): boolean;
        getClass(): Internal.Class<any>;
        insets(): Internal.Insets;
        setMixingCutoutShape(arg0: Internal.Shape_): void;
        mouseExit(arg0: java_.awt.Event_, arg1: number, arg2: number): boolean;
        getHierarchyListeners(): Internal.HierarchyListener[];
        isShowing(): boolean;
        mouseEnter(arg0: java_.awt.Event_, arg1: number, arg2: number): boolean;
        mouseDrag(arg0: java_.awt.Event_, arg1: number, arg2: number): boolean;
        preferredSize(): Internal.Dimension;
        getMouseListeners(): Internal.MouseListener[];
        setFont(arg0: Internal.Font_): void;
        deliverEvent(arg0: java_.awt.Event_): void;
        getForeground(): java_.awt.Color;
        isAncestorOf(arg0: java_.awt.Component_): boolean;
        getComponentCount(): number;
        setCursor(arg0: Internal.Cursor_): void;
        getFont(): Internal.Font;
        isDisplayable(): boolean;
        getGraphicsConfiguration(): Internal.GraphicsConfiguration;
        getComponent(arg0: number): java_.awt.Component;
        setLocale(arg0: Internal.Locale_): void;
        removeComponentListener(arg0: Internal.ComponentListener_): void;
        requestFocus(): void;
        requestFocus(arg0: Internal.FocusEvent$Cause_): void;
        locate(arg0: number, arg1: number): java_.awt.Component;
        addFocusListener(arg0: Internal.FocusListener_): void;
        getComponentAt(arg0: Internal.Point_): java_.awt.Component;
        getComponentAt(arg0: number, arg1: number): java_.awt.Component;
        isFocusCycleRoot(arg0: Internal.Container_): boolean;
        isFocusCycleRoot(): boolean;
        setFocusTraversalKeysEnabled(arg0: boolean): void;
        getComponentZOrder(arg0: java_.awt.Component_): number;
        setBackground(arg0: java_.awt.Color_): void;
        printAll(arg0: Internal.Graphics_): void;
        getToolkit(): Internal.Toolkit;
        transferFocusUpCycle(): void;
        isFontSet(): boolean;
        setSize(arg0: number, arg1: number): void;
        setSize(arg0: Internal.Dimension_): void;
        setLocation(arg0: number, arg1: number): void;
        setLocation(arg0: Internal.Point_): void;
        isFocusTraversalPolicyProvider(): boolean;
        getGraphics(): Internal.Graphics;
        removeFocusListener(arg0: Internal.FocusListener_): void;
        setIgnoreRepaint(arg0: boolean): void;
        transferFocusBackward(): void;
        move(arg0: number, arg1: number): void;
        transferFocusDownCycle(): void;
        setForeground(arg0: java_.awt.Color_): void;
        invalidate(): void;
        getAccessibleContext(): Internal.AccessibleContext;
        isFocusOwner(): boolean;
        getX(): number;
        getSize(arg0: Internal.Dimension_): Internal.Dimension;
        getSize(): Internal.Dimension;
        getY(): number;
        removeHierarchyBoundsListener(arg0: Internal.HierarchyBoundsListener_): void;
        getFocusTraversalPolicy(): Internal.FocusTraversalPolicy;
        removeMouseListener(arg0: Internal.MouseListener_): void;
        getBackground(): java_.awt.Color;
        addMouseListener(arg0: Internal.MouseListener_): void;
        static readonly ABORT : 128;
        static readonly CENTER_ALIGNMENT : 0.5;
        static readonly PROPERTIES : 4;
        static readonly SOMEBITS : 8;
        static readonly BOTTOM_ALIGNMENT : 1.0;
        static readonly WIDTH : 1;
        static readonly HEIGHT : 2;
        static readonly FRAMEBITS : 16;
        static readonly LEFT_ALIGNMENT : 0.0;
        static readonly ALLBITS : 32;
        static readonly RIGHT_ALIGNMENT : 1.0;
        static readonly TOP_ALIGNMENT : 0.0;
        static readonly ERROR : 64;
        get parent(): Internal.Container;
        get inputContext(): Internal.InputContext;
        get dropTarget(): Internal.DropTarget;
        get graphicsConfiguration(): Internal.GraphicsConfiguration;
        get foreground(): java_.awt.Color;
        get graphics(): Internal.Graphics;
        get baselineResizeBehavior(): Internal.Component$BaselineResizeBehavior;
        get foregroundSet(): boolean;
        get mouseWheelListeners(): Internal.MouseWheelListener[];
        get propertyChangeListeners(): Internal.PropertyChangeListener[];
        get doubleBuffered(): boolean;
        get height(): number;
        get visible(): boolean;
        get displayable(): boolean;
        get maximumSizeSet(): boolean;
        get focusable(): boolean;
        get mousePosition(): Internal.Point;
        get focusTraversalPolicySet(): boolean;
        get focusTraversalKeysEnabled(): boolean;
        get focusOwner(): boolean;
        get componentCount(): number;
        get focusTraversalPolicy(): Internal.FocusTraversalPolicy;
        get toolkit(): Internal.Toolkit;
        get focusCycleRootAncestor(): Internal.Container;
        get focusCycleRoot(): boolean;
        get background(): java_.awt.Color;
        get name(): string;
        get focusTraversable(): boolean;
        get focusTraversalPolicyProvider(): boolean;
        get maximumSize(): Internal.Dimension;
        get containerListeners(): Internal.ContainerListener[];
        get hierarchyListeners(): Internal.HierarchyListener[];
        get minimumSizeSet(): boolean;
        get cursor(): Internal.Cursor;
        get accessibleContext(): Internal.AccessibleContext;
        get alignmentX(): number;
        get alignmentY(): number;
        get components(): java_.awt.Component[];
        get componentOrientation(): Internal.ComponentOrientation;
        get locale(): Internal.Locale;
        get ignoreRepaint(): boolean;
        get enabled(): boolean;
        get lightweight(): boolean;
        get valid(): boolean;
        get componentListeners(): Internal.ComponentListener[];
        get locationOnScreen(): Internal.Point;
        get cursorSet(): boolean;
        get colorModel(): Internal.ColorModel;
        get class(): Internal.Class<any>;
        get keyListeners(): Internal.KeyListener[];
        get inputMethodListeners(): Internal.InputMethodListener[];
        get opaque(): boolean;
        get validateRoot(): boolean;
        get mouseListeners(): Internal.MouseListener[];
        get inputMethodRequests(): Internal.InputMethodRequests;
        get hierarchyBoundsListeners(): Internal.HierarchyBoundsListener[];
        get preferredSizeSet(): boolean;
        get treeLock(): any;
        get focusListeners(): Internal.FocusListener[];
        get backgroundSet(): boolean;
        get width(): number;
        get x(): number;
        get y(): number;
        get fontSet(): boolean;
        get showing(): boolean;
        get mouseMotionListeners(): Internal.MouseMotionListener[];
        get font(): Internal.Font;
        set cursor(arg0: Internal.Cursor_);
        set visible(arg0: boolean);
        set componentOrientation(arg0: Internal.ComponentOrientation_);
        set dropTarget(arg0: Internal.DropTarget_);
        set focusable(arg0: boolean);
        set foreground(arg0: java_.awt.Color_);
        set locale(arg0: Internal.Locale_);
        set ignoreRepaint(arg0: boolean);
        set enabled(arg0: boolean);
        set focusTraversalKeysEnabled(arg0: boolean);
        set mixingCutoutShape(arg0: Internal.Shape_);
        set focusTraversalPolicy(arg0: Internal.FocusTraversalPolicy_);
        set background(arg0: java_.awt.Color_);
        set focusCycleRoot(arg0: boolean);
        set focusTraversalPolicyProvider(arg0: boolean);
        set name(arg0: string);
        set maximumSize(arg0: Internal.Dimension_);
        set font(arg0: Internal.Font_);
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    type Container_ = Container;
    interface Boolean2IntFunction extends Internal.Function<boolean, number> {
        getOrDefault(arg0: any, arg1: number): number;
        getOrDefault(arg0: boolean, arg1: number): number;
        andThenShort(arg0: Internal.Int2ShortFunction_): Internal.Boolean2ShortFunction;
        composeByte(arg0: Internal.Byte2BooleanFunction_): Internal.Byte2IntFunction;
        andThenInt(arg0: Internal.Int2IntFunction_): Internal.Boolean2IntFunction;
        composeReference<T_>(arg0: Internal.Reference2BooleanFunction_<T_>): Internal.Reference2IntFunction<T_>;
        andThen<T_>(arg0: java_.util.function_.Function_<number, T_>): java_.util.function_.Function<boolean, T_>;
        put(arg0: boolean, arg1: number): number;
        remove(arg0: any): number;
        remove(arg0: boolean): number;
        defaultReturnValue(): number;
        defaultReturnValue(arg0: number): void;
        andThenDouble(arg0: Internal.Int2DoubleFunction_): Internal.Boolean2DoubleFunction;
        andThenObject<T_>(arg0: Internal.Int2ObjectFunction_<T_>): Internal.Boolean2ObjectFunction<T_>;
        get(arg0: any): number;
        get(arg0: boolean): number;
        andThenLong(arg0: Internal.Int2LongFunction_): Internal.Boolean2LongFunction;
        composeLong(arg0: Internal.Long2BooleanFunction_): Internal.Long2IntFunction;
        andThenByte(arg0: Internal.Int2ByteFunction_): Internal.Boolean2ByteFunction;
        andThenFloat(arg0: Internal.Int2FloatFunction_): Internal.Boolean2FloatFunction;
        apply(arg0: boolean): number;
        containsKey(arg0: boolean): boolean;
        containsKey(arg0: any): boolean;
        composeInt(arg0: Internal.Int2BooleanFunction_): Internal.Int2IntFunction;
        clear(): void;
        composeFloat(arg0: Internal.Float2BooleanFunction_): Internal.Float2IntFunction;
        andThenChar(arg0: Internal.Int2CharFunction_): Internal.Boolean2CharFunction;
        composeObject<T_>(arg0: Internal.Object2BooleanFunction_<T_>): Internal.Object2IntFunction<T_>;
        size(): number;
        compose<T_>(arg0: java_.util.function_.Function_<T_, boolean>): java_.util.function_.Function<T_, number>;
        composeShort(arg0: Internal.Short2BooleanFunction_): Internal.Short2IntFunction;
        andThenReference<T_>(arg0: Internal.Int2ReferenceFunction_<T_>): Internal.Boolean2ReferenceFunction<T_>;
        composeChar(arg0: Internal.Char2BooleanFunction_): Internal.Char2IntFunction;
        composeDouble(arg0: Internal.Double2BooleanFunction_): Internal.Double2IntFunction;
    }
    type Boolean2IntFunction_ = ((arg0: boolean) => number) | Boolean2IntFunction;
    interface Tier {
        getTag(): Internal.TagKey<Internal.Block>;
    }
    type Tier_ = Tier;
    interface Wrapper {
        unwrap(): any;
    }
    type Wrapper_ = Wrapper;
    interface UnmodifiableCommentedConfig extends Internal.UnmodifiableConfig {
        getShortOrElse(arg0: string, arg1: number): number;
        getShortOrElse(arg0: Internal.List_<string>, arg1: number): number;
        getByte(arg0: Internal.List_<string>): number;
        getByte(arg0: string): number;
        containsComment(arg0: Internal.List_<string>): boolean;
        containsComment(arg0: string): boolean;
        getEnum<T_>(arg0: string, arg1: Internal.Class_<T_>, arg2: Internal.EnumGetMethod_): T_;
        getEnum<T_>(arg0: Internal.List_<string>, arg1: Internal.Class_<T_>): T_;
        getEnum<T_>(arg0: Internal.List_<string>, arg1: Internal.Class_<T_>, arg2: Internal.EnumGetMethod_): T_;
        getEnum<T_>(arg0: string, arg1: Internal.Class_<T_>): T_;
        getLongOrElse(arg0: string, arg1: Internal.LongSupplier_): number;
        getLongOrElse(arg0: Internal.List_<string>, arg1: Internal.LongSupplier_): number;
        getLongOrElse(arg0: Internal.List_<string>, arg1: number): number;
        getLongOrElse(arg0: string, arg1: number): number;
        getByteOrElse(arg0: Internal.List_<string>, arg1: number): number;
        getByteOrElse(arg0: string, arg1: number): number;
        get<T_>(arg0: string): T_;
        get<T_>(arg0: Internal.List_<string>): T_;
        getComments(arg0: Internal.Map_<string, Internal.UnmodifiableCommentedConfig$CommentNode_>): void;
        getComments(): Internal.Map<string, Internal.UnmodifiableCommentedConfig$CommentNode>;
        valueMap(): Internal.Map<string, any>;
        getOrElse<T_>(arg0: Internal.List_<string>, arg1: T_): T_;
        getOrElse<T_>(arg0: string, arg1: Internal.Supplier_<T_>): T_;
        getOrElse<T_>(arg0: string, arg1: T_): T_;
        getOrElse<T_>(arg0: Internal.List_<string>, arg1: Internal.Supplier_<T_>): T_;
        getEnumOrElse<T_>(arg0: string, arg1: Internal.Class_<T_>, arg2: Internal.EnumGetMethod_, arg3: Internal.Supplier_<T_>): T_;
        getEnumOrElse<T_>(arg0: Internal.List_<string>, arg1: T_): T_;
        getEnumOrElse<T_>(arg0: Internal.List_<string>, arg1: T_, arg2: Internal.EnumGetMethod_): T_;
        getEnumOrElse<T_>(arg0: string, arg1: T_): T_;
        getEnumOrElse<T_>(arg0: string, arg1: T_, arg2: Internal.EnumGetMethod_): T_;
        getEnumOrElse<T_>(arg0: Internal.List_<string>, arg1: Internal.Class_<T_>, arg2: Internal.EnumGetMethod_, arg3: Internal.Supplier_<T_>): T_;
        getEnumOrElse<T_>(arg0: Internal.List_<string>, arg1: Internal.Class_<T_>, arg2: Internal.Supplier_<T_>): T_;
        getEnumOrElse<T_>(arg0: string, arg1: Internal.Class_<T_>, arg2: Internal.Supplier_<T_>): T_;
        getComment(arg0: string): string;
        getComment(arg0: Internal.List_<string>): string;
        getIntOrElse(arg0: string, arg1: Internal.IntSupplier_): number;
        getIntOrElse(arg0: string, arg1: number): number;
        getIntOrElse(arg0: Internal.List_<string>, arg1: number): number;
        getIntOrElse(arg0: Internal.List_<string>, arg1: Internal.IntSupplier_): number;
        apply<T_>(arg0: string): T_;
        apply<T_>(arg0: Internal.List_<string>): T_;
        getShort(arg0: string): number;
        getShort(arg0: Internal.List_<string>): number;
        getOptionalComment(arg0: Internal.List_<string>): Internal.Optional<string>;
        getOptionalComment(arg0: string): Internal.Optional<string>;
        entrySet(): Internal.Set<Internal.UnmodifiableCommentedConfig$Entry>;
        configFormat(): Internal.ConfigFormat<any>;
        isEmpty(): boolean;
        getOptionalInt(arg0: string): Internal.OptionalInt;
        getOptionalInt(arg0: Internal.List_<string>): Internal.OptionalInt;
        commentMap(): Internal.Map<string, string>;
        getCharOrElse(arg0: Internal.List_<string>, arg1: string): string;
        getCharOrElse(arg0: string, arg1: string): string;
        getLong(arg0: string): number;
        getLong(arg0: Internal.List_<string>): number;
        getInt(arg0: string): number;
        getInt(arg0: Internal.List_<string>): number;
        getChar(arg0: string): string;
        getChar(arg0: Internal.List_<string>): string;
        getOptional<T_>(arg0: string): Internal.Optional<T_>;
        getOptional<T_>(arg0: Internal.List_<string>): Internal.Optional<T_>;
        contains(arg0: Internal.List_<string>): boolean;
        contains(arg0: string): boolean;
        size(): number;
        isNull(arg0: string): boolean;
        isNull(arg0: Internal.List_<string>): boolean;
        getRaw<T_>(arg0: string): T_;
        getRaw<T_>(arg0: Internal.List_<string>): T_;
        getOptionalLong(arg0: string): Internal.OptionalLong;
        getOptionalLong(arg0: Internal.List_<string>): Internal.OptionalLong;
        getOptionalEnum<T_>(arg0: string, arg1: Internal.Class_<T_>): Internal.Optional<T_>;
        getOptionalEnum<T_>(arg0: Internal.List_<string>, arg1: Internal.Class_<T_>): Internal.Optional<T_>;
        getOptionalEnum<T_>(arg0: string, arg1: Internal.Class_<T_>, arg2: Internal.EnumGetMethod_): Internal.Optional<T_>;
        getOptionalEnum<T_>(arg0: Internal.List_<string>, arg1: Internal.Class_<T_>, arg2: Internal.EnumGetMethod_): Internal.Optional<T_>;
    }
    type UnmodifiableCommentedConfig_ = UnmodifiableCommentedConfig;
    class DependencyRequirement extends Internal.Enum<Internal.DependencyRequirement> {
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        static valueOf(name: string): Internal.DependencyRequirement;
        static valueOf<T_>(arg0: Internal.Class_<T_>, arg1: string): T_;
        notifyAll(): void;
        static values(): Internal.DependencyRequirement[];
        compareTo(arg0: Internal.DependencyRequirement_): number;
        describeConstable(): Internal.Optional<Internal.Enum$EnumDesc<Internal.DependencyRequirement>>;
        notify(): void;
        getDeclaringClass(): Internal.Class<Internal.DependencyRequirement>;
        hashCode(): number;
        equals(arg0: any): boolean;
        name(): string;
        toString(): string;
        ordinal(): number;
        static readonly ONE_STARTED : Internal.DependencyRequirement;
        static readonly ALL_STARTED : Internal.DependencyRequirement;
        static readonly NAME_MAP : Internal.NameMap<Internal.DependencyRequirement>;
        readonly one : boolean;
        readonly id : string;
        readonly completed : boolean;
        static readonly ALL_COMPLETED : Internal.DependencyRequirement;
        static readonly ONE_COMPLETED : Internal.DependencyRequirement;
        get class(): Internal.Class<any>;
        get declaringClass(): Internal.Class<Internal.DependencyRequirement>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    type DependencyRequirement_ = "one_completed" | "all_completed" | "one_started" | "all_started" | DependencyRequirement;
    class GraphicsDevice$WindowTranslucency extends Internal.Enum<Internal.GraphicsDevice$WindowTranslucency> {
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        static valueOf(arg0: string): Internal.GraphicsDevice$WindowTranslucency;
        static valueOf<T_>(arg0: Internal.Class_<T_>, arg1: string): T_;
        notifyAll(): void;
        static values(): Internal.GraphicsDevice$WindowTranslucency[];
        compareTo(arg0: Internal.GraphicsDevice$WindowTranslucency_): number;
        describeConstable(): Internal.Optional<Internal.Enum$EnumDesc<Internal.GraphicsDevice$WindowTranslucency>>;
        notify(): void;
        getDeclaringClass(): Internal.Class<Internal.GraphicsDevice$WindowTranslucency>;
        hashCode(): number;
        equals(arg0: any): boolean;
        name(): string;
        toString(): string;
        ordinal(): number;
        static readonly PERPIXEL_TRANSPARENT : Internal.GraphicsDevice$WindowTranslucency;
        static readonly TRANSLUCENT : Internal.GraphicsDevice$WindowTranslucency;
        static readonly PERPIXEL_TRANSLUCENT : Internal.GraphicsDevice$WindowTranslucency;
        get class(): Internal.Class<any>;
        get declaringClass(): Internal.Class<Internal.GraphicsDevice$WindowTranslucency>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    type GraphicsDevice$WindowTranslucency_ = "perpixel_transparent" | "translucent" | "perpixel_translucent" | GraphicsDevice$WindowTranslucency;
    interface LevelKJS extends Internal.AsKJS {
        asKJS(): any;
    }
    type LevelKJS_ = LevelKJS;
    class Duration implements Internal.TemporalAmount, Internal.Comparable<Internal.Duration>, Internal.Serializable {
        getClass(): Internal.Class<any>;
        negated(): Internal.Duration;
        plusHours(arg0: number): Internal.Duration;
        isPositive(): boolean;
        compareTo(arg0: Internal.Duration_): number;
        multipliedBy(arg0: number): Internal.Duration;
        plusSeconds(arg0: number): Internal.Duration;
        toMillis(): number;
        static from(arg0: Internal.TemporalAmount_): Internal.Duration;
        plusNanos(arg0: number): Internal.Duration;
        static ofMinutes(arg0: number): Internal.Duration;
        static between(arg0: Internal.Temporal_, arg1: Internal.Temporal_): Internal.Duration;
        static ofSeconds(arg0: number, arg1: number): Internal.Duration;
        static ofSeconds(arg0: number): Internal.Duration;
        truncatedTo(arg0: Internal.TemporalUnit_): Internal.Duration;
        minusNanos(arg0: number): Internal.Duration;
        getNano(): number;
        toMillisPart(): number;
        plus(arg0: number, arg1: Internal.TemporalUnit_): Internal.Duration;
        plus(arg0: Internal.Duration_): Internal.Duration;
        toMinutesPart(): number;
        toNanos(): number;
        toMinutes(): number;
        toHours(): number;
        plusMillis(arg0: number): Internal.Duration;
        subtractFrom(arg0: Internal.Temporal_): Internal.Temporal;
        toSecondsPart(): number;
        static ofMillis(arg0: number): Internal.Duration;
        minus(arg0: number, arg1: Internal.TemporalUnit_): Internal.Duration;
        minus(arg0: Internal.Duration_): Internal.Duration;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        minusHours(arg0: number): Internal.Duration;
        notifyAll(): void;
        withSeconds(arg0: number): Internal.Duration;
        minusMillis(arg0: number): Internal.Duration;
        plusMinutes(arg0: number): Internal.Duration;
        notify(): void;
        toSeconds(): number;
        dividedBy(arg0: number): Internal.Duration;
        dividedBy(arg0: Internal.Duration_): number;
        minusMinutes(arg0: number): Internal.Duration;
        plusDays(arg0: number): Internal.Duration;
        hashCode(): number;
        static of(arg0: number, arg1: Internal.TemporalUnit_): Internal.Duration;
        get(arg0: Internal.TemporalUnit_): number;
        isZero(): boolean;
        toDays(): number;
        toNanosPart(): number;
        isNegative(): boolean;
        static ofDays(arg0: number): Internal.Duration;
        static parse(arg0: Internal.CharSequence_): Internal.Duration;
        minusDays(arg0: number): Internal.Duration;
        toHoursPart(): number;
        toDaysPart(): number;
        static ofNanos(arg0: number): Internal.Duration;
        getSeconds(): number;
        abs(): Internal.Duration;
        static ofHours(arg0: number): Internal.Duration;
        withNanos(arg0: number): Internal.Duration;
        equals(arg0: any): boolean;
        getUnits(): Internal.List<Internal.TemporalUnit>;
        addTo(arg0: Internal.Temporal_): Internal.Temporal;
        toString(): string;
        minusSeconds(arg0: number): Internal.Duration;
        static readonly ZERO : Internal.Duration;
        get zero(): boolean;
        get negative(): boolean;
        get seconds(): number;
        get nano(): number;
        get positive(): boolean;
        get units(): Internal.List<Internal.TemporalUnit>;
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    type Duration_ = Duration;
    /**
    */
    abstract class Text implements Internal.Iterable<Internal.Text>, Internal.Comparable<Internal.Text>, Internal.JsonSerializable, Internal.WrappedJS {
        getClass(): Internal.Class<any>;
        rawCopy(): Internal.Text;
        hasStyle(): boolean;
        compareTo(other: Internal.Text_): number;
        italic(value: boolean): Internal.Text;
        italic(): Internal.Text;
        static componentOf(o: any): Internal.Component;
        red(): Internal.Text;
        aqua(): Internal.Text;
        iterator(): Internal.Iterator<Internal.Text>;
        white(): Internal.Text;
        noColor(): Internal.Text;
        darkPurple(): Internal.Text;
        static join(separator: Internal.Text_, texts: Internal.Iterable_<Internal.Text_>): Internal.Text;
        obfuscated(): Internal.Text;
        obfuscated(value: boolean): Internal.Text;
        write(buffer: Internal.FriendlyByteBuf_): void;
        static read(buffer: Internal.FriendlyByteBuf_): Internal.Text;
        spliterator(): Internal.Spliterator<Internal.Text>;
        getSiblings(): Internal.List<Internal.Text>;
        bold(value: boolean): Internal.Text;
        bold(): Internal.Text;
        click(value: string): Internal.Text;
        toJson(): Internal.JsonElement;
        darkGray(): Internal.Text;
        insertion(value: string): Internal.Text;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        color(c: Internal.Color_): Internal.Text;
        notifyAll(): void;
        yellow(): Internal.Text;
        darkBlue(): Internal.Text;
        notify(): void;
        gold(): Internal.Text;
        hover(text: any): Internal.Text;
        gray(): Internal.Text;
        darkRed(): Internal.Text;
        hashCode(): number;
        static of(o: any): Internal.Text;
        strikethrough(): Internal.Text;
        strikethrough(value: boolean): Internal.Text;
        copy(): Internal.Text;
        rawComponent(): Internal.MutableComponent;
        createStyleJson(): Internal.JsonObject;
        hasSiblings(): boolean;
        green(): Internal.Text;
        darkGreen(): Internal.Text;
        forEach(arg0: Internal.Consumer_<Internal.Text_>): void;
        lightPurple(): Internal.Text;
        black(): Internal.Text;
        getString(): string;
        getStyleAndSiblingJson(): Internal.JsonObject;
        darkAqua(): Internal.Text;
        component(): Internal.Component;
        blue(): Internal.Text;
        underlined(): Internal.Text;
        underlined(value: boolean): Internal.Text;
        equals(obj: any): boolean;
        toString(): string;
        createStyle(): Internal.Style;
        append(sibling: any): Internal.Text;
        font(value: string): Internal.Text;
        get siblings(): Internal.List<Internal.Text>;
        get string(): string;
        get styleAndSiblingJson(): Internal.JsonObject;
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    /**
    */
    type Text_ = string | Text;
    class SlabBlockBuilder extends Internal.ShapedBlockBuilder {
        noItem(): Internal.BlockBuilder;
        suffocating(b: boolean): Internal.BlockBuilder;
        getClass(): Internal.Class<any>;
        translationKey(key: string): Internal.BuilderBase<Internal.Block>;
        newID(pre: string, post: string): ResourceLocation;
        type(type: string): Internal.BuilderBase<Internal.Block>;
        unbreakable(): Internal.BlockBuilder;
        model(m: string): Internal.BlockBuilder;
        tag(tag: ResourceLocation_): Internal.BlockBuilder;
        generateDataJsons(generator: Internal.DataJsonGenerator_): void;
        tagBoth(tag: ResourceLocation_): Internal.BlockBuilder;
        defaultCutout(): Internal.BlockBuilder;
        item(i: Internal.Consumer_<Internal.BlockItemBuilder_>): Internal.BlockBuilder;
        resistance(r: number): Internal.BlockBuilder;
        hardness(h: number): Internal.BlockBuilder;
        slipperiness(f: number): Internal.BlockBuilder;
        getRegistryType(): Internal.RegistryObjectBuilderTypes<Internal.Block>;
        textureSide(direction: Internal.Direction_, tex: string): Internal.BlockBuilder;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        clientRegistry(minecraft: Internal.Minecraft_): void;
        waterlogged(): Internal.BlockBuilder;
        transformObject(obj: Internal.Block_): Internal.Block;
        color(index: number, c: Internal.Color_): Internal.BlockBuilder;
        textureAll(tex: string): Internal.BlockBuilder;
        displayName(name: string): Internal.BuilderBase<Internal.Block>;
        notifyAll(): void;
        box(x0: number, y0: number, z0: number, x1: number, y1: number, z1: number): Internal.BlockBuilder;
        box(x0: number, y0: number, z0: number, x1: number, y1: number, z1: number, scale16: boolean): Internal.BlockBuilder;
        viewBlocking(b: boolean): Internal.BlockBuilder;
        notify(): void;
        transparent(b: boolean): Internal.BlockBuilder;
        createAdditionalObjects(): void;
        tagBlock(tag: ResourceLocation_): Internal.BlockBuilder;
        fullBlock(f: boolean): Internal.BlockBuilder;
        createProperties(): Internal.BlockBehaviour$Properties;
        notSolid(): Internal.BlockBuilder;
        generateBlockModels(builder: Internal.BlockBuilder_): Internal.Map<ResourceLocation, Internal.JsonObject>;
        hashCode(): number;
        noCollission(): Internal.BlockBuilder;
        get(): Internal.Block;
        requiresTool(f: boolean): Internal.BlockBuilder;
        renderType(l: string): Internal.BlockBuilder;
        jumpFactor(f: number): Internal.BlockBuilder;
        createShape(): Internal.VoxelShape;
        generateAssetJsons(generator: Internal.AssetJsonGenerator_): void;
        noCollision(): Internal.BlockBuilder;
        opaque(o: boolean): Internal.BlockBuilder;
        randomTick(randomTickCallback: Internal.Consumer_<Internal.RandomTickCallbackJS_>): Internal.BlockBuilder;
        getTranslationKeyGroup(): string;
        texture(id: string, tex: string): Internal.BlockBuilder;
        noDrops(): Internal.BlockBuilder;
        generateLang(lang: Internal.Map_<string, string>): void;
        tagItem(tag: ResourceLocation_): Internal.BlockBuilder;
        speedFactor(f: number): Internal.BlockBuilder;
        noValidSpawns(b: boolean): Internal.BlockBuilder;
        createObject(): Internal.Block;
        lightLevel(light: number): Internal.BlockBuilder;
        addResourcePackLocations(path: string, list: Internal.List_<ResourceLocation_>, packType: Internal.PackType_): void;
        defaultTranslucent(): Internal.BlockBuilder;
        material(m: Internal.MaterialJS_): Internal.BlockBuilder;
        equals(arg0: any): boolean;
        toString(): string;
        redstoneConductor(b: boolean): Internal.BlockBuilder;
        lootTable : ((arg0: Internal.LootBuilder) => void);
        modelJson : Internal.JsonObject;
        blockstateJson : Internal.JsonObject;
        readonly id : ResourceLocation;
        randomTickCallback : ((arg0: Internal.RandomTickCallbackJS) => void);
        get registryType(): Internal.RegistryObjectBuilderTypes<Internal.Block>;
        get class(): Internal.Class<any>;
        get translationKeyGroup(): string;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    type SlabBlockBuilder_ = SlabBlockBuilder;
    abstract class UnmodifiableListIterator <E> extends Internal.UnmodifiableIterator<E> implements Internal.ListIterator<E> {
        next(): E;
        add(arg0: E): void;
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        set(arg0: E): void;
        previous(): E;
        notifyAll(): void;
        hasNext(): boolean;
        nextIndex(): number;
        notify(): void;
        remove(): void;
        hashCode(): number;
        equals(arg0: any): boolean;
        hasPrevious(): boolean;
        toString(): string;
        forEachRemaining(arg0: Internal.Consumer_<E>): void;
        previousIndex(): number;
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    type UnmodifiableListIterator_<E> = UnmodifiableListIterator<E>;
    interface Codec <A> extends Internal.Encoder<A>, Internal.Decoder<A> {
        encode<T_>(arg0: A, arg1: Internal.DynamicOps_<T_>, arg2: T_): Internal.DataResult<T_>;
        flatComapMap<S_>(arg0: java_.util.function_.Function_<A, S_>, arg1: java_.util.function_.Function_<S_, Internal.DataResult_<A>>): Internal.Codec<S_>;
        dispatch<E_>(arg0: java_.util.function_.Function_<E_, A>, arg1: java_.util.function_.Function_<A, Internal.Codec_<E_>>): Internal.Codec<E_>;
        dispatch<E_>(arg0: string, arg1: java_.util.function_.Function_<E_, A>, arg2: java_.util.function_.Function_<A, Internal.Codec_<E_>>): Internal.Codec<E_>;
        deprecated(arg0: number): Internal.Codec<A>;
        simple(): Internal.Decoder$Simple<A>;
        dispatchMap<E_>(arg0: string, arg1: java_.util.function_.Function_<E_, A>, arg2: java_.util.function_.Function_<A, Internal.Codec_<E_>>): Internal.MapCodec<E_>;
        dispatchMap<E_>(arg0: java_.util.function_.Function_<E_, A>, arg1: java_.util.function_.Function_<A, Internal.Codec_<E_>>): Internal.MapCodec<E_>;
        decode<T_>(arg0: Internal.DynamicOps_<T_>, arg1: T_): Internal.DataResult<Internal.Pair<A, T_>>;
        decode<T_>(arg0: Internal.Dynamic_<T_>): Internal.DataResult<Internal.Pair<A, T_>>;
        comapFlatMap<S_>(arg0: java_.util.function_.Function_<A, Internal.DataResult_<S_>>, arg1: java_.util.function_.Function_<S_, A>): Internal.Codec<S_>;
        promotePartial(arg0: Internal.Consumer_<string>): Internal.Codec<A>;
        flatXmap<S_>(arg0: java_.util.function_.Function_<A, Internal.DataResult_<S_>>, arg1: java_.util.function_.Function_<S_, Internal.DataResult_<A>>): Internal.Codec<S_>;
        comap<B_>(arg0: java_.util.function_.Function_<B_, A>): Internal.Encoder<B_>;
        fieldOf(arg0: string): Internal.MapCodec<A>;
        xmap<S_>(arg0: java_.util.function_.Function_<A, S_>, arg1: java_.util.function_.Function_<S_, A>): Internal.Codec<S_>;
        listOf(): Internal.Codec<Internal.List<A>>;
        map<B_>(arg0: java_.util.function_.Function_<A, B_>): Internal.Decoder<B_>;
        encodeStart<T_>(arg0: Internal.DynamicOps_<T_>, arg1: A): Internal.DataResult<T_>;
        optionalFieldOf(arg0: string, arg1: A, arg2: Internal.Lifecycle_): Internal.MapCodec<A>;
        optionalFieldOf(arg0: string, arg1: A): Internal.MapCodec<A>;
        optionalFieldOf(arg0: string): Internal.MapCodec<Internal.Optional<A>>;
        optionalFieldOf(arg0: string, arg1: Internal.Lifecycle_, arg2: A, arg3: Internal.Lifecycle_): Internal.MapCodec<A>;
        flatComap<B_>(arg0: java_.util.function_.Function_<B_, Internal.DataResult_<A>>): Internal.Encoder<B_>;
        partialDispatch<E_>(arg0: string, arg1: java_.util.function_.Function_<E_, Internal.DataResult_<A>>, arg2: java_.util.function_.Function_<A, Internal.DataResult_<Internal.Codec_<E_>>>): Internal.Codec<E_>;
        terminal(): Internal.Decoder$Terminal<A>;
        parse<T_>(arg0: Internal.DynamicOps_<T_>, arg1: T_): Internal.DataResult<A>;
        parse<T_>(arg0: Internal.Dynamic_<T_>): Internal.DataResult<A>;
        withLifecycle(arg0: Internal.Lifecycle_): Internal.Codec<A>;
        orElse(arg0: A): Internal.Codec<A>;
        orElse(arg0: Internal.Consumer_<string>, arg1: A): Internal.Codec<A>;
        orElse(arg0: Internal.UnaryOperator_<string>, arg1: A): Internal.Codec<A>;
        flatMap<B_>(arg0: java_.util.function_.Function_<A, Internal.DataResult_<B_>>): Internal.Decoder<B_>;
        boxed(): Internal.Decoder$Boxed<A>;
        dispatchStable<E_>(arg0: java_.util.function_.Function_<E_, A>, arg1: java_.util.function_.Function_<A, Internal.Codec_<E_>>): Internal.Codec<E_>;
        orElseGet(arg0: Internal.Consumer_<string>, arg1: Internal.Supplier_<A>): Internal.Codec<A>;
        orElseGet(arg0: Internal.Supplier_<A>): Internal.Codec<A>;
        orElseGet(arg0: Internal.UnaryOperator_<string>, arg1: Internal.Supplier_<A>): Internal.Codec<A>;
        stable(): Internal.Codec<A>;
        mapResult(arg0: Internal.Codec$ResultFunction_<A>): Internal.Codec<A>;
    }
    type Codec_<A> = Codec<A>;
    interface BlockKJS extends Internal.BlockBuilderProvider {
        getBlockStatesKJS(): Internal.List<Internal.BlockState>;
        setSoundTypeKJS(arg0: Internal.SoundType_): void;
        getBlockBuilderKJS(): Internal.BlockBuilder;
        setExplosionResistanceKJS(arg0: number): void;
        setBlockBuilderKJS(arg0: Internal.BlockBuilder_): void;
        getTypeDataKJS(): Internal.CompoundTag;
        setJumpFactorKJS(arg0: number): void;
        setSpeedFactorKJS(arg0: number): void;
        setFrictionKJS(arg0: number): void;
        setIsRandomlyTickingKJS(arg0: boolean): void;
        setHasCollisionKJS(arg0: boolean): void;
        setMaterialKJS(arg0: Internal.Material_): void;
    }
    type BlockKJS_ = BlockKJS;
    interface MinecraftServerKJS extends Internal.AsKJS {
        getReloadableResourcesKJS(): Internal.MinecraftServer$ReloadableResources;
        asKJS(): any;
    }
    type MinecraftServerKJS_ = MinecraftServerKJS;
    abstract class FocusTraversalPolicy {
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        getInitialComponent(arg0: java_.awt.Window_): java_.awt.Component;
        getComponentBefore(arg0: Internal.Container_, arg1: java_.awt.Component_): java_.awt.Component;
        hashCode(): number;
        notifyAll(): void;
        equals(arg0: any): boolean;
        getFirstComponent(arg0: Internal.Container_): java_.awt.Component;
        toString(): string;
        getLastComponent(arg0: Internal.Container_): java_.awt.Component;
        getComponentAfter(arg0: Internal.Container_, arg1: java_.awt.Component_): java_.awt.Component;
        notify(): void;
        getDefaultComponent(arg0: Internal.Container_): java_.awt.Component;
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    type FocusTraversalPolicy_ = FocusTraversalPolicy;
    interface IForgeItemStack extends Internal.ICapabilitySerializable<Internal.CompoundTag> {
        canElytraFly(arg0: Internal.LivingEntity_): boolean;
        getCapability<T_>(arg0: Internal.Capability_<T_>, arg1: Internal.Direction_): Internal.LazyOptional<T_>;
        getCapability<T_>(arg0: Internal.Capability_<T_>): Internal.LazyOptional<T_>;
        canEquip(arg0: EquipmentSlot_, arg1: Internal.Entity_): boolean;
        canPerformAction(arg0: Internal.ToolAction_): boolean;
        onBlockStartBreak(arg0: BlockPos_, arg1: Internal.Player_): boolean;
        onHorseArmorTick(arg0: Internal.Level_, arg1: Internal.Mob_): void;
        shouldCauseBlockBreakReset(arg0: Internal.ItemStack_): boolean;
        getItemEnchantability(): number;
        getEntityLifespan(arg0: Internal.Level_): number;
        serializeNBT(): Internal.CompoundTag;
        getXpRepairRatio(): number;
        getHighlightTip(arg0: Internal.Component_): Internal.Component;
        readShareTag(arg0: Internal.CompoundTag_): void;
        canWalkOnPowderedSnow(arg0: Internal.LivingEntity_): boolean;
        onEntityItemUpdate(arg0: Internal.ItemEntity_): boolean;
        onArmorTick(arg0: Internal.Level_, arg1: Internal.Player_): void;
        isBookEnchantable(arg0: Internal.ItemStack_): boolean;
        hasContainerItem(): boolean;
        canDisableShield(arg0: Internal.ItemStack_, arg1: Internal.LivingEntity_, arg2: Internal.LivingEntity_): boolean;
        getFoodProperties(arg0: Internal.LivingEntity_): Internal.FoodProperties;
        doesSneakBypassUse(arg0: Internal.LevelReader_, arg1: BlockPos_, arg2: Internal.Player_): boolean;
        onItemUseFirst(arg0: Internal.UseOnContext_): Internal.InteractionResult;
        deserializeNBT(arg0: Internal.CompoundTag_): void;
        getContainerItem(): Internal.ItemStack;
        onUsingTick(arg0: Internal.LivingEntity_, arg1: number): void;
        isPiglinCurrency(): boolean;
        getSweepHitBox(arg0: Internal.Player_, arg1: Internal.Entity_): Internal.AABB;
        onDestroyed(arg0: Internal.ItemEntity_, arg1: Internal.DamageSource_): void;
        isRepairable(): boolean;
        getEquipmentSlot(): EquipmentSlot;
        getShareTag(): Internal.CompoundTag;
        getBurnTime(arg0: Internal.RecipeType_<any>): number;
        onDroppedByPlayer(arg0: Internal.Player_): boolean;
        onEntitySwing(arg0: Internal.LivingEntity_): boolean;
        equals(arg0: Internal.ItemStack_, arg1: boolean): boolean;
        elytraFlightTick(arg0: Internal.LivingEntity_, arg1: number): boolean;
        makesPiglinsNeutral(arg0: Internal.LivingEntity_): boolean;
        isEnderMask(arg0: Internal.Player_, arg1: Internal.EnderMan_): boolean;
        areShareTagsEqual(arg0: Internal.ItemStack_): boolean;
        canApplyAtEnchantingTable(arg0: Internal.Enchantment_): boolean;
    }
    type IForgeItemStack_ = IForgeItemStack;
    class Proxy {
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        address(): Internal.SocketAddress;
        hashCode(): number;
        notifyAll(): void;
        equals(arg0: any): boolean;
        toString(): string;
        type(): Internal.Proxy$Type;
        notify(): void;
        static readonly NO_PROXY : Internal.Proxy;
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    type Proxy_ = Proxy;
    abstract class AbstractLong2ObjectFunction <V> implements Internal.Long2ObjectFunction<V>, Internal.Serializable {
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        getOrDefault(arg0: number, arg1: V): V;
        getOrDefault(arg0: any, arg1: V): V;
        notifyAll(): void;
        andThenShort(arg0: Internal.Object2ShortFunction_<V>): Internal.Long2ShortFunction;
        composeByte(arg0: Internal.Byte2LongFunction_): Internal.Byte2ObjectFunction<V>;
        andThenInt(arg0: Internal.Object2IntFunction_<V>): Internal.Long2IntFunction;
        andThen<V_>(arg0: java_.util.function_.Function_<V, V_>): java_.util.function_.Function<number, V_>;
        composeReference<T_>(arg0: Internal.Reference2LongFunction_<T_>): Internal.Reference2ObjectFunction<T_, V>;
        put(arg0: number, arg1: V): V;
        remove(arg0: any): V;
        remove(arg0: number): V;
        notify(): void;
        defaultReturnValue(arg0: V): void;
        defaultReturnValue(): V;
        andThenDouble(arg0: Internal.Object2DoubleFunction_<V>): Internal.Long2DoubleFunction;
        andThenObject<T_>(arg0: Internal.Object2ObjectFunction_<V, T_>): Internal.Long2ObjectFunction<T_>;
        hashCode(): number;
        get(arg0: any): V;
        get(arg0: number): V;
        andThenLong(arg0: Internal.Object2LongFunction_<V>): Internal.Long2LongFunction;
        composeLong(arg0: Internal.Long2LongFunction_): Internal.Long2ObjectFunction<V>;
        andThenByte(arg0: Internal.Object2ByteFunction_<V>): Internal.Long2ByteFunction;
        andThenFloat(arg0: Internal.Object2FloatFunction_<V>): Internal.Long2FloatFunction;
        apply(arg0: number): V;
        containsKey(arg0: any): boolean;
        containsKey(arg0: number): boolean;
        composeInt(arg0: Internal.Int2LongFunction_): Internal.Int2ObjectFunction<V>;
        clear(): void;
        composeFloat(arg0: Internal.Float2LongFunction_): Internal.Float2ObjectFunction<V>;
        andThenChar(arg0: Internal.Object2CharFunction_<V>): Internal.Long2CharFunction;
        composeObject<T_>(arg0: Internal.Object2LongFunction_<T_>): Internal.Object2ObjectFunction<T_, V>;
        size(): number;
        compose<T_>(arg0: java_.util.function_.Function_<T_, number>): java_.util.function_.Function<T_, V>;
        composeShort(arg0: Internal.Short2LongFunction_): Internal.Short2ObjectFunction<V>;
        equals(arg0: any): boolean;
        andThenReference<T_>(arg0: Internal.Object2ReferenceFunction_<V, T_>): Internal.Long2ReferenceFunction<T_>;
        composeChar(arg0: Internal.Char2LongFunction_): Internal.Char2ObjectFunction<V>;
        toString(): string;
        composeDouble(arg0: Internal.Double2LongFunction_): Internal.Double2ObjectFunction<V>;
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    type AbstractLong2ObjectFunction_<V> = AbstractLong2ObjectFunction<V>;
    interface ChannelInboundHandler extends Internal.ChannelHandler {
        channelInactive(arg0: Internal.ChannelHandlerContext_): void;
        channelUnregistered(arg0: Internal.ChannelHandlerContext_): void;
        channelReadComplete(arg0: Internal.ChannelHandlerContext_): void;
        exceptionCaught(arg0: Internal.ChannelHandlerContext_, arg1: Internal.Throwable_): void;
        channelActive(arg0: Internal.ChannelHandlerContext_): void;
        handlerAdded(arg0: Internal.ChannelHandlerContext_): void;
        userEventTriggered(arg0: Internal.ChannelHandlerContext_, arg1: any): void;
        channelRegistered(arg0: Internal.ChannelHandlerContext_): void;
        handlerRemoved(arg0: Internal.ChannelHandlerContext_): void;
        channelWritabilityChanged(arg0: Internal.ChannelHandlerContext_): void;
        channelRead(arg0: Internal.ChannelHandlerContext_, arg1: any): void;
    }
    type ChannelInboundHandler_ = ChannelInboundHandler;
    interface EntityAccess {
    }
    type EntityAccess_ = EntityAccess;
    class OffsetDateTime implements Internal.Temporal, Internal.TemporalAdjuster, Internal.Comparable<Internal.OffsetDateTime>, Internal.Serializable {
        getClass(): Internal.Class<any>;
        plusHours(arg0: number): Internal.OffsetDateTime;
        isEqual(arg0: Internal.OffsetDateTime_): boolean;
        toLocalTime(): Internal.LocalTime;
        compareTo(arg0: Internal.OffsetDateTime_): number;
        withOffsetSameLocal(arg0: Internal.ZoneOffset_): Internal.OffsetDateTime;
        getDayOfWeek(): Internal.DayOfWeek;
        plusSeconds(arg0: number): Internal.OffsetDateTime;
        getMinute(): number;
        static from(arg0: Internal.TemporalAccessor_): Internal.OffsetDateTime;
        getMonth(): Internal.Month;
        plusNanos(arg0: number): Internal.OffsetDateTime;
        atZoneSameInstant(arg0: Internal.ZoneId_): Internal.ZonedDateTime;
        withHour(arg0: number): Internal.OffsetDateTime;
        plusMonths(arg0: number): Internal.OffsetDateTime;
        plusYears(arg0: number): Internal.OffsetDateTime;
        truncatedTo(arg0: Internal.TemporalUnit_): Internal.OffsetDateTime;
        query<R_>(arg0: Internal.TemporalQuery_<R_>): R_;
        minusNanos(arg0: number): Internal.OffsetDateTime;
        getNano(): number;
        format(arg0: Internal.DateTimeFormatter_): string;
        isSupported(arg0: Internal.TemporalUnit_): boolean;
        isSupported(arg0: Internal.TemporalField_): boolean;
        plus(arg0: number, arg1: Internal.TemporalUnit_): Internal.OffsetDateTime;
        plus(arg0: Internal.TemporalAmount_): Internal.OffsetDateTime;
        getYear(): number;
        toEpochSecond(): number;
        toLocalDateTime(): Internal.LocalDateTime;
        withDayOfMonth(arg0: number): Internal.OffsetDateTime;
        withMonth(arg0: number): Internal.OffsetDateTime;
        isAfter(arg0: Internal.OffsetDateTime_): boolean;
        static ofInstant(arg0: Internal.Instant_, arg1: Internal.ZoneId_): Internal.OffsetDateTime;
        minus(arg0: number, arg1: Internal.TemporalUnit_): Internal.OffsetDateTime;
        minus(arg0: Internal.TemporalAmount_): Internal.OffsetDateTime;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        toOffsetTime(): Internal.OffsetTime;
        minusHours(arg0: number): Internal.OffsetDateTime;
        notifyAll(): void;
        getOffset(): Internal.ZoneOffset;
        adjustInto(arg0: Internal.Temporal_): Internal.Temporal;
        range(arg0: Internal.TemporalField_): Internal.ValueRange;
        withYear(arg0: number): Internal.OffsetDateTime;
        plusMinutes(arg0: number): Internal.OffsetDateTime;
        notify(): void;
        minusMinutes(arg0: number): Internal.OffsetDateTime;
        plusDays(arg0: number): Internal.OffsetDateTime;
        atZoneSimilarLocal(arg0: Internal.ZoneId_): Internal.ZonedDateTime;
        hashCode(): number;
        static now(arg0: Internal.Clock_): Internal.OffsetDateTime;
        static now(): Internal.OffsetDateTime;
        static now(arg0: Internal.ZoneId_): Internal.OffsetDateTime;
        static of(arg0: number, arg1: number, arg2: number, arg3: number, arg4: number, arg5: number, arg6: number, arg7: Internal.ZoneOffset_): Internal.OffsetDateTime;
        static of(arg0: Internal.LocalDateTime_, arg1: Internal.ZoneOffset_): Internal.OffsetDateTime;
        static of(arg0: Internal.LocalDate_, arg1: Internal.LocalTime_, arg2: Internal.ZoneOffset_): Internal.OffsetDateTime;
        get(arg0: Internal.TemporalField_): number;
        getDayOfYear(): number;
        plusWeeks(arg0: number): Internal.OffsetDateTime;
        getHour(): number;
        withMinute(arg0: number): Internal.OffsetDateTime;
        getMonthValue(): number;
        toZonedDateTime(): Internal.ZonedDateTime;
        minusYears(arg0: number): Internal.OffsetDateTime;
        minusWeeks(arg0: number): Internal.OffsetDateTime;
        withDayOfYear(arg0: number): Internal.OffsetDateTime;
        static parse(arg0: Internal.CharSequence_): Internal.OffsetDateTime;
        static parse(arg0: Internal.CharSequence_, arg1: Internal.DateTimeFormatter_): Internal.OffsetDateTime;
        toInstant(): Internal.Instant;
        isBefore(arg0: Internal.OffsetDateTime_): boolean;
        minusDays(arg0: number): Internal.OffsetDateTime;
        withNano(arg0: number): Internal.OffsetDateTime;
        getLong(arg0: Internal.TemporalField_): number;
        minusMonths(arg0: number): Internal.OffsetDateTime;
        with(arg0: Internal.TemporalAdjuster_): Internal.OffsetDateTime;
        with(arg0: Internal.TemporalField_, arg1: number): Internal.OffsetDateTime;
        toLocalDate(): Internal.LocalDate;
        withOffsetSameInstant(arg0: Internal.ZoneOffset_): Internal.OffsetDateTime;
        equals(arg0: any): boolean;
        getSecond(): number;
        static timeLineOrder(): Internal.Comparator<Internal.OffsetDateTime>;
        until(arg0: Internal.Temporal_, arg1: Internal.TemporalUnit_): number;
        toString(): string;
        getDayOfMonth(): number;
        minusSeconds(arg0: number): Internal.OffsetDateTime;
        withSecond(arg0: number): Internal.OffsetDateTime;
        static readonly MIN : Internal.OffsetDateTime;
        static readonly MAX : Internal.OffsetDateTime;
        get dayOfWeek(): Internal.DayOfWeek;
        get month(): Internal.Month;
        get offset(): Internal.ZoneOffset;
        get hour(): number;
        get year(): number;
        get dayOfYear(): number;
        get dayOfMonth(): number;
        get monthValue(): number;
        get nano(): number;
        get class(): Internal.Class<any>;
        get minute(): number;
        get second(): number;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    type OffsetDateTime_ = OffsetDateTime;
    class MobSpawnSettings$MobSpawnCost {
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        hashCode(): number;
        notifyAll(): void;
        equals(arg0: any): boolean;
        toString(): string;
        notify(): void;
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    type MobSpawnSettings$MobSpawnCost_ = MobSpawnSettings$MobSpawnCost;
    interface ForgeItemAccessor {
        inc$setRenderProperties(arg0: any): void;
    }
    type ForgeItemAccessor_ = ForgeItemAccessor;
    class QuestShape extends Internal.Icon {
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        notifyAll(): void;
        getShapePixels(): Internal.PixelBuffer;
        withTint(color: Internal.Color4I_): Internal.Icon;
        notify(): void;
        createPixelBuffer(): Internal.PixelBuffer;
        static reload(list: Internal.List_<string>): void;
        hashCode(): number;
        static get(id: string): Internal.QuestShape;
        copy(): Internal.Icon;
        hasPixelBuffer(): boolean;
        combineWith(icon: Internal.Icon_): Internal.Icon;
        combineWith(icons: Internal.Icon_[]): Internal.Icon;
        getJson(): Internal.JsonElement;
        drawStatic(matrixStack: Internal.PoseStack_, x: number, y: number, w: number, h: number): void;
        withBorder(color: Internal.Color4I_, roundEdges: boolean): Internal.Icon;
        withColor(color: Internal.Color4I_): Internal.Icon;
        isEmpty(): boolean;
        withUV(x: number, y: number, w: number, h: number, tw: number, th: number): Internal.Icon;
        withUV(u0: number, v0: number, u1: number, v1: number): Internal.Icon;
        draw(matrixStack: Internal.PoseStack_, x: number, y: number, w: number, h: number): void;
        draw3D(matrixStack: Internal.PoseStack_): void;
        static getIcon(json: Internal.JsonElement_): Internal.Icon;
        static getIcon(id: ResourceLocation_): Internal.Icon;
        static getIcon(id: string): Internal.Icon;
        getIngredient(): any;
        equals(o: any): boolean;
        withPadding(padding: number): Internal.Icon;
        toString(): string;
        readonly outline : Internal.ImageIcon;
        static idMapWithDefault : Internal.NameMap<string>;
        readonly shape : Internal.ImageIcon;
        readonly background : Internal.ImageIcon;
        static idMap : Internal.NameMap<string>;
        readonly id : string;
        static readonly MAP : {"circle":Internal.QuestShape,"square":Internal.QuestShape,"rsquare":Internal.QuestShape,"diamond":Internal.QuestShape,"pentagon":Internal.QuestShape,"hexagon":Internal.QuestShape,"octagon":Internal.QuestShape,"heart":Internal.QuestShape,"gear":Internal.QuestShape};
        static readonly EMPTY : Internal.Color4I;
        get shapePixels(): Internal.PixelBuffer;
        get ingredient(): any;
        get json(): Internal.JsonElement;
        get class(): Internal.Class<any>;
        get empty(): boolean;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    type QuestShape_ = QuestShape;
    class FTBQuestsKubeJSWrapper {
        getQuestObjectTypes(): Internal.Map<string, Internal.QuestObjectType>;
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        getObject(world: Internal.LevelJS_, id: any): Internal.QuestObjectBase;
        getServerDataFromPlayer(player: Internal.Player_): Internal.FTBQuestsKubeJSPlayerData;
        getQuestShapes(): Internal.Map<string, Internal.QuestShape>;
        notifyAll(): void;
        getFile(world: Internal.LevelJS_): Internal.QuestFile;
        notify(): void;
        hashCode(): number;
        equals(arg0: any): boolean;
        getServerDataFromSource(source: Internal.CommandSourceStack_): Internal.FTBQuestsKubeJSPlayerData;
        toString(): string;
        getData(player: Internal.PlayerJS_<any>): Internal.TeamData;
        getData(world: Internal.LevelJS_, uuid: Internal.UUID_): Internal.TeamData;
        static readonly INSTANCE : Internal.FTBQuestsKubeJSWrapper;
        get questShapes(): Internal.Map<string, Internal.QuestShape>;
        get class(): Internal.Class<any>;
        get questObjectTypes(): Internal.Map<string, Internal.QuestObjectType>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    type FTBQuestsKubeJSWrapper_ = FTBQuestsKubeJSWrapper;
    interface DoubleIterable extends Internal.Iterable<number> {
        iterator(): Internal.DoubleIterator;
        spliterator(): Internal.DoubleSpliterator;
        forEach(arg0: java_.util.function_.DoubleConsumer_): void;
        forEach(arg0: Internal.Consumer_<number>): void;
        forEach(arg0: Internal.DoubleConsumer_): void;
        doubleSpliterator(): Internal.DoubleSpliterator;
        doubleIterator(): Internal.DoubleIterator;
    }
    type DoubleIterable_ = DoubleIterable;
    class Rectangle extends Internal.Rectangle2D implements Internal.Shape, Internal.Serializable {
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        getLocation(): Internal.Point;
        intersects(arg0: Internal.Rectangle_): boolean;
        intersects(arg0: number, arg1: number, arg2: number, arg3: number): boolean;
        intersects(arg0: Internal.Rectangle2D_): boolean;
        notifyAll(): void;
        getFrame(): Internal.Rectangle2D;
        getWidth(): number;
        inside(arg0: number, arg1: number): boolean;
        notify(): void;
        translate(arg0: number, arg1: number): void;
        getBounds(): Internal.Rectangle;
        setFrameFromCenter(arg0: Internal.Point2D_, arg1: Internal.Point2D_): void;
        setFrameFromCenter(arg0: number, arg1: number, arg2: number, arg3: number): void;
        getHeight(): number;
        setSize(arg0: number, arg1: number): void;
        setSize(arg0: Internal.Dimension_): void;
        getPathIterator(arg0: Internal.AffineTransform_): Internal.PathIterator;
        getPathIterator(arg0: Internal.AffineTransform_, arg1: number): Internal.PathIterator;
        setFrame(arg0: number, arg1: number, arg2: number, arg3: number): void;
        setFrame(arg0: Internal.Rectangle2D_): void;
        setFrame(arg0: Internal.Point2D_, arg1: Internal.Dimension2D_): void;
        setLocation(arg0: Internal.Point_): void;
        setLocation(arg0: number, arg1: number): void;
        hashCode(): number;
        intersection(arg0: Internal.Rectangle_): Internal.Rectangle;
        getCenterY(): number;
        getCenterX(): number;
        add(arg0: Internal.Rectangle_): void;
        add(arg0: Internal.Point_): void;
        add(arg0: number, arg1: number): void;
        add(arg0: Internal.Point2D_): void;
        add(arg0: Internal.Rectangle2D_): void;
        move(arg0: number, arg1: number): void;
        grow(arg0: number, arg1: number): void;
        static intersect(arg0: Internal.Rectangle2D_, arg1: Internal.Rectangle2D_, arg2: Internal.Rectangle2D_): void;
        getMaxX(): number;
        isEmpty(): boolean;
        getMaxY(): number;
        setRect(arg0: number, arg1: number, arg2: number, arg3: number): void;
        setRect(arg0: Internal.Rectangle2D_): void;
        reshape(arg0: number, arg1: number, arg2: number, arg3: number): void;
        union(arg0: Internal.Rectangle_): Internal.Rectangle;
        static union(arg0: Internal.Rectangle2D_, arg1: Internal.Rectangle2D_, arg2: Internal.Rectangle2D_): void;
        setBounds(arg0: number, arg1: number, arg2: number, arg3: number): void;
        setBounds(arg0: Internal.Rectangle_): void;
        setFrameFromDiagonal(arg0: number, arg1: number, arg2: number, arg3: number): void;
        setFrameFromDiagonal(arg0: Internal.Point2D_, arg1: Internal.Point2D_): void;
        intersectsLine(arg0: Internal.Line2D_): boolean;
        intersectsLine(arg0: number, arg1: number, arg2: number, arg3: number): boolean;
        getX(): number;
        getSize(): Internal.Dimension;
        contains(arg0: number, arg1: number, arg2: number, arg3: number): boolean;
        contains(arg0: Internal.Rectangle_): boolean;
        contains(arg0: Internal.Point_): boolean;
        contains(arg0: number, arg1: number): boolean;
        contains(arg0: Internal.Point2D_): boolean;
        contains(arg0: Internal.Rectangle2D_): boolean;
        getY(): number;
        createUnion(arg0: Internal.Rectangle2D_): Internal.Rectangle2D;
        outcode(arg0: number, arg1: number): number;
        outcode(arg0: Internal.Point2D_): number;
        equals(arg0: any): boolean;
        clone(): any;
        getBounds2D(): Internal.Rectangle2D;
        resize(arg0: number, arg1: number): void;
        toString(): string;
        createIntersection(arg0: Internal.Rectangle2D_): Internal.Rectangle2D;
        getMinX(): number;
        getMinY(): number;
        static readonly OUT_TOP : 2;
        static readonly OUT_RIGHT : 4;
        x : number;
        width : number;
        y : number;
        static readonly OUT_BOTTOM : 8;
        static readonly OUT_LEFT : 1;
        height : number;
        get centerY(): number;
        get centerX(): number;
        get maxY(): number;
        get maxX(): number;
        get bounds2D(): Internal.Rectangle2D;
        get empty(): boolean;
        get size(): Internal.Dimension;
        get minY(): number;
        get minX(): number;
        get bounds(): Internal.Rectangle;
        get location(): Internal.Point;
        get class(): Internal.Class<any>;
        get frame(): Internal.Rectangle2D;
        set rect(arg0: Internal.Rectangle2D_);
        set size(arg0: Internal.Dimension_);
        set bounds(arg0: Internal.Rectangle_);
        set location(arg0: Internal.Point_);
        set frame(arg0: Internal.Rectangle2D_);
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    type Rectangle_ = Rectangle;
    class RayTraceResultJS {
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        hashCode(): number;
        notifyAll(): void;
        equals(arg0: any): boolean;
        toString(): string;
        notify(): void;
        readonly fromEntity : Internal.EntityJS;
        readonly distance : number;
        hitX : number;
        hitY : number;
        hitZ : number;
        facing : Internal.Direction;
        block : Internal.BlockContainerJS;
        readonly type : string;
        entity : Internal.EntityJS;
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    type RayTraceResultJS_ = RayTraceResultJS;
    interface BlockPredicate {
        check(arg0: Internal.BlockContainerJS_): boolean;
    }
    type BlockPredicate_ = BlockPredicate;
    class NoiseChunk implements Internal.DensityFunction$ContextProvider, Internal.DensityFunction$FunctionContext, Internal.AccessorNoiseChunk {
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        hashCode(): number;
        notifyAll(): void;
        equals(arg0: any): boolean;
        toString(): string;
        notify(): void;
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    type NoiseChunk_ = NoiseChunk;
    class Matrix3f implements Internal.Matrix3fExtended {
        multiplyBackward(arg0: Internal.Matrix3f_): void;
        getClass(): Internal.Class<any>;
        getA20(): number;
        rotate(quaternion: Internal.Quaternion_): void;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        getA10(): number;
        getA21(): number;
        getA00(): number;
        getA22(): number;
        getA11(): number;
        getA01(): number;
        getA12(): number;
        getA02(): number;
        notifyAll(): void;
        notify(): void;
        hashCode(): number;
        equals(arg0: any): boolean;
        transformVecZ(x: number, y: number, z: number): number;
        transformVecZ(dir: Internal.Vector3f_): number;
        transformVecY(x: number, y: number, z: number): number;
        transformVecY(dir: Internal.Vector3f_): number;
        toString(): string;
        transformVecX(x: number, y: number, z: number): number;
        transformVecX(dir: Internal.Vector3f_): number;
        computeNormal(dir: Internal.Direction_): number;
        get a00(): number;
        get a22(): number;
        get a11(): number;
        get a10(): number;
        get a21(): number;
        get a02(): number;
        get a01(): number;
        get a12(): number;
        get class(): Internal.Class<any>;
        get a20(): number;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    type Matrix3f_ = Matrix3f;
    interface IIngredientAcceptor <THIS> {
        addIngredients<I>(arg0: Internal.IIngredientType_<I>, arg1: Internal.List_<I>): THIS;
        addIngredients(arg0: Internal.Ingredient_): THIS;
        addIngredient<I>(arg0: Internal.IIngredientType_<I>, arg1: I): THIS;
        addIngredientsUnsafe(arg0: Internal.List_<any>): THIS;
        addItemStack(arg0: Internal.ItemStack_): THIS;
        addItemStacks(arg0: Internal.List_<Internal.ItemStack_>): THIS;
    }
    type IIngredientAcceptor_<THIS> = IIngredientAcceptor<THIS>;
    interface AttributeSet {
        getResolveParent(): Internal.AttributeSet;
        getAttribute(arg0: any): any;
        containsAttributes(arg0: Internal.AttributeSet_): boolean;
        getAttributeNames(): Internal.Enumeration<any>;
        isEqual(arg0: Internal.AttributeSet_): boolean;
        isDefined(arg0: any): boolean;
        containsAttribute(arg0: any, arg1: any): boolean;
        copyAttributes(): Internal.AttributeSet;
        getAttributeCount(): number;
    }
    type AttributeSet_ = AttributeSet;
    abstract class Dictionary <K, V> {
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        keys(): Internal.Enumeration<K>;
        notifyAll(): void;
        isEmpty(): boolean;
        notify(): void;
        put(arg0: K, arg1: V): V;
        remove(arg0: any): V;
        size(): number;
        hashCode(): number;
        equals(arg0: any): boolean;
        elements(): Internal.Enumeration<V>;
        get(arg0: any): V;
        toString(): string;
        get class(): Internal.Class<any>;
        get empty(): boolean;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    type Dictionary_<K, V> = Dictionary<K, V>;
    class MouseWheelEvent extends Internal.MouseEvent {
        getClass(): Internal.Class<any>;
        setSource(arg0: any): void;
        translatePoint(arg0: number, arg1: number): void;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        getPreciseWheelRotation(): number;
        getLocationOnScreen(): Internal.Point;
        notifyAll(): void;
        isMetaDown(): boolean;
        consume(): void;
        getModifiersEx(): number;
        notify(): void;
        isPopupTrigger(): boolean;
        isShiftDown(): boolean;
        getButton(): number;
        paramString(): string;
        isConsumed(): boolean;
        static getModifiersExText(arg0: number): string;
        hashCode(): number;
        isAltGraphDown(): boolean;
        static getMaskForButton(arg0: number): number;
        getModifiers(): number;
        isAltDown(): boolean;
        getPoint(): Internal.Point;
        static getMouseModifiersText(arg0: number): string;
        isControlDown(): boolean;
        getScrollType(): number;
        getID(): number;
        getUnitsToScroll(): number;
        getScrollAmount(): number;
        getX(): number;
        getY(): number;
        getYOnScreen(): number;
        getSource(): any;
        equals(arg0: any): boolean;
        getWhen(): number;
        getClickCount(): number;
        toString(): string;
        getWheelRotation(): number;
        getComponent(): java_.awt.Component;
        getXOnScreen(): number;
        static readonly ADJUSTMENT_EVENT_MASK : 256;
        static readonly MOUSE_FIRST : 500;
        static readonly BUTTON1_MASK : 16;
        static readonly MOUSE_PRESSED : 501;
        static readonly WHEEL_BLOCK_SCROLL : 1;
        static readonly FOCUS_EVENT_MASK : 4;
        static readonly INVOCATION_EVENT_MASK : 16384;
        static readonly RESERVED_ID_MAX : 1999;
        static readonly BUTTON1 : 1;
        static readonly BUTTON2_MASK : 8;
        static readonly CONTAINER_EVENT_MASK : 2;
        static readonly MOUSE_WHEEL_EVENT_MASK : 131072;
        static readonly ALT_DOWN_MASK : 512;
        static readonly MOUSE_MOTION_EVENT_MASK : 32;
        static readonly BUTTON1_DOWN_MASK : 1024;
        static readonly COMPONENT_SHOWN : 102;
        static readonly MOUSE_LAST : 507;
        static readonly META_DOWN_MASK : 256;
        static readonly BUTTON3_DOWN_MASK : 4096;
        static readonly TEXT_EVENT_MASK : 1024;
        static readonly NOBUTTON : 0;
        static readonly COMPONENT_RESIZED : 101;
        static readonly MOUSE_EVENT_MASK : 16;
        static readonly MOUSE_WHEEL : 507;
        static readonly COMPONENT_EVENT_MASK : 1;
        static readonly PAINT_EVENT_MASK : 8192;
        static readonly SHIFT_MASK : 1;
        static readonly COMPONENT_HIDDEN : 103;
        static readonly INPUT_METHOD_EVENT_MASK : 2048;
        static readonly HIERARCHY_BOUNDS_EVENT_MASK : 65536;
        static readonly COMPONENT_LAST : 103;
        static readonly ALT_GRAPH_MASK : 32;
        static readonly KEY_EVENT_MASK : 8;
        static readonly WINDOW_EVENT_MASK : 64;
        static readonly MOUSE_EXITED : 505;
        static readonly CTRL_MASK : 2;
        static readonly ALT_MASK : 8;
        static readonly MOUSE_CLICKED : 500;
        static readonly COMPONENT_FIRST : 100;
        static readonly WINDOW_FOCUS_EVENT_MASK : 524288;
        static readonly MOUSE_MOVED : 503;
        static readonly COMPONENT_MOVED : 100;
        static readonly SHIFT_DOWN_MASK : 64;
        static readonly CTRL_DOWN_MASK : 128;
        static readonly BUTTON2 : 2;
        static readonly BUTTON3 : 3;
        static readonly BUTTON2_DOWN_MASK : 2048;
        static readonly ALT_GRAPH_DOWN_MASK : 8192;
        static readonly ACTION_EVENT_MASK : 128;
        static readonly ITEM_EVENT_MASK : 512;
        static readonly MOUSE_RELEASED : 502;
        static readonly BUTTON3_MASK : 4;
        static readonly WHEEL_UNIT_SCROLL : 0;
        static readonly HIERARCHY_EVENT_MASK : 32768;
        static readonly WINDOW_STATE_EVENT_MASK : 262144;
        static readonly META_MASK : 4;
        static readonly MOUSE_ENTERED : 504;
        static readonly MOUSE_DRAGGED : 506;
        get consumed(): boolean;
        get clickCount(): number;
        get yOnScreen(): number;
        get xOnScreen(): number;
        get source(): any;
        get modifiers(): number;
        get when(): number;
        get point(): Internal.Point;
        get button(): number;
        get preciseWheelRotation(): number;
        get scrollType(): number;
        get locationOnScreen(): Internal.Point;
        get metaDown(): boolean;
        get scrollAmount(): number;
        get class(): Internal.Class<any>;
        get altDown(): boolean;
        get wheelRotation(): number;
        get controlDown(): boolean;
        get altGraphDown(): boolean;
        get component(): java_.awt.Component;
        get modifiersEx(): number;
        get shiftDown(): boolean;
        get popupTrigger(): boolean;
        get x(): number;
        get y(): number;
        get iD(): number;
        get unitsToScroll(): number;
        set source(arg0: any);
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    type MouseWheelEvent_ = MouseWheelEvent;
    abstract class ByteBuf implements Internal.ReferenceCounted, Internal.Comparable<Internal.ByteBuf> {
        asReadOnly(): Internal.ByteBuf;
        markReaderIndex(): Internal.ByteBuf;
        getByte(arg0: number): number;
        release(arg0: number): boolean;
        release(): boolean;
        readDoubleLE(): number;
        writeZero(arg0: number): Internal.ByteBuf;
        resetReaderIndex(): Internal.ByteBuf;
        writeFloat(arg0: number): Internal.ByteBuf;
        setLongLE(arg0: number, arg1: number): Internal.ByteBuf;
        readRetainedSlice(arg0: number): Internal.ByteBuf;
        slice(arg0: number, arg1: number): Internal.ByteBuf;
        slice(): Internal.ByteBuf;
        setDoubleLE(arg0: number, arg1: number): Internal.ByteBuf;
        getMediumLE(arg0: number): number;
        readUnsignedIntLE(): number;
        writeFloatLE(arg0: number): Internal.ByteBuf;
        readInt(): number;
        order(arg0: Internal.ByteOrder_): Internal.ByteBuf;
        order(): Internal.ByteOrder;
        writeMedium(arg0: number): Internal.ByteBuf;
        resetWriterIndex(): Internal.ByteBuf;
        writableBytes(): number;
        maxCapacity(): number;
        getUnsignedShort(arg0: number): number;
        bytesBefore(arg0: number, arg1: number, arg2: number): number;
        bytesBefore(arg0: number, arg1: number): number;
        bytesBefore(arg0: number): number;
        nioBufferCount(): number;
        setInt(arg0: number, arg1: number): Internal.ByteBuf;
        getInt(arg0: number): number;
        markWriterIndex(): Internal.ByteBuf;
        isReadable(arg0: number): boolean;
        isReadable(): boolean;
        writeBoolean(arg0: boolean): Internal.ByteBuf;
        setIntLE(arg0: number, arg1: number): Internal.ByteBuf;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        writeLongLE(arg0: number): Internal.ByteBuf;
        setShortLE(arg0: number, arg1: number): Internal.ByteBuf;
        retain(): Internal.ByteBuf;
        retain(arg0: number): Internal.ByteBuf;
        isWritable(arg0: number): boolean;
        isWritable(): boolean;
        notify(): void;
        readChar(): string;
        hasMemoryAddress(): boolean;
        capacity(): number;
        capacity(arg0: number): Internal.ByteBuf;
        readCharSequence(arg0: number, arg1: Internal.Charset_): Internal.CharSequence;
        isReadOnly(): boolean;
        readUnsignedShortLE(): number;
        readDouble(): number;
        readFloat(): number;
        getLongLE(arg0: number): number;
        getBoolean(arg0: number): boolean;
        copy(arg0: number, arg1: number): Internal.ByteBuf;
        copy(): Internal.ByteBuf;
        readShortLE(): number;
        readUnsignedMedium(): number;
        ensureWritable(arg0: number, arg1: boolean): number;
        ensureWritable(arg0: number): Internal.ByteBuf;
        writeInt(arg0: number): Internal.ByteBuf;
        readFloatLE(): number;
        getDoubleLE(arg0: number): number;
        hasArray(): boolean;
        memoryAddress(): number;
        maxFastWritableBytes(): number;
        readableBytes(): number;
        readSlice(arg0: number): Internal.ByteBuf;
        getIntLE(arg0: number): number;
        nioBuffers(): Internal.ByteBuffer[];
        nioBuffers(arg0: number, arg1: number): Internal.ByteBuffer[];
        forEachByteDesc(arg0: number, arg1: number, arg2: Internal.ByteProcessor_): number;
        forEachByteDesc(arg0: Internal.ByteProcessor_): number;
        skipBytes(arg0: number): Internal.ByteBuf;
        getLong(arg0: number): number;
        readLong(): number;
        readShort(): number;
        equals(arg0: any): boolean;
        setZero(arg0: number, arg1: number): Internal.ByteBuf;
        getUnsignedMedium(arg0: number): number;
        readBytes(arg0: number[], arg1: number, arg2: number): Internal.ByteBuf;
        readBytes(arg0: number[]): Internal.ByteBuf;
        readBytes(arg0: Internal.ByteBuf_, arg1: number, arg2: number): Internal.ByteBuf;
        readBytes(arg0: Internal.ByteBuf_, arg1: number): Internal.ByteBuf;
        readBytes(arg0: Internal.ByteBuf_): Internal.ByteBuf;
        readBytes(arg0: Internal.FileChannel_, arg1: number, arg2: number): number;
        readBytes(arg0: Internal.GatheringByteChannel_, arg1: number): number;
        readBytes(arg0: Internal.OutputStream_, arg1: number): Internal.ByteBuf;
        readBytes(arg0: Internal.ByteBuffer_): Internal.ByteBuf;
        readBytes(arg0: number): Internal.ByteBuf;
        readBoolean(): boolean;
        toString(arg0: number, arg1: number, arg2: Internal.Charset_): string;
        toString(arg0: Internal.Charset_): string;
        toString(): string;
        retainedSlice(): Internal.ByteBuf;
        retainedSlice(arg0: number, arg1: number): Internal.ByteBuf;
        readMediumLE(): number;
        setMedium(arg0: number, arg1: number): Internal.ByteBuf;
        isDirect(): boolean;
        setBoolean(arg0: number, arg1: boolean): Internal.ByteBuf;
        getClass(): Internal.Class<any>;
        getFloatLE(arg0: number): number;
        readerIndex(arg0: number): Internal.ByteBuf;
        readerIndex(): number;
        getCharSequence(arg0: number, arg1: number, arg2: Internal.Charset_): Internal.CharSequence;
        setShort(arg0: number, arg1: number): Internal.ByteBuf;
        compareTo(arg0: Internal.ByteBuf_): number;
        getBytes(arg0: number, arg1: Internal.ByteBuf_): Internal.ByteBuf;
        getBytes(arg0: number, arg1: Internal.ByteBuf_, arg2: number): Internal.ByteBuf;
        getBytes(arg0: number, arg1: Internal.ByteBuf_, arg2: number, arg3: number): Internal.ByteBuf;
        getBytes(arg0: number, arg1: Internal.FileChannel_, arg2: number, arg3: number): number;
        getBytes(arg0: number, arg1: Internal.GatheringByteChannel_, arg2: number): number;
        getBytes(arg0: number, arg1: Internal.OutputStream_, arg2: number): Internal.ByteBuf;
        getBytes(arg0: number, arg1: number[]): Internal.ByteBuf;
        getBytes(arg0: number, arg1: number[], arg2: number, arg3: number): Internal.ByteBuf;
        getBytes(arg0: number, arg1: Internal.ByteBuffer_): Internal.ByteBuf;
        unwrap(): Internal.ByteBuf;
        setDouble(arg0: number, arg1: number): Internal.ByteBuf;
        setChar(arg0: number, arg1: number): Internal.ByteBuf;
        refCnt(): number;
        getUnsignedIntLE(arg0: number): number;
        setFloatLE(arg0: number, arg1: number): Internal.ByteBuf;
        getUnsignedInt(arg0: number): number;
        indexOf(arg0: number, arg1: number, arg2: number): number;
        writeByte(arg0: number): Internal.ByteBuf;
        nioBuffer(): Internal.ByteBuffer;
        nioBuffer(arg0: number, arg1: number): Internal.ByteBuffer;
        discardSomeReadBytes(): Internal.ByteBuf;
        touch(arg0: any): Internal.ByteBuf;
        touch(): Internal.ByteBuf;
        duplicate(): Internal.ByteBuf;
        writerIndex(arg0: number): Internal.ByteBuf;
        writerIndex(): number;
        writeCharSequence(arg0: Internal.CharSequence_, arg1: Internal.Charset_): number;
        readUnsignedInt(): number;
        getUnsignedShortLE(arg0: number): number;
        retainedDuplicate(): Internal.ByteBuf;
        getChar(arg0: number): string;
        setLong(arg0: number, arg1: number): Internal.ByteBuf;
        readMedium(): number;
        writeBytes(arg0: Internal.ByteBuffer_): Internal.ByteBuf;
        writeBytes(arg0: Internal.InputStream_, arg1: number): number;
        writeBytes(arg0: Internal.ScatteringByteChannel_, arg1: number): number;
        writeBytes(arg0: Internal.FileChannel_, arg1: number, arg2: number): number;
        writeBytes(arg0: Internal.ByteBuf_): Internal.ByteBuf;
        writeBytes(arg0: Internal.ByteBuf_, arg1: number, arg2: number): Internal.ByteBuf;
        writeBytes(arg0: number[]): Internal.ByteBuf;
        writeBytes(arg0: number[], arg1: number, arg2: number): Internal.ByteBuf;
        writeBytes(arg0: Internal.ByteBuf_, arg1: number): Internal.ByteBuf;
        forEachByte(arg0: number, arg1: number, arg2: Internal.ByteProcessor_): number;
        forEachByte(arg0: Internal.ByteProcessor_): number;
        setIndex(arg0: number, arg1: number): Internal.ByteBuf;
        writeShort(arg0: number): Internal.ByteBuf;
        getShortLE(arg0: number): number;
        alloc(): Internal.ByteBufAllocator;
        getMedium(arg0: number): number;
        readUnsignedShort(): number;
        setByte(arg0: number, arg1: number): Internal.ByteBuf;
        writeShortLE(arg0: number): Internal.ByteBuf;
        maxWritableBytes(): number;
        notifyAll(): void;
        getDouble(arg0: number): number;
        getFloat(arg0: number): number;
        writeLong(arg0: number): Internal.ByteBuf;
        writeIntLE(arg0: number): Internal.ByteBuf;
        array(): number[];
        setCharSequence(arg0: number, arg1: Internal.CharSequence_, arg2: Internal.Charset_): number;
        hashCode(): number;
        internalNioBuffer(arg0: number, arg1: number): Internal.ByteBuffer;
        arrayOffset(): number;
        readIntLE(): number;
        setMediumLE(arg0: number, arg1: number): Internal.ByteBuf;
        readUnsignedByte(): number;
        readUnsignedMediumLE(): number;
        readLongLE(): number;
        writeDouble(arg0: number): Internal.ByteBuf;
        setBytes(arg0: number, arg1: Internal.ByteBuf_): Internal.ByteBuf;
        setBytes(arg0: number, arg1: Internal.ByteBuf_, arg2: number): Internal.ByteBuf;
        setBytes(arg0: number, arg1: Internal.ByteBuf_, arg2: number, arg3: number): Internal.ByteBuf;
        setBytes(arg0: number, arg1: number[]): Internal.ByteBuf;
        setBytes(arg0: number, arg1: Internal.FileChannel_, arg2: number, arg3: number): number;
        setBytes(arg0: number, arg1: Internal.InputStream_, arg2: number): number;
        setBytes(arg0: number, arg1: Internal.ScatteringByteChannel_, arg2: number): number;
        setBytes(arg0: number, arg1: number[], arg2: number, arg3: number): Internal.ByteBuf;
        setBytes(arg0: number, arg1: Internal.ByteBuffer_): Internal.ByteBuf;
        setFloat(arg0: number, arg1: number): Internal.ByteBuf;
        getShort(arg0: number): number;
        writeMediumLE(arg0: number): Internal.ByteBuf;
        clear(): Internal.ByteBuf;
        getUnsignedByte(arg0: number): number;
        discardReadBytes(): Internal.ByteBuf;
        writeChar(arg0: number): Internal.ByteBuf;
        isContiguous(): boolean;
        writeDoubleLE(arg0: number): Internal.ByteBuf;
        getUnsignedMediumLE(arg0: number): number;
        readByte(): number;
        get readable(): boolean;
        get direct(): boolean;
        get readOnly(): boolean;
        get class(): Internal.Class<any>;
        get contiguous(): boolean;
        get writable(): boolean;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    type ByteBuf_ = ByteBuf;
    class ServerTeam extends Internal.Team {
        msg(player: Internal.ServerPlayer_, message: string): number;
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        getName(): Internal.Component;
        notifyAll(): void;
        getHighestRank(playerId: Internal.UUID_): Internal.TeamRank;
        save(): void;
        getId(): Internal.UUID;
        isMember(uuid: Internal.UUID_): boolean;
        getOwner(): Internal.UUID;
        isOfficer(profile: Internal.UUID_): boolean;
        getDescription(): string;
        delete(source: Internal.CommandSourceStack_): number;
        notify(): void;
        getColoredName(): Internal.Component;
        serializeNBT(): Internal.SNBTCompoundTag;
        hashCode(): number;
        info(source: Internal.CommandSourceStack_): number;
        settings(source: Internal.CommandSourceStack_, key: Internal.TeamProperty_<any>, value: string): number;
        isAlly(profile: Internal.UUID_): boolean;
        getProperty<T_>(property: Internal.TeamProperty_<T_>): T_;
        isValid(): boolean;
        getExtraData(): Internal.CompoundTag;
        getColor(): number;
        sendMessage(from: Internal.UUID_, text: Internal.Component_): void;
        deserializeNBT(tag: Internal.CompoundTag_): void;
        getRanked(rank: Internal.TeamRank_): Internal.Map<Internal.UUID, Internal.TeamRank>;
        getOnlineRanked(rank: Internal.TeamRank_): Internal.List<Internal.ServerPlayer>;
        denyInvite(source: Internal.CommandSourceStack_): number;
        isFreeToJoin(): boolean;
        isInvited(profile: Internal.UUID_): boolean;
        getStringID(): string;
        getDisplayName(): string;
        getOnlineMembers(): Internal.List<Internal.ServerPlayer>;
        getType(): Internal.TeamType;
        setProperty<T_>(property: Internal.TeamProperty_<T_>, value: T_): void;
        equals(o: any): boolean;
        toString(): string;
        getMembers(): Internal.Set<Internal.UUID>;
        static readonly FREE_TO_JOIN : Internal.BooleanProperty;
        readonly manager : Internal.TeamManager;
        static readonly DESCRIPTION : Internal.StringProperty;
        static readonly COLOR : Internal.ColorProperty;
        readonly messageHistory : Internal.List<Internal.TeamMessage>;
        static readonly DISPLAY_NAME : Internal.StringProperty;
        readonly properties : Internal.TeamProperties;
        get owner(): Internal.UUID;
        get onlineMembers(): Internal.List<Internal.ServerPlayer>;
        get color(): number;
        get extraData(): Internal.CompoundTag;
        get displayName(): string;
        get description(): string;
        get type(): Internal.TeamType;
        get freeToJoin(): boolean;
        get valid(): boolean;
        get stringID(): string;
        get members(): Internal.Set<Internal.UUID>;
        get name(): Internal.Component;
        get id(): Internal.UUID;
        get class(): Internal.Class<any>;
        get coloredName(): Internal.Component;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    type ServerTeam_ = ServerTeam;
    class Class <T> implements Internal.Serializable, Internal.GenericDeclaration, java_.lang.reflect.Type, Internal.AnnotatedElement, Internal.TypeDescriptor$OfField<Internal.Class<any>>, Internal.Constable {
        getModule(): Internal.Module;
        getClass(): Internal.Class<any>;
        isSealed(): boolean;
        getResource(arg0: string): Internal.URL;
        getName(): string;
        isLocalClass(): boolean;
        isSynthetic(): boolean;
        getCanonicalName(): string;
        getMethod(arg0: string, arg1: Internal.Class_<any>[]): Internal.Method;
        describeConstable(): Internal.Optional<Internal.ClassDesc>;
        getDeclaredFields(): Internal.Field[];
        isMemberClass(): boolean;
        cast(arg0: any): T;
        isInstance(arg0: any): boolean;
        getEnclosingMethod(): Internal.Method;
        getPermittedSubclasses(): Internal.Class<any>[];
        getSigners(): any[];
        getTypeParameters(): any[];
        isInterface(): boolean;
        getPackage(): Internal.Package;
        arrayType(): Internal.Class<any>;
        getNestHost(): Internal.Class<any>;
        asSubclass<U_>(arg0: Internal.Class_<U_>): Internal.Class<U_>;
        getField(arg0: string): Internal.Field;
        descriptorString(): string;
        getInterfaces(): Internal.Class<any>[];
        getAnnotatedInterfaces(): Internal.AnnotatedType[];
        newInstance(): T;
        getFields(): Internal.Field[];
        getAnnotation<A_>(arg0: Internal.Class_<A_>): A_;
        getRecordComponents(): any[];
        getComponentType(): Internal.Class<any>;
        getDeclaredAnnotation<A_>(arg0: Internal.Class_<A_>): A_;
        getSimpleName(): string;
        isArray(): boolean;
        getPackageName(): string;
        getMethods(): Internal.Method[];
        isPrimitive(): boolean;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        isAnnotation(): boolean;
        getProtectionDomain(): Internal.ProtectionDomain;
        getDeclaredConstructors(): Internal.Constructor<any>[];
        isAnnotationPresent(arg0: Internal.Class_<Internal.Annotation_>): boolean;
        notifyAll(): void;
        desiredAssertionStatus(): boolean;
        getNestMembers(): Internal.Class<any>[];
        getGenericInterfaces(): java_.lang.reflect.Type[];
        getClassLoader(): Internal.ClassLoader;
        isAssignableFrom(arg0: Internal.Class_<any>): boolean;
        notify(): void;
        getDeclaredAnnotations(): Internal.Annotation[];
        getDeclaredMethods(): Internal.Method[];
        getDeclaringClass(): Internal.Class<any>;
        getAnnotationsByType<A_>(arg0: Internal.Class_<A_>): A_[];
        getConstructors(): Internal.Constructor<any>[];
        hashCode(): number;
        getAnnotatedSuperclass(): Internal.AnnotatedType;
        toGenericString(): string;
        getModifiers(): number;
        getTypeName(): string;
        getEnclosingConstructor(): Internal.Constructor<any>;
        isNestmateOf(arg0: Internal.Class_<any>): boolean;
        getClasses(): Internal.Class<any>[];
        getSuperclass(): Internal.Class<T>;
        getDeclaredField(arg0: string): Internal.Field;
        componentType(): Internal.Class<any>;
        static forName(arg0: Internal.Module_, arg1: string): Internal.Class<any>;
        static forName(arg0: string, arg1: boolean, arg2: Internal.ClassLoader_): Internal.Class<any>;
        static forName(arg0: string): Internal.Class<any>;
        getResourceAsStream(arg0: string): Internal.InputStream;
        isRecord(): boolean;
        getDeclaredMethod(arg0: string, arg1: Internal.Class_<any>[]): Internal.Method;
        isEnum(): boolean;
        getDeclaredConstructor(arg0: Internal.Class_<any>[]): Internal.Constructor<T>;
        getAnnotations(): Internal.Annotation[];
        getConstructor(arg0: Internal.Class_<any>[]): Internal.Constructor<T>;
        getEnumConstants(): T[];
        isHidden(): boolean;
        getDeclaredAnnotationsByType<A_>(arg0: Internal.Class_<A_>): A_[];
        getDeclaredClasses(): Internal.Class<any>[];
        equals(arg0: any): boolean;
        isAnonymousClass(): boolean;
        getEnclosingClass(): Internal.Class<any>;
        toString(): string;
        getGenericSuperclass(): java_.lang.reflect.Type;
        get enclosingConstructor(): Internal.Constructor<any>;
        get annotations(): Internal.Annotation[];
        get memberClass(): boolean;
        get declaredConstructors(): Internal.Constructor<any>[];
        get declaredFields(): Internal.Field[];
        get superclass(): Internal.Class<T>;
        get record(): boolean;
        get canonicalName(): string;
        get package(): Internal.Package;
        get protectionDomain(): Internal.ProtectionDomain;
        get sealed(): boolean;
        get module(): Internal.Module;
        get enclosingMethod(): Internal.Method;
        get enum(): boolean;
        get declaringClass(): Internal.Class<any>;
        get synthetic(): boolean;
        get constructors(): Internal.Constructor<any>[];
        get declaredClasses(): Internal.Class<any>[];
        get name(): string;
        get fields(): Internal.Field[];
        get classLoader(): Internal.ClassLoader;
        get primitive(): boolean;
        get hidden(): boolean;
        get methods(): Internal.Method[];
        get classes(): Internal.Class<any>[];
        get typeName(): string;
        get declaredMethods(): Internal.Method[];
        get interface(): boolean;
        get genericInterfaces(): java_.lang.reflect.Type[];
        get modifiers(): number;
        get typeParameters(): any[];
        get annotatedSuperclass(): Internal.AnnotatedType;
        get permittedSubclasses(): Internal.Class<any>[];
        get array(): boolean;
        get enumConstants(): T[];
        get annotatedInterfaces(): Internal.AnnotatedType[];
        get packageName(): string;
        get class(): Internal.Class<any>;
        get annotation(): boolean;
        get declaredAnnotations(): Internal.Annotation[];
        get interfaces(): Internal.Class<any>[];
        get genericSuperclass(): java_.lang.reflect.Type;
        get localClass(): boolean;
        get enclosingClass(): Internal.Class<any>;
        get nestMembers(): Internal.Class<any>[];
        get signers(): any[];
        get recordComponents(): any[];
        get simpleName(): string;
        get nestHost(): Internal.Class<any>;
        get anonymousClass(): boolean;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    type Class_<T> = Class<T>;
    interface FloatSpliterator extends Internal.Spliterator$OfPrimitive<number, Internal.FloatConsumer, Internal.FloatSpliterator> {
        trySplit(): Internal.FloatSpliterator;
        characteristics(): number;
        tryAdvance(arg0: Internal.Consumer_<number>): boolean;
        tryAdvance(arg0: Internal.FloatConsumer_): boolean;
        getComparator(): Internal.FloatComparator;
        getExactSizeIfKnown(): number;
        estimateSize(): number;
        skip(arg0: number): number;
        hasCharacteristics(arg0: number): boolean;
        forEachRemaining(arg0: Internal.Consumer_<number>): void;
        forEachRemaining(arg0: Internal.FloatConsumer_): void;
    }
    type FloatSpliterator_ = FloatSpliterator;
    class SNBTCompoundTag extends Internal.CompoundTag {
        getCompound(string: string): Internal.SNBTCompoundTag;
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        notifyAll(): void;
        singleLine(key: string): void;
        singleLine(): void;
        notify(): void;
        getNullableList(key: string, type: number): Internal.ListTag;
        putNumber(key: string, number: Internal.Number_): void;
        isBoolean(key: string): boolean;
        hashCode(): number;
        getList<T_>(key: string, type: Internal.Class_<T_>): Internal.List<T_>;
        merge(arg0: Internal.CompoundTag_): Internal.CompoundTag;
        equals(arg0: any): boolean;
        static of(tag: net.minecraft.nbt.Tag_): Internal.SNBTCompoundTag;
        toString(): string;
        getComment(key: string): string;
        comment(key: string, comment: string[]): void;
        comment(key: string, comment: string): void;
        putNull(key: string): void;
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    type SNBTCompoundTag_ = SNBTCompoundTag;
    class WoodenPressurePlateBlockBuilder extends Internal.ShapedBlockBuilder {
        noItem(): Internal.BlockBuilder;
        suffocating(b: boolean): Internal.BlockBuilder;
        getClass(): Internal.Class<any>;
        translationKey(key: string): Internal.BuilderBase<Internal.Block>;
        newID(pre: string, post: string): ResourceLocation;
        type(type: string): Internal.BuilderBase<Internal.Block>;
        unbreakable(): Internal.BlockBuilder;
        model(m: string): Internal.BlockBuilder;
        tag(tag: ResourceLocation_): Internal.BlockBuilder;
        generateDataJsons(generator: Internal.DataJsonGenerator_): void;
        tagBoth(tag: ResourceLocation_): Internal.BlockBuilder;
        defaultCutout(): Internal.BlockBuilder;
        item(i: Internal.Consumer_<Internal.BlockItemBuilder_>): Internal.BlockBuilder;
        resistance(r: number): Internal.BlockBuilder;
        hardness(h: number): Internal.BlockBuilder;
        slipperiness(f: number): Internal.BlockBuilder;
        getRegistryType(): Internal.RegistryObjectBuilderTypes<Internal.Block>;
        textureSide(direction: Internal.Direction_, tex: string): Internal.BlockBuilder;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        clientRegistry(minecraft: Internal.Minecraft_): void;
        waterlogged(): Internal.BlockBuilder;
        transformObject(obj: Internal.Block_): Internal.Block;
        color(index: number, c: Internal.Color_): Internal.BlockBuilder;
        textureAll(tex: string): Internal.BlockBuilder;
        displayName(name: string): Internal.BuilderBase<Internal.Block>;
        notifyAll(): void;
        box(x0: number, y0: number, z0: number, x1: number, y1: number, z1: number): Internal.BlockBuilder;
        box(x0: number, y0: number, z0: number, x1: number, y1: number, z1: number, scale16: boolean): Internal.BlockBuilder;
        viewBlocking(b: boolean): Internal.BlockBuilder;
        notify(): void;
        transparent(b: boolean): Internal.BlockBuilder;
        createAdditionalObjects(): void;
        tagBlock(tag: ResourceLocation_): Internal.BlockBuilder;
        fullBlock(f: boolean): Internal.BlockBuilder;
        createProperties(): Internal.BlockBehaviour$Properties;
        notSolid(): Internal.BlockBuilder;
        generateBlockModels(builder: Internal.BlockBuilder_): Internal.Map<ResourceLocation, Internal.JsonObject>;
        hashCode(): number;
        noCollission(): Internal.BlockBuilder;
        get(): Internal.Block;
        requiresTool(f: boolean): Internal.BlockBuilder;
        renderType(l: string): Internal.BlockBuilder;
        jumpFactor(f: number): Internal.BlockBuilder;
        createShape(): Internal.VoxelShape;
        generateAssetJsons(generator: Internal.AssetJsonGenerator_): void;
        noCollision(): Internal.BlockBuilder;
        opaque(o: boolean): Internal.BlockBuilder;
        randomTick(randomTickCallback: Internal.Consumer_<Internal.RandomTickCallbackJS_>): Internal.BlockBuilder;
        getTranslationKeyGroup(): string;
        texture(id: string, tex: string): Internal.BlockBuilder;
        noDrops(): Internal.BlockBuilder;
        generateLang(lang: Internal.Map_<string, string>): void;
        tagItem(tag: ResourceLocation_): Internal.BlockBuilder;
        speedFactor(f: number): Internal.BlockBuilder;
        noValidSpawns(b: boolean): Internal.BlockBuilder;
        createObject(): Internal.Block;
        lightLevel(light: number): Internal.BlockBuilder;
        addResourcePackLocations(path: string, list: Internal.List_<ResourceLocation_>, packType: Internal.PackType_): void;
        defaultTranslucent(): Internal.BlockBuilder;
        material(m: Internal.MaterialJS_): Internal.BlockBuilder;
        equals(arg0: any): boolean;
        toString(): string;
        redstoneConductor(b: boolean): Internal.BlockBuilder;
        lootTable : ((arg0: Internal.LootBuilder) => void);
        modelJson : Internal.JsonObject;
        blockstateJson : Internal.JsonObject;
        readonly id : ResourceLocation;
        randomTickCallback : ((arg0: Internal.RandomTickCallbackJS) => void);
        get registryType(): Internal.RegistryObjectBuilderTypes<Internal.Block>;
        get class(): Internal.Class<any>;
        get translationKeyGroup(): string;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    type WoodenPressurePlateBlockBuilder_ = WoodenPressurePlateBlockBuilder;
    class Date implements Internal.Serializable, Internal.Cloneable, Internal.Comparable<Internal.Date> {
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        static UTC(arg0: number, arg1: number, arg2: number, arg3: number, arg4: number, arg5: number): number;
        before(arg0: Internal.Date_): boolean;
        getTime(): number;
        notifyAll(): void;
        compareTo(arg0: Internal.Date_): number;
        notify(): void;
        getHours(): number;
        setHours(arg0: number): void;
        setSeconds(arg0: number): void;
        hashCode(): number;
        getDate(): number;
        static from(arg0: Internal.Instant_): Internal.Date;
        getMonth(): number;
        after(arg0: Internal.Date_): boolean;
        setTime(arg0: number): void;
        setMonth(arg0: number): void;
        setMinutes(arg0: number): void;
        static parse(arg0: string): number;
        setYear(arg0: number): void;
        toInstant(): Internal.Instant;
        getDay(): number;
        getMinutes(): number;
        toGMTString(): string;
        getTimezoneOffset(): number;
        getSeconds(): number;
        getYear(): number;
        equals(arg0: any): boolean;
        clone(): any;
        setDate(arg0: number): void;
        toString(): string;
        toLocaleString(): string;
        get date(): number;
        get hours(): number;
        get seconds(): number;
        get month(): number;
        get timezoneOffset(): number;
        get year(): number;
        get minutes(): number;
        get time(): number;
        get class(): Internal.Class<any>;
        get day(): number;
        set date(arg0: number);
        set seconds(arg0: number);
        set hours(arg0: number);
        set month(arg0: number);
        set year(arg0: number);
        set minutes(arg0: number);
        set time(arg0: number);
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    type Date_ = Date;
    /**
    */
    abstract class FluidStackJS implements Internal.WrappedJS, Internal.Copyable {
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        getNbt(): Internal.CompoundTag;
        getChance(): number;
        notifyAll(): void;
        getTags(): Internal.Collection<ResourceLocation>;
        getId(): string;
        notify(): void;
        toNBT(): Internal.CompoundTag;
        setChance(c: number): void;
        hashCode(): number;
        static of(o: any, amount: number, nbt: Internal.CompoundTag_): Internal.FluidStackJS;
        static of(o: any): Internal.FluidStackJS;
        withAmount(amount: number): Internal.FluidStackJS;
        withChance(c: number): Internal.FluidStackJS;
        copy(): Internal.FluidStackJS;
        setAmount(arg0: number): void;
        withNBT(nbt: Internal.CompoundTag_): Internal.FluidStackJS;
        getAmount(): number;
        hasTag(tag: ResourceLocation_): boolean;
        isEmpty(): boolean;
        hasChance(): boolean;
        strongEquals(o: any): boolean;
        getFluidStack(): Internal.FluidStack;
        toJson(): Internal.JsonObject;
        equals(o: any): boolean;
        getFluid(): Internal.Fluid;
        static fromJson(e: Internal.JsonElement_): Internal.FluidStackJS;
        toString(): string;
        removeChance(): void;
        setNbt(arg0: Internal.CompoundTag_): void;
        get nbt(): Internal.CompoundTag;
        get amount(): number;
        get chance(): number;
        get fluidStack(): Internal.FluidStack;
        get fluid(): Internal.Fluid;
        get id(): string;
        get class(): Internal.Class<any>;
        get tags(): Internal.Collection<ResourceLocation>;
        get empty(): boolean;
        set nbt(arg0: Internal.CompoundTag_);
        set amount(arg0: number);
        set chance(c: number);
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    /**
    */
    type FluidStackJS_ = Internal.FluidStack_ | Internal.Fluid_ | Internal.JsonObject_ | {fluid: ResourceLocation_, amount?: number, nbt?: Internal.CompoundTag_} | "" | "-" | "empty" | "minecraft:empty" | `${string} ${number}` | FluidStackJS;
    class VariantBlockStateGenerator$Variant {
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        toJson(): Internal.JsonElement;
        hashCode(): number;
        notifyAll(): void;
        equals(arg0: any): boolean;
        toString(): string;
        model(s: string): Internal.VariantBlockStateGenerator$Model;
        notify(): void;
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    type VariantBlockStateGenerator$Variant_ = VariantBlockStateGenerator$Variant;
    class Random implements Internal.RandomGenerator, Internal.Serializable {
        nextFloat(): number;
        nextFloat(arg0: number): number;
        nextFloat(arg0: number, arg1: number): number;
        getClass(): Internal.Class<any>;
        isDeprecated(): boolean;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        notifyAll(): void;
        nextInt(): number;
        nextInt(arg0: number): number;
        nextInt(arg0: number, arg1: number): number;
        nextLong(): number;
        nextLong(arg0: number, arg1: number): number;
        nextLong(arg0: number): number;
        notify(): void;
        nextGaussian(): number;
        nextGaussian(arg0: number, arg1: number): number;
        nextDouble(): number;
        nextDouble(arg0: number): number;
        nextDouble(arg0: number, arg1: number): number;
        nextBytes(arg0: number[]): void;
        longs(arg0: number): Internal.LongStream;
        longs(arg0: number, arg1: number): Internal.LongStream;
        longs(arg0: number, arg1: number, arg2: number): Internal.LongStream;
        longs(): Internal.LongStream;
        nextExponential(): number;
        doubles(arg0: number): Internal.DoubleStream;
        doubles(arg0: number, arg1: number, arg2: number): Internal.DoubleStream;
        doubles(arg0: number, arg1: number): Internal.DoubleStream;
        doubles(): Internal.DoubleStream;
        ints(arg0: number): Internal.IntStream;
        ints(): Internal.IntStream;
        ints(arg0: number, arg1: number, arg2: number): Internal.IntStream;
        ints(arg0: number, arg1: number): Internal.IntStream;
        hashCode(): number;
        equals(arg0: any): boolean;
        toString(): string;
        nextBoolean(): boolean;
        setSeed(arg0: number): void;
        get deprecated(): boolean;
        get class(): Internal.Class<any>;
        set seed(arg0: number);
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    type Random_ = Random;
    abstract class ChannelHandlerAdapter implements Internal.ChannelHandler {
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        hashCode(): number;
        notifyAll(): void;
        equals(arg0: any): boolean;
        exceptionCaught(arg0: Internal.ChannelHandlerContext_, arg1: Internal.Throwable_): void;
        toString(): string;
        handlerAdded(arg0: Internal.ChannelHandlerContext_): void;
        isSharable(): boolean;
        notify(): void;
        handlerRemoved(arg0: Internal.ChannelHandlerContext_): void;
        get sharable(): boolean;
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    type ChannelHandlerAdapter_ = ChannelHandlerAdapter;
    class Explosion {
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        getPosition(): Vec3;
        redirect$cej000$lychee_getDrops(arg0: Internal.BlockState_, arg1: Internal.LootContext$Builder_): Internal.List<any>;
        hashCode(): number;
        getExploder(): Internal.Entity;
        notifyAll(): void;
        equals(arg0: any): boolean;
        toString(): string;
        notify(): void;
        readonly position : Vec3;
        get exploder(): Internal.Entity;
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    type Explosion_ = Explosion;
    interface ByteProcessor {
        process(arg0: number): boolean;
    }
    type ByteProcessor_ = ByteProcessor;
    class SlotWidget extends com.lowdragmc.lowdraglib.gui.widget.Widget implements Internal.IIngredientSlot {
        getClass(): Internal.Class<any>;
        mouseWheelMove(arg0: number, arg1: number, arg2: number): boolean;
        mouseDragged(arg0: number, arg1: number, arg2: number, arg3: number, arg4: number): boolean;
        drawInForeground(arg0: Internal.PoseStack_, arg1: number, arg2: number, arg3: number): void;
        getHandle(): Internal.Slot;
        readUpdateInfo(arg0: number, arg1: Internal.FriendlyByteBuf_): void;
        toRectangleBox(): Internal.Rect2i;
        isActive(): boolean;
        getGui(): Internal.ModularUI;
        setBackgroundTexture(arg0: Internal.IGuiTexture_): Internal.SlotWidget;
        updateScreen(): void;
        mouseMoved(arg0: number, arg1: number): void;
        setVisible(arg0: boolean): void;
        static isMouseOver(arg0: number, arg1: number, arg2: number, arg3: number, arg4: number, arg5: number): boolean;
        addSelfPosition(arg0: number, arg1: number): Internal.Position;
        isParent(arg0: Internal.WidgetGroup_): boolean;
        keyPressed(arg0: number, arg1: number, arg2: number): boolean;
        setDrawOverlay(arg0: boolean): Internal.SlotWidget;
        setHoverTexture(arg0: Internal.IGuiTexture_[]): com.lowdragmc.lowdraglib.gui.widget.Widget;
        isMouseOverElement(arg0: number, arg1: number): boolean;
        isVisible(): boolean;
        setOnAddedTooltips(arg0: Internal.BiConsumer_<Internal.SlotWidget_, Internal.List_<Internal.Component_>>): Internal.SlotWidget;
        getSelfPosition(): Internal.Position;
        setClientSideWidget(): com.lowdragmc.lowdraglib.gui.widget.Widget;
        handleClientAction(arg0: number, arg1: Internal.FriendlyByteBuf_): void;
        canMergeSlot(arg0: Internal.ItemStack_): boolean;
        mouseClicked(arg0: number, arg1: number, arg2: number): boolean;
        isEnabled(): boolean;
        setLocationInfo(arg0: boolean, arg1: boolean): com.lowdragmc.lowdraglib.gui.widget.Widget;
        charTyped(arg0: string, arg1: number): boolean;
        readInitialData(arg0: Internal.FriendlyByteBuf_): void;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        setChangeListener(arg0: Internal.Runnable_): Internal.SlotWidget;
        notifyAll(): void;
        isInitialized(): boolean;
        onSlotChanged(): void;
        setBackground(arg0: Internal.IGuiTexture_[]): com.lowdragmc.lowdraglib.gui.widget.Widget;
        notify(): void;
        slotClick(arg0: number, arg1: Internal.ClickType_, arg2: Internal.Player_): Internal.ItemStack;
        mouseReleased(arg0: number, arg1: number, arg2: number): boolean;
        setSize(arg0: Internal.Size_): void;
        canPutStack(arg0: Internal.ItemStack_): boolean;
        initWidget(): void;
        hashCode(): number;
        getNativeWidgets(): Internal.List<Internal.SlotWidget>;
        getRealStack(arg0: Internal.ItemStack_): Internal.ItemStack;
        canTakeStack(arg0: Internal.Player_): boolean;
        keyReleased(arg0: number, arg1: number, arg2: number): boolean;
        detectAndSendChanges(): void;
        getParent(): Internal.WidgetGroup;
        setItemHook(arg0: java_.util.function_.Function_<Internal.ItemStack_, Internal.ItemStack_>): Internal.SlotWidget;
        setSelfPosition(arg0: Internal.Position_): void;
        isRemote(): boolean;
        setFocus(arg0: boolean): void;
        setUiAccess(arg0: Internal.WidgetUIAccess_): void;
        drawInBackground(arg0: Internal.PoseStack_, arg1: number, arg2: number, arg3: number): void;
        getParentPosition(): Internal.Position;
        getSize(): Internal.Size;
        setActive(arg0: boolean): void;
        getPosition(): Internal.Position;
        getIngredientOverMouse(arg0: number, arg1: number): any;
        isFocus(): boolean;
        equals(arg0: any): boolean;
        onFocusChanged(arg0: com.lowdragmc.lowdraglib.gui.widget.Widget_, arg1: com.lowdragmc.lowdraglib.gui.widget.Widget_): void;
        setHoverTooltips(arg0: Internal.List_<Internal.Component_>): com.lowdragmc.lowdraglib.gui.widget.Widget;
        setHoverTooltips(arg0: string[]): com.lowdragmc.lowdraglib.gui.widget.Widget;
        setHoverTooltips(arg0: Internal.Component_[]): com.lowdragmc.lowdraglib.gui.widget.Widget;
        writeInitialData(arg0: Internal.FriendlyByteBuf_): void;
        toString(): string;
        setParentPosition(arg0: Internal.Position_): void;
        setDrawHoverTips(arg0: boolean): Internal.SlotWidget;
        setGui(arg0: Internal.ModularUI_): void;
        isPlayerContainer : boolean;
        isPlayerHotBar : boolean;
        drawOverlay : boolean;
        drawHoverTips : boolean;
        get selfPosition(): Internal.Position;
        get parent(): Internal.WidgetGroup;
        get visible(): boolean;
        get nativeWidgets(): Internal.List<Internal.SlotWidget>;
        get active(): boolean;
        get focus(): boolean;
        get handle(): Internal.Slot;
        get remote(): boolean;
        get enabled(): boolean;
        get parentPosition(): Internal.Position;
        get size(): Internal.Size;
        get initialized(): boolean;
        get gui(): Internal.ModularUI;
        get position(): Internal.Position;
        get class(): Internal.Class<any>;
        set selfPosition(arg0: Internal.Position_);
        set visible(arg0: boolean);
        set active(arg0: boolean);
        set focus(arg0: boolean);
        set hoverTooltips(arg0: Internal.List_<Internal.Component_>);
        set parentPosition(arg0: Internal.Position_);
        set changeListener(arg0: Internal.Runnable_);
        set size(arg0: Internal.Size_);
        set hoverTexture(arg0: Internal.IGuiTexture_[]);
        set background(arg0: Internal.IGuiTexture_[]);
        set backgroundTexture(arg0: Internal.IGuiTexture_);
        set gui(arg0: Internal.ModularUI_);
        set uiAccess(arg0: Internal.WidgetUIAccess_);
        set itemHook(arg0: java_.util.function_.Function_<Internal.ItemStack_, Internal.ItemStack_>);
        set onAddedTooltips(arg0: Internal.BiConsumer_<Internal.SlotWidget_, Internal.List_<Internal.Component_>>);
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    type SlotWidget_ = SlotWidget;
    interface AccessorSoundType {
        botania_getBreakSound(): Internal.SoundEvent;
    }
    type AccessorSoundType_ = AccessorSoundType;
    class AmbientParticleSettings {
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        hashCode(): number;
        notifyAll(): void;
        equals(arg0: any): boolean;
        toString(): string;
        notify(): void;
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    type AmbientParticleSettings_ = AmbientParticleSettings;
    interface AccessorBiome {
        callGetTemperature(arg0: BlockPos_): number;
    }
    type AccessorBiome_ = AccessorBiome;
    abstract class ArgumentBuilder <S, T> {
        redirect(arg0: Internal.CommandNode_<S>): T;
        redirect(arg0: Internal.CommandNode_<S>, arg1: Internal.SingleRedirectModifier_<S>): T;
        getClass(): Internal.Class<any>;
        getRedirectModifier(): Internal.RedirectModifier<S>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        getRedirect(): Internal.CommandNode<S>;
        getCommand(): Internal.Command<S>;
        forward(arg0: Internal.CommandNode_<S>, arg1: Internal.RedirectModifier_<S>, arg2: boolean): T;
        notifyAll(): void;
        then(arg0: Internal.CommandNode_<S>): T;
        then(arg0: Internal.ArgumentBuilder_<S, any>): T;
        notify(): void;
        isFork(): boolean;
        getRequirement(): Internal.Predicate<S>;
        fork(arg0: Internal.CommandNode_<S>, arg1: Internal.RedirectModifier_<S>): T;
        build(): Internal.CommandNode<S>;
        hashCode(): number;
        equals(arg0: any): boolean;
        getArguments(): Internal.Collection<Internal.CommandNode<S>>;
        toString(): string;
        executes(arg0: Internal.Command_<S>): T;
        requires(arg0: Internal.Predicate_<S>): T;
        get arguments(): Internal.Collection<Internal.CommandNode<S>>;
        get requirement(): Internal.Predicate<S>;
        get redirectModifier(): Internal.RedirectModifier<S>;
        get class(): Internal.Class<any>;
        get command(): Internal.Command<S>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    type ArgumentBuilder_<S, T> = ArgumentBuilder<S, T>;
    class MethodHandles$Lookup {
        getClass(): Internal.Class<any>;
        findStaticVarHandle(arg0: Internal.Class_<any>, arg1: string, arg2: Internal.Class_<any>): Internal.VarHandle;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        notifyAll(): void;
        hasFullPrivilegeAccess(): boolean;
        findStaticGetter(arg0: Internal.Class_<any>, arg1: string, arg2: Internal.Class_<any>): Internal.MethodHandle;
        lookupClass(): Internal.Class<any>;
        defineHiddenClass(arg0: number[], arg1: boolean, arg2: any_[]): Internal.MethodHandles$Lookup;
        notify(): void;
        unreflectSetter(arg0: Internal.Field_): Internal.MethodHandle;
        findVirtual(arg0: Internal.Class_<any>, arg1: string, arg2: Internal.MethodType_): Internal.MethodHandle;
        findConstructor(arg0: Internal.Class_<any>, arg1: Internal.MethodType_): Internal.MethodHandle;
        dropLookupMode(arg0: number): Internal.MethodHandles$Lookup;
        findStaticSetter(arg0: Internal.Class_<any>, arg1: string, arg2: Internal.Class_<any>): Internal.MethodHandle;
        bind(arg0: any, arg1: string, arg2: Internal.MethodType_): Internal.MethodHandle;
        hashCode(): number;
        findGetter(arg0: Internal.Class_<any>, arg1: string, arg2: Internal.Class_<any>): Internal.MethodHandle;
        hasPrivateAccess(): boolean;
        unreflectGetter(arg0: Internal.Field_): Internal.MethodHandle;
        accessClass(arg0: Internal.Class_<any>): Internal.Class<any>;
        findSpecial(arg0: Internal.Class_<any>, arg1: string, arg2: Internal.MethodType_, arg3: Internal.Class_<any>): Internal.MethodHandle;
        in(arg0: Internal.Class_<any>): Internal.MethodHandles$Lookup;
        defineClass(arg0: number[]): Internal.Class<any>;
        unreflectConstructor(arg0: Internal.Constructor_<any>): Internal.MethodHandle;
        unreflectVarHandle(arg0: Internal.Field_): Internal.VarHandle;
        findClass(arg0: string): Internal.Class<any>;
        defineHiddenClassWithClassData(arg0: number[], arg1: any, arg2: boolean, arg3: any_[]): Internal.MethodHandles$Lookup;
        unreflectSpecial(arg0: Internal.Method_, arg1: Internal.Class_<any>): Internal.MethodHandle;
        lookupModes(): number;
        findStatic(arg0: Internal.Class_<any>, arg1: string, arg2: Internal.MethodType_): Internal.MethodHandle;
        ensureInitialized(arg0: Internal.Class_<any>): Internal.Class<any>;
        unreflect(arg0: Internal.Method_): Internal.MethodHandle;
        findVarHandle(arg0: Internal.Class_<any>, arg1: string, arg2: Internal.Class_<any>): Internal.VarHandle;
        findSetter(arg0: Internal.Class_<any>, arg1: string, arg2: Internal.Class_<any>): Internal.MethodHandle;
        equals(arg0: any): boolean;
        toString(): string;
        previousLookupClass(): Internal.Class<any>;
        revealDirect(arg0: Internal.MethodHandle_): Internal.MethodHandleInfo;
        static readonly MODULE : 16;
        static readonly PACKAGE : 8;
        static readonly PUBLIC : 1;
        static readonly ORIGINAL : 64;
        static readonly UNCONDITIONAL : 32;
        static readonly PROTECTED : 4;
        static readonly PRIVATE : 2;
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    type MethodHandles$Lookup_ = MethodHandles$Lookup;
    class AttributeKey <T> extends Internal.AbstractConstant<Internal.AttributeKey<T>> {
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        hashCode(): number;
        static valueOf<T_>(arg0: string): Internal.AttributeKey<T_>;
        static valueOf<T_>(arg0: Internal.Class_<any>, arg1: string): Internal.AttributeKey<T_>;
        notifyAll(): void;
        equals(arg0: any): boolean;
        name(): string;
        static exists(arg0: string): boolean;
        toString(): string;
        static newInstance<T_>(arg0: string): Internal.AttributeKey<T_>;
        id(): number;
        compareTo(arg0: Internal.AttributeKey_<Internal.AttributeKey_<T>>): number;
        notify(): void;
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    type AttributeKey_<T> = AttributeKey<T>;
    abstract class GraphicsDevice {
        getClass(): Internal.Class<any>;
        getConfigurations(): Internal.GraphicsConfiguration[];
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        isFullScreenSupported(): boolean;
        setDisplayMode(arg0: Internal.DisplayMode_): void;
        notifyAll(): void;
        setFullScreenWindow(arg0: java_.awt.Window_): void;
        getFullScreenWindow(): java_.awt.Window;
        getAvailableAcceleratedMemory(): number;
        getDefaultConfiguration(): Internal.GraphicsConfiguration;
        notify(): void;
        getDisplayMode(): Internal.DisplayMode;
        isDisplayChangeSupported(): boolean;
        getIDstring(): string;
        getType(): number;
        hashCode(): number;
        getBestConfiguration(arg0: Internal.GraphicsConfigTemplate_): Internal.GraphicsConfiguration;
        equals(arg0: any): boolean;
        isWindowTranslucencySupported(arg0: Internal.GraphicsDevice$WindowTranslucency_): boolean;
        toString(): string;
        getDisplayModes(): Internal.DisplayMode[];
        static readonly TYPE_IMAGE_BUFFER : 2;
        static readonly TYPE_RASTER_SCREEN : 0;
        static readonly TYPE_PRINTER : 1;
        get fullScreenSupported(): boolean;
        get availableAcceleratedMemory(): number;
        get iDstring(): string;
        get configurations(): Internal.GraphicsConfiguration[];
        get displayChangeSupported(): boolean;
        get displayModes(): Internal.DisplayMode[];
        get fullScreenWindow(): java_.awt.Window;
        get type(): number;
        get class(): Internal.Class<any>;
        get displayMode(): Internal.DisplayMode;
        get defaultConfiguration(): Internal.GraphicsConfiguration;
        set fullScreenWindow(arg0: java_.awt.Window_);
        set displayMode(arg0: Internal.DisplayMode_);
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    type GraphicsDevice_ = GraphicsDevice;
    interface IInnerCapabilityProvider extends Internal.ICapabilityProvider {
        getCapability<T_>(arg0: Internal.Capability_<T_>, arg1: Internal.Direction_): Internal.LazyOptional<T_>;
        getCapability<T_>(arg0: Internal.Capability_<T_>): Internal.LazyOptional<T_>;
        getInnerCapability<T_>(arg0: Internal.Capability_<T_>, arg1: Internal.Direction_): Internal.LazyOptional<T_>;
    }
    type IInnerCapabilityProvider_ = IInnerCapabilityProvider;
    class LiteralArgumentBuilder <S> extends Internal.ArgumentBuilder<S, Internal.LiteralArgumentBuilder<S>> {
        redirect(arg0: Internal.CommandNode_<S>): Internal.LiteralArgumentBuilder<S>;
        redirect(arg0: Internal.CommandNode_<S>, arg1: Internal.SingleRedirectModifier_<S>): Internal.LiteralArgumentBuilder<S>;
        getClass(): Internal.Class<any>;
        getRedirectModifier(): Internal.RedirectModifier<S>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        getRedirect(): Internal.CommandNode<S>;
        getCommand(): Internal.Command<S>;
        forward(arg0: Internal.CommandNode_<S>, arg1: Internal.RedirectModifier_<S>, arg2: boolean): Internal.LiteralArgumentBuilder<S>;
        notifyAll(): void;
        then(arg0: Internal.CommandNode_<S>): Internal.LiteralArgumentBuilder<S>;
        then(arg0: Internal.ArgumentBuilder_<S, any>): Internal.LiteralArgumentBuilder<S>;
        notify(): void;
        isFork(): boolean;
        static literal<S_>(arg0: string): Internal.LiteralArgumentBuilder<S_>;
        getRequirement(): Internal.Predicate<S>;
        fork(arg0: Internal.CommandNode_<S>, arg1: Internal.RedirectModifier_<S>): Internal.LiteralArgumentBuilder<S>;
        getLiteral(): string;
        build(): Internal.LiteralCommandNode<S>;
        hashCode(): number;
        equals(arg0: any): boolean;
        getArguments(): Internal.Collection<Internal.CommandNode<S>>;
        toString(): string;
        executes(arg0: Internal.Command_<S>): Internal.LiteralArgumentBuilder<S>;
        requires(arg0: Internal.Predicate_<S>): Internal.LiteralArgumentBuilder<S>;
        get arguments(): Internal.Collection<Internal.CommandNode<S>>;
        get requirement(): Internal.Predicate<S>;
        get redirectModifier(): Internal.RedirectModifier<S>;
        get class(): Internal.Class<any>;
        get command(): Internal.Command<S>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    type LiteralArgumentBuilder_<S> = LiteralArgumentBuilder<S>;
    class Menu extends Internal.MenuItem implements Internal.MenuContainer, Internal.Accessible {
        setName(arg0: string): void;
        getListeners<T_>(arg0: Internal.Class_<T_>): T_[];
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        getName(): string;
        getLabel(): string;
        notifyAll(): void;
        getItemCount(): number;
        getItem(arg0: number): Internal.MenuItem;
        insert(arg0: Internal.MenuItem_, arg1: number): void;
        insert(arg0: string, arg1: number): void;
        isTearOff(): boolean;
        getShortcut(): Internal.MenuShortcut;
        notify(): void;
        remove(arg0: number): void;
        remove(arg0: Internal.MenuComponent_): void;
        paramString(): string;
        removeAll(): void;
        removeActionListener(arg0: Internal.ActionListener_): void;
        addSeparator(): void;
        hashCode(): number;
        enable(arg0: boolean): void;
        enable(): void;
        setFont(arg0: Internal.Font_): void;
        setShortcut(arg0: Internal.MenuShortcut_): void;
        add(arg0: Internal.MenuItem_): Internal.MenuItem;
        add(arg0: string): void;
        getParent(): Internal.MenuContainer;
        dispatchEvent(arg0: Internal.AWTEvent_): void;
        deleteShortcut(): void;
        addActionListener(arg0: Internal.ActionListener_): void;
        countItems(): number;
        setActionCommand(arg0: string): void;
        getAccessibleContext(): Internal.AccessibleContext;
        postEvent(arg0: java_.awt.Event_): boolean;
        setEnabled(arg0: boolean): void;
        addNotify(): void;
        disable(): void;
        equals(arg0: any): boolean;
        isEnabled(): boolean;
        getActionListeners(): Internal.ActionListener[];
        setLabel(arg0: string): void;
        removeNotify(): void;
        getFont(): Internal.Font;
        toString(): string;
        getActionCommand(): string;
        insertSeparator(arg0: number): void;
        get accessibleContext(): Internal.AccessibleContext;
        get parent(): Internal.MenuContainer;
        get actionCommand(): string;
        get shortcut(): Internal.MenuShortcut;
        get actionListeners(): Internal.ActionListener[];
        get tearOff(): boolean;
        get name(): string;
        get label(): string;
        get class(): Internal.Class<any>;
        get enabled(): boolean;
        get itemCount(): number;
        get font(): Internal.Font;
        set actionCommand(arg0: string);
        set shortcut(arg0: Internal.MenuShortcut_);
        set name(arg0: string);
        set label(arg0: string);
        set enabled(arg0: boolean);
        set font(arg0: Internal.Font_);
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    type Menu_ = Menu;
    class DragSource implements Internal.Serializable {
        removeDragSourceListener(arg0: Internal.DragSourceListener_): void;
        getListeners<T_>(arg0: Internal.Class_<T_>): T_[];
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        createDragGestureRecognizer<T_>(arg0: Internal.Class_<T_>, arg1: java_.awt.Component_, arg2: number, arg3: Internal.DragGestureListener_): T_;
        createDefaultDragGestureRecognizer(arg0: java_.awt.Component_, arg1: number, arg2: Internal.DragGestureListener_): Internal.DragGestureRecognizer;
        notifyAll(): void;
        static isDragImageSupported(): boolean;
        addDragSourceMotionListener(arg0: Internal.DragSourceMotionListener_): void;
        getDragSourceMotionListeners(): Internal.DragSourceMotionListener[];
        notify(): void;
        addDragSourceListener(arg0: Internal.DragSourceListener_): void;
        removeDragSourceMotionListener(arg0: Internal.DragSourceMotionListener_): void;
        static getDefaultDragSource(): Internal.DragSource;
        getFlavorMap(): Internal.FlavorMap;
        static getDragThreshold(): number;
        hashCode(): number;
        equals(arg0: any): boolean;
        startDrag(arg0: Internal.DragGestureEvent_, arg1: Internal.Cursor_, arg2: Internal.Image_, arg3: Internal.Point_, arg4: Internal.Transferable_, arg5: Internal.DragSourceListener_, arg6: Internal.FlavorMap_): void;
        startDrag(arg0: Internal.DragGestureEvent_, arg1: Internal.Cursor_, arg2: Internal.Transferable_, arg3: Internal.DragSourceListener_, arg4: Internal.FlavorMap_): void;
        startDrag(arg0: Internal.DragGestureEvent_, arg1: Internal.Cursor_, arg2: Internal.Transferable_, arg3: Internal.DragSourceListener_): void;
        startDrag(arg0: Internal.DragGestureEvent_, arg1: Internal.Cursor_, arg2: Internal.Image_, arg3: Internal.Point_, arg4: Internal.Transferable_, arg5: Internal.DragSourceListener_): void;
        toString(): string;
        getDragSourceListeners(): Internal.DragSourceListener[];
        static readonly DefaultCopyNoDrop : Internal.Cursor;
        static readonly DefaultMoveNoDrop : Internal.Cursor;
        static readonly DefaultMoveDrop : Internal.Cursor;
        static readonly DefaultLinkDrop : Internal.Cursor;
        static readonly DefaultLinkNoDrop : Internal.Cursor;
        static readonly DefaultCopyDrop : Internal.Cursor;
        get dragImageSupported(): boolean;
        get dragSourceMotionListeners(): Internal.DragSourceMotionListener[];
        get flavorMap(): Internal.FlavorMap;
        get dragThreshold(): number;
        get defaultDragSource(): Internal.DragSource;
        get dragSourceListeners(): Internal.DragSourceListener[];
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    type DragSource_ = DragSource;
    abstract class ForgeRegistryEntry <V> implements Internal.IForgeRegistryEntry<V> {
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        hashCode(): number;
        notifyAll(): void;
        equals(arg0: any): boolean;
        getRegistryType(): Internal.Class<V>;
        getRegistryName(): ResourceLocation;
        toString(): string;
        setRegistryName(arg0: ResourceLocation_): V;
        setRegistryName(arg0: string): V;
        setRegistryName(arg0: string, arg1: string): V;
        notify(): void;
        readonly delegate : Internal.IRegistryDelegate<V>;
        get registryType(): Internal.Class<V>;
        get registryName(): ResourceLocation;
        get class(): Internal.Class<any>;
        set registryName(arg0: ResourceLocation_);
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    type ForgeRegistryEntry_<V> = ForgeRegistryEntry<V>;
    abstract class Biome$TemperatureModifier extends Internal.Enum<Internal.Biome$TemperatureModifier> implements Internal.StringRepresentable {
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        static valueOf(arg0: string): Internal.Biome$TemperatureModifier;
        static valueOf<T_>(arg0: Internal.Class_<T_>, arg1: string): T_;
        notifyAll(): void;
        static values(): Internal.Biome$TemperatureModifier[];
        compareTo(arg0: Internal.Biome$TemperatureModifier_): number;
        describeConstable(): Internal.Optional<Internal.Enum$EnumDesc<Internal.Biome$TemperatureModifier>>;
        notify(): void;
        getDeclaringClass(): Internal.Class<Internal.Biome$TemperatureModifier>;
        hashCode(): number;
        equals(arg0: any): boolean;
        name(): string;
        toString(): string;
        ordinal(): number;
        static readonly NONE : Internal.Biome$TemperatureModifier;
        static readonly FROZEN : Internal.Biome$TemperatureModifier;
        get class(): Internal.Class<any>;
        get declaringClass(): Internal.Class<Internal.Biome$TemperatureModifier>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    type Biome$TemperatureModifier_ = "frozen" | "none" | Biome$TemperatureModifier;
    class ArsNouveauEnchantmentRecipeJS extends Internal.RecipeJS {
        parseResultItemList(o: any): Internal.List<Internal.ItemStackJS>;
        getClass(): Internal.Class<any>;
        ingredientAction(filter: Internal.IngredientActionFilter_, action: Internal.IngredientAction_): Internal.RecipeJS;
        convertReplacedInput(index: number, oldIngredient: Internal.IngredientJS_, newIngredient: Internal.IngredientJS_): Internal.IngredientJS;
        getUniqueId(): string;
        replaceOutput(i: Internal.IngredientJS_, with_: Internal.ItemStackJS_, exact: boolean): boolean;
        replaceOutput(i: Internal.IngredientJS_, with_: Internal.ItemStackJS_, exact: boolean, func: Internal.BiFunction_<Internal.ItemStackJS_, Internal.ItemStackJS_, Internal.ItemStackJS_>): boolean;
        parseIngredientItemList(o: any): Internal.List<Internal.IngredientJS>;
        merge(data: any): Internal.RecipeJS;
        getPath(): string;
        create(args: Internal.ListJS_): void;
        parseIngredientItemStackList(o: any): Internal.List<Internal.IngredientStackJS>;
        id(_id: ResourceLocation_): Internal.RecipeJS;
        parseIngredientItem(o: any, key: string): Internal.IngredientJS;
        parseIngredientItem(o: any): Internal.IngredientJS;
        group(g: string): Internal.RecipeJS;
        getOriginalRecipeResult(): Internal.ItemStackJS;
        getOriginalRecipeIngredients(): Internal.List<Internal.IngredientJS>;
        getInputIndex(ingredient: Internal.IngredientJS_, exact: boolean): number;
        setGroup(g: string): void;
        serialize(): void;
        replaceInput(i: Internal.IngredientJS_, with_: Internal.IngredientJS_, exact: boolean, func: Internal.BiFunction_<Internal.IngredientJS_, Internal.IngredientJS_, Internal.IngredientJS_>): boolean;
        replaceInput(i: Internal.IngredientJS_, with_: Internal.IngredientJS_, exact: boolean): boolean;
        getType(): string;
        getGroup(): string;
        hasOutput(ingredient: Internal.IngredientJS_, exact: boolean): boolean;
        keepIngredient(filter: Internal.IngredientActionFilter_): Internal.RecipeJS;
        customIngredientAction(filter: Internal.IngredientActionFilter_, id: string): Internal.RecipeJS;
        modifyResult(callback: Internal.ModifyRecipeResultCallback_): Internal.RecipeJS;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        getMod(): string;
        notifyAll(): void;
        convertReplacedOutput(index: number, oldStack: Internal.ItemStackJS_, newStack: Internal.ItemStackJS_): Internal.ItemStackJS;
        save(): void;
        damageIngredient(filter: Internal.IngredientActionFilter_): Internal.RecipeJS;
        damageIngredient(filter: Internal.IngredientActionFilter_, damage: number): Internal.RecipeJS;
        getId(): string;
        dontAdd(): void;
        notify(): void;
        serializeJson(): void;
        createRecipe(): Internal.Recipe<any>;
        getFromToString(): string;
        hashCode(): number;
        deserializeJson(): void;
        getOrCreateId(): ResourceLocation;
        deserialize(): void;
        serializeNBTAsJson(): boolean;
        getOutputIndex(ingredient: Internal.IngredientJS_, exact: boolean): number;
        serializeIngredientStack(in_: Internal.IngredientStackJS_): Internal.JsonElement;
        resultFromRecipeJson(json: Internal.JsonObject_): Internal.ItemStackJS;
        stage(s: string): Internal.RecipeJS;
        equals(arg0: any): boolean;
        serializeItemStack(stack: Internal.ItemStackJS_): Internal.JsonElement;
        toString(): string;
        hasInput(ingredient: Internal.IngredientJS_, exact: boolean): boolean;
        parseResultItem(o: any): Internal.ItemStackJS;
        replaceIngredient(filter: Internal.IngredientActionFilter_, item: Internal.ItemStackJS_): Internal.RecipeJS;
        static currentRecipe : Internal.RecipeJS;
        originalJson : Internal.JsonObject;
        serializeOutputs : boolean;
        originalRecipe : Internal.Recipe<any>;
        readonly inputItems : Internal.List<((arg0: Internal.ItemStackJS) => boolean)>;
        static itemErrors : false;
        json : Internal.JsonObject;
        readonly outputItems : Internal.List<Internal.ItemStackJS>;
        type : Internal.RecipeTypeJS;
        serializeInputs : boolean;
        get path(): string;
        get originalRecipeIngredients(): Internal.List<Internal.IngredientJS>;
        get mod(): string;
        get originalRecipeResult(): Internal.ItemStackJS;
        get orCreateId(): ResourceLocation;
        get class(): Internal.Class<any>;
        get fromToString(): string;
        get uniqueId(): string;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    type ArsNouveauEnchantmentRecipeJS_ = ArsNouveauEnchantmentRecipeJS;
    interface Delayed extends Internal.Comparable<Internal.Delayed> {
        getDelay(arg0: Internal.TimeUnit_): number;
        compareTo(arg0: Internal.Delayed_): number;
    }
    type Delayed_ = Delayed;
    interface DragSourceListener extends Internal.EventListener {
        dragEnter(arg0: Internal.DragSourceDragEvent_): void;
        dragDropEnd(arg0: Internal.DragSourceDropEvent_): void;
        dropActionChanged(arg0: Internal.DragSourceDragEvent_): void;
        dragOver(arg0: Internal.DragSourceDragEvent_): void;
        dragExit(arg0: Internal.DragSourceEvent_): void;
    }
    type DragSourceListener_ = DragSourceListener;
    interface Map <K, V> {
        getOrDefault(arg0: any, arg1: V): V;
        computeIfAbsent(arg0: K, arg1: java_.util.function_.Function_<K, V>): V;
        values(): Internal.Collection<V>;
        replace(arg0: K, arg1: V): V;
        replace(arg0: K, arg1: V, arg2: V): boolean;
        replaceAll(arg0: Internal.BiFunction_<K, V, V>): void;
        containsValue(arg0: any): boolean;
        put(arg0: K, arg1: V): V;
        remove(arg0: any): V;
        remove(arg0: any, arg1: any): boolean;
        compute(arg0: K, arg1: Internal.BiFunction_<K, V, V>): V;
        hashCode(): number;
        putAll(arg0: Internal.Map_<K, V>): void;
        merge(arg0: K, arg1: V, arg2: Internal.BiFunction_<V, V, V>): V;
        get(arg0: any): V;
        keySet(): Internal.Set<K>;
        entrySet(): Internal.Set<Internal.Map$Entry<K, V>>;
        containsKey(arg0: any): boolean;
        forEach(arg0: Internal.BiConsumer_<K, V>): void;
        isEmpty(): boolean;
        clear(): void;
        computeIfPresent(arg0: K, arg1: Internal.BiFunction_<K, V, V>): V;
        size(): number;
        equals(arg0: any): boolean;
        putIfAbsent(arg0: K, arg1: V): V;
    }
    type Map_<K, V> = Map<K, V>;
    interface AccessorEntity {
        bookshelf$createHoverEvent(): Internal.HoverEvent;
    }
    type AccessorEntity_ = AccessorEntity;
    abstract class Enum <E> implements Internal.Constable, Internal.Comparable<E>, Internal.Serializable {
        getClass(): Internal.Class<any>;
        getDeclaringClass(): Internal.Class<E>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        static valueOf<T_>(arg0: Internal.Class_<T_>, arg1: string): T_;
        hashCode(): number;
        notifyAll(): void;
        equals(arg0: any): boolean;
        name(): string;
        toString(): string;
        compareTo(arg0: E): number;
        describeConstable(): Internal.Optional<Internal.Enum$EnumDesc<E>>;
        notify(): void;
        ordinal(): number;
        get class(): Internal.Class<any>;
        get declaringClass(): Internal.Class<E>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    type Enum_<E> = Enum<E>;
    interface BiomeAccess {
        byg_invokeGetGrassColorFromTexture(): number;
    }
    type BiomeAccess_ = BiomeAccess;
    abstract class AbstractStringBuilder implements Internal.Appendable, Internal.CharSequence {
        deleteCharAt(arg0: number): Internal.AbstractStringBuilder;
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        codePointAt(arg0: number): number;
        notifyAll(): void;
        setCharAt(arg0: number, arg1: string): void;
        replace(arg0: number, arg1: number, arg2: string): Internal.AbstractStringBuilder;
        insert(arg0: number, arg1: string): Internal.AbstractStringBuilder;
        insert(arg0: number, arg1: Internal.CharSequence_): Internal.AbstractStringBuilder;
        insert(arg0: number, arg1: string[]): Internal.AbstractStringBuilder;
        insert(arg0: number, arg1: any): Internal.AbstractStringBuilder;
        insert(arg0: number, arg1: string[], arg2: number, arg3: number): Internal.AbstractStringBuilder;
        insert(arg0: number, arg1: boolean): Internal.AbstractStringBuilder;
        insert(arg0: number, arg1: number): Internal.AbstractStringBuilder;
        insert(arg0: number, arg1: Internal.CharSequence_, arg2: number, arg3: number): Internal.AbstractStringBuilder;
        delete(arg0: number, arg1: number): Internal.AbstractStringBuilder;
        notify(): void;
        substring(arg0: number): string;
        substring(arg0: number, arg1: number): string;
        capacity(): number;
        appendCodePoint(arg0: number): Internal.AbstractStringBuilder;
        hashCode(): number;
        codePointBefore(arg0: number): number;
        indexOf(arg0: string): number;
        indexOf(arg0: string, arg1: number): number;
        codePointCount(arg0: number, arg1: number): number;
        codePoints(): Internal.IntStream;
        trimToSize(): void;
        getChars(arg0: number, arg1: number, arg2: string[], arg3: number): void;
        isEmpty(): boolean;
        length(): number;
        subSequence(arg0: number, arg1: number): Internal.CharSequence;
        reverse(): Internal.AbstractStringBuilder;
        lastIndexOf(arg0: string): number;
        lastIndexOf(arg0: string, arg1: number): number;
        setLength(arg0: number): void;
        equals(arg0: any): boolean;
        toString(): string;
        ensureCapacity(arg0: number): void;
        chars(): Internal.IntStream;
        offsetByCodePoints(arg0: number, arg1: number): number;
        charAt(arg0: number): string;
        append(arg0: Internal.CharSequence_): Internal.AbstractStringBuilder;
        append(arg0: Internal.CharSequence_, arg1: number, arg2: number): Internal.AbstractStringBuilder;
        append(arg0: string[]): Internal.AbstractStringBuilder;
        append(arg0: any): Internal.AbstractStringBuilder;
        append(arg0: Internal.StringBuffer_): Internal.AbstractStringBuilder;
        append(arg0: string): Internal.AbstractStringBuilder;
        append(arg0: number): Internal.AbstractStringBuilder;
        append(arg0: boolean): Internal.AbstractStringBuilder;
        append(arg0: string[], arg1: number, arg2: number): Internal.AbstractStringBuilder;
        get class(): Internal.Class<any>;
        get empty(): boolean;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    type AbstractStringBuilder_ = AbstractStringBuilder;
    interface Long2ReferenceFunction <V> extends Internal.Function<number, V>, Internal.LongFunction<V> {
        getOrDefault(arg0: number, arg1: V): V;
        getOrDefault(arg0: any, arg1: V): V;
        andThenShort(arg0: Internal.Reference2ShortFunction_<V>): Internal.Long2ShortFunction;
        composeByte(arg0: Internal.Byte2LongFunction_): Internal.Byte2ReferenceFunction<V>;
        andThenInt(arg0: Internal.Reference2IntFunction_<V>): Internal.Long2IntFunction;
        andThen<V_>(arg0: java_.util.function_.Function_<V, V_>): java_.util.function_.Function<number, V_>;
        composeReference<T_>(arg0: Internal.Reference2LongFunction_<T_>): Internal.Reference2ReferenceFunction<T_, V>;
        put(arg0: number, arg1: V): V;
        remove(arg0: any): V;
        remove(arg0: number): V;
        defaultReturnValue(arg0: V): void;
        defaultReturnValue(): V;
        andThenDouble(arg0: Internal.Reference2DoubleFunction_<V>): Internal.Long2DoubleFunction;
        andThenObject<T_>(arg0: Internal.Reference2ObjectFunction_<V, T_>): Internal.Long2ObjectFunction<T_>;
        get(arg0: any): V;
        get(arg0: number): V;
        andThenLong(arg0: Internal.Reference2LongFunction_<V>): Internal.Long2LongFunction;
        composeLong(arg0: Internal.Long2LongFunction_): Internal.Long2ReferenceFunction<V>;
        andThenByte(arg0: Internal.Reference2ByteFunction_<V>): Internal.Long2ByteFunction;
        andThenFloat(arg0: Internal.Reference2FloatFunction_<V>): Internal.Long2FloatFunction;
        apply(arg0: number): V;
        containsKey(arg0: any): boolean;
        containsKey(arg0: number): boolean;
        composeInt(arg0: Internal.Int2LongFunction_): Internal.Int2ReferenceFunction<V>;
        clear(): void;
        composeFloat(arg0: Internal.Float2LongFunction_): Internal.Float2ReferenceFunction<V>;
        andThenChar(arg0: Internal.Reference2CharFunction_<V>): Internal.Long2CharFunction;
        composeObject<T_>(arg0: Internal.Object2LongFunction_<T_>): Internal.Object2ReferenceFunction<T_, V>;
        size(): number;
        compose<T_>(arg0: java_.util.function_.Function_<T_, number>): java_.util.function_.Function<T_, V>;
        composeShort(arg0: Internal.Short2LongFunction_): Internal.Short2ReferenceFunction<V>;
        andThenReference<T_>(arg0: Internal.Reference2ReferenceFunction_<V, T_>): Internal.Long2ReferenceFunction<T_>;
        composeChar(arg0: Internal.Char2LongFunction_): Internal.Char2ReferenceFunction<V>;
        composeDouble(arg0: Internal.Double2LongFunction_): Internal.Double2ReferenceFunction<V>;
    }
    type Long2ReferenceFunction_<V> = ((arg0: number) => V) | Long2ReferenceFunction<V>;
    interface Byte2ObjectMap$FastEntrySet <V> extends Internal.ObjectSet<Internal.Byte2ObjectMap$Entry<V>> {
        add(arg0: Internal.Byte2ObjectMap$Entry_<V>): boolean;
        spliterator(): Internal.ObjectSpliterator<Internal.Byte2ObjectMap$Entry<V>>;
        forEach(arg0: Internal.Consumer_<Internal.Byte2ObjectMap$Entry_<V>>): void;
        containsAll(arg0: Internal.Collection_<any>): boolean;
        isEmpty(): boolean;
        clear(): void;
        fastIterator(): Internal.ObjectIterator<Internal.Byte2ObjectMap$Entry<V>>;
        remove(arg0: any): boolean;
        removeIf(arg0: Internal.Predicate_<Internal.Byte2ObjectMap$Entry_<V>>): boolean;
        fastForEach(arg0: Internal.Consumer_<Internal.Byte2ObjectMap$Entry_<V>>): void;
        removeAll(arg0: Internal.Collection_<any>): boolean;
        contains(arg0: any): boolean;
        iterator(): Internal.ObjectIterator<Internal.Byte2ObjectMap$Entry<V>>;
        size(): number;
        addAll(arg0: Internal.Collection_<Internal.Byte2ObjectMap$Entry_<V>>): boolean;
        stream(): Internal.Stream<Internal.Byte2ObjectMap$Entry<V>>;
        hashCode(): number;
        equals(arg0: any): boolean;
        toArray<T_>(arg0: T_[]): T_[];
        toArray<T_>(arg0: Internal.IntFunction_<T_[]>): T_[];
        toArray(): any[];
        parallelStream(): Internal.Stream<Internal.Byte2ObjectMap$Entry<V>>;
        retainAll(arg0: Internal.Collection_<any>): boolean;
    }
    type Byte2ObjectMap$FastEntrySet_<V> = Byte2ObjectMap$FastEntrySet<V>;
    /**
    * Fired when the entity loot table is registering.
    */
    class EntityLootEventJS extends Internal.LootEventJS {
        cancel(): void;
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        isCancelled(): boolean;
        modifyEntity(type: Internal.EntityType_<any>, b: Internal.Consumer_<Internal.LootBuilder_>): void;
        notifyAll(): void;
        addJson(id: ResourceLocation_, json: Internal.JsonObject_): void;
        notify(): void;
        modify(id: ResourceLocation_, b: Internal.Consumer_<Internal.LootBuilder_>): void;
        addEntity(type: Internal.EntityType_<any>, b: Internal.Consumer_<Internal.LootBuilder_>): void;
        removeAll(): void;
        post(t: Internal.ScriptType_, id: string, sub: string): boolean;
        post(t: Internal.ScriptType_, id: string): boolean;
        getType(): string;
        hashCode(): number;
        equals(arg0: any): boolean;
        toString(): string;
        getDirectory(): string;
        canCancel(): boolean;
        get cancelled(): boolean;
        get type(): string;
        get class(): Internal.Class<any>;
        get directory(): string;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    /**
    * Fired when the entity loot table is registering.
    */
    type EntityLootEventJS_ = EntityLootEventJS;
    class BlockDestructionProgress implements Internal.Comparable<Internal.BlockDestructionProgress> {
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        hashCode(): number;
        notifyAll(): void;
        equals(arg0: any): boolean;
        toString(): string;
        compareTo(arg0: Internal.BlockDestructionProgress_): number;
        notify(): void;
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    type BlockDestructionProgress_ = BlockDestructionProgress;
    class BufferedImage extends Internal.Image implements Internal.WritableRenderedImage, Internal.Transparency {
        getMinTileX(): number;
        getClass(): Internal.Class<any>;
        getMinTileY(): number;
        isTileWritable(arg0: number, arg1: number): boolean;
        setRGB(arg0: number, arg1: number, arg2: number, arg3: number, arg4: number[], arg5: number, arg6: number): void;
        setRGB(arg0: number, arg1: number, arg2: number): void;
        getNumYTiles(): number;
        coerceData(arg0: boolean): void;
        getSampleModel(): Internal.SampleModel;
        getWritableTile(arg0: number, arg1: number): Internal.WritableRaster;
        removeTileObserver(arg0: Internal.TileObserver_): void;
        getPropertyNames(): string[];
        getNumXTiles(): number;
        getRGB(arg0: number, arg1: number, arg2: number, arg3: number, arg4: number[], arg5: number, arg6: number): number[];
        getRGB(arg0: number, arg1: number): number;
        getTile(arg0: number, arg1: number): Internal.Raster;
        getTransparency(): number;
        getType(): number;
        getSource(): Internal.ImageProducer;
        getMinX(): number;
        getMinY(): number;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        getTileWidth(): number;
        notifyAll(): void;
        getSources(): Internal.Vector<Internal.RenderedImage>;
        getWidth(): number;
        getWidth(arg0: Internal.ImageObserver_): number;
        addTileObserver(arg0: Internal.TileObserver_): void;
        getTileGridXOffset(): number;
        notify(): void;
        getScaledInstance(arg0: number, arg1: number, arg2: number): Internal.Image;
        getWritableTileIndices(): Internal.Point[];
        getHeight(): number;
        getHeight(arg0: Internal.ImageObserver_): number;
        flush(): void;
        hashCode(): number;
        getAccelerationPriority(): number;
        createGraphics(): Internal.Graphics2D;
        getGraphics(): Internal.Graphics;
        getData(arg0: Internal.Rectangle_): Internal.Raster;
        getData(): Internal.Raster;
        getAlphaRaster(): Internal.WritableRaster;
        getRaster(): Internal.WritableRaster;
        getTileHeight(): number;
        getSubimage(arg0: number, arg1: number, arg2: number, arg3: number): Internal.BufferedImage;
        getColorModel(): Internal.ColorModel;
        getProperty(arg0: string): any;
        getProperty(arg0: string, arg1: Internal.ImageObserver_): any;
        setData(arg0: Internal.Raster_): void;
        hasTileWriters(): boolean;
        getCapabilities(arg0: Internal.GraphicsConfiguration_): Internal.ImageCapabilities;
        isAlphaPremultiplied(): boolean;
        copyData(arg0: Internal.WritableRaster_): Internal.WritableRaster;
        setAccelerationPriority(arg0: number): void;
        getTileGridYOffset(): number;
        equals(arg0: any): boolean;
        toString(): string;
        releaseWritableTile(arg0: number, arg1: number): void;
        static readonly TYPE_3BYTE_BGR : 5;
        static readonly TYPE_USHORT_565_RGB : 8;
        static readonly TYPE_INT_ARGB_PRE : 3;
        static readonly TYPE_USHORT_555_RGB : 9;
        static readonly TYPE_USHORT_GRAY : 11;
        static readonly BITMASK : 2;
        static readonly SCALE_FAST : 2;
        static readonly SCALE_AREA_AVERAGING : 16;
        static readonly TYPE_BYTE_INDEXED : 13;
        static readonly SCALE_SMOOTH : 4;
        static readonly SCALE_REPLICATE : 8;
        static readonly TYPE_4BYTE_ABGR : 6;
        static readonly TYPE_INT_ARGB : 2;
        static readonly OPAQUE : 1;
        static readonly SCALE_DEFAULT : 1;
        static readonly TYPE_CUSTOM : 0;
        static readonly TYPE_INT_RGB : 1;
        static readonly TYPE_INT_BGR : 4;
        static readonly TRANSLUCENT : 3;
        static readonly UndefinedProperty : any;
        static readonly TYPE_BYTE_GRAY : 10;
        static readonly TYPE_4BYTE_ABGR_PRE : 7;
        static readonly TYPE_BYTE_BINARY : 12;
        get numXTiles(): number;
        get sources(): Internal.Vector<Internal.RenderedImage>;
        get data(): Internal.Raster;
        get alphaPremultiplied(): boolean;
        get source(): Internal.ImageProducer;
        get graphics(): Internal.Graphics;
        get type(): number;
        get accelerationPriority(): number;
        get colorModel(): Internal.ColorModel;
        get class(): Internal.Class<any>;
        get tileGridXOffset(): number;
        get writableTileIndices(): Internal.Point[];
        get height(): number;
        get raster(): Internal.WritableRaster;
        get tileGridYOffset(): number;
        get tileWidth(): number;
        get minTileX(): number;
        get minTileY(): number;
        get minY(): number;
        get minX(): number;
        get propertyNames(): string[];
        get transparency(): number;
        get width(): number;
        get numYTiles(): number;
        get sampleModel(): Internal.SampleModel;
        get alphaRaster(): Internal.WritableRaster;
        get tileHeight(): number;
        set accelerationPriority(arg0: number);
        set data(arg0: Internal.Raster_);
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    type BufferedImage_ = BufferedImage;
    class EntityDimensions {
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        hashCode(): number;
        notifyAll(): void;
        equals(arg0: any): boolean;
        toString(): string;
        notify(): void;
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    type EntityDimensions_ = EntityDimensions;
    class Dynamic2CommandExceptionType implements Internal.CommandExceptionType {
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        createWithContext(arg0: Internal.ImmutableStringReader_, arg1: any, arg2: any): Internal.CommandSyntaxException;
        hashCode(): number;
        notifyAll(): void;
        equals(arg0: any): boolean;
        create(arg0: any, arg1: any): Internal.CommandSyntaxException;
        toString(): string;
        notify(): void;
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    type Dynamic2CommandExceptionType_ = Dynamic2CommandExceptionType;
    class BucketItem extends Internal.Item implements Internal.DispensibleContainerItem {
        getClass(): Internal.Class<any>;
        canElytraFly(arg0: Internal.ItemStack_, arg1: Internal.LivingEntity_): boolean;
        setBurnTime(i: number): void;
        setDamage(arg0: Internal.ItemStack_, arg1: number): void;
        canPerformAction(arg0: Internal.ItemStack_, arg1: Internal.ToolAction_): boolean;
        damageItem<T_>(arg0: Internal.ItemStack_, arg1: number, arg2: T_, arg3: Internal.Consumer_<T_>): number;
        shouldCauseBlockBreakReset(arg0: Internal.ItemStack_, arg1: Internal.ItemStack_): boolean;
        getItemEnchantability(arg0: Internal.ItemStack_): number;
        getPlacer(): Internal.BlockPlacerItem;
        shouldCauseReequipAnimation(arg0: Internal.ItemStack_, arg1: Internal.ItemStack_, arg2: boolean): boolean;
        getXpRepairRatio(arg0: Internal.ItemStack_): number;
        readShareTag(arg0: Internal.ItemStack_, arg1: Internal.CompoundTag_): void;
        handler$bcn000$overrideOtherStackedOnMe(arg0: Internal.ItemStack_, arg1: Internal.ItemStack_, arg2: Internal.Slot_, arg3: Internal.ClickAction_, arg4: Internal.Player_, arg5: Internal.SlotAccess_, arg6: Internal.CallbackInfoReturnable_<any>): void;
        onEntityItemUpdate(arg0: Internal.ItemStack_, arg1: Internal.ItemEntity_): boolean;
        getDamage(arg0: Internal.ItemStack_): number;
        isBookEnchantable(arg0: Internal.ItemStack_, arg1: Internal.ItemStack_): boolean;
        canDisableShield(arg0: Internal.ItemStack_, arg1: Internal.ItemStack_, arg2: Internal.LivingEntity_, arg3: Internal.LivingEntity_): boolean;
        onUsingTick(arg0: Internal.ItemStack_, arg1: Internal.LivingEntity_, arg2: number): void;
        isPiglinCurrency(arg0: Internal.ItemStack_): boolean;
        getCreativeTabs(): Internal.Collection<Internal.CreativeModeTab>;
        createEntity(arg0: Internal.Level_, arg1: Internal.Entity_, arg2: Internal.ItemStack_): Internal.Entity;
        getSweepHitBox(arg0: Internal.ItemStack_, arg1: Internal.Player_, arg2: Internal.Entity_): Internal.AABB;
        isRepairable(arg0: Internal.ItemStack_): boolean;
        getPlaceableBlock(): Internal.Block;
        getShareTag(arg0: Internal.ItemStack_): Internal.CompoundTag;
        getBurnTime(arg0: Internal.ItemStack_, arg1: Internal.RecipeType_<any>): number;
        onDroppedByPlayer(arg0: Internal.ItemStack_, arg1: Internal.Player_): boolean;
        isDamageable(arg0: Internal.ItemStack_): boolean;
        onEntitySwing(arg0: Internal.ItemStack_, arg1: Internal.LivingEntity_): boolean;
        getRegistryType(): Internal.Class<Internal.Item>;
        setItemBuilderKJS(b: Internal.ItemBuilder_): void;
        elytraFlightTick(arg0: Internal.ItemStack_, arg1: Internal.LivingEntity_, arg2: number): boolean;
        getItemBuilderKJS(): Internal.ItemBuilder;
        handler$bcn000$overrideStackedOnOther(arg0: Internal.ItemStack_, arg1: Internal.Slot_, arg2: Internal.ClickAction_, arg3: Internal.Player_, arg4: Internal.CallbackInfoReturnable_<any>): void;
        getAttributeModifiers(arg0: EquipmentSlot_, arg1: Internal.ItemStack_): Internal.Multimap<Internal.Attribute, Internal.AttributeModifier>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        onLeftClickEntity(arg0: Internal.ItemStack_, arg1: Internal.Player_, arg2: Internal.Entity_): boolean;
        canEquip(arg0: Internal.ItemStack_, arg1: EquipmentSlot_, arg2: Internal.Entity_): boolean;
        notifyAll(): void;
        getId(): string;
        notify(): void;
        onBlockStartBreak(arg0: Internal.ItemStack_, arg1: BlockPos_, arg2: Internal.Player_): boolean;
        onHorseArmorTick(arg0: Internal.ItemStack_, arg1: Internal.Level_, arg2: Internal.Mob_): void;
        canContinueUsing(arg0: Internal.ItemStack_, arg1: Internal.ItemStack_): boolean;
        getEntityLifespan(arg0: Internal.ItemStack_, arg1: Internal.Level_): number;
        getRenderPropertiesInternal(): any;
        getArmorTexture(arg0: Internal.ItemStack_, arg1: Internal.Entity_, arg2: EquipmentSlot_, arg3: string): string;
        getDefaultTooltipHideFlags(arg0: Internal.ItemStack_): number;
        hashCode(): number;
        hasCustomEntity(arg0: Internal.ItemStack_): boolean;
        getHighlightTip(arg0: Internal.ItemStack_, arg1: Internal.Component_): Internal.Component;
        canWalkOnPowderedSnow(arg0: Internal.ItemStack_, arg1: Internal.LivingEntity_): boolean;
        initializeClient(arg0: Internal.Consumer_<Internal.IItemRenderProperties_>): void;
        getMaxDamage(arg0: Internal.ItemStack_): number;
        getCreatorModId(arg0: Internal.ItemStack_): string;
        isDamaged(arg0: Internal.ItemStack_): boolean;
        onArmorTick(arg0: Internal.ItemStack_, arg1: Internal.Level_, arg2: Internal.Player_): void;
        hasContainerItem(arg0: Internal.ItemStack_): boolean;
        getFoodProperties(arg0: Internal.ItemStack_, arg1: Internal.LivingEntity_): Internal.FoodProperties;
        doesSneakBypassUse(arg0: Internal.ItemStack_, arg1: Internal.LevelReader_, arg2: BlockPos_, arg3: Internal.Player_): boolean;
        makePlaceable(arg0: Internal.Block_): void;
        onItemUseFirst(arg0: Internal.ItemStack_, arg1: Internal.UseOnContext_): Internal.InteractionResult;
        getContainerItem(arg0: Internal.ItemStack_): Internal.ItemStack;
        getRegistryName(): ResourceLocation;
        setRegistryName(arg0: ResourceLocation_): Internal.Item;
        setRegistryName(arg0: string): Internal.Item;
        setRegistryName(arg0: string, arg1: string): Internal.Item;
        onDestroyed(arg0: Internal.ItemEntity_, arg1: Internal.DamageSource_): void;
        isCorrectToolForDrops(arg0: Internal.ItemStack_, arg1: Internal.BlockState_): boolean;
        getEquipmentSlot(arg0: Internal.ItemStack_): EquipmentSlot;
        getItemStackLimit(arg0: Internal.ItemStack_): number;
        initCapabilities(arg0: Internal.ItemStack_, arg1: Internal.CompoundTag_): Internal.ICapabilityProvider;
        equals(arg0: any): boolean;
        makesPiglinsNeutral(arg0: Internal.ItemStack_, arg1: Internal.LivingEntity_): boolean;
        getTypeData(): Internal.CompoundTag;
        getFluid(): Internal.Fluid;
        toString(): string;
        isEnderMask(arg0: Internal.ItemStack_, arg1: Internal.Player_, arg2: Internal.EnderMan_): boolean;
        canApplyAtEnchantingTable(arg0: Internal.ItemStack_, arg1: Internal.Enchantment_): boolean;
        readonly delegate : Internal.IRegistryDelegate<Internal.Item>;
        renderProperties : any;
        get registryType(): Internal.Class<Internal.Item>;
        get itemBuilderKJS(): Internal.ItemBuilder;
        get renderPropertiesInternal(): any;
        get placer(): Internal.BlockPlacerItem;
        get placeableBlock(): Internal.Block;
        get creativeTabs(): Internal.Collection<Internal.CreativeModeTab>;
        get fluid(): Internal.Fluid;
        get id(): string;
        get registryName(): ResourceLocation;
        get typeData(): Internal.CompoundTag;
        get class(): Internal.Class<any>;
        set itemBuilderKJS(b: Internal.ItemBuilder_);
        set burnTime(i: number);
        set registryName(arg0: ResourceLocation_);
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    type BucketItem_ = BucketItem;
    class FoodBuilder {
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        removeEffect(mobEffect: Internal.MobEffect_): Internal.FoodBuilder;
        notifyAll(): void;
        alwaysEdible(): Internal.FoodBuilder;
        alwaysEdible(flag: boolean): Internal.FoodBuilder;
        fastToEat(flag: boolean): Internal.FoodBuilder;
        fastToEat(): Internal.FoodBuilder;
        notify(): void;
        hunger(h: number): Internal.FoodBuilder;
        saturation(s: number): Internal.FoodBuilder;
        build(): Internal.FoodProperties;
        hashCode(): number;
        equals(arg0: any): boolean;
        effect(mobEffectId: ResourceLocation_, duration: number, amplifier: number, probability: number): Internal.FoodBuilder;
        meat(flag: boolean): Internal.FoodBuilder;
        meat(): Internal.FoodBuilder;
        toString(): string;
        eaten(e: Internal.Consumer_<Internal.ItemFoodEatenEventJS_>): Internal.FoodBuilder;
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    type FoodBuilder_ = FoodBuilder;
    class Enum$EnumDesc <E> extends Internal.DynamicConstantDesc<E> {
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        static ofCanonical<T_>(arg0: Internal.DirectMethodHandleDesc_, arg1: string, arg2: Internal.ClassDesc_, arg3: Internal.ConstantDesc_[]): Internal.ConstantDesc;
        bootstrapMethod(): Internal.DirectMethodHandleDesc;
        constantName(): string;
        notifyAll(): void;
        bootstrapArgsList(): Internal.List<Internal.ConstantDesc>;
        resolveConstantDesc(arg0: Internal.MethodHandles$Lookup_): E;
        notify(): void;
        constantType(): Internal.ClassDesc;
        hashCode(): number;
        bootstrapArgs(): Internal.ConstantDesc[];
        equals(arg0: any): boolean;
        static of<E_>(arg0: Internal.ClassDesc_, arg1: string): Internal.Enum$EnumDesc<E_>;
        static of<T_>(arg0: Internal.DirectMethodHandleDesc_, arg1: Internal.ConstantDesc_[]): Internal.DynamicConstantDesc<T_>;
        static of<T_>(arg0: Internal.DirectMethodHandleDesc_): Internal.DynamicConstantDesc<T_>;
        static ofNamed<T_>(arg0: Internal.DirectMethodHandleDesc_, arg1: string, arg2: Internal.ClassDesc_, arg3: Internal.ConstantDesc_[]): Internal.DynamicConstantDesc<T_>;
        toString(): string;
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    type Enum$EnumDesc_<E> = Enum$EnumDesc<E>;
    interface Object2BooleanFunction <K> extends Internal.Function<K, boolean>, Internal.Predicate<K> {
        getOrDefault(arg0: any, arg1: boolean): boolean;
        andThenShort(arg0: Internal.Boolean2ShortFunction_): Internal.Object2ShortFunction<K>;
        composeByte(arg0: Internal.Byte2ObjectFunction_<K>): Internal.Byte2BooleanFunction;
        andThenInt(arg0: Internal.Boolean2IntFunction_): Internal.Object2IntFunction<K>;
        composeReference<T_>(arg0: Internal.Reference2ObjectFunction_<T_, K>): Internal.Reference2BooleanFunction<T_>;
        andThen<T_>(arg0: java_.util.function_.Function_<boolean, T_>): java_.util.function_.Function<K, T_>;
        put(arg0: K, arg1: boolean): boolean;
        remove(arg0: any): boolean;
        defaultReturnValue(): boolean;
        defaultReturnValue(arg0: boolean): void;
        andThenDouble(arg0: Internal.Boolean2DoubleFunction_): Internal.Object2DoubleFunction<K>;
        andThenObject<T_>(arg0: Internal.Boolean2ObjectFunction_<T_>): Internal.Object2ObjectFunction<K, T_>;
        and(arg0: Internal.Predicate_<K>): Internal.Predicate<K>;
        get(arg0: any): boolean;
        andThenLong(arg0: Internal.Boolean2LongFunction_): Internal.Object2LongFunction<K>;
        removeBoolean(arg0: any): boolean;
        composeLong(arg0: Internal.Long2ObjectFunction_<K>): Internal.Long2BooleanFunction;
        getBoolean(arg0: any): boolean;
        andThenByte(arg0: Internal.Boolean2ByteFunction_): Internal.Object2ByteFunction<K>;
        andThenFloat(arg0: Internal.Boolean2FloatFunction_): Internal.Object2FloatFunction<K>;
        or(arg0: Internal.Predicate_<K>): Internal.Predicate<K>;
        test(arg0: K): boolean;
        apply(arg0: K): boolean;
        containsKey(arg0: any): boolean;
        composeInt(arg0: Internal.Int2ObjectFunction_<K>): Internal.Int2BooleanFunction;
        clear(): void;
        composeFloat(arg0: Internal.Float2ObjectFunction_<K>): Internal.Float2BooleanFunction;
        andThenChar(arg0: Internal.Boolean2CharFunction_): Internal.Object2CharFunction<K>;
        composeObject<T_>(arg0: Internal.Object2ObjectFunction_<T_, K>): Internal.Object2BooleanFunction<T_>;
        size(): number;
        compose<V_>(arg0: java_.util.function_.Function_<V_, K>): java_.util.function_.Function<V_, boolean>;
        negate(): Internal.Predicate<K>;
        composeShort(arg0: Internal.Short2ObjectFunction_<K>): Internal.Short2BooleanFunction;
        andThenReference<T_>(arg0: Internal.Boolean2ReferenceFunction_<T_>): Internal.Object2ReferenceFunction<K, T_>;
        composeChar(arg0: Internal.Char2ObjectFunction_<K>): Internal.Char2BooleanFunction;
        composeDouble(arg0: Internal.Double2ObjectFunction_<K>): Internal.Double2BooleanFunction;
    }
    type Object2BooleanFunction_<K> = ((arg0: any) => boolean) | Object2BooleanFunction<K>;
    abstract class RenderType extends Internal.RenderStateShard implements net.coderbot.iris.mixin.rendertype.RenderTypeAccessor, Internal.RenderTypeAccessor, Internal.AccessorRenderType {
        getClass(): Internal.Class<any>;
        handler$bhl000$setupNoLighting(arg0: Internal.BufferBuilder_, arg1: number, arg2: number, arg3: number, arg4: Internal.CallbackInfo_): void;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        hashCode(): number;
        notifyAll(): void;
        equals(arg0: any): boolean;
        toString(): string;
        handler$bhl000$cleanNoLighting(arg0: Internal.BufferBuilder_, arg1: number, arg2: number, arg3: number, arg4: Internal.CallbackInfo_): void;
        notify(): void;
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    type RenderType_ = RenderType;
    class Hashtable <K, V> extends Internal.Dictionary<K, V> implements Internal.Map<K, V>, Internal.Cloneable, Internal.Serializable {
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        getOrDefault(arg0: any, arg1: V): V;
        keys(): Internal.Enumeration<K>;
        notifyAll(): void;
        computeIfAbsent(arg0: K, arg1: java_.util.function_.Function_<K, V>): V;
        values(): Internal.Collection<V>;
        replace(arg0: K, arg1: V): V;
        replace(arg0: K, arg1: V, arg2: V): boolean;
        replaceAll(arg0: Internal.BiFunction_<K, V, V>): void;
        notify(): void;
        containsValue(arg0: any): boolean;
        put(arg0: K, arg1: V): V;
        remove(arg0: any): V;
        remove(arg0: any, arg1: any): boolean;
        compute(arg0: K, arg1: Internal.BiFunction_<K, V, V>): V;
        hashCode(): number;
        putAll(arg0: Internal.Map_<K, V>): void;
        merge(arg0: K, arg1: V, arg2: Internal.BiFunction_<V, V, V>): V;
        get(arg0: any): V;
        keySet(): Internal.Set<K>;
        entrySet(): Internal.Set<Internal.Map$Entry<K, V>>;
        containsKey(arg0: any): boolean;
        forEach(arg0: Internal.BiConsumer_<K, V>): void;
        isEmpty(): boolean;
        clear(): void;
        contains(arg0: any): boolean;
        computeIfPresent(arg0: K, arg1: Internal.BiFunction_<K, V, V>): V;
        size(): number;
        elements(): Internal.Enumeration<V>;
        equals(arg0: any): boolean;
        clone(): any;
        toString(): string;
        putIfAbsent(arg0: K, arg1: V): V;
        get class(): Internal.Class<any>;
        get empty(): boolean;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    type Hashtable_<K, V> = Hashtable<K, V>;
    abstract class SimplePreparableReloadListener <T> implements Internal.PreparableReloadListener {
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        hashCode(): number;
        notifyAll(): void;
        equals(arg0: any): boolean;
        toString(): string;
        notify(): void;
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    type SimplePreparableReloadListener_<T> = SimplePreparableReloadListener<T>;
    interface ObjectOutput extends Internal.DataOutput, Internal.AutoCloseable {
        writeInt(arg0: number): void;
        writeByte(arg0: number): void;
        writeObject(arg0: any): void;
        writeFloat(arg0: number): void;
        writeChar(arg0: number): void;
        writeLong(arg0: number): void;
        writeBytes(arg0: string): void;
        flush(): void;
        writeUTF(arg0: string): void;
        writeShort(arg0: number): void;
        writeChars(arg0: string): void;
        close(): void;
        write(arg0: number[], arg1: number, arg2: number): void;
        write(arg0: number[]): void;
        write(arg0: number): void;
        writeBoolean(arg0: boolean): void;
        writeDouble(arg0: number): void;
    }
    type ObjectOutput_ = ObjectOutput;
    class ContinuationPending extends Internal.RuntimeException {
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        printStackTrace(): void;
        printStackTrace(arg0: Internal.PrintWriter_): void;
        printStackTrace(arg0: Internal.PrintStream_): void;
        getLocalizedMessage(): string;
        notifyAll(): void;
        initCause(arg0: Internal.Throwable_): Internal.Throwable;
        getMessage(): string;
        getApplicationState(): any;
        getCause(): Internal.Throwable;
        notify(): void;
        getContinuation(): any;
        addSuppressed(arg0: Internal.Throwable_): void;
        setStackTrace(arg0: any_[]): void;
        getStackTrace(): any[];
        setApplicationState(applicationState: any): void;
        hashCode(): number;
        equals(arg0: any): boolean;
        getSuppressed(): Internal.Throwable[];
        toString(): string;
        fillInStackTrace(): Internal.Throwable;
        setContinuation(continuation: Internal.NativeContinuation_): void;
        get localizedMessage(): string;
        get applicationState(): any;
        get cause(): Internal.Throwable;
        get stackTrace(): any[];
        get suppressed(): Internal.Throwable[];
        get message(): string;
        get class(): Internal.Class<any>;
        get continuation(): any;
        set applicationState(applicationState: any);
        set stackTrace(arg0: any_[]);
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    type ContinuationPending_ = ContinuationPending;
    interface LongStream$Builder extends java_.util.function_.LongConsumer {
        add(arg0: number): Internal.LongStream$Builder;
        build(): Internal.LongStream;
        andThen(arg0: java_.util.function_.LongConsumer_): java_.util.function_.LongConsumer;
        accept(arg0: number): void;
    }
    type LongStream$Builder_ = LongStream$Builder;
    class ModuleDescriptor$Opens implements Internal.Comparable<Internal.ModuleDescriptor$Opens> {
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        hashCode(): number;
        notifyAll(): void;
        equals(arg0: any): boolean;
        isQualified(): boolean;
        toString(): string;
        source(): string;
        compareTo(arg0: Internal.ModuleDescriptor$Opens_): number;
        modifiers(): Internal.Set<Internal.ModuleDescriptor$Opens$Modifier>;
        targets(): Internal.Set<string>;
        notify(): void;
        get qualified(): boolean;
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    type ModuleDescriptor$Opens_ = ModuleDescriptor$Opens;
    interface DoubleComparator extends Internal.Comparator<number> {
        compare(arg0: number, arg1: number): number;
        thenComparingLong(arg0: Internal.ToLongFunction_<number>): Internal.Comparator<number>;
        thenComparingInt(arg0: Internal.ToIntFunction_<number>): Internal.Comparator<number>;
        thenComparing(arg0: Internal.Comparator_<number>): Internal.Comparator<number>;
        thenComparing(arg0: Internal.DoubleComparator_): Internal.DoubleComparator;
        thenComparing<U_>(arg0: java_.util.function_.Function_<number, U_>, arg1: Internal.Comparator_<U_>): Internal.Comparator<number>;
        thenComparing<U_>(arg0: java_.util.function_.Function_<number, U_>): Internal.Comparator<number>;
        thenComparingDouble(arg0: Internal.ToDoubleFunction_<number>): Internal.Comparator<number>;
        equals(arg0: any): boolean;
        reversed(): Internal.DoubleComparator;
    }
    type DoubleComparator_ = ((arg0: number, arg1: number) => number) | DoubleComparator;
    interface IRecipeCategory <T> {
        getTooltipStrings(arg0: T, arg1: Internal.IRecipeSlotsView_, arg2: number, arg3: number): Internal.List<Internal.Component>;
        getTooltipStrings(arg0: T, arg1: number, arg2: number): Internal.List<Internal.Component>;
        setRecipe(arg0: Internal.IRecipeLayoutBuilder_, arg1: T, arg2: Internal.List_<Internal.IFocus_<any>>): void;
        setRecipe(arg0: Internal.IRecipeLayout_, arg1: T, arg2: Internal.IIngredients_): void;
        setRecipe(arg0: Internal.IRecipeLayoutBuilder_, arg1: T, arg2: Internal.IFocusGroup_): void;
        getRegistryName(arg0: T): ResourceLocation;
        draw(arg0: T, arg1: Internal.PoseStack_, arg2: number, arg3: number): void;
        draw(arg0: T, arg1: Internal.IRecipeSlotsView_, arg2: Internal.PoseStack_, arg3: number, arg4: number): void;
        handleInput(arg0: T, arg1: number, arg2: number, arg3: Internal.InputConstants$Key_): boolean;
        isHandled(arg0: T): boolean;
        getIcon(): Internal.IDrawable;
        getUid(): ResourceLocation;
        getRecipeType(): mezz.jei.api.recipe.RecipeType<T>;
        getTitle(): Internal.Component;
        handleClick(arg0: T, arg1: number, arg2: number, arg3: number): boolean;
        setIngredients(arg0: T, arg1: Internal.IIngredients_): void;
        getRecipeClass(): Internal.Class<T>;
        getBackground(): Internal.IDrawable;
    }
    type IRecipeCategory_<T> = IRecipeCategory<T>;
    class LiquidBlock extends Internal.Block implements Internal.BucketPickup {
        rotate(arg0: Internal.BlockState_, arg1: Internal.LevelAccessor_, arg2: BlockPos_, arg3: Internal.Rotation_): Internal.BlockState;
        getClass(): Internal.Class<any>;
        getStateAtViewpoint(arg0: Internal.BlockState_, arg1: Internal.BlockGetter_, arg2: BlockPos_, arg3: Vec3_): Internal.BlockState;
        onBlockExploded(arg0: Internal.BlockState_, arg1: Internal.Level_, arg2: BlockPos_, arg3: Internal.Explosion_): void;
        getBedDirection(arg0: Internal.BlockState_, arg1: Internal.LevelReader_, arg2: BlockPos_): Internal.Direction;
        getPickupSound(arg0: Internal.BlockState_): Internal.Optional<Internal.SoundEvent>;
        isBed(arg0: Internal.BlockState_, arg1: Internal.BlockGetter_, arg2: BlockPos_, arg3: Internal.Entity_): boolean;
        canHarvestBlock(arg0: Internal.BlockState_, arg1: Internal.BlockGetter_, arg2: BlockPos_, arg3: Internal.Player_): boolean;
        makesOpenTrapdoorAboveClimbable(arg0: Internal.BlockState_, arg1: Internal.LevelReader_, arg2: BlockPos_, arg3: Internal.BlockState_): boolean;
        isLadder(arg0: Internal.BlockState_, arg1: Internal.LevelReader_, arg2: BlockPos_, arg3: Internal.LivingEntity_): boolean;
        shouldDisplayFluidOverlay(arg0: Internal.BlockState_, arg1: Internal.BlockAndTintGetter_, arg2: BlockPos_, arg3: Internal.FluidState_): boolean;
        canStickTo(arg0: Internal.BlockState_, arg1: Internal.BlockState_): boolean;
        onNeighborChange(arg0: Internal.BlockState_, arg1: Internal.LevelReader_, arg2: BlockPos_, arg3: BlockPos_): void;
        getWeakChanges(arg0: Internal.BlockState_, arg1: Internal.LevelReader_, arg2: BlockPos_): boolean;
        canEntityDestroy(arg0: Internal.BlockState_, arg1: Internal.BlockGetter_, arg2: BlockPos_, arg3: Internal.Entity_): boolean;
        isBurning(arg0: Internal.BlockState_, arg1: Internal.BlockGetter_, arg2: BlockPos_): boolean;
        getFriction(arg0: Internal.BlockState_, arg1: Internal.LevelReader_, arg2: BlockPos_, arg3: Internal.Entity_): number;
        isValidSpawn(arg0: Internal.BlockState_, arg1: Internal.BlockGetter_, arg2: BlockPos_, arg3: Internal.SpawnPlacements$Type_, arg4: Internal.EntityType_<any>): boolean;
        isPortalFrame(arg0: Internal.BlockState_, arg1: Internal.BlockGetter_, arg2: BlockPos_): boolean;
        getExplosionResistance(arg0: Internal.BlockState_, arg1: Internal.BlockGetter_, arg2: BlockPos_, arg3: Internal.Explosion_): number;
        isScaffolding(arg0: Internal.BlockState_, arg1: Internal.LevelReader_, arg2: BlockPos_, arg3: Internal.LivingEntity_): boolean;
        canSustainPlant(arg0: Internal.BlockState_, arg1: Internal.BlockGetter_, arg2: BlockPos_, arg3: Internal.Direction_, arg4: Internal.IPlantable_): boolean;
        canDropFromExplosion(arg0: Internal.BlockState_, arg1: Internal.BlockGetter_, arg2: BlockPos_, arg3: Internal.Explosion_): boolean;
        isStickyBlock(arg0: Internal.BlockState_): boolean;
        isFertile(arg0: Internal.BlockState_, arg1: Internal.BlockGetter_, arg2: BlockPos_): boolean;
        getAiPathNodeType(arg0: Internal.BlockState_, arg1: Internal.BlockGetter_, arg2: BlockPos_, arg3: Internal.Mob_): Internal.BlockPathTypes;
        getBlockBuilderKJS(): Internal.BlockBuilder;
        isSlimeBlock(arg0: Internal.BlockState_): boolean;
        getRegistryType(): Internal.Class<Internal.Block>;
        getFireSpreadSpeed(arg0: Internal.BlockState_, arg1: Internal.BlockGetter_, arg2: BlockPos_, arg3: Internal.Direction_): number;
        getToolModifiedState(arg0: Internal.BlockState_, arg1: Internal.Level_, arg2: BlockPos_, arg3: Internal.Player_, arg4: Internal.ItemStack_, arg5: Internal.ToolAction_): Internal.BlockState;
        getToolModifiedState(arg0: Internal.BlockState_, arg1: Internal.UseOnContext_, arg2: Internal.ToolAction_, arg3: boolean): Internal.BlockState;
        getBeaconColorMultiplier(arg0: Internal.BlockState_, arg1: Internal.LevelReader_, arg2: BlockPos_, arg3: BlockPos_): number[];
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        getExpDrop(arg0: Internal.BlockState_, arg1: Internal.LevelReader_, arg2: BlockPos_, arg3: number, arg4: number): number;
        isConduitFrame(arg0: Internal.BlockState_, arg1: Internal.LevelReader_, arg2: BlockPos_, arg3: BlockPos_): boolean;
        notifyAll(): void;
        getLightEmission(arg0: Internal.BlockState_, arg1: Internal.BlockGetter_, arg2: BlockPos_): number;
        onDestroyedByPlayer(arg0: Internal.BlockState_, arg1: Internal.Level_, arg2: BlockPos_, arg3: Internal.Player_, arg4: boolean, arg5: Internal.FluidState_): boolean;
        getId(): string;
        shouldCheckWeakPower(arg0: Internal.BlockState_, arg1: Internal.LevelReader_, arg2: BlockPos_, arg3: Internal.Direction_): boolean;
        collisionExtendsVertically(arg0: Internal.BlockState_, arg1: Internal.BlockGetter_, arg2: BlockPos_, arg3: Internal.Entity_): boolean;
        notify(): void;
        supportsExternalFaceHiding(arg0: Internal.BlockState_): boolean;
        addLandingEffects(arg0: Internal.BlockState_, arg1: Internal.ServerLevel_, arg2: BlockPos_, arg3: Internal.BlockState_, arg4: Internal.LivingEntity_, arg5: number): boolean;
        getRenderPropertiesInternal(): any;
        getSoundType(arg0: Internal.BlockState_, arg1: Internal.LevelReader_, arg2: BlockPos_, arg3: Internal.Entity_): Internal.SoundType;
        hashCode(): number;
        addRunningEffects(arg0: Internal.BlockState_, arg1: Internal.Level_, arg2: BlockPos_, arg3: Internal.Entity_): boolean;
        hidesNeighborFace(arg0: Internal.BlockGetter_, arg1: BlockPos_, arg2: Internal.BlockState_, arg3: Internal.BlockState_, arg4: Internal.Direction_): boolean;
        initializeClient(arg0: Internal.Consumer_<Internal.IBlockRenderProperties_>): void;
        getCloneItemStack(arg0: Internal.BlockState_, arg1: Internal.HitResult_, arg2: Internal.BlockGetter_, arg3: BlockPos_, arg4: Internal.Player_): Internal.ItemStack;
        getBlockStatesKJS(): Internal.List<Internal.BlockState>;
        isFlammable(arg0: Internal.BlockState_, arg1: Internal.BlockGetter_, arg2: BlockPos_, arg3: Internal.Direction_): boolean;
        onCaughtFire(arg0: Internal.BlockState_, arg1: Internal.Level_, arg2: BlockPos_, arg3: Internal.Direction_, arg4: Internal.LivingEntity_): void;
        getEnchantPowerBonus(arg0: Internal.BlockState_, arg1: Internal.LevelReader_, arg2: BlockPos_): number;
        getRegistryName(): ResourceLocation;
        setBedOccupied(arg0: Internal.BlockState_, arg1: Internal.Level_, arg2: BlockPos_, arg3: Internal.LivingEntity_, arg4: boolean): void;
        setRegistryName(arg0: ResourceLocation_): Internal.Block;
        setRegistryName(arg0: string): Internal.Block;
        setRegistryName(arg0: string, arg1: string): Internal.Block;
        isFireSource(arg0: Internal.BlockState_, arg1: Internal.LevelReader_, arg2: BlockPos_, arg3: Internal.Direction_): boolean;
        getRespawnPosition(arg0: Internal.BlockState_, arg1: Internal.EntityType_<any>, arg2: Internal.LevelReader_, arg3: BlockPos_, arg4: number, arg5: Internal.LivingEntity_): Internal.Optional<Vec3>;
        equals(arg0: any): boolean;
        canConnectRedstone(arg0: Internal.BlockState_, arg1: Internal.BlockGetter_, arg2: BlockPos_, arg3: Internal.Direction_): boolean;
        setBlockBuilderKJS(b: Internal.BlockBuilder_): void;
        getTypeData(): Internal.CompoundTag;
        getFluid(): Internal.FlowingFluid;
        toString(): string;
        getFlammability(arg0: Internal.BlockState_, arg1: Internal.BlockGetter_, arg2: BlockPos_, arg3: Internal.Direction_): number;
        readonly delegate : Internal.IRegistryDelegate<Internal.Block>;
        get registryType(): Internal.Class<Internal.Block>;
        get blockBuilderKJS(): Internal.BlockBuilder;
        get renderPropertiesInternal(): any;
        get blockStatesKJS(): Internal.List<Internal.BlockState>;
        get fluid(): Internal.FlowingFluid;
        get id(): string;
        get registryName(): ResourceLocation;
        get typeData(): Internal.CompoundTag;
        get class(): Internal.Class<any>;
        set blockBuilderKJS(b: Internal.BlockBuilder_);
        set registryName(arg0: ResourceLocation_);
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    type LiquidBlock_ = LiquidBlock;
    class FontManager implements Internal.AutoCloseable, Internal.AccessorFontManager {
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        hashCode(): number;
        notifyAll(): void;
        equals(arg0: any): boolean;
        toString(): string;
        close(): void;
        notify(): void;
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    type FontManager_ = FontManager;
    class BotaniaRunicAltarRecipeJS extends Internal.RecipeJS {
        parseResultItemList(o: any): Internal.List<Internal.ItemStackJS>;
        getClass(): Internal.Class<any>;
        ingredientAction(filter: Internal.IngredientActionFilter_, action: Internal.IngredientAction_): Internal.RecipeJS;
        convertReplacedInput(index: number, oldIngredient: Internal.IngredientJS_, newIngredient: Internal.IngredientJS_): Internal.IngredientJS;
        getUniqueId(): string;
        replaceOutput(i: Internal.IngredientJS_, with_: Internal.ItemStackJS_, exact: boolean): boolean;
        replaceOutput(i: Internal.IngredientJS_, with_: Internal.ItemStackJS_, exact: boolean, func: Internal.BiFunction_<Internal.ItemStackJS_, Internal.ItemStackJS_, Internal.ItemStackJS_>): boolean;
        parseIngredientItemList(o: any): Internal.List<Internal.IngredientJS>;
        merge(data: any): Internal.RecipeJS;
        getPath(): string;
        create(args: Internal.ListJS_): void;
        parseIngredientItemStackList(o: any): Internal.List<Internal.IngredientStackJS>;
        id(_id: ResourceLocation_): Internal.RecipeJS;
        parseIngredientItem(o: any, key: string): Internal.IngredientJS;
        parseIngredientItem(o: any): Internal.IngredientJS;
        group(g: string): Internal.RecipeJS;
        getOriginalRecipeResult(): Internal.ItemStackJS;
        getOriginalRecipeIngredients(): Internal.List<Internal.IngredientJS>;
        getInputIndex(ingredient: Internal.IngredientJS_, exact: boolean): number;
        setGroup(g: string): void;
        serialize(): void;
        replaceInput(i: Internal.IngredientJS_, with_: Internal.IngredientJS_, exact: boolean, func: Internal.BiFunction_<Internal.IngredientJS_, Internal.IngredientJS_, Internal.IngredientJS_>): boolean;
        replaceInput(i: Internal.IngredientJS_, with_: Internal.IngredientJS_, exact: boolean): boolean;
        getType(): string;
        getGroup(): string;
        hasOutput(ingredient: Internal.IngredientJS_, exact: boolean): boolean;
        keepIngredient(filter: Internal.IngredientActionFilter_): Internal.RecipeJS;
        customIngredientAction(filter: Internal.IngredientActionFilter_, id: string): Internal.RecipeJS;
        modifyResult(callback: Internal.ModifyRecipeResultCallback_): Internal.RecipeJS;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        getMod(): string;
        notifyAll(): void;
        convertReplacedOutput(index: number, oldStack: Internal.ItemStackJS_, newStack: Internal.ItemStackJS_): Internal.ItemStackJS;
        save(): void;
        damageIngredient(filter: Internal.IngredientActionFilter_): Internal.RecipeJS;
        damageIngredient(filter: Internal.IngredientActionFilter_, damage: number): Internal.RecipeJS;
        getId(): string;
        dontAdd(): void;
        notify(): void;
        serializeJson(): void;
        createRecipe(): Internal.Recipe<any>;
        getFromToString(): string;
        hashCode(): number;
        deserializeJson(): void;
        getOrCreateId(): ResourceLocation;
        deserialize(): void;
        serializeNBTAsJson(): boolean;
        getOutputIndex(ingredient: Internal.IngredientJS_, exact: boolean): number;
        serializeIngredientStack(in_: Internal.IngredientStackJS_): Internal.JsonElement;
        resultFromRecipeJson(json: Internal.JsonObject_): Internal.ItemStackJS;
        stage(s: string): Internal.RecipeJS;
        mana(t: number): Internal.BotaniaRunicAltarRecipeJS;
        equals(arg0: any): boolean;
        serializeItemStack(stack: Internal.ItemStackJS_): Internal.JsonElement;
        toString(): string;
        hasInput(ingredient: Internal.IngredientJS_, exact: boolean): boolean;
        parseResultItem(o: any): Internal.ItemStackJS;
        replaceIngredient(filter: Internal.IngredientActionFilter_, item: Internal.ItemStackJS_): Internal.RecipeJS;
        static currentRecipe : Internal.RecipeJS;
        originalJson : Internal.JsonObject;
        serializeOutputs : boolean;
        originalRecipe : Internal.Recipe<any>;
        readonly inputItems : Internal.List<((arg0: Internal.ItemStackJS) => boolean)>;
        static itemErrors : false;
        json : Internal.JsonObject;
        readonly outputItems : Internal.List<Internal.ItemStackJS>;
        type : Internal.RecipeTypeJS;
        serializeInputs : boolean;
        get path(): string;
        get originalRecipeIngredients(): Internal.List<Internal.IngredientJS>;
        get mod(): string;
        get originalRecipeResult(): Internal.ItemStackJS;
        get orCreateId(): ResourceLocation;
        get class(): Internal.Class<any>;
        get fromToString(): string;
        get uniqueId(): string;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    type BotaniaRunicAltarRecipeJS_ = BotaniaRunicAltarRecipeJS;
    interface IRecipeSlotBuilder extends Internal.IIngredientAcceptor<Internal.IRecipeSlotBuilder> {
        addIngredients<I_>(arg0: Internal.IIngredientType_<I_>, arg1: Internal.List_<I_>): Internal.IRecipeSlotBuilder;
        addIngredients(arg0: Internal.Ingredient_): Internal.IRecipeSlotBuilder;
        setFluidRenderer(arg0: number, arg1: boolean, arg2: number, arg3: number): Internal.IRecipeSlotBuilder;
        addIngredient<I_>(arg0: Internal.IIngredientType_<I_>, arg1: I_): Internal.IRecipeSlotBuilder;
        setSlotName(arg0: string): Internal.IRecipeSlotBuilder;
        addIngredientsUnsafe(arg0: Internal.List_<any>): Internal.IRecipeSlotBuilder;
        addTooltipCallback(arg0: Internal.IRecipeSlotTooltipCallback_): Internal.IRecipeSlotBuilder;
        addItemStack(arg0: Internal.ItemStack_): Internal.IRecipeSlotBuilder;
        addItemStacks(arg0: Internal.List_<Internal.ItemStack_>): Internal.IRecipeSlotBuilder;
        setOverlay(arg0: Internal.IDrawable_, arg1: number, arg2: number): Internal.IRecipeSlotBuilder;
        setCustomRenderer<T_>(arg0: Internal.IIngredientType_<T_>, arg1: Internal.IIngredientRenderer_<T_>): Internal.IRecipeSlotBuilder;
        setBackground(arg0: Internal.IDrawable_, arg1: number, arg2: number): Internal.IRecipeSlotBuilder;
    }
    type IRecipeSlotBuilder_ = IRecipeSlotBuilder;
    class VertexFormat implements Internal.BufferVertexFormat {
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        getStride(): number;
        hasPosition(): boolean;
        notifyAll(): void;
        getOffset(arg0: number): number;
        getElementMapping(): Internal.ImmutableMap<string, Internal.VertexFormatElement>;
        notify(): void;
        hasColor(): boolean;
        hasNormal(): boolean;
        hashCode(): number;
        equals(arg0: any): boolean;
        toString(): string;
        hasUV(arg0: number): boolean;
        get elementMapping(): Internal.ImmutableMap<string, Internal.VertexFormatElement>;
        get stride(): number;
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    type VertexFormat_ = VertexFormat;
    abstract class PrintJob {
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        hashCode(): number;
        notifyAll(): void;
        equals(arg0: any): boolean;
        toString(): string;
        end(): void;
        finalize(): void;
        getGraphics(): Internal.Graphics;
        getPageDimension(): Internal.Dimension;
        getPageResolution(): number;
        notify(): void;
        lastPageFirst(): boolean;
        get pageDimension(): Internal.Dimension;
        get graphics(): Internal.Graphics;
        get class(): Internal.Class<any>;
        get pageResolution(): number;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    type PrintJob_ = PrintJob;
    class ModifyRecipeCraftingGrid {
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        getPlayer(): Internal.PlayerJS<any>;
        notifyAll(): void;
        getWidth(): number;
        findAll(): Internal.List<Internal.ItemStackJS>;
        findAll(ingredient: Internal.IngredientJS_): Internal.List<Internal.ItemStackJS>;
        notify(): void;
        getHeight(): number;
        hashCode(): number;
        find(ingredient: Internal.IngredientJS_, skip: number): Internal.ItemStackJS;
        find(ingredient: Internal.IngredientJS_): Internal.ItemStackJS;
        equals(arg0: any): boolean;
        getMenu(): Internal.AbstractContainerMenu;
        get(index: number): Internal.ItemStackJS;
        toString(): string;
        get width(): number;
        get menu(): Internal.AbstractContainerMenu;
        get class(): Internal.Class<any>;
        get player(): Internal.PlayerJS<any>;
        get height(): number;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    type ModifyRecipeCraftingGrid_ = ModifyRecipeCraftingGrid;
    interface MethodTypeDesc extends Internal.ConstantDesc, Internal.TypeDescriptor$OfMethod<Internal.ClassDesc, Internal.MethodTypeDesc> {
        parameterType(arg0: number): Internal.ClassDesc;
        dropParameterTypes(arg0: number, arg1: number): Internal.MethodTypeDesc;
        parameterCount(): number;
        changeReturnType(arg0: Internal.ClassDesc_): Internal.MethodTypeDesc;
        descriptorString(): string;
        insertParameterTypes(arg0: number, arg1: Internal.ClassDesc_[]): Internal.MethodTypeDesc;
        resolveConstantDesc(arg0: Internal.MethodHandles$Lookup_): any;
        changeParameterType(arg0: number, arg1: Internal.ClassDesc_): Internal.MethodTypeDesc;
        parameterArray(): Internal.ClassDesc[];
        equals(arg0: any): boolean;
        parameterList(): Internal.List<Internal.ClassDesc>;
        displayDescriptor(): string;
        returnType(): Internal.ClassDesc;
    }
    type MethodTypeDesc_ = MethodTypeDesc;
    interface IPacket {
        encode(arg0: Internal.FriendlyByteBuf_): void;
        decode(arg0: Internal.FriendlyByteBuf_): void;
        execute(arg0: Internal.NetworkEvent$Context_): void;
    }
    type IPacket_ = IPacket;
    class FlavorEvent extends Internal.EventObject {
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        hashCode(): number;
        getSource(): any;
        notifyAll(): void;
        equals(arg0: any): boolean;
        toString(): string;
        notify(): void;
        get source(): any;
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    type FlavorEvent_ = FlavorEvent;
    abstract class RhinoException extends Internal.RuntimeException {
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        getLocalizedMessage(): string;
        getScriptStack(limit: number, hideFunction: string): any[];
        getScriptStack(): any[];
        notifyAll(): void;
        initColumnNumber(columnNumber: number): void;
        getCause(): Internal.Throwable;
        notify(): void;
        getScriptStackTrace(limit: number, functionName: string): string;
        getScriptStackTrace(): string;
        addSuppressed(arg0: Internal.Throwable_): void;
        getStackTrace(): any[];
        columnNumber(): number;
        hashCode(): number;
        getSuppressed(): Internal.Throwable[];
        details(): string;
        printStackTrace(s: Internal.PrintWriter_): void;
        printStackTrace(s: Internal.PrintStream_): void;
        printStackTrace(): void;
        initSourceName(sourceName: string): void;
        initCause(arg0: Internal.Throwable_): Internal.Throwable;
        getMessage(): string;
        initLineSource(lineSource: string): void;
        setStackTrace(arg0: any_[]): void;
        lineSource(): string;
        equals(arg0: any): boolean;
        initLineNumber(lineNumber: number): void;
        toString(): string;
        sourceName(): string;
        lineNumber(): number;
        fillInStackTrace(): Internal.Throwable;
        get localizedMessage(): string;
        get scriptStack(): any[];
        get cause(): Internal.Throwable;
        get scriptStackTrace(): string;
        get stackTrace(): any[];
        get suppressed(): Internal.Throwable[];
        get message(): string;
        get class(): Internal.Class<any>;
        set stackTrace(arg0: any_[]);
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    type RhinoException_ = RhinoException;
    interface URLStreamHandlerFactory {
        createURLStreamHandler(arg0: string): Internal.URLStreamHandler;
    }
    type URLStreamHandlerFactory_ = URLStreamHandlerFactory;
    interface EnchantmentBuilder$PostFunction {
        apply(arg0: Internal.LivingEntityJS_, arg1: Internal.EntityJS_, arg2: number): void;
    }
    type EnchantmentBuilder$PostFunction_ = ((arg0: Internal.LivingEntityJS, arg1: Internal.EntityJS, arg2: number) => void) | EnchantmentBuilder$PostFunction;
    class Dynamic <T> extends Internal.DynamicLike<T> {
        createIntList(arg0: Internal.IntStream_): Internal.Dynamic<any>;
        createLong(arg0: number): Internal.Dynamic<T>;
        getClass(): Internal.Class<any>;
        getElementGeneric(arg0: T): Internal.DataResult<T>;
        getElementGeneric(arg0: T, arg1: T): T;
        updateMapValues(arg0: java_.util.function_.Function_<Internal.Pair_<Internal.Dynamic_<any>, Internal.Dynamic_<any>>, Internal.Pair_<Internal.Dynamic_<any>, Internal.Dynamic_<any>>>): Internal.Dynamic<T>;
        createLongList(arg0: Internal.LongStream_): Internal.Dynamic<any>;
        readMap<K_, V_>(arg0: Internal.Decoder_<K_>, arg1: Internal.Decoder_<V_>): Internal.DataResult<Internal.List<Internal.Pair<K_, V_>>>;
        readMap<R_>(arg0: Internal.DataResult_<R_>, arg1: Internal.Function3_<R_, Internal.Dynamic_<T>, Internal.Dynamic_<T>, Internal.DataResult_<R_>>): Internal.DataResult<R_>;
        readMap<K_, V_>(arg0: Internal.Decoder_<K_>, arg1: java_.util.function_.Function_<K_, Internal.Decoder_<V_>>): Internal.DataResult<Internal.List<Internal.Pair<K_, V_>>>;
        asListOpt<U_>(arg0: java_.util.function_.Function_<Internal.Dynamic_<T>, U_>): Internal.DataResult<Internal.List<U_>>;
        createShort(arg0: number): Internal.Dynamic<T>;
        static convert<S_, T_>(arg0: Internal.DynamicOps_<S_>, arg1: Internal.DynamicOps_<T_>, arg2: S_): T_;
        convert<R_>(arg0: Internal.DynamicOps_<R_>): Internal.Dynamic<R_>;
        decode<A_>(arg0: Internal.Decoder_<A_>): Internal.DataResult<Internal.Pair<A_, T>>;
        asIntStreamOpt(): Internal.DataResult<Internal.IntStream>;
        asList<U_>(arg0: java_.util.function_.Function_<Internal.Dynamic_<T>, U_>): Internal.List<U_>;
        getMapValues(): Internal.DataResult<Internal.Map<Internal.Dynamic<T>, Internal.Dynamic<T>>>;
        cast<U_>(arg0: Internal.DynamicOps_<U_>): U_;
        readList<E_>(arg0: Internal.Decoder_<E_>): Internal.DataResult<Internal.List<E_>>;
        readList<E_>(arg0: java_.util.function_.Function_<Internal.Dynamic_<any>, Internal.DataResult_<E_>>): Internal.DataResult<Internal.List<E_>>;
        merge(arg0: Internal.Dynamic_<any>, arg1: Internal.Dynamic_<any>): Internal.OptionalDynamic<T>;
        merge(arg0: Internal.Dynamic_<any>): Internal.OptionalDynamic<T>;
        asString(): Internal.DataResult<string>;
        asString(arg0: string): string;
        asByte(arg0: number): number;
        createList(arg0: Internal.Stream_<Internal.Dynamic_<any>>): Internal.Dynamic<T>;
        read<A_>(arg0: Internal.Decoder_<A_>): Internal.DataResult<A_>;
        asByteBufferOpt(): Internal.DataResult<Internal.ByteBuffer>;
        createString(arg0: string): Internal.Dynamic<T>;
        asMapOpt(): Internal.DataResult<Internal.Stream<Internal.Pair<Internal.Dynamic<T>, Internal.Dynamic<T>>>>;
        asMapOpt<K_, V_>(arg0: java_.util.function_.Function_<Internal.Dynamic_<T>, K_>, arg1: java_.util.function_.Function_<Internal.Dynamic_<T>, V_>): Internal.DataResult<Internal.Map<K_, V_>>;
        getGeneric(arg0: T): Internal.DataResult<T>;
        asStream(): Internal.Stream<Internal.Dynamic<T>>;
        asLong(arg0: number): number;
        createByte(arg0: number): Internal.Dynamic<T>;
        asDouble(arg0: number): number;
        asBoolean(arg0: boolean): boolean;
        updateGeneric(arg0: T, arg1: java_.util.function_.Function_<T, T>): Internal.Dynamic<T>;
        createDouble(arg0: number): Internal.Dynamic<T>;
        asLongStreamOpt(): Internal.DataResult<Internal.LongStream>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        asMap<K_, V_>(arg0: java_.util.function_.Function_<Internal.Dynamic_<T>, K_>, arg1: java_.util.function_.Function_<Internal.Dynamic_<T>, V_>): Internal.Map<K_, V_>;
        asStreamOpt(): Internal.DataResult<Internal.Stream<Internal.Dynamic<T>>>;
        notifyAll(): void;
        update(arg0: string, arg1: java_.util.function_.Function_<Internal.Dynamic_<any>, Internal.Dynamic_<any>>): Internal.Dynamic<T>;
        asIntStream(): Internal.IntStream;
        createByteList(arg0: Internal.ByteBuffer_): Internal.Dynamic<any>;
        asByteBuffer(): Internal.ByteBuffer;
        asFloat(arg0: number): number;
        asLongStream(): Internal.LongStream;
        notify(): void;
        createBoolean(arg0: boolean): Internal.Dynamic<T>;
        remove(arg0: string): Internal.Dynamic<T>;
        asInt(arg0: number): number;
        into<V_>(arg0: java_.util.function_.Function_<Internal.Dynamic_<T>, V_>): V_;
        emptyList(): Internal.Dynamic<T>;
        asShort(arg0: number): number;
        hashCode(): number;
        get(arg0: string): Internal.OptionalDynamic<T>;
        emptyMap(): Internal.Dynamic<T>;
        createNumeric(arg0: Internal.Number_): Internal.Dynamic<T>;
        map(arg0: java_.util.function_.Function_<T, T>): Internal.Dynamic<T>;
        set(arg0: string, arg1: Internal.Dynamic_<any>): Internal.Dynamic<T>;
        asNumber(): Internal.DataResult<Internal.Number>;
        asNumber(arg0: Internal.Number_): Internal.Number;
        createMap(arg0: Internal.Map_<Internal.Dynamic_<any>, Internal.Dynamic_<any>>): Internal.Dynamic<T>;
        castTyped<U_>(arg0: Internal.DynamicOps_<U_>): Internal.Dynamic<U_>;
        createFloat(arg0: number): Internal.Dynamic<T>;
        getValue(): T;
        getOps(): Internal.DynamicOps<T>;
        getElement(arg0: string): Internal.DataResult<T>;
        getElement(arg0: string, arg1: T): T;
        equals(arg0: any): boolean;
        createInt(arg0: number): Internal.Dynamic<T>;
        toString(): string;
        get ops(): Internal.DynamicOps<T>;
        get mapValues(): Internal.DataResult<Internal.Map<Internal.Dynamic<T>, Internal.Dynamic<T>>>;
        get class(): Internal.Class<any>;
        get value(): T;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    type Dynamic_<T> = Dynamic<T>;
    interface IRecipeSlotTooltipCallback {
        onTooltip(arg0: Internal.IRecipeSlotView_, arg1: Internal.List_<Internal.Component_>): void;
    }
    type IRecipeSlotTooltipCallback_ = ((arg0: Internal.IRecipeSlotView, arg1: Internal.List<Internal.Component>) => void) | IRecipeSlotTooltipCallback;
    class BooleanProperty extends Internal.TeamProperty<boolean> {
        getClass(): Internal.Class<any>;
        readValue(buf: Internal.FriendlyByteBuf_): boolean;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        fromNBT(tag: net.minecraft.nbt.Tag_): Internal.Optional<boolean>;
        notifyAll(): void;
        notify(): void;
        toNBT(value: boolean): net.minecraft.nbt.Tag;
        getType(): Internal.TeamPropertyType<boolean>;
        hashCode(): number;
        equals(o: any): boolean;
        toString(value: boolean): string;
        toString(): string;
        fromString(string: string): Internal.Optional<boolean>;
        writeValue(buf: Internal.FriendlyByteBuf_, value: boolean): void;
        config(config: Internal.ConfigGroup_, value: Internal.TeamPropertyValue_<boolean>): void;
        write(buf: Internal.FriendlyByteBuf_): void;
        readonly defaultValue : boolean;
        readonly id : ResourceLocation;
        get type(): Internal.TeamPropertyType<boolean>;
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    type BooleanProperty_ = BooleanProperty;
    interface EntityKJS extends Internal.AsKJS {
        getPersistentDataKJS(): Internal.CompoundTag;
        asKJS(): any;
    }
    type EntityKJS_ = EntityKJS;
    interface Boolean2LongFunction extends Internal.Function<boolean, number> {
        getOrDefault(arg0: any, arg1: number): number;
        getOrDefault(arg0: boolean, arg1: number): number;
        andThenShort(arg0: Internal.Long2ShortFunction_): Internal.Boolean2ShortFunction;
        composeByte(arg0: Internal.Byte2BooleanFunction_): Internal.Byte2LongFunction;
        andThenInt(arg0: Internal.Long2IntFunction_): Internal.Boolean2IntFunction;
        composeReference<T_>(arg0: Internal.Reference2BooleanFunction_<T_>): Internal.Reference2LongFunction<T_>;
        andThen<T_>(arg0: java_.util.function_.Function_<number, T_>): java_.util.function_.Function<boolean, T_>;
        put(arg0: boolean, arg1: number): number;
        remove(arg0: any): number;
        remove(arg0: boolean): number;
        defaultReturnValue(): number;
        defaultReturnValue(arg0: number): void;
        andThenDouble(arg0: Internal.Long2DoubleFunction_): Internal.Boolean2DoubleFunction;
        andThenObject<T_>(arg0: Internal.Long2ObjectFunction_<T_>): Internal.Boolean2ObjectFunction<T_>;
        get(arg0: any): number;
        get(arg0: boolean): number;
        andThenLong(arg0: Internal.Long2LongFunction_): Internal.Boolean2LongFunction;
        composeLong(arg0: Internal.Long2BooleanFunction_): Internal.Long2LongFunction;
        andThenByte(arg0: Internal.Long2ByteFunction_): Internal.Boolean2ByteFunction;
        andThenFloat(arg0: Internal.Long2FloatFunction_): Internal.Boolean2FloatFunction;
        apply(arg0: boolean): number;
        containsKey(arg0: boolean): boolean;
        containsKey(arg0: any): boolean;
        composeInt(arg0: Internal.Int2BooleanFunction_): Internal.Int2LongFunction;
        clear(): void;
        composeFloat(arg0: Internal.Float2BooleanFunction_): Internal.Float2LongFunction;
        andThenChar(arg0: Internal.Long2CharFunction_): Internal.Boolean2CharFunction;
        composeObject<T_>(arg0: Internal.Object2BooleanFunction_<T_>): Internal.Object2LongFunction<T_>;
        size(): number;
        compose<T_>(arg0: java_.util.function_.Function_<T_, boolean>): java_.util.function_.Function<T_, number>;
        composeShort(arg0: Internal.Short2BooleanFunction_): Internal.Short2LongFunction;
        andThenReference<T_>(arg0: Internal.Long2ReferenceFunction_<T_>): Internal.Boolean2ReferenceFunction<T_>;
        composeChar(arg0: Internal.Char2BooleanFunction_): Internal.Char2LongFunction;
        composeDouble(arg0: Internal.Double2BooleanFunction_): Internal.Double2LongFunction;
    }
    type Boolean2LongFunction_ = ((arg0: boolean) => number) | Boolean2LongFunction;
    class GameRulesJS {
        getClass(): Internal.Class<any>;
        getInt(rule: string): number;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        set(rule: string, value: any): void;
        hashCode(): number;
        notifyAll(): void;
        equals(arg0: any): boolean;
        toString(): string;
        getBoolean(rule: string): boolean;
        getString(rule: string): string;
        notify(): void;
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    type GameRulesJS_ = GameRulesJS;
    class PageAttributes$OrientationRequestedType extends Internal.AttributeValue {
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        notifyAll(): void;
        equals(arg0: any): boolean;
        notify(): void;
        static readonly LANDSCAPE : Internal.PageAttributes$OrientationRequestedType;
        static readonly PORTRAIT : Internal.PageAttributes$OrientationRequestedType;
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    type PageAttributes$OrientationRequestedType_ = PageAttributes$OrientationRequestedType;
    interface AccessorMobEffectInstance {
        setDuration(arg0: number): void;
        bookshelf$setHiddenEffect(arg0: Internal.MobEffectInstance_): void;
        bookshelf$tickDownDuration(): number;
        bookshelf$getHiddenEffect(): Internal.MobEffectInstance;
    }
    type AccessorMobEffectInstance_ = AccessorMobEffectInstance;
    interface Short2ObjectFunction <V> extends Internal.Function<number, V>, Internal.IntFunction<V> {
        getOrDefault(arg0: number, arg1: V): V;
        getOrDefault(arg0: any, arg1: V): V;
        andThenShort(arg0: Internal.Object2ShortFunction_<V>): Internal.Short2ShortFunction;
        composeByte(arg0: Internal.Byte2ShortFunction_): Internal.Byte2ObjectFunction<V>;
        andThenInt(arg0: Internal.Object2IntFunction_<V>): Internal.Short2IntFunction;
        andThen<V_>(arg0: java_.util.function_.Function_<V, V_>): java_.util.function_.Function<number, V_>;
        composeReference<T_>(arg0: Internal.Reference2ShortFunction_<T_>): Internal.Reference2ObjectFunction<T_, V>;
        put(arg0: number, arg1: V): V;
        remove(arg0: any): V;
        remove(arg0: number): V;
        defaultReturnValue(arg0: V): void;
        defaultReturnValue(): V;
        andThenDouble(arg0: Internal.Object2DoubleFunction_<V>): Internal.Short2DoubleFunction;
        andThenObject<T_>(arg0: Internal.Object2ObjectFunction_<V, T_>): Internal.Short2ObjectFunction<T_>;
        get(arg0: any): V;
        get(arg0: number): V;
        andThenLong(arg0: Internal.Object2LongFunction_<V>): Internal.Short2LongFunction;
        composeLong(arg0: Internal.Long2ShortFunction_): Internal.Long2ObjectFunction<V>;
        andThenByte(arg0: Internal.Object2ByteFunction_<V>): Internal.Short2ByteFunction;
        andThenFloat(arg0: Internal.Object2FloatFunction_<V>): Internal.Short2FloatFunction;
        apply(arg0: number): V;
        containsKey(arg0: any): boolean;
        containsKey(arg0: number): boolean;
        composeInt(arg0: Internal.Int2ShortFunction_): Internal.Int2ObjectFunction<V>;
        clear(): void;
        composeFloat(arg0: Internal.Float2ShortFunction_): Internal.Float2ObjectFunction<V>;
        andThenChar(arg0: Internal.Object2CharFunction_<V>): Internal.Short2CharFunction;
        composeObject<T_>(arg0: Internal.Object2ShortFunction_<T_>): Internal.Object2ObjectFunction<T_, V>;
        size(): number;
        compose<T_>(arg0: java_.util.function_.Function_<T_, number>): java_.util.function_.Function<T_, V>;
        composeShort(arg0: Internal.Short2ShortFunction_): Internal.Short2ObjectFunction<V>;
        andThenReference<T_>(arg0: Internal.Object2ReferenceFunction_<V, T_>): Internal.Short2ReferenceFunction<T_>;
        composeChar(arg0: Internal.Char2ShortFunction_): Internal.Char2ObjectFunction<V>;
        composeDouble(arg0: Internal.Double2ShortFunction_): Internal.Double2ObjectFunction<V>;
    }
    type Short2ObjectFunction_<V> = ((arg0: number) => V) | Short2ObjectFunction<V>;
    interface LevelRendererAccessor {
        getLevel(): Internal.ClientLevel;
        invokeRenderEntity(arg0: Internal.Entity_, arg1: number, arg2: number, arg3: number, arg4: number, arg5: Internal.PoseStack_, arg6: Internal.MultiBufferSource_): void;
        getEntityRenderDispatcher(): Internal.EntityRenderDispatcher;
        setRenderBuffers(arg0: Internal.RenderBuffers_): void;
        invokeSetupRender(arg0: Internal.Camera_, arg1: net.minecraft.client.renderer.culling.Frustum_, arg2: boolean, arg3: boolean): void;
        getRenderBuffers(): Internal.RenderBuffers;
        invokeRenderChunkLayer(arg0: Internal.RenderType_, arg1: Internal.PoseStack_, arg2: number, arg3: number, arg4: number, arg5: Internal.Matrix4f_): void;
    }
    type LevelRendererAccessor_ = LevelRendererAccessor;
    class CommandRegistryEventJS extends Internal.ServerEventJS {
        cancel(): void;
        getServer(): Internal.ServerJS;
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        isCancelled(): boolean;
        isForSinglePlayer(): boolean;
        notifyAll(): void;
        notify(): void;
        getCommands(): Internal.ClassWrapper<Internal.Commands>;
        isForMultiPlayer(): boolean;
        post(t: Internal.ScriptType_, id: string, sub: string): boolean;
        post(t: Internal.ScriptType_, id: string): boolean;
        hashCode(): number;
        equals(arg0: any): boolean;
        getArguments(): Internal.ClassWrapper<Internal.ArgumentTypeWrapper>;
        toString(): string;
        canCancel(): boolean;
        register(command: Internal.LiteralArgumentBuilder_<Internal.CommandSourceStack_>): Internal.LiteralCommandNode<Internal.CommandSourceStack>;
        readonly selection : Internal.Commands$CommandSelection;
        readonly dispatcher : Internal.CommandDispatcher<Internal.CommandSourceStack>;
        get server(): Internal.ServerJS;
        get forSinglePlayer(): boolean;
        get cancelled(): boolean;
        get arguments(): Internal.ClassWrapper<Internal.ArgumentTypeWrapper>;
        get forMultiPlayer(): boolean;
        get class(): Internal.Class<any>;
        get commands(): Internal.ClassWrapper<Internal.Commands>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    type CommandRegistryEventJS_ = CommandRegistryEventJS;
    class PageAttributes$OriginType extends Internal.AttributeValue {
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        notifyAll(): void;
        equals(arg0: any): boolean;
        notify(): void;
        static readonly PRINTABLE : Internal.PageAttributes$OriginType;
        static readonly PHYSICAL : Internal.PageAttributes$OriginType;
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    type PageAttributes$OriginType_ = PageAttributes$OriginType;
    class Products$P10 <F, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10> {
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        apply<R>(arg0: Internal.Applicative_<F, any>, arg1: Internal.Function10_<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, R>): Internal.App<F, R>;
        apply<R>(arg0: Internal.Applicative_<F, any>, arg1: Internal.App_<F, Internal.Function10_<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, R>>): Internal.App<F, R>;
        hashCode(): number;
        notifyAll(): void;
        equals(arg0: any): boolean;
        toString(): string;
        notify(): void;
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    type Products$P10_<F, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10> = Products$P10<F, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10>;
    interface RecipeManagerAccess {
        callByType<C, T>(arg0: Internal.RecipeType_<T>): Internal.Map<ResourceLocation, Internal.Recipe<C>>;
    }
    type RecipeManagerAccess_ = RecipeManagerAccess;
    interface Char2CharFunction extends Internal.Function<string, string>, Internal.IntUnaryOperator {
        getOrDefault(arg0: any, arg1: string): string;
        getOrDefault(arg0: string, arg1: string): string;
        andThenShort(arg0: Internal.Char2ShortFunction_): Internal.Char2ShortFunction;
        composeByte(arg0: Internal.Byte2CharFunction_): Internal.Byte2CharFunction;
        andThenInt(arg0: Internal.Char2IntFunction_): Internal.Char2IntFunction;
        composeReference<T_>(arg0: Internal.Reference2CharFunction_<T_>): Internal.Reference2CharFunction<T_>;
        andThen<T_>(arg0: java_.util.function_.Function_<string, T_>): java_.util.function_.Function<string, T_>;
        andThen(arg0: Internal.IntUnaryOperator_): Internal.IntUnaryOperator;
        put(arg0: string, arg1: string): string;
        remove(arg0: string): string;
        remove(arg0: any): string;
        defaultReturnValue(): string;
        defaultReturnValue(arg0: string): void;
        andThenDouble(arg0: Internal.Char2DoubleFunction_): Internal.Char2DoubleFunction;
        andThenObject<T_>(arg0: Internal.Char2ObjectFunction_<T_>): Internal.Char2ObjectFunction<T_>;
        get(arg0: any): string;
        get(arg0: string): string;
        andThenLong(arg0: Internal.Char2LongFunction_): Internal.Char2LongFunction;
        composeLong(arg0: Internal.Long2CharFunction_): Internal.Long2CharFunction;
        andThenByte(arg0: Internal.Char2ByteFunction_): Internal.Char2ByteFunction;
        andThenFloat(arg0: Internal.Char2FloatFunction_): Internal.Char2FloatFunction;
        applyAsInt(arg0: number): number;
        apply(arg0: string): string;
        containsKey(arg0: any): boolean;
        containsKey(arg0: string): boolean;
        composeInt(arg0: Internal.Int2CharFunction_): Internal.Int2CharFunction;
        clear(): void;
        composeFloat(arg0: Internal.Float2CharFunction_): Internal.Float2CharFunction;
        andThenChar(arg0: Internal.Char2CharFunction_): Internal.Char2CharFunction;
        composeObject<T_>(arg0: Internal.Object2CharFunction_<T_>): Internal.Object2CharFunction<T_>;
        size(): number;
        compose<T_>(arg0: java_.util.function_.Function_<T_, string>): java_.util.function_.Function<T_, string>;
        compose(arg0: Internal.IntUnaryOperator_): Internal.IntUnaryOperator;
        composeShort(arg0: Internal.Short2CharFunction_): Internal.Short2CharFunction;
        andThenReference<T_>(arg0: Internal.Char2ReferenceFunction_<T_>): Internal.Char2ReferenceFunction<T_>;
        composeChar(arg0: Internal.Char2CharFunction_): Internal.Char2CharFunction;
        composeDouble(arg0: Internal.Double2CharFunction_): Internal.Double2CharFunction;
    }
    type Char2CharFunction_ = ((arg0: string) => string) | Char2CharFunction;
    class FluidBlockBuilder extends Internal.BlockBuilder {
        noItem(): Internal.BlockBuilder;
        suffocating(b: boolean): Internal.BlockBuilder;
        getClass(): Internal.Class<any>;
        translationKey(key: string): Internal.BuilderBase<Internal.Block>;
        newID(pre: string, post: string): ResourceLocation;
        type(type: string): Internal.BuilderBase<Internal.Block>;
        unbreakable(): Internal.BlockBuilder;
        model(m: string): Internal.BlockBuilder;
        tag(tag: ResourceLocation_): Internal.BlockBuilder;
        generateDataJsons(generator: Internal.DataJsonGenerator_): void;
        tagBoth(tag: ResourceLocation_): Internal.BlockBuilder;
        defaultCutout(): Internal.BlockBuilder;
        item(i: Internal.Consumer_<Internal.BlockItemBuilder_>): Internal.BlockBuilder;
        resistance(r: number): Internal.BlockBuilder;
        hardness(h: number): Internal.BlockBuilder;
        slipperiness(f: number): Internal.BlockBuilder;
        getRegistryType(): Internal.RegistryObjectBuilderTypes<Internal.Block>;
        textureSide(direction: Internal.Direction_, tex: string): Internal.BlockBuilder;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        clientRegistry(minecraft: Internal.Minecraft_): void;
        waterlogged(): Internal.BlockBuilder;
        transformObject(obj: Internal.Block_): Internal.Block;
        color(index: number, c: Internal.Color_): Internal.BlockBuilder;
        textureAll(tex: string): Internal.BlockBuilder;
        displayName(name: string): Internal.BuilderBase<Internal.Block>;
        notifyAll(): void;
        box(x0: number, y0: number, z0: number, x1: number, y1: number, z1: number): Internal.BlockBuilder;
        box(x0: number, y0: number, z0: number, x1: number, y1: number, z1: number, scale16: boolean): Internal.BlockBuilder;
        viewBlocking(b: boolean): Internal.BlockBuilder;
        notify(): void;
        transparent(b: boolean): Internal.BlockBuilder;
        createAdditionalObjects(): void;
        tagBlock(tag: ResourceLocation_): Internal.BlockBuilder;
        fullBlock(f: boolean): Internal.BlockBuilder;
        createProperties(): Internal.BlockBehaviour$Properties;
        notSolid(): Internal.BlockBuilder;
        generateBlockModels(builder: Internal.BlockBuilder_): Internal.Map<ResourceLocation, Internal.JsonObject>;
        hashCode(): number;
        noCollission(): Internal.BlockBuilder;
        get(): Internal.Block;
        requiresTool(f: boolean): Internal.BlockBuilder;
        renderType(l: string): Internal.BlockBuilder;
        jumpFactor(f: number): Internal.BlockBuilder;
        createShape(): Internal.VoxelShape;
        generateAssetJsons(generator: Internal.AssetJsonGenerator_): void;
        noCollision(): Internal.BlockBuilder;
        opaque(o: boolean): Internal.BlockBuilder;
        randomTick(randomTickCallback: Internal.Consumer_<Internal.RandomTickCallbackJS_>): Internal.BlockBuilder;
        getTranslationKeyGroup(): string;
        texture(id: string, tex: string): Internal.BlockBuilder;
        noDrops(): Internal.BlockBuilder;
        generateLang(lang: Internal.Map_<string, string>): void;
        tagItem(tag: ResourceLocation_): Internal.BlockBuilder;
        speedFactor(f: number): Internal.BlockBuilder;
        noValidSpawns(b: boolean): Internal.BlockBuilder;
        createObject(): Internal.Block;
        lightLevel(light: number): Internal.BlockBuilder;
        addResourcePackLocations(path: string, list: Internal.List_<ResourceLocation_>, packType: Internal.PackType_): void;
        defaultTranslucent(): Internal.BlockBuilder;
        material(m: Internal.MaterialJS_): Internal.BlockBuilder;
        equals(arg0: any): boolean;
        toString(): string;
        redstoneConductor(b: boolean): Internal.BlockBuilder;
        lootTable : ((arg0: Internal.LootBuilder) => void);
        modelJson : Internal.JsonObject;
        blockstateJson : Internal.JsonObject;
        readonly id : ResourceLocation;
        randomTickCallback : ((arg0: Internal.RandomTickCallbackJS) => void);
        get registryType(): Internal.RegistryObjectBuilderTypes<Internal.Block>;
        get class(): Internal.Class<any>;
        get translationKeyGroup(): string;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    type FluidBlockBuilder_ = FluidBlockBuilder;
    interface IntSpliterator extends Internal.Spliterator$OfInt {
        trySplit(): Internal.IntSpliterator;
        characteristics(): number;
        tryAdvance(arg0: Internal.Consumer_<number>): boolean;
        tryAdvance(arg0: Internal.IntConsumer_): boolean;
        tryAdvance(arg0: java_.util.function_.IntConsumer_): boolean;
        getComparator(): Internal.IntComparator;
        getExactSizeIfKnown(): number;
        estimateSize(): number;
        skip(arg0: number): number;
        hasCharacteristics(arg0: number): boolean;
        forEachRemaining(arg0: Internal.Consumer_<number>): void;
        forEachRemaining(arg0: Internal.IntConsumer_): void;
        forEachRemaining(arg0: java_.util.function_.IntConsumer_): void;
    }
    type IntSpliterator_ = IntSpliterator;
    interface Byte2LongFunction extends Internal.Function<number, number>, Internal.IntToLongFunction {
        getOrDefault(arg0: any, arg1: number): number;
        getOrDefault(arg0: number, arg1: number): number;
        andThenShort(arg0: Internal.Long2ShortFunction_): Internal.Byte2ShortFunction;
        composeByte(arg0: Internal.Byte2ByteFunction_): Internal.Byte2LongFunction;
        andThenInt(arg0: Internal.Long2IntFunction_): Internal.Byte2IntFunction;
        composeReference<T_>(arg0: Internal.Reference2ByteFunction_<T_>): Internal.Reference2LongFunction<T_>;
        andThen<T_>(arg0: java_.util.function_.Function_<number, T_>): java_.util.function_.Function<number, T_>;
        put(arg0: number, arg1: number): number;
        remove(arg0: number): number;
        remove(arg0: any): number;
        defaultReturnValue(): number;
        defaultReturnValue(arg0: number): void;
        andThenDouble(arg0: Internal.Long2DoubleFunction_): Internal.Byte2DoubleFunction;
        andThenObject<T_>(arg0: Internal.Long2ObjectFunction_<T_>): Internal.Byte2ObjectFunction<T_>;
        get(arg0: any): number;
        get(arg0: number): number;
        andThenLong(arg0: Internal.Long2LongFunction_): Internal.Byte2LongFunction;
        composeLong(arg0: Internal.Long2ByteFunction_): Internal.Long2LongFunction;
        andThenByte(arg0: Internal.Long2ByteFunction_): Internal.Byte2ByteFunction;
        andThenFloat(arg0: Internal.Long2FloatFunction_): Internal.Byte2FloatFunction;
        apply(arg0: number): number;
        containsKey(arg0: any): boolean;
        containsKey(arg0: number): boolean;
        composeInt(arg0: Internal.Int2ByteFunction_): Internal.Int2LongFunction;
        clear(): void;
        composeFloat(arg0: Internal.Float2ByteFunction_): Internal.Float2LongFunction;
        andThenChar(arg0: Internal.Long2CharFunction_): Internal.Byte2CharFunction;
        applyAsLong(arg0: number): number;
        composeObject<T_>(arg0: Internal.Object2ByteFunction_<T_>): Internal.Object2LongFunction<T_>;
        size(): number;
        compose<T_>(arg0: java_.util.function_.Function_<T_, number>): java_.util.function_.Function<T_, number>;
        composeShort(arg0: Internal.Short2ByteFunction_): Internal.Short2LongFunction;
        andThenReference<T_>(arg0: Internal.Long2ReferenceFunction_<T_>): Internal.Byte2ReferenceFunction<T_>;
        composeChar(arg0: Internal.Char2ByteFunction_): Internal.Char2LongFunction;
        composeDouble(arg0: Internal.Double2ByteFunction_): Internal.Double2LongFunction;
    }
    type Byte2LongFunction_ = ((arg0: number) => number) | Byte2LongFunction;
    class QuestObjectType extends Internal.Enum<Internal.QuestObjectType> implements Internal.Predicate<Internal.QuestObjectBase> {
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        or(arg0: Internal.Predicate_<Internal.QuestObjectBase_>): Internal.Predicate<Internal.QuestObjectBase>;
        test(object: Internal.QuestObjectBase_): boolean;
        static valueOf(name: string): Internal.QuestObjectType;
        static valueOf<T_>(arg0: Internal.Class_<T_>, arg1: string): T_;
        notifyAll(): void;
        static values(): Internal.QuestObjectType[];
        getColor(): Internal.ChatFormatting;
        compareTo(arg0: Internal.QuestObjectType_): number;
        describeConstable(): Internal.Optional<Internal.Enum$EnumDesc<Internal.QuestObjectType>>;
        notify(): void;
        getDeclaringClass(): Internal.Class<Internal.QuestObjectType>;
        and(arg0: Internal.Predicate_<Internal.QuestObjectBase_>): Internal.Predicate<Internal.QuestObjectBase>;
        negate(): Internal.Predicate<Internal.QuestObjectBase>;
        hashCode(): number;
        equals(arg0: any): boolean;
        name(): string;
        toString(): string;
        ordinal(): number;
        static readonly TASK : Internal.QuestObjectType;
        static readonly ALL_PROGRESSING_OR_NULL : ((arg0: Internal.QuestObjectBase) => boolean);
        static readonly NULL : Internal.QuestObjectType;
        readonly translationKey : string;
        static readonly NAME_MAP : Internal.NameMap<Internal.QuestObjectType>;
        static readonly REWARD : Internal.QuestObjectType;
        static readonly ALL_PROGRESSING : ((arg0: Internal.QuestObjectBase) => boolean);
        static readonly CHAPTER : Internal.QuestObjectType;
        static readonly CHAPTER_GROUP : Internal.QuestObjectType;
        readonly id : string;
        static readonly FILE : Internal.QuestObjectType;
        static readonly REWARD_TABLE : Internal.QuestObjectType;
        static readonly QUEST : Internal.QuestObjectType;
        get color(): Internal.ChatFormatting;
        get class(): Internal.Class<any>;
        get declaringClass(): Internal.Class<Internal.QuestObjectType>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    type QuestObjectType_ = "reward" | "chapter" | "chapter_group" | "file" | "task" | "null" | "reward_table" | "quest" | QuestObjectType;
    class Tristate extends Internal.Enum<Internal.Tristate> {
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        static read(nbt: Internal.CompoundTag_, key: string): Internal.Tristate;
        static read(buffer: Internal.FriendlyByteBuf_): Internal.Tristate;
        static valueOf(name: string): Internal.Tristate;
        static valueOf<T_>(arg0: Internal.Class_<T_>, arg1: string): T_;
        notifyAll(): void;
        static values(): Internal.Tristate[];
        isFalse(): boolean;
        compareTo(arg0: Internal.Tristate_): number;
        describeConstable(): Internal.Optional<Internal.Enum$EnumDesc<Internal.Tristate>>;
        notify(): void;
        getDeclaringClass(): Internal.Class<Internal.Tristate>;
        isTrue(): boolean;
        isDefault(): boolean;
        hashCode(): number;
        equals(arg0: any): boolean;
        get(def: boolean): boolean;
        name(): string;
        getOpposite(): Internal.Tristate;
        toString(): string;
        write(buffer: Internal.FriendlyByteBuf_): void;
        write(nbt: Internal.CompoundTag_, key: string): void;
        ordinal(): number;
        readonly result : Internal.InteractionResult;
        readonly color : Internal.Color4I;
        static readonly NAME_MAP : Internal.NameMap<Internal.Tristate>;
        readonly displayName : string;
        readonly icon : Internal.Icon;
        static readonly TRUE : Internal.Tristate;
        static readonly FALSE : Internal.Tristate;
        static readonly VALUES : Internal.Tristate[];
        static readonly DEFAULT : Internal.Tristate;
        get default(): boolean;
        get false(): boolean;
        get true(): boolean;
        get opposite(): Internal.Tristate;
        get class(): Internal.Class<any>;
        get declaringClass(): Internal.Class<Internal.Tristate>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    type Tristate_ = "default" | "false" | "true" | Tristate;
    abstract class ConfigValue <T> implements Internal.Comparable<Internal.ConfigValue<T>> {
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        getName(): string;
        setCanEdit(e: boolean): Internal.ConfigValue<Internal.ConfigValue<Internal.ConfigValue<T>>>;
        notifyAll(): void;
        isEqual(v1: Internal.ConfigValue_<Internal.ConfigValue_<T>>, v2: Internal.ConfigValue_<Internal.ConfigValue_<T>>): boolean;
        compareTo(o: Internal.ConfigValue_<Internal.ConfigValue_<Internal.ConfigValue_<T>>>): number;
        notify(): void;
        getCanEdit(): boolean;
        getTooltip(): string;
        hashCode(): number;
        getStringForGUI(v: Internal.ConfigValue_<Internal.ConfigValue_<T>>): Internal.Component;
        getPath(): string;
        copy(value: Internal.ConfigValue_<Internal.ConfigValue_<T>>): Internal.ConfigValue<Internal.ConfigValue<T>>;
        static info(key: string, value: any): Internal.Component;
        init(g: Internal.ConfigGroup_, i: string, v: Internal.ConfigValue_<Internal.ConfigValue_<T>>, c: Internal.Consumer_<Internal.ConfigValue_<Internal.ConfigValue_<T>>>, def: Internal.ConfigValue_<Internal.ConfigValue_<T>>): Internal.ConfigValue<Internal.ConfigValue<Internal.ConfigValue<T>>>;
        getColor(v: Internal.ConfigValue_<Internal.ConfigValue_<T>>): Internal.Color4I;
        addInfo(list: Internal.TooltipList_): void;
        getIcon(v: Internal.ConfigValue_<Internal.ConfigValue_<T>>): Internal.Icon;
        setIcon(i: Internal.Icon_): Internal.ConfigValue<Internal.ConfigValue<Internal.ConfigValue<T>>>;
        setOrder(o: number): Internal.ConfigValue<Internal.ConfigValue<Internal.ConfigValue<T>>>;
        getNameKey(): string;
        setNameKey(key: string): Internal.ConfigValue<Internal.ConfigValue<Internal.ConfigValue<T>>>;
        equals(arg0: any): boolean;
        onClicked(arg0: Internal.MouseButton_, arg1: Internal.ConfigCallback_): void;
        toString(): string;
        setCurrentValue(v: Internal.ConfigValue_<Internal.ConfigValue_<T>>): boolean;
        defaultValue : Internal.ConfigValue<Internal.ConfigValue<T>>;
        id : string;
        static readonly NULL_TEXT : Internal.TextComponent;
        setter : ((arg0: Internal.ConfigValue<Internal.ConfigValue<T>>) => void);
        value : Internal.ConfigValue<Internal.ConfigValue<T>>;
        group : Internal.ConfigGroup;
        get path(): string;
        get nameKey(): string;
        get canEdit(): boolean;
        get name(): string;
        get tooltip(): string;
        get class(): Internal.Class<any>;
        set nameKey(key: string);
        set canEdit(e: boolean);
        set icon(i: Internal.Icon_);
        set currentValue(v: Internal.ConfigValue_<Internal.ConfigValue_<T>>);
        set order(o: number);
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    type ConfigValue_<T> = ConfigValue<T>;
    class TagEventJS$TagWrapper {
        getObjectIds(): Internal.Collection<ResourceLocation>;
        add(ids: string[]): Internal.TagEventJS$TagWrapper<>;
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        removeAll(): Internal.TagEventJS$TagWrapper<>;
        hashCode(): number;
        notifyAll(): void;
        equals(arg0: any): boolean;
        toString(): string;
        sort(): boolean;
        notify(): void;
        setPriorityList(o: any): void;
        remove(ids: string[]): Internal.TagEventJS$TagWrapper<>;
        get class(): Internal.Class<any>;
        get objectIds(): Internal.Collection<ResourceLocation>;
        set priorityList(o: any);
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    type TagEventJS$TagWrapper_ = TagEventJS$TagWrapper;
    abstract class FontMetrics implements Internal.Serializable {
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        getMaxCharBounds(arg0: Internal.Graphics_): Internal.Rectangle2D;
        notifyAll(): void;
        notify(): void;
        getHeight(): number;
        getMaxAscent(): number;
        hashCode(): number;
        getFontRenderContext(): Internal.FontRenderContext;
        bytesWidth(arg0: number[], arg1: number, arg2: number): number;
        getLineMetrics(arg0: string, arg1: number, arg2: number, arg3: Internal.Graphics_): Internal.LineMetrics;
        getLineMetrics(arg0: string[], arg1: number, arg2: number, arg3: Internal.Graphics_): Internal.LineMetrics;
        getLineMetrics(arg0: Internal.CharacterIterator_, arg1: number, arg2: number, arg3: Internal.Graphics_): Internal.LineMetrics;
        getLineMetrics(arg0: string, arg1: Internal.Graphics_): Internal.LineMetrics;
        getDescent(): number;
        hasUniformLineMetrics(): boolean;
        getLeading(): number;
        getStringBounds(arg0: Internal.CharacterIterator_, arg1: number, arg2: number, arg3: Internal.Graphics_): Internal.Rectangle2D;
        getStringBounds(arg0: string[], arg1: number, arg2: number, arg3: Internal.Graphics_): Internal.Rectangle2D;
        getStringBounds(arg0: string, arg1: number, arg2: number, arg3: Internal.Graphics_): Internal.Rectangle2D;
        getStringBounds(arg0: string, arg1: Internal.Graphics_): Internal.Rectangle2D;
        charWidth(arg0: number): number;
        charWidth(arg0: string): number;
        getMaxDecent(): number;
        getMaxDescent(): number;
        charsWidth(arg0: string[], arg1: number, arg2: number): number;
        getAscent(): number;
        stringWidth(arg0: string): number;
        getMaxAdvance(): number;
        equals(arg0: any): boolean;
        getFont(): Internal.Font;
        toString(): string;
        getWidths(): number[];
        get maxAscent(): number;
        get descent(): number;
        get maxDescent(): number;
        get ascent(): number;
        get maxDecent(): number;
        get leading(): number;
        get fontRenderContext(): Internal.FontRenderContext;
        get maxAdvance(): number;
        get widths(): number[];
        get class(): Internal.Class<any>;
        get height(): number;
        get font(): Internal.Font;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    type FontMetrics_ = FontMetrics;
    class FenceGateBlockBuilder extends Internal.ShapedBlockBuilder {
        noItem(): Internal.BlockBuilder;
        suffocating(b: boolean): Internal.BlockBuilder;
        getClass(): Internal.Class<any>;
        translationKey(key: string): Internal.BuilderBase<Internal.Block>;
        newID(pre: string, post: string): ResourceLocation;
        type(type: string): Internal.BuilderBase<Internal.Block>;
        unbreakable(): Internal.BlockBuilder;
        model(m: string): Internal.BlockBuilder;
        tag(tag: ResourceLocation_): Internal.BlockBuilder;
        generateDataJsons(generator: Internal.DataJsonGenerator_): void;
        tagBoth(tag: ResourceLocation_): Internal.BlockBuilder;
        defaultCutout(): Internal.BlockBuilder;
        item(i: Internal.Consumer_<Internal.BlockItemBuilder_>): Internal.BlockBuilder;
        resistance(r: number): Internal.BlockBuilder;
        hardness(h: number): Internal.BlockBuilder;
        slipperiness(f: number): Internal.BlockBuilder;
        getRegistryType(): Internal.RegistryObjectBuilderTypes<Internal.Block>;
        textureSide(direction: Internal.Direction_, tex: string): Internal.BlockBuilder;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        clientRegistry(minecraft: Internal.Minecraft_): void;
        waterlogged(): Internal.BlockBuilder;
        transformObject(obj: Internal.Block_): Internal.Block;
        color(index: number, c: Internal.Color_): Internal.BlockBuilder;
        textureAll(tex: string): Internal.BlockBuilder;
        displayName(name: string): Internal.BuilderBase<Internal.Block>;
        notifyAll(): void;
        box(x0: number, y0: number, z0: number, x1: number, y1: number, z1: number): Internal.BlockBuilder;
        box(x0: number, y0: number, z0: number, x1: number, y1: number, z1: number, scale16: boolean): Internal.BlockBuilder;
        viewBlocking(b: boolean): Internal.BlockBuilder;
        notify(): void;
        transparent(b: boolean): Internal.BlockBuilder;
        createAdditionalObjects(): void;
        tagBlock(tag: ResourceLocation_): Internal.BlockBuilder;
        fullBlock(f: boolean): Internal.BlockBuilder;
        createProperties(): Internal.BlockBehaviour$Properties;
        notSolid(): Internal.BlockBuilder;
        generateBlockModels(builder: Internal.BlockBuilder_): Internal.Map<ResourceLocation, Internal.JsonObject>;
        hashCode(): number;
        noCollission(): Internal.BlockBuilder;
        get(): Internal.Block;
        requiresTool(f: boolean): Internal.BlockBuilder;
        renderType(l: string): Internal.BlockBuilder;
        jumpFactor(f: number): Internal.BlockBuilder;
        createShape(): Internal.VoxelShape;
        generateAssetJsons(generator: Internal.AssetJsonGenerator_): void;
        noCollision(): Internal.BlockBuilder;
        opaque(o: boolean): Internal.BlockBuilder;
        randomTick(randomTickCallback: Internal.Consumer_<Internal.RandomTickCallbackJS_>): Internal.BlockBuilder;
        getTranslationKeyGroup(): string;
        texture(id: string, tex: string): Internal.BlockBuilder;
        noDrops(): Internal.BlockBuilder;
        generateLang(lang: Internal.Map_<string, string>): void;
        tagItem(tag: ResourceLocation_): Internal.BlockBuilder;
        speedFactor(f: number): Internal.BlockBuilder;
        noValidSpawns(b: boolean): Internal.BlockBuilder;
        createObject(): Internal.Block;
        lightLevel(light: number): Internal.BlockBuilder;
        addResourcePackLocations(path: string, list: Internal.List_<ResourceLocation_>, packType: Internal.PackType_): void;
        defaultTranslucent(): Internal.BlockBuilder;
        material(m: Internal.MaterialJS_): Internal.BlockBuilder;
        equals(arg0: any): boolean;
        toString(): string;
        redstoneConductor(b: boolean): Internal.BlockBuilder;
        lootTable : ((arg0: Internal.LootBuilder) => void);
        modelJson : Internal.JsonObject;
        blockstateJson : Internal.JsonObject;
        readonly id : ResourceLocation;
        randomTickCallback : ((arg0: Internal.RandomTickCallbackJS) => void);
        get registryType(): Internal.RegistryObjectBuilderTypes<Internal.Block>;
        get class(): Internal.Class<any>;
        get translationKeyGroup(): string;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    type FenceGateBlockBuilder_ = FenceGateBlockBuilder;
    /**
    */
    class PickaxeItemBuilder extends Internal.HandheldItemBuilder {
        barWidth(barWidth: Internal.ToIntFunction_<Internal.ItemStackJS_>): Internal.ItemBuilder;
        getClass(): Internal.Class<any>;
        maxStackSize(v: number): Internal.ItemBuilder;
        translationKey(key: string): Internal.BuilderBase<Internal.Item>;
        newID(pre: string, post: string): ResourceLocation;
        use(use: Internal.ItemBuilder$UseCallback_): Internal.ItemBuilder;
        maxDamage(v: number): Internal.ItemBuilder;
        textureJson(json: Internal.JsonObject_): Internal.ItemBuilder;
        tooltip(text: Internal.Component_): Internal.ItemBuilder;
        modifyTier(callback: Internal.Consumer_<Internal.MutableToolTier_>): Internal.HandheldItemBuilder;
        type(type: string): Internal.BuilderBase<Internal.Item>;
        containerItem(id: string): Internal.ItemBuilder;
        subtypes(fn: java_.util.function_.Function_<Internal.ItemStackJS_, Internal.Collection_<Internal.ItemStackJS_>>): Internal.ItemBuilder;
        modelJson(json: Internal.JsonObject_): Internal.ItemBuilder;
        burnTime(v: number): Internal.ItemBuilder;
        useDuration(useDuration: Internal.ToIntFunction_<Internal.ItemStackJS_>): Internal.ItemBuilder;
        tag(tag: ResourceLocation_): Internal.BuilderBase<Internal.Item>;
        parentModel(m: string): Internal.ItemBuilder;
        generateDataJsons(generator: Internal.DataJsonGenerator_): void;
        group(g: string): Internal.ItemBuilder;
        static ofArmorMaterial(o: any): Internal.ArmorMaterial;
        /**
        */
        modifyAttribute(attribute: net.minecraft.world.entity.ai.attributes.Attribute_, identifier: string, d: number, operation: Internal.AttributeModifier$Operation_): Internal.ItemBuilder;
        getRegistryType(): Internal.RegistryObjectBuilderTypes<Internal.Item>;
        attackDamageBonus(f: number): Internal.HandheldItemBuilder;
        glow(v: boolean): Internal.ItemBuilder;
        useAnimation(animation: Internal.UseAnim_): Internal.ItemBuilder;
        rarity(v: Rarity_): Internal.ItemBuilder;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        clientRegistry(minecraft: Internal.Minecraft_): void;
        transformObject(obj: Internal.Item_): Internal.Item;
        color(callback: Internal.ItemBuilder$ItemColorJS_): Internal.ItemBuilder;
        color(index: number, c: Internal.Color_): Internal.ItemBuilder;
        displayName(name: string): Internal.BuilderBase<Internal.Item>;
        notifyAll(): void;
        barColor(barColor: java_.util.function_.Function_<Internal.ItemStackJS_, Internal.Color_>): Internal.ItemBuilder;
        notify(): void;
        createAdditionalObjects(): void;
        speed(f: number): Internal.HandheldItemBuilder;
        tier(t: Internal.Tier_): Internal.HandheldItemBuilder;
        hashCode(): number;
        get(): Internal.Item;
        speedBaseline(f: number): Internal.HandheldItemBuilder;
        generateAssetJsons(generator: Internal.AssetJsonGenerator_): void;
        getTranslationKeyGroup(): string;
        texture(key: string, tex: string): Internal.ItemBuilder;
        texture(tex: string): Internal.ItemBuilder;
        generateLang(lang: Internal.Map_<string, string>): void;
        food(b: Internal.Consumer_<Internal.FoodBuilder_>): Internal.ItemBuilder;
        createObject(): Internal.Item;
        releaseUsing(releaseUsing: Internal.ItemBuilder$ReleaseUsingCallback_): Internal.ItemBuilder;
        attackDamageBaseline(f: number): Internal.HandheldItemBuilder;
        unstackable(): Internal.ItemBuilder;
        addResourcePackLocations(path: string, list: Internal.List_<ResourceLocation_>, packType: Internal.PackType_): void;
        equals(arg0: any): boolean;
        toString(): string;
        finishUsing(finishUsing: Internal.ItemBuilder$FinishUsingCallback_): Internal.ItemBuilder;
        createItemProperties(): Internal.Item$Properties;
        static readonly TOOL_TIERS : {"gold":any,"diamond":any,"iron":any,"wood":any,"stone":any,"netherite":any};
        static readonly ARMOR_TIERS : {"gold":any,"chain":any,"diamond":any,"turtle":any,"iron":any,"leather":any,"netherite":any};
        readonly id : ResourceLocation;
        get registryType(): Internal.RegistryObjectBuilderTypes<Internal.Item>;
        get class(): Internal.Class<any>;
        get translationKeyGroup(): string;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    /**
    */
    type PickaxeItemBuilder_ = PickaxeItemBuilder;
    class MultipartBlockStateGenerator$Part {
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        toJson(): Internal.JsonObject;
        hashCode(): number;
        notifyAll(): void;
        equals(arg0: any): boolean;
        toString(): string;
        model(s: string): Internal.VariantBlockStateGenerator$Model;
        notify(): void;
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    type MultipartBlockStateGenerator$Part_ = MultipartBlockStateGenerator$Part;
    class ClientTeamManager {
        getClass(): Internal.Class<any>;
        init(self: Internal.UUID_, messages: Internal.List_<Internal.TeamMessage_>): void;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        getName(id: Internal.UUID_): Internal.Component;
        hashCode(): number;
        getTeam(id: Internal.UUID_): Internal.ClientTeam;
        notifyAll(): void;
        equals(arg0: any): boolean;
        toString(): string;
        getKnownPlayer(id: Internal.UUID_): Internal.KnownClientPlayer;
        getId(): Internal.UUID;
        write(buffer: Internal.FriendlyByteBuf_, now: number): void;
        notify(): void;
        readonly knownPlayers : Internal.Map<Internal.UUID, Internal.KnownClientPlayer>;
        selfTeam : Internal.ClientTeam;
        invalid : boolean;
        static INSTANCE : Internal.ClientTeamManager;
        readonly teamMap : Internal.Map<Internal.UUID, Internal.ClientTeam>;
        selfKnownPlayer : Internal.KnownClientPlayer;
        get id(): Internal.UUID;
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    type ClientTeamManager_ = ClientTeamManager;
    interface DispensibleContainerItem {
    }
    type DispensibleContainerItem_ = DispensibleContainerItem;
    interface CustomJavaToJsWrapperProvider <T> {
        create(arg0: T): Internal.CustomJavaToJsWrapper;
    }
    type CustomJavaToJsWrapperProvider_<T> = ((arg0: T) => Internal.CustomJavaToJsWrapper) | CustomJavaToJsWrapperProvider<T>;
    class BlockContainerJS implements Internal.SpecialEquality {
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        spawnFireworks(fireworks: Internal.FireworksJS_): void;
        notifyAll(): void;
        getBiomeId(): ResourceLocation;
        getItem(): Internal.ItemStackJS;
        getUp(): Internal.BlockContainerJS;
        getTags(): Internal.Collection<ResourceLocation>;
        getId(): string;
        clearCache(): void;
        getCanSeeSky(): boolean;
        getEast(): Internal.BlockContainerJS;
        notify(): void;
        canSeeSkyFromBelowWater(): boolean;
        getNorth(): Internal.BlockContainerJS;
        hashCode(): number;
        getPos(): BlockPos;
        setEntityData(tag: Internal.CompoundTag_): void;
        getDimension(): string;
        getEntityId(): string;
        mergeEntityData(tag: Internal.CompoundTag_): void;
        getInventory(facing: Internal.Direction_): Internal.InventoryJS;
        getBlockLight(): number;
        getLight(): number;
        getWest(): Internal.BlockContainerJS;
        getPlayersInRadius(radius: number): Internal.EntityArrayList;
        getPlayersInRadius(): Internal.EntityArrayList;
        set(id: ResourceLocation_, properties: Internal.Map_<any, any>, flags: number): void;
        set(id: ResourceLocation_, properties: Internal.Map_<any, any>): void;
        set(id: ResourceLocation_): void;
        hasTag(tag: ResourceLocation_): boolean;
        offset(f: Internal.Direction_): Internal.BlockContainerJS;
        offset(f: Internal.Direction_, d: number): Internal.BlockContainerJS;
        offset(x: number, y: number, z: number): Internal.BlockContainerJS;
        getDown(): Internal.BlockContainerJS;
        getProperties(): Internal.Map<string, string>;
        createExplosion(): Internal.ExplosionJS;
        setBlockState(state: Internal.BlockState_, flags: number): void;
        getEntity(): Internal.BlockEntity;
        createEntity(id: ResourceLocation_): Internal.EntityJS;
        getMaterial(): Internal.MaterialJS;
        getSouth(): Internal.BlockContainerJS;
        spawnLightning(effectOnly: boolean): void;
        spawnLightning(effectOnly: boolean, player: Internal.EntityJS_): void;
        getLevel(): Internal.LevelJS;
        getX(): number;
        getY(): number;
        getZ(): number;
        getEntityData(): Internal.CompoundTag;
        equals(obj: any): boolean;
        getTypeData(): Internal.CompoundTag;
        toString(): string;
        getBlockState(): Internal.BlockState;
        getSkyLight(): number;
        specialEquals(o: any, shallow: boolean): boolean;
        readonly minecraftLevel : Internal.Level;
        get blockState(): Internal.BlockState;
        get biomeId(): ResourceLocation;
        get south(): Internal.BlockContainerJS;
        get playersInRadius(): Internal.EntityArrayList;
        get north(): Internal.BlockContainerJS;
        get skyLight(): number;
        get down(): Internal.BlockContainerJS;
        get east(): Internal.BlockContainerJS;
        get pos(): BlockPos;
        get blockLight(): number;
        get west(): Internal.BlockContainerJS;
        get up(): Internal.BlockContainerJS;
        get id(): string;
        get class(): Internal.Class<any>;
        get dimension(): string;
        get item(): Internal.ItemStackJS;
        get level(): Internal.LevelJS;
        get canSeeSky(): boolean;
        get entityId(): string;
        get typeData(): Internal.CompoundTag;
        get tags(): Internal.Collection<ResourceLocation>;
        get material(): Internal.MaterialJS;
        get light(): number;
        get x(): number;
        get y(): number;
        get z(): number;
        get properties(): Internal.Map<string, string>;
        get entity(): Internal.BlockEntity;
        get entityData(): Internal.CompoundTag;
        set entityData(tag: Internal.CompoundTag_);
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    type BlockContainerJS_ = BlockContainerJS;
    class AddAttributesFunction implements Internal.LootItemFunction {
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        preserveDefaultAttributes(arg0: Internal.ItemStack_, arg1: EquipmentSlot_): void;
        apply(arg0: Internal.ItemStack_, arg1: Internal.LootContext_): Internal.ItemStack;
        hashCode(): number;
        notifyAll(): void;
        equals(arg0: any): boolean;
        toString(): string;
        andThen<V_>(arg0: java_.util.function_.Function_<Internal.ItemStack_, V_>): Internal.BiFunction<Internal.ItemStack, Internal.LootContext, V_>;
        notify(): void;
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    type AddAttributesFunction_ = AddAttributesFunction;
    interface ProfilerMeasured {
    }
    type ProfilerMeasured_ = ProfilerMeasured;
    interface Channel extends Internal.Closeable {
        isOpen(): boolean;
        close(): void;
    }
    type Channel_ = Channel;
    class Music {
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        hashCode(): number;
        notifyAll(): void;
        equals(arg0: any): boolean;
        toString(): string;
        notify(): void;
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    type Music_ = Music;
    class Cursor implements Internal.Serializable {
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        getName(): string;
        getType(): number;
        hashCode(): number;
        notifyAll(): void;
        equals(arg0: any): boolean;
        static getSystemCustomCursor(arg0: string): Internal.Cursor;
        static getPredefinedCursor(arg0: number): Internal.Cursor;
        static getDefaultCursor(): Internal.Cursor;
        toString(): string;
        notify(): void;
        static readonly N_RESIZE_CURSOR : 8;
        static readonly S_RESIZE_CURSOR : 9;
        static readonly TEXT_CURSOR : 2;
        static readonly NW_RESIZE_CURSOR : 6;
        static readonly W_RESIZE_CURSOR : 10;
        static readonly SE_RESIZE_CURSOR : 5;
        static readonly CUSTOM_CURSOR : -1;
        static readonly NE_RESIZE_CURSOR : 7;
        static readonly SW_RESIZE_CURSOR : 4;
        static readonly DEFAULT_CURSOR : 0;
        static readonly CROSSHAIR_CURSOR : 1;
        static readonly E_RESIZE_CURSOR : 11;
        static readonly HAND_CURSOR : 12;
        static readonly WAIT_CURSOR : 3;
        static readonly MOVE_CURSOR : 13;
        get name(): string;
        get type(): number;
        get defaultCursor(): Internal.Cursor;
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    type Cursor_ = Cursor;
    class InputMethodEvent extends Internal.AWTEvent {
        getClass(): Internal.Class<any>;
        setSource(arg0: any): void;
        getCommittedCharacterCount(): number;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        getText(): Internal.AttributedCharacterIterator;
        notifyAll(): void;
        getID(): number;
        consume(): void;
        notify(): void;
        getVisiblePosition(): Internal.TextHitInfo;
        paramString(): string;
        isConsumed(): boolean;
        getCaret(): Internal.TextHitInfo;
        hashCode(): number;
        getSource(): any;
        equals(arg0: any): boolean;
        getWhen(): number;
        toString(): string;
        static readonly ADJUSTMENT_EVENT_MASK : 256;
        static readonly MOUSE_EVENT_MASK : 16;
        static readonly CARET_POSITION_CHANGED : 1101;
        static readonly COMPONENT_EVENT_MASK : 1;
        static readonly PAINT_EVENT_MASK : 8192;
        static readonly INPUT_METHOD_EVENT_MASK : 2048;
        static readonly HIERARCHY_BOUNDS_EVENT_MASK : 65536;
        static readonly INPUT_METHOD_TEXT_CHANGED : 1100;
        static readonly FOCUS_EVENT_MASK : 4;
        static readonly INPUT_METHOD_LAST : 1101;
        static readonly TEXT_EVENT_MASK : 1024;
        static readonly INVOCATION_EVENT_MASK : 16384;
        static readonly KEY_EVENT_MASK : 8;
        static readonly RESERVED_ID_MAX : 1999;
        static readonly ACTION_EVENT_MASK : 128;
        static readonly ITEM_EVENT_MASK : 512;
        static readonly CONTAINER_EVENT_MASK : 2;
        static readonly WINDOW_EVENT_MASK : 64;
        static readonly HIERARCHY_EVENT_MASK : 32768;
        static readonly WINDOW_STATE_EVENT_MASK : 262144;
        static readonly MOUSE_WHEEL_EVENT_MASK : 131072;
        static readonly MOUSE_MOTION_EVENT_MASK : 32;
        static readonly INPUT_METHOD_FIRST : 1100;
        static readonly WINDOW_FOCUS_EVENT_MASK : 524288;
        get consumed(): boolean;
        get visiblePosition(): Internal.TextHitInfo;
        get caret(): Internal.TextHitInfo;
        get text(): Internal.AttributedCharacterIterator;
        get iD(): number;
        get source(): any;
        get class(): Internal.Class<any>;
        get when(): number;
        get committedCharacterCount(): number;
        set source(arg0: any);
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    type InputMethodEvent_ = InputMethodEvent;
    class RecipeTypeJS {
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        getMod(): string;
        hashCode(): number;
        notifyAll(): void;
        equals(obj: any): boolean;
        isCustom(): boolean;
        getId(): ResourceLocation;
        toString(): string;
        notify(): void;
        readonly factory : (() => Internal.RecipeJS);
        readonly serializer : Internal.RecipeSerializer<any>;
        get mod(): string;
        get custom(): boolean;
        get id(): ResourceLocation;
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    type RecipeTypeJS_ = RecipeTypeJS;
    interface ArchitecturyFluidAttributes {
        getBucketItem(): Internal.Item;
        canConvertToSource(): boolean;
        getBlock(): Internal.LiquidBlock;
        getSlopeFindDistance(arg0: Internal.LevelReader_): number;
        getSlopeFindDistance(): number;
        getName(stack: Internal.FluidStack_): Internal.Component;
        getName(): Internal.Component;
        getExplosionResistance(): number;
        isLighterThanAir(arg0: Internal.FluidStack_, arg1: Internal.BlockAndTintGetter_, arg2: BlockPos_): boolean;
        isLighterThanAir(): boolean;
        isLighterThanAir(stack: Internal.FluidStack_): boolean;
        getTranslationKey(arg0: Internal.FluidStack_): string;
        getTranslationKey(): string;
        getTickDelay(arg0: Internal.LevelReader_): number;
        getTickDelay(): number;
        getFillSound(stack: Internal.FluidStack_): Internal.SoundEvent;
        getFillSound(): Internal.SoundEvent;
        getFillSound(arg0: Internal.FluidStack_, arg1: Internal.BlockAndTintGetter_, arg2: BlockPos_): Internal.SoundEvent;
        getColor(): number;
        getColor(arg0: Internal.FluidStack_, arg1: Internal.BlockAndTintGetter_, arg2: BlockPos_): number;
        getColor(stack: Internal.FluidStack_): number;
        getSourceTexture(arg0: Internal.FluidStack_, arg1: Internal.BlockAndTintGetter_, arg2: BlockPos_): ResourceLocation;
        getSourceTexture(): ResourceLocation;
        getSourceTexture(stack: Internal.FluidStack_): ResourceLocation;
        getRarity(stack: Internal.FluidStack_): Rarity;
        getRarity(arg0: Internal.FluidStack_, arg1: Internal.BlockAndTintGetter_, arg2: BlockPos_): Rarity;
        getRarity(): Rarity;
        getDensity(stack: Internal.FluidStack_): number;
        getDensity(arg0: Internal.FluidStack_, arg1: Internal.BlockAndTintGetter_, arg2: BlockPos_): number;
        getDensity(): number;
        getEmptySound(): Internal.SoundEvent;
        getEmptySound(arg0: Internal.FluidStack_, arg1: Internal.BlockAndTintGetter_, arg2: BlockPos_): Internal.SoundEvent;
        getEmptySound(stack: Internal.FluidStack_): Internal.SoundEvent;
        getLuminosity(): number;
        getLuminosity(stack: Internal.FluidStack_): number;
        getLuminosity(arg0: Internal.FluidStack_, arg1: Internal.BlockAndTintGetter_, arg2: BlockPos_): number;
        getViscosity(arg0: Internal.FluidStack_, arg1: Internal.BlockAndTintGetter_, arg2: BlockPos_): number;
        getViscosity(stack: Internal.FluidStack_): number;
        getViscosity(): number;
        getFlowingTexture(arg0: Internal.FluidStack_, arg1: Internal.BlockAndTintGetter_, arg2: BlockPos_): ResourceLocation;
        getFlowingTexture(stack: Internal.FluidStack_): ResourceLocation;
        getFlowingTexture(): ResourceLocation;
        getFlowingFluid(): Internal.Fluid;
        getTemperature(stack: Internal.FluidStack_): number;
        getTemperature(arg0: Internal.FluidStack_, arg1: Internal.BlockAndTintGetter_, arg2: BlockPos_): number;
        getTemperature(): number;
        getSourceFluid(): Internal.Fluid;
        getDropOff(arg0: Internal.LevelReader_): number;
        getDropOff(): number;
    }
    type ArchitecturyFluidAttributes_ = ArchitecturyFluidAttributes;
    interface JsonDeserializer <T> {
        deserialize(arg0: Internal.JsonElement_, arg1: java_.lang.reflect.Type_, arg2: Internal.JsonDeserializationContext_): T;
    }
    type JsonDeserializer_<T> = JsonDeserializer<T>;
    interface ObjDoubleConsumer <T> {
        accept(arg0: T, arg1: number): void;
    }
    type ObjDoubleConsumer_<T> = ((arg0: T, arg1: number) => void) | ObjDoubleConsumer<T>;
    interface IntToDoubleFunction {
        applyAsDouble(arg0: number): number;
    }
    type IntToDoubleFunction_ = ((arg0: number) => number) | IntToDoubleFunction;
    class Products$P4 <F, T1, T2, T3, T4> {
        t4(): Internal.App<F, T4>;
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        apply<R>(arg0: Internal.Applicative_<F, any>, arg1: Internal.Function4_<T1, T2, T3, T4, R>): Internal.App<F, R>;
        apply<R>(arg0: Internal.Applicative_<F, any>, arg1: Internal.App_<F, Internal.Function4_<T1, T2, T3, T4, R>>): Internal.App<F, R>;
        hashCode(): number;
        and<T5, T6, T7>(arg0: Internal.Products$P3_<F, T5, T6, T7>): Internal.Products$P7<F, T1, T2, T3, T4, T5, T6, T7>;
        and<T5, T6, T7, T8>(arg0: Internal.Products$P4_<F, T5, T6, T7, T8>): Internal.Products$P8<F, T1, T2, T3, T4, T5, T6, T7, T8>;
        and<T5, T6>(arg0: Internal.Products$P2_<F, T5, T6>): Internal.Products$P6<F, T1, T2, T3, T4, T5, T6>;
        and<T5>(arg0: Internal.App_<F, T5>): Internal.Products$P5<F, T1, T2, T3, T4, T5>;
        notifyAll(): void;
        equals(arg0: any): boolean;
        toString(): string;
        t1(): Internal.App<F, T1>;
        notify(): void;
        t2(): Internal.App<F, T2>;
        t3(): Internal.App<F, T3>;
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    type Products$P4_<F, T1, T2, T3, T4> = Products$P4<F, T1, T2, T3, T4>;
    interface DoubleFunction <R> {
        apply(arg0: number): R;
    }
    type DoubleFunction_<R> = ((arg0: number) => R) | DoubleFunction<R>;
    interface IGhostIngredientTarget {
        getPhantomTargets(arg0: any): Internal.List<Internal.Target>;
    }
    type IGhostIngredientTarget_ = IGhostIngredientTarget;
    interface AccessorFontManager {
        bookshelf$getFonts(): Internal.Map<ResourceLocation, Internal.FontSet>;
    }
    type AccessorFontManager_ = AccessorFontManager;
    class DynamicCommandExceptionType implements Internal.CommandExceptionType {
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        createWithContext(arg0: Internal.ImmutableStringReader_, arg1: any): Internal.CommandSyntaxException;
        hashCode(): number;
        notifyAll(): void;
        equals(arg0: any): boolean;
        create(arg0: any): Internal.CommandSyntaxException;
        toString(): string;
        notify(): void;
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    type DynamicCommandExceptionType_ = DynamicCommandExceptionType;
    class SimplePredicate {
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        buildPredicate(): Internal.SimplePredicate;
        test(arg0: Internal.MultiblockState_): boolean;
        notifyAll(): void;
        getCandidates(): Internal.List<Internal.ItemStack>;
        notify(): void;
        testLimited(arg0: Internal.MultiblockState_): boolean;
        toJson(arg0: Internal.JsonObject_): Internal.JsonObject;
        hashCode(): number;
        equals(arg0: any): boolean;
        getConfigWidget(arg0: Internal.List_<Internal.WidgetGroup_>): Internal.List<Internal.WidgetGroup>;
        fromJson(arg0: Internal.Gson_, arg1: Internal.JsonObject_): void;
        toString(): string;
        testGlobal(arg0: Internal.MultiblockState_): boolean;
        getToolTips(arg0: Internal.TraceabilityPredicate_): Internal.List<string>;
        nbtParser : string;
        io : Internal.IO;
        disableRenderFormed : boolean;
        static AIR : Internal.SimplePredicate;
        static ANY : Internal.SimplePredicate;
        readonly type : string;
        maxCount : number;
        toolTips : Internal.List<string>;
        slotName : string;
        customTips : string;
        candidates : (() => Internal.BlockInfo[]);
        predicate : ((arg0: Internal.MultiblockState) => boolean);
        minCount : number;
        previewCount : number;
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    type SimplePredicate_ = SimplePredicate;
    interface ContextFactory$Listener {
        contextReleased(arg0: Internal.Context_): void;
        contextCreated(arg0: Internal.Context_): void;
    }
    type ContextFactory$Listener_ = ContextFactory$Listener;
    interface Float2CharFunction extends Internal.Function<number, string>, Internal.DoubleToIntFunction {
        getOrDefault(arg0: any, arg1: string): string;
        getOrDefault(arg0: number, arg1: string): string;
        andThenShort(arg0: Internal.Char2ShortFunction_): Internal.Float2ShortFunction;
        composeByte(arg0: Internal.Byte2FloatFunction_): Internal.Byte2CharFunction;
        andThenInt(arg0: Internal.Char2IntFunction_): Internal.Float2IntFunction;
        composeReference<T_>(arg0: Internal.Reference2FloatFunction_<T_>): Internal.Reference2CharFunction<T_>;
        andThen<T_>(arg0: java_.util.function_.Function_<string, T_>): java_.util.function_.Function<number, T_>;
        put(arg0: number, arg1: string): string;
        remove(arg0: number): string;
        remove(arg0: any): string;
        defaultReturnValue(): string;
        defaultReturnValue(arg0: string): void;
        andThenDouble(arg0: Internal.Char2DoubleFunction_): Internal.Float2DoubleFunction;
        andThenObject<T_>(arg0: Internal.Char2ObjectFunction_<T_>): Internal.Float2ObjectFunction<T_>;
        get(arg0: any): string;
        get(arg0: number): string;
        andThenLong(arg0: Internal.Char2LongFunction_): Internal.Float2LongFunction;
        composeLong(arg0: Internal.Long2FloatFunction_): Internal.Long2CharFunction;
        andThenByte(arg0: Internal.Char2ByteFunction_): Internal.Float2ByteFunction;
        andThenFloat(arg0: Internal.Char2FloatFunction_): Internal.Float2FloatFunction;
        applyAsInt(arg0: number): number;
        apply(arg0: number): string;
        containsKey(arg0: any): boolean;
        containsKey(arg0: number): boolean;
        composeInt(arg0: Internal.Int2FloatFunction_): Internal.Int2CharFunction;
        clear(): void;
        composeFloat(arg0: Internal.Float2FloatFunction_): Internal.Float2CharFunction;
        andThenChar(arg0: Internal.Char2CharFunction_): Internal.Float2CharFunction;
        composeObject<T_>(arg0: Internal.Object2FloatFunction_<T_>): Internal.Object2CharFunction<T_>;
        size(): number;
        compose<T_>(arg0: java_.util.function_.Function_<T_, number>): java_.util.function_.Function<T_, string>;
        composeShort(arg0: Internal.Short2FloatFunction_): Internal.Short2CharFunction;
        andThenReference<T_>(arg0: Internal.Char2ReferenceFunction_<T_>): Internal.Float2ReferenceFunction<T_>;
        composeChar(arg0: Internal.Char2FloatFunction_): Internal.Char2CharFunction;
        composeDouble(arg0: Internal.Double2FloatFunction_): Internal.Double2CharFunction;
    }
    type Float2CharFunction_ = ((arg0: number) => string) | Float2CharFunction;
    class BlockModificationProperties {
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        notifyAll(): void;
        setSpeedFactor(v: number): void;
        setExplosionResistance(v: number): void;
        notify(): void;
        setMaterial(v: Internal.MaterialJS_): void;
        setRandomlyTicking(v: boolean): void;
        setRequiresTool(v: boolean): void;
        hashCode(): number;
        equals(arg0: any): boolean;
        setJumpFactor(v: number): void;
        toString(): string;
        setFriction(v: number): void;
        setDestroySpeed(v: number): void;
        setHasCollision(v: boolean): void;
        setLightEmission(v: number): void;
        setSoundType(v: Internal.SoundType_): void;
        readonly block : Internal.BlockKJS;
        get class(): Internal.Class<any>;
        set lightEmission(v: number);
        set explosionResistance(v: number);
        set destroySpeed(v: number);
        set material(v: Internal.MaterialJS_);
        set requiresTool(v: boolean);
        set speedFactor(v: number);
        set randomlyTicking(v: boolean);
        set soundType(v: Internal.SoundType_);
        set hasCollision(v: boolean);
        set friction(v: number);
        set jumpFactor(v: number);
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    type BlockModificationProperties_ = BlockModificationProperties;
    interface Object2ObjectFunction <K, V> extends Internal.Function<K, V> {
        getOrDefault(arg0: any, arg1: V): V;
        andThenShort(arg0: Internal.Object2ShortFunction_<V>): Internal.Object2ShortFunction<K>;
        composeByte(arg0: Internal.Byte2ObjectFunction_<K>): Internal.Byte2ObjectFunction<V>;
        andThenInt(arg0: Internal.Object2IntFunction_<V>): Internal.Object2IntFunction<K>;
        andThen<V_>(arg0: java_.util.function_.Function_<V, V_>): java_.util.function_.Function<K, V_>;
        composeReference<T_>(arg0: Internal.Reference2ObjectFunction_<T_, K>): Internal.Reference2ObjectFunction<T_, V>;
        put(arg0: K, arg1: V): V;
        remove(arg0: any): V;
        defaultReturnValue(arg0: V): void;
        defaultReturnValue(): V;
        andThenDouble(arg0: Internal.Object2DoubleFunction_<V>): Internal.Object2DoubleFunction<K>;
        andThenObject<T_>(arg0: Internal.Object2ObjectFunction_<V, T_>): Internal.Object2ObjectFunction<K, T_>;
        get(arg0: any): V;
        andThenLong(arg0: Internal.Object2LongFunction_<V>): Internal.Object2LongFunction<K>;
        composeLong(arg0: Internal.Long2ObjectFunction_<K>): Internal.Long2ObjectFunction<V>;
        andThenByte(arg0: Internal.Object2ByteFunction_<V>): Internal.Object2ByteFunction<K>;
        andThenFloat(arg0: Internal.Object2FloatFunction_<V>): Internal.Object2FloatFunction<K>;
        apply(arg0: K): V;
        containsKey(arg0: any): boolean;
        composeInt(arg0: Internal.Int2ObjectFunction_<K>): Internal.Int2ObjectFunction<V>;
        clear(): void;
        composeFloat(arg0: Internal.Float2ObjectFunction_<K>): Internal.Float2ObjectFunction<V>;
        andThenChar(arg0: Internal.Object2CharFunction_<V>): Internal.Object2CharFunction<K>;
        composeObject<T_>(arg0: Internal.Object2ObjectFunction_<T_, K>): Internal.Object2ObjectFunction<T_, V>;
        size(): number;
        compose<V_>(arg0: java_.util.function_.Function_<V_, K>): java_.util.function_.Function<V_, V>;
        composeShort(arg0: Internal.Short2ObjectFunction_<K>): Internal.Short2ObjectFunction<V>;
        andThenReference<T_>(arg0: Internal.Object2ReferenceFunction_<V, T_>): Internal.Object2ReferenceFunction<K, T_>;
        composeChar(arg0: Internal.Char2ObjectFunction_<K>): Internal.Char2ObjectFunction<V>;
        composeDouble(arg0: Internal.Double2ObjectFunction_<K>): Internal.Double2ObjectFunction<V>;
    }
    type Object2ObjectFunction_<K, V> = ((arg0: any) => V) | Object2ObjectFunction<K, V>;
    class WriteInitialDataEvent extends Internal.EventJS {
        cancel(): void;
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        isCancelled(): boolean;
        getPacketBuffer(): Internal.FriendlyByteBuf;
        post(t: Internal.ScriptType_, id: string, sub: string): boolean;
        post(t: Internal.ScriptType_, id: string): boolean;
        hashCode(): number;
        notifyAll(): void;
        equals(arg0: any): boolean;
        toString(): string;
        getComponent(): Internal.ComponentTileEntity<any>;
        notify(): void;
        canCancel(): boolean;
        static readonly ID : "mbd.write_initial_data";
        get component(): Internal.ComponentTileEntity<any>;
        get packetBuffer(): Internal.FriendlyByteBuf;
        get cancelled(): boolean;
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    type WriteInitialDataEvent_ = WriteInitialDataEvent;
    interface Function7 <T1, T2, T3, T4, T5, T6, T7, R> {
        apply(arg0: T1, arg1: T2, arg2: T3, arg3: T4, arg4: T5, arg5: T6, arg6: T7): R;
        curry5(): Internal.Function5<T1, T2, T3, T4, T5, Internal.BiFunction<T6, T7, R>>;
        curry6(): Internal.Function6<T1, T2, T3, T4, T5, T6, java_.util.function_.Function<T7, R>>;
        curry3(): Internal.Function3<T1, T2, T3, Internal.Function4<T4, T5, T6, T7, R>>;
        curry4(): Internal.Function4<T1, T2, T3, T4, Internal.Function3<T5, T6, T7, R>>;
        curry2(): Internal.BiFunction<T1, T2, Internal.Function5<T3, T4, T5, T6, T7, R>>;
        curry(): java_.util.function_.Function<T1, Internal.Function6<T2, T3, T4, T5, T6, T7, R>>;
    }
    type Function7_<T1, T2, T3, T4, T5, T6, T7, R> = Function7<T1, T2, T3, T4, T5, T6, T7, R>;
    interface NarrationSupplier {
    }
    type NarrationSupplier_ = NarrationSupplier;
    class MaterialJS {
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        hashCode(): number;
        notifyAll(): void;
        equals(arg0: any): boolean;
        getMinecraftMaterial(): Internal.Material;
        toString(): string;
        getId(): string;
        notify(): void;
        getSound(): Internal.SoundType;
        get minecraftMaterial(): Internal.Material;
        get sound(): Internal.SoundType;
        get id(): string;
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    type MaterialJS_ = MaterialJS;
    interface Boolean2ByteFunction extends Internal.Function<boolean, number> {
        getOrDefault(arg0: any, arg1: number): number;
        getOrDefault(arg0: boolean, arg1: number): number;
        andThenShort(arg0: Internal.Byte2ShortFunction_): Internal.Boolean2ShortFunction;
        composeByte(arg0: Internal.Byte2BooleanFunction_): Internal.Byte2ByteFunction;
        andThenInt(arg0: Internal.Byte2IntFunction_): Internal.Boolean2IntFunction;
        composeReference<T_>(arg0: Internal.Reference2BooleanFunction_<T_>): Internal.Reference2ByteFunction<T_>;
        andThen<T_>(arg0: java_.util.function_.Function_<number, T_>): java_.util.function_.Function<boolean, T_>;
        put(arg0: boolean, arg1: number): number;
        remove(arg0: any): number;
        remove(arg0: boolean): number;
        defaultReturnValue(): number;
        defaultReturnValue(arg0: number): void;
        andThenDouble(arg0: Internal.Byte2DoubleFunction_): Internal.Boolean2DoubleFunction;
        andThenObject<T_>(arg0: Internal.Byte2ObjectFunction_<T_>): Internal.Boolean2ObjectFunction<T_>;
        get(arg0: any): number;
        get(arg0: boolean): number;
        andThenLong(arg0: Internal.Byte2LongFunction_): Internal.Boolean2LongFunction;
        composeLong(arg0: Internal.Long2BooleanFunction_): Internal.Long2ByteFunction;
        andThenByte(arg0: Internal.Byte2ByteFunction_): Internal.Boolean2ByteFunction;
        andThenFloat(arg0: Internal.Byte2FloatFunction_): Internal.Boolean2FloatFunction;
        apply(arg0: boolean): number;
        containsKey(arg0: boolean): boolean;
        containsKey(arg0: any): boolean;
        composeInt(arg0: Internal.Int2BooleanFunction_): Internal.Int2ByteFunction;
        clear(): void;
        composeFloat(arg0: Internal.Float2BooleanFunction_): Internal.Float2ByteFunction;
        andThenChar(arg0: Internal.Byte2CharFunction_): Internal.Boolean2CharFunction;
        composeObject<T_>(arg0: Internal.Object2BooleanFunction_<T_>): Internal.Object2ByteFunction<T_>;
        size(): number;
        compose<T_>(arg0: java_.util.function_.Function_<T_, boolean>): java_.util.function_.Function<T_, number>;
        composeShort(arg0: Internal.Short2BooleanFunction_): Internal.Short2ByteFunction;
        andThenReference<T_>(arg0: Internal.Byte2ReferenceFunction_<T_>): Internal.Boolean2ReferenceFunction<T_>;
        composeChar(arg0: Internal.Char2BooleanFunction_): Internal.Char2ByteFunction;
        composeDouble(arg0: Internal.Double2BooleanFunction_): Internal.Double2ByteFunction;
    }
    type Boolean2ByteFunction_ = ((arg0: boolean) => number) | Boolean2ByteFunction;
    interface IItemFilter {
        resetFilterData(filter: Internal.ItemStack_): void;
        filter(arg0: Internal.ItemStack_, arg1: Internal.ItemStack_): boolean;
        getItems(filter: Internal.ItemStack_, set: Internal.Set_<Internal.Item_>): void;
        filterItem(filter: Internal.ItemStack_, item: Internal.Item_): boolean;
        getDisplayItemStacks(filter: Internal.ItemStack_, list: Internal.List_<Internal.ItemStack_>): void;
        addInfo(filter: Internal.ItemStack_, info: Internal.FilterInfo_, expanded: boolean): void;
        clearFilterCache(filter: Internal.ItemStack_): void;
    }
    type IItemFilter_ = IItemFilter;
    abstract class AbstractConstant <T> implements Internal.Constant<T> {
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        hashCode(): number;
        notifyAll(): void;
        equals(arg0: any): boolean;
        name(): string;
        toString(): string;
        id(): number;
        compareTo(arg0: T): number;
        notify(): void;
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    type AbstractConstant_<T> = AbstractConstant<T>;
    class PropertyChangeEvent extends Internal.EventObject {
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        setPropagationId(arg0: any): void;
        hashCode(): number;
        getSource(): any;
        notifyAll(): void;
        equals(arg0: any): boolean;
        toString(): string;
        getPropagationId(): any;
        getOldValue(): any;
        getNewValue(): any;
        notify(): void;
        getPropertyName(): string;
        get newValue(): any;
        get propertyName(): string;
        get source(): any;
        get oldValue(): any;
        get class(): Internal.Class<any>;
        get propagationId(): any;
        set propagationId(arg0: any);
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    type PropertyChangeEvent_ = PropertyChangeEvent;
    class Font implements Internal.Serializable {
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        getName(): string;
        isTransformed(): boolean;
        getMaxCharBounds(arg0: Internal.FontRenderContext_): Internal.Rectangle2D;
        isPlain(): boolean;
        notifyAll(): void;
        getMissingGlyphCode(): number;
        static decode(arg0: string): Internal.Font;
        notify(): void;
        isItalic(): boolean;
        getFontName(arg0: Internal.Locale_): string;
        getFontName(): string;
        getStyle(): number;
        getAvailableAttributes(): Internal.AttributedCharacterIterator$Attribute[];
        hashCode(): number;
        getBaselineFor(arg0: string): number;
        getLineMetrics(arg0: string[], arg1: number, arg2: number, arg3: Internal.FontRenderContext_): Internal.LineMetrics;
        getLineMetrics(arg0: Internal.CharacterIterator_, arg1: number, arg2: number, arg3: Internal.FontRenderContext_): Internal.LineMetrics;
        getLineMetrics(arg0: string, arg1: Internal.FontRenderContext_): Internal.LineMetrics;
        getLineMetrics(arg0: string, arg1: number, arg2: number, arg3: Internal.FontRenderContext_): Internal.LineMetrics;
        static createFonts(arg0: Internal.File_): Internal.Font[];
        static createFonts(arg0: Internal.InputStream_): Internal.Font[];
        getSize2D(): number;
        getTransform(): Internal.AffineTransform;
        hasUniformLineMetrics(): boolean;
        getStringBounds(arg0: Internal.CharacterIterator_, arg1: number, arg2: number, arg3: Internal.FontRenderContext_): Internal.Rectangle2D;
        getStringBounds(arg0: string[], arg1: number, arg2: number, arg3: Internal.FontRenderContext_): Internal.Rectangle2D;
        getStringBounds(arg0: string, arg1: number, arg2: number, arg3: Internal.FontRenderContext_): Internal.Rectangle2D;
        getStringBounds(arg0: string, arg1: Internal.FontRenderContext_): Internal.Rectangle2D;
        canDisplay(arg0: string): boolean;
        canDisplay(arg0: number): boolean;
        getAttributes(): Internal.Map<Internal.TextAttribute, any>;
        deriveFont(arg0: number, arg1: Internal.AffineTransform_): Internal.Font;
        deriveFont(arg0: number, arg1: number): Internal.Font;
        deriveFont(arg0: Internal.Map_<Internal.AttributedCharacterIterator$Attribute_, any>): Internal.Font;
        deriveFont(arg0: number): Internal.Font;
        deriveFont(arg0: Internal.AffineTransform_): Internal.Font;
        getPSName(): string;
        hasLayoutAttributes(): boolean;
        isBold(): boolean;
        getNumGlyphs(): number;
        canDisplayUpTo(arg0: string): number;
        canDisplayUpTo(arg0: string[], arg1: number, arg2: number): number;
        canDisplayUpTo(arg0: Internal.CharacterIterator_, arg1: number, arg2: number): number;
        getItalicAngle(): number;
        createGlyphVector(arg0: Internal.FontRenderContext_, arg1: string[]): Internal.GlyphVector;
        createGlyphVector(arg0: Internal.FontRenderContext_, arg1: string): Internal.GlyphVector;
        createGlyphVector(arg0: Internal.FontRenderContext_, arg1: number[]): Internal.GlyphVector;
        createGlyphVector(arg0: Internal.FontRenderContext_, arg1: Internal.CharacterIterator_): Internal.GlyphVector;
        getSize(): number;
        getFamily(): string;
        getFamily(arg0: Internal.Locale_): string;
        static textRequiresLayout(arg0: string[], arg1: number, arg2: number): boolean;
        equals(arg0: any): boolean;
        static getFont(arg0: string): Internal.Font;
        static getFont(arg0: Internal.Map_<Internal.AttributedCharacterIterator$Attribute_, any>): Internal.Font;
        static getFont(arg0: string, arg1: Internal.Font_): Internal.Font;
        toString(): string;
        static createFont(arg0: number, arg1: Internal.File_): Internal.Font;
        static createFont(arg0: number, arg1: Internal.InputStream_): Internal.Font;
        layoutGlyphVector(arg0: Internal.FontRenderContext_, arg1: string[], arg2: number, arg3: number, arg4: number): Internal.GlyphVector;
        static readonly PLAIN : 0;
        static readonly ITALIC : 2;
        static readonly CENTER_BASELINE : 1;
        static readonly HANGING_BASELINE : 2;
        static readonly DIALOG : "Dialog";
        static readonly MONOSPACED : "Monospaced";
        static readonly DIALOG_INPUT : "DialogInput";
        static readonly LAYOUT_NO_LIMIT_CONTEXT : 4;
        static readonly LAYOUT_RIGHT_TO_LEFT : 1;
        static readonly SANS_SERIF : "SansSerif";
        static readonly SERIF : "Serif";
        static readonly TRUETYPE_FONT : 0;
        static readonly ROMAN_BASELINE : 0;
        static readonly LAYOUT_NO_START_CONTEXT : 2;
        static readonly LAYOUT_LEFT_TO_RIGHT : 0;
        static readonly BOLD : 1;
        static readonly TYPE1_FONT : 1;
        get italicAngle(): number;
        get numGlyphs(): number;
        get bold(): boolean;
        get availableAttributes(): Internal.AttributedCharacterIterator$Attribute[];
        get italic(): boolean;
        get size2D(): number;
        get fontName(): string;
        get transform(): Internal.AffineTransform;
        get size(): number;
        get plain(): boolean;
        get name(): string;
        get transformed(): boolean;
        get missingGlyphCode(): number;
        get style(): number;
        get attributes(): Internal.Map<Internal.TextAttribute, any>;
        get pSName(): string;
        get family(): string;
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    type Font_ = Font;
    class Quaternion {
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        hashCode(): number;
        notifyAll(): void;
        equals(arg0: any): boolean;
        toString(): string;
        notify(): void;
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    type Quaternion_ = Quaternion;
    interface ITeleporter {
        getPortalInfo(arg0: Internal.Entity_, arg1: Internal.ServerLevel_, arg2: java_.util.function_.Function_<Internal.ServerLevel_, Internal.PortalInfo_>): Internal.PortalInfo;
        isVanilla(): boolean;
        playTeleportSound(arg0: Internal.ServerPlayer_, arg1: Internal.ServerLevel_, arg2: Internal.ServerLevel_): boolean;
        placeEntity(arg0: Internal.Entity_, arg1: Internal.ServerLevel_, arg2: Internal.ServerLevel_, arg3: number, arg4: java_.util.function_.Function_<boolean, Internal.Entity_>): Internal.Entity;
    }
    type ITeleporter_ = ITeleporter;
    interface DomainCombiner {
        combine(arg0: Internal.ProtectionDomain_[], arg1: Internal.ProtectionDomain_[]): Internal.ProtectionDomain[];
    }
    type DomainCombiner_ = DomainCombiner;
    interface BucketPickup extends Internal.IForgeBucketPickup {
        getPickupSound(arg0: Internal.BlockState_): Internal.Optional<Internal.SoundEvent>;
    }
    type BucketPickup_ = BucketPickup;
    interface ByteChannel extends Internal.ReadableByteChannel, Internal.WritableByteChannel {
        isOpen(): boolean;
        read(arg0: Internal.ByteBuffer_): number;
        write(arg0: Internal.ByteBuffer_): number;
        close(): void;
    }
    type ByteChannel_ = ByteChannel;
    interface PoiTypeAccess {
    }
    type PoiTypeAccess_ = PoiTypeAccess;
    class ThreadGroup implements Internal.Thread$UncaughtExceptionHandler {
        setMaxPriority(arg0: number): void;
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        getName(): string;
        notifyAll(): void;
        notify(): void;
        hashCode(): number;
        isDaemon(): boolean;
        interrupt(): void;
        activeGroupCount(): number;
        enumerate(arg0: Internal.ThreadGroup_[], arg1: boolean): number;
        enumerate(arg0: Internal.ThreadGroup_[]): number;
        enumerate(arg0: Internal.Thread_[]): number;
        enumerate(arg0: Internal.Thread_[], arg1: boolean): number;
        suspend(): void;
        activeCount(): number;
        resume(): void;
        getParent(): Internal.ThreadGroup;
        isDestroyed(): boolean;
        destroy(): void;
        parentOf(arg0: Internal.ThreadGroup_): boolean;
        list(): void;
        checkAccess(): void;
        setDaemon(arg0: boolean): void;
        allowThreadSuspension(arg0: boolean): boolean;
        getMaxPriority(): number;
        stop(): void;
        equals(arg0: any): boolean;
        uncaughtException(arg0: Internal.Thread_, arg1: Internal.Throwable_): void;
        toString(): string;
        get parent(): Internal.ThreadGroup;
        get destroyed(): boolean;
        get maxPriority(): number;
        get name(): string;
        get class(): Internal.Class<any>;
        get daemon(): boolean;
        set maxPriority(arg0: number);
        set daemon(arg0: boolean);
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    type ThreadGroup_ = ThreadGroup;
    abstract class Graphics {
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        drawOval(arg0: number, arg1: number, arg2: number, arg3: number): void;
        fillArc(arg0: number, arg1: number, arg2: number, arg3: number, arg4: number, arg5: number): void;
        notifyAll(): void;
        getClipRect(): Internal.Rectangle;
        fillRect(arg0: number, arg1: number, arg2: number, arg3: number): void;
        notify(): void;
        drawString(arg0: string, arg1: number, arg2: number): void;
        drawString(arg0: Internal.AttributedCharacterIterator_, arg1: number, arg2: number): void;
        translate(arg0: number, arg1: number): void;
        getFontMetrics(arg0: Internal.Font_): Internal.FontMetrics;
        getFontMetrics(): Internal.FontMetrics;
        draw3DRect(arg0: number, arg1: number, arg2: number, arg3: number, arg4: boolean): void;
        fillPolygon(arg0: number[], arg1: number[], arg2: number): void;
        fillPolygon(arg0: Internal.Polygon_): void;
        getClipBounds(arg0: Internal.Rectangle_): Internal.Rectangle;
        getClipBounds(): Internal.Rectangle;
        hashCode(): number;
        drawChars(arg0: string[], arg1: number, arg2: number, arg3: number, arg4: number): void;
        drawRoundRect(arg0: number, arg1: number, arg2: number, arg3: number, arg4: number, arg5: number): void;
        fill3DRect(arg0: number, arg1: number, arg2: number, arg3: number, arg4: boolean): void;
        create(arg0: number, arg1: number, arg2: number, arg3: number): Internal.Graphics;
        create(): Internal.Graphics;
        setClip(arg0: number, arg1: number, arg2: number, arg3: number): void;
        setClip(arg0: Internal.Shape_): void;
        setFont(arg0: Internal.Font_): void;
        drawPolyline(arg0: number[], arg1: number[], arg2: number): void;
        fillRoundRect(arg0: number, arg1: number, arg2: number, arg3: number, arg4: number, arg5: number): void;
        clipRect(arg0: number, arg1: number, arg2: number, arg3: number): void;
        getColor(): java_.awt.Color;
        drawLine(arg0: number, arg1: number, arg2: number, arg3: number): void;
        drawArc(arg0: number, arg1: number, arg2: number, arg3: number, arg4: number, arg5: number): void;
        copyArea(arg0: number, arg1: number, arg2: number, arg3: number, arg4: number, arg5: number): void;
        drawBytes(arg0: number[], arg1: number, arg2: number, arg3: number, arg4: number): void;
        clearRect(arg0: number, arg1: number, arg2: number, arg3: number): void;
        drawImage(arg0: Internal.Image_, arg1: number, arg2: number, arg3: number, arg4: number, arg5: Internal.ImageObserver_): boolean;
        drawImage(arg0: Internal.Image_, arg1: number, arg2: number, arg3: java_.awt.Color_, arg4: Internal.ImageObserver_): boolean;
        drawImage(arg0: Internal.Image_, arg1: number, arg2: number, arg3: Internal.ImageObserver_): boolean;
        drawImage(arg0: Internal.Image_, arg1: number, arg2: number, arg3: number, arg4: number, arg5: number, arg6: number, arg7: number, arg8: number, arg9: java_.awt.Color_, arg10: Internal.ImageObserver_): boolean;
        drawImage(arg0: Internal.Image_, arg1: number, arg2: number, arg3: number, arg4: number, arg5: java_.awt.Color_, arg6: Internal.ImageObserver_): boolean;
        drawImage(arg0: Internal.Image_, arg1: number, arg2: number, arg3: number, arg4: number, arg5: number, arg6: number, arg7: number, arg8: number, arg9: Internal.ImageObserver_): boolean;
        setPaintMode(): void;
        setColor(arg0: java_.awt.Color_): void;
        hitClip(arg0: number, arg1: number, arg2: number, arg3: number): boolean;
        equals(arg0: any): boolean;
        getClip(): Internal.Shape;
        getFont(): Internal.Font;
        dispose(): void;
        toString(): string;
        finalize(): void;
        fillOval(arg0: number, arg1: number, arg2: number, arg3: number): void;
        drawRect(arg0: number, arg1: number, arg2: number, arg3: number): void;
        setXORMode(arg0: java_.awt.Color_): void;
        drawPolygon(arg0: number[], arg1: number[], arg2: number): void;
        drawPolygon(arg0: Internal.Polygon_): void;
        get color(): java_.awt.Color;
        get clipBounds(): Internal.Rectangle;
        get fontMetrics(): Internal.FontMetrics;
        get class(): Internal.Class<any>;
        get clip(): Internal.Shape;
        get font(): Internal.Font;
        set color(arg0: java_.awt.Color_);
        set xORMode(arg0: java_.awt.Color_);
        set clip(arg0: Internal.Shape_);
        set font(arg0: Internal.Font_);
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    type Graphics_ = Graphics;
    interface DensityFunction$FunctionContext {
    }
    type DensityFunction$FunctionContext_ = DensityFunction$FunctionContext;
    class AddJEIEventJS <T> extends Internal.EventJS {
        cancel(): void;
        add(o: any): void;
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        isCancelled(): boolean;
        post(t: Internal.ScriptType_, id: string, sub: string): boolean;
        post(t: Internal.ScriptType_, id: string): boolean;
        hashCode(): number;
        notifyAll(): void;
        equals(arg0: any): boolean;
        toString(): string;
        notify(): void;
        canCancel(): boolean;
        get cancelled(): boolean;
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    type AddJEIEventJS_<T> = AddJEIEventJS<T>;
    class ModelGenerator$Face {
        getClass(): Internal.Class<any>;
        uv(u0: number, v0: number, u1: number, v1: number): Internal.ModelGenerator$Face;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        toJson(): Internal.JsonObject;
        hashCode(): number;
        tex(t: string): Internal.ModelGenerator$Face;
        notifyAll(): void;
        equals(arg0: any): boolean;
        toString(): string;
        cull(): Internal.ModelGenerator$Face;
        cull(d: Internal.Direction_): Internal.ModelGenerator$Face;
        notify(): void;
        tintindex(i: number): Internal.ModelGenerator$Face;
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    type ModelGenerator$Face_ = ModelGenerator$Face;
    /**
    */
    class ArmorItemBuilder$Boots extends Internal.ArmorItemBuilder {
        barWidth(barWidth: Internal.ToIntFunction_<Internal.ItemStackJS_>): Internal.ItemBuilder;
        getClass(): Internal.Class<any>;
        maxStackSize(v: number): Internal.ItemBuilder;
        translationKey(key: string): Internal.BuilderBase<Internal.Item>;
        newID(pre: string, post: string): ResourceLocation;
        use(use: Internal.ItemBuilder$UseCallback_): Internal.ItemBuilder;
        maxDamage(v: number): Internal.ItemBuilder;
        textureJson(json: Internal.JsonObject_): Internal.ItemBuilder;
        tooltip(text: Internal.Component_): Internal.ItemBuilder;
        modifyTier(callback: Internal.Consumer_<Internal.MutableArmorTier_>): Internal.ArmorItemBuilder;
        type(type: string): Internal.BuilderBase<Internal.Item>;
        containerItem(id: string): Internal.ItemBuilder;
        subtypes(fn: java_.util.function_.Function_<Internal.ItemStackJS_, Internal.Collection_<Internal.ItemStackJS_>>): Internal.ItemBuilder;
        modelJson(json: Internal.JsonObject_): Internal.ItemBuilder;
        burnTime(v: number): Internal.ItemBuilder;
        useDuration(useDuration: Internal.ToIntFunction_<Internal.ItemStackJS_>): Internal.ItemBuilder;
        tag(tag: ResourceLocation_): Internal.BuilderBase<Internal.Item>;
        parentModel(m: string): Internal.ItemBuilder;
        generateDataJsons(generator: Internal.DataJsonGenerator_): void;
        group(g: string): Internal.ItemBuilder;
        static ofArmorMaterial(o: any): Internal.ArmorMaterial;
        /**
        */
        modifyAttribute(attribute: net.minecraft.world.entity.ai.attributes.Attribute_, identifier: string, d: number, operation: Internal.AttributeModifier$Operation_): Internal.ItemBuilder;
        getRegistryType(): Internal.RegistryObjectBuilderTypes<Internal.Item>;
        glow(v: boolean): Internal.ItemBuilder;
        useAnimation(animation: Internal.UseAnim_): Internal.ItemBuilder;
        rarity(v: Rarity_): Internal.ItemBuilder;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        clientRegistry(minecraft: Internal.Minecraft_): void;
        transformObject(obj: Internal.Item_): Internal.Item;
        color(callback: Internal.ItemBuilder$ItemColorJS_): Internal.ItemBuilder;
        color(index: number, c: Internal.Color_): Internal.ItemBuilder;
        displayName(name: string): Internal.BuilderBase<Internal.Item>;
        notifyAll(): void;
        barColor(barColor: java_.util.function_.Function_<Internal.ItemStackJS_, Internal.Color_>): Internal.ItemBuilder;
        notify(): void;
        createAdditionalObjects(): void;
        tier(t: Internal.ArmorMaterial_): Internal.ArmorItemBuilder;
        hashCode(): number;
        get(): Internal.Item;
        generateAssetJsons(generator: Internal.AssetJsonGenerator_): void;
        getTranslationKeyGroup(): string;
        texture(key: string, tex: string): Internal.ItemBuilder;
        texture(tex: string): Internal.ItemBuilder;
        generateLang(lang: Internal.Map_<string, string>): void;
        food(b: Internal.Consumer_<Internal.FoodBuilder_>): Internal.ItemBuilder;
        createObject(): Internal.Item;
        releaseUsing(releaseUsing: Internal.ItemBuilder$ReleaseUsingCallback_): Internal.ItemBuilder;
        unstackable(): Internal.ItemBuilder;
        addResourcePackLocations(path: string, list: Internal.List_<ResourceLocation_>, packType: Internal.PackType_): void;
        equals(arg0: any): boolean;
        toString(): string;
        finishUsing(finishUsing: Internal.ItemBuilder$FinishUsingCallback_): Internal.ItemBuilder;
        createItemProperties(): Internal.Item$Properties;
        armorTier : Internal.MutableArmorTier;
        static readonly TOOL_TIERS : {"gold":any,"diamond":any,"iron":any,"wood":any,"stone":any,"netherite":any};
        static readonly ARMOR_TIERS : {"gold":any,"chain":any,"diamond":any,"turtle":any,"iron":any,"leather":any,"netherite":any};
        readonly equipmentSlot : EquipmentSlot;
        readonly id : ResourceLocation;
        get registryType(): Internal.RegistryObjectBuilderTypes<Internal.Item>;
        get class(): Internal.Class<any>;
        get translationKeyGroup(): string;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    /**
    */
    type ArmorItemBuilder$Boots_ = ArmorItemBuilder$Boots;
    class ModularUIContainer extends Internal.AbstractContainerMenu implements Internal.WidgetUIAccess {
        getClass(): Internal.Class<any>;
        getModularUI(): Internal.ModularUI;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        notifyAll(): void;
        notify(): void;
        handleClientAction(arg0: Internal.CPacketUIClientAction_): void;
        writeUpdateInfo(arg0: com.lowdragmc.lowdraglib.gui.widget.Widget_, arg1: number, arg2: Internal.Consumer_<Internal.FriendlyByteBuf_>): void;
        notifySizeChange(): void;
        hashCode(): number;
        equals(arg0: any): boolean;
        handler$bmb000$doClick(arg0: number, arg1: number, arg2: Internal.ClickType_, arg3: Internal.Player_, arg4: Internal.CallbackInfo_): void;
        attemptMergeStack(arg0: Internal.ItemStack_, arg1: boolean, arg2: boolean): boolean;
        notifyWidgetChange(): void;
        toString(): string;
        writeClientAction(arg0: com.lowdragmc.lowdraglib.gui.widget.Widget_, arg1: number, arg2: Internal.Consumer_<Internal.FriendlyByteBuf_>): void;
        static mergeItemStack(arg0: Internal.ItemStack_, arg1: Internal.List_<Internal.Slot_>, arg2: boolean): boolean;
        get modularUI(): Internal.ModularUI;
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    type ModularUIContainer_ = ModularUIContainer;
    class EnchantmentCategory extends Internal.Enum<Internal.EnchantmentCategory> implements Internal.IExtensibleEnum {
        init(): void;
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        static valueOf(arg0: string): Internal.EnchantmentCategory;
        static valueOf<T_>(arg0: Internal.Class_<T_>, arg1: string): T_;
        notifyAll(): void;
        static values(): Internal.EnchantmentCategory[];
        compareTo(arg0: Internal.EnchantmentCategory_): number;
        describeConstable(): Internal.Optional<Internal.Enum$EnumDesc<Internal.EnchantmentCategory>>;
        notify(): void;
        getDeclaringClass(): Internal.Class<Internal.EnchantmentCategory>;
        hashCode(): number;
        equals(arg0: any): boolean;
        name(): string;
        static create(arg0: string, arg1: Internal.Predicate_<Internal.Item_>): Internal.EnchantmentCategory;
        toString(): string;
        ordinal(): number;
        static readonly ARMOR_HEAD : Internal.EnchantmentCategory;
        static readonly BREAKABLE : Internal.EnchantmentCategory;
        static readonly ARMOR : Internal.EnchantmentCategory;
        static readonly ARMOR_LEGS : Internal.EnchantmentCategory;
        static readonly FISHING_ROD : Internal.EnchantmentCategory;
        static readonly BOW : Internal.EnchantmentCategory;
        static readonly ARMOR_FEET : Internal.EnchantmentCategory;
        static readonly TRIDENT : Internal.EnchantmentCategory;
        static readonly VANISHABLE : Internal.EnchantmentCategory;
        static readonly ARMOR_CHEST : Internal.EnchantmentCategory;
        static readonly WEARABLE : Internal.EnchantmentCategory;
        static readonly WEAPON : Internal.EnchantmentCategory;
        static readonly DIGGER : Internal.EnchantmentCategory;
        static readonly CROSSBOW : Internal.EnchantmentCategory;
        get class(): Internal.Class<any>;
        get declaringClass(): Internal.Class<Internal.EnchantmentCategory>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    type EnchantmentCategory_ = "crossbow" | "sword_or_axe" | "sword_or_axe_or_crossbow" | "vanishable" | "mythicbotany_mjoellnir" | "bow" | "digger" | "enchantable" | "weapon" | "armor_legs" | "armor_head" | "ranged" | "twilightforest_block_and_chain" | "armor_feet" | "edelwood_bucket" | "malum:soul_hunter_only" | "fishing_rod" | "wearable" | "slingshot" | "trident" | "broom" | "armor_chest" | "pickaxe_or_shovel" | "malum:rebound_scythe_only" | "knife" | "armor" | "straddleboard" | "breakable" | "malum:scythe_only" | "hoe" | EnchantmentCategory;
    interface GatheringByteChannel extends Internal.WritableByteChannel {
        isOpen(): boolean;
        close(): void;
        write(arg0: Internal.ByteBuffer_[], arg1: number, arg2: number): number;
        write(arg0: Internal.ByteBuffer_[]): number;
        write(arg0: Internal.ByteBuffer_): number;
    }
    type GatheringByteChannel_ = GatheringByteChannel;
    interface Function <K, V> extends java_.util.function_.Function<K, V> {
        getOrDefault(arg0: any, arg1: V): V;
        size(): number;
        compose<V_>(arg0: java_.util.function_.Function_<V_, K>): java_.util.function_.Function<V_, V>;
        apply(arg0: K): V;
        containsKey(arg0: any): boolean;
        get(arg0: any): V;
        clear(): void;
        andThen<V_>(arg0: java_.util.function_.Function_<V, V_>): java_.util.function_.Function<K, V_>;
        put(arg0: K, arg1: V): V;
        remove(arg0: any): V;
    }
    type Function_<K, V> = ((arg0: any) => V) | Function<K, V>;
    interface Long2CharFunction extends Internal.Function<number, string>, Internal.LongToIntFunction {
        getOrDefault(arg0: any, arg1: string): string;
        getOrDefault(arg0: number, arg1: string): string;
        andThenShort(arg0: Internal.Char2ShortFunction_): Internal.Long2ShortFunction;
        composeByte(arg0: Internal.Byte2LongFunction_): Internal.Byte2CharFunction;
        andThenInt(arg0: Internal.Char2IntFunction_): Internal.Long2IntFunction;
        composeReference<T_>(arg0: Internal.Reference2LongFunction_<T_>): Internal.Reference2CharFunction<T_>;
        andThen<T_>(arg0: java_.util.function_.Function_<string, T_>): java_.util.function_.Function<number, T_>;
        put(arg0: number, arg1: string): string;
        remove(arg0: number): string;
        remove(arg0: any): string;
        defaultReturnValue(): string;
        defaultReturnValue(arg0: string): void;
        andThenDouble(arg0: Internal.Char2DoubleFunction_): Internal.Long2DoubleFunction;
        andThenObject<T_>(arg0: Internal.Char2ObjectFunction_<T_>): Internal.Long2ObjectFunction<T_>;
        get(arg0: any): string;
        get(arg0: number): string;
        andThenLong(arg0: Internal.Char2LongFunction_): Internal.Long2LongFunction;
        composeLong(arg0: Internal.Long2LongFunction_): Internal.Long2CharFunction;
        andThenByte(arg0: Internal.Char2ByteFunction_): Internal.Long2ByteFunction;
        andThenFloat(arg0: Internal.Char2FloatFunction_): Internal.Long2FloatFunction;
        applyAsInt(arg0: number): number;
        apply(arg0: number): string;
        containsKey(arg0: any): boolean;
        containsKey(arg0: number): boolean;
        composeInt(arg0: Internal.Int2LongFunction_): Internal.Int2CharFunction;
        clear(): void;
        composeFloat(arg0: Internal.Float2LongFunction_): Internal.Float2CharFunction;
        andThenChar(arg0: Internal.Char2CharFunction_): Internal.Long2CharFunction;
        composeObject<T_>(arg0: Internal.Object2LongFunction_<T_>): Internal.Object2CharFunction<T_>;
        size(): number;
        compose<T_>(arg0: java_.util.function_.Function_<T_, number>): java_.util.function_.Function<T_, string>;
        composeShort(arg0: Internal.Short2LongFunction_): Internal.Short2CharFunction;
        andThenReference<T_>(arg0: Internal.Char2ReferenceFunction_<T_>): Internal.Long2ReferenceFunction<T_>;
        composeChar(arg0: Internal.Char2LongFunction_): Internal.Char2CharFunction;
        composeDouble(arg0: Internal.Double2LongFunction_): Internal.Double2CharFunction;
    }
    type Long2CharFunction_ = ((arg0: number) => string) | Long2CharFunction;
    interface LongSupplier {
        getAsLong(): number;
    }
    type LongSupplier_ = (() => number) | LongSupplier;
    class DetectorBlock$Builder extends Internal.BlockBuilder {
        noItem(): Internal.BlockBuilder;
        suffocating(b: boolean): Internal.BlockBuilder;
        getClass(): Internal.Class<any>;
        translationKey(key: string): Internal.BuilderBase<Internal.Block>;
        newID(pre: string, post: string): ResourceLocation;
        type(type: string): Internal.BuilderBase<Internal.Block>;
        detectorId(id: string): Internal.DetectorBlock$Builder;
        unbreakable(): Internal.BlockBuilder;
        model(m: string): Internal.BlockBuilder;
        tag(tag: ResourceLocation_): Internal.BlockBuilder;
        generateDataJsons(generator: Internal.DataJsonGenerator_): void;
        tagBoth(tag: ResourceLocation_): Internal.BlockBuilder;
        defaultCutout(): Internal.BlockBuilder;
        item(i: Internal.Consumer_<Internal.BlockItemBuilder_>): Internal.BlockBuilder;
        resistance(r: number): Internal.BlockBuilder;
        hardness(h: number): Internal.BlockBuilder;
        slipperiness(f: number): Internal.BlockBuilder;
        getRegistryType(): Internal.RegistryObjectBuilderTypes<Internal.Block>;
        textureSide(direction: Internal.Direction_, tex: string): Internal.BlockBuilder;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        clientRegistry(minecraft: Internal.Minecraft_): void;
        waterlogged(): Internal.BlockBuilder;
        transformObject(obj: Internal.Block_): Internal.Block;
        color(index: number, c: Internal.Color_): Internal.BlockBuilder;
        textureAll(tex: string): Internal.BlockBuilder;
        displayName(name: string): Internal.BuilderBase<Internal.Block>;
        notifyAll(): void;
        box(x0: number, y0: number, z0: number, x1: number, y1: number, z1: number): Internal.BlockBuilder;
        box(x0: number, y0: number, z0: number, x1: number, y1: number, z1: number, scale16: boolean): Internal.BlockBuilder;
        viewBlocking(b: boolean): Internal.BlockBuilder;
        notify(): void;
        transparent(b: boolean): Internal.BlockBuilder;
        createAdditionalObjects(): void;
        tagBlock(tag: ResourceLocation_): Internal.BlockBuilder;
        fullBlock(f: boolean): Internal.BlockBuilder;
        createProperties(): Internal.BlockBehaviour$Properties;
        notSolid(): Internal.BlockBuilder;
        generateBlockModels(builder: Internal.BlockBuilder_): Internal.Map<ResourceLocation, Internal.JsonObject>;
        hashCode(): number;
        noCollission(): Internal.BlockBuilder;
        get(): Internal.Block;
        requiresTool(f: boolean): Internal.BlockBuilder;
        renderType(l: string): Internal.BlockBuilder;
        jumpFactor(f: number): Internal.BlockBuilder;
        createShape(): Internal.VoxelShape;
        generateAssetJsons(generator: Internal.AssetJsonGenerator_): void;
        noCollision(): Internal.BlockBuilder;
        opaque(o: boolean): Internal.BlockBuilder;
        randomTick(randomTickCallback: Internal.Consumer_<Internal.RandomTickCallbackJS_>): Internal.BlockBuilder;
        getTranslationKeyGroup(): string;
        texture(id: string, tex: string): Internal.BlockBuilder;
        noDrops(): Internal.BlockBuilder;
        generateLang(lang: Internal.Map_<string, string>): void;
        tagItem(tag: ResourceLocation_): Internal.BlockBuilder;
        speedFactor(f: number): Internal.BlockBuilder;
        noValidSpawns(b: boolean): Internal.BlockBuilder;
        createObject(): Internal.Block;
        lightLevel(light: number): Internal.BlockBuilder;
        addResourcePackLocations(path: string, list: Internal.List_<ResourceLocation_>, packType: Internal.PackType_): void;
        defaultTranslucent(): Internal.BlockBuilder;
        material(m: Internal.MaterialJS_): Internal.BlockBuilder;
        equals(arg0: any): boolean;
        toString(): string;
        redstoneConductor(b: boolean): Internal.BlockBuilder;
        lootTable : ((arg0: Internal.LootBuilder) => void);
        modelJson : Internal.JsonObject;
        blockstateJson : Internal.JsonObject;
        readonly id : ResourceLocation;
        randomTickCallback : ((arg0: Internal.RandomTickCallbackJS) => void);
        get registryType(): Internal.RegistryObjectBuilderTypes<Internal.Block>;
        get class(): Internal.Class<any>;
        get translationKeyGroup(): string;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    type DetectorBlock$Builder_ = DetectorBlock$Builder;
    interface Closeable extends Internal.AutoCloseable {
        close(): void;
    }
    type Closeable_ = Closeable;
    abstract class TeamBase {
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        getName(): Internal.Component;
        notifyAll(): void;
        getHighestRank(playerId: Internal.UUID_): Internal.TeamRank;
        save(): void;
        getId(): Internal.UUID;
        isMember(uuid: Internal.UUID_): boolean;
        isOfficer(profile: Internal.UUID_): boolean;
        getDescription(): string;
        notify(): void;
        getColoredName(): Internal.Component;
        hashCode(): number;
        isAlly(profile: Internal.UUID_): boolean;
        getProperty<T>(property: Internal.TeamProperty_<T>): T;
        isValid(): boolean;
        getExtraData(): Internal.CompoundTag;
        getColor(): number;
        getRanked(rank: Internal.TeamRank_): Internal.Map<Internal.UUID, Internal.TeamRank>;
        isFreeToJoin(): boolean;
        isInvited(profile: Internal.UUID_): boolean;
        getStringID(): string;
        getDisplayName(): string;
        getType(): Internal.TeamType;
        setProperty<T>(property: Internal.TeamProperty_<T>, value: T): void;
        equals(o: any): boolean;
        toString(): string;
        getMembers(): Internal.Set<Internal.UUID>;
        static readonly FREE_TO_JOIN : Internal.BooleanProperty;
        static readonly DESCRIPTION : Internal.StringProperty;
        static readonly COLOR : Internal.ColorProperty;
        readonly messageHistory : Internal.List<Internal.TeamMessage>;
        static readonly DISPLAY_NAME : Internal.StringProperty;
        readonly properties : Internal.TeamProperties;
        get color(): number;
        get extraData(): Internal.CompoundTag;
        get displayName(): string;
        get description(): string;
        get type(): Internal.TeamType;
        get freeToJoin(): boolean;
        get valid(): boolean;
        get stringID(): string;
        get members(): Internal.Set<Internal.UUID>;
        get name(): Internal.Component;
        get id(): Internal.UUID;
        get class(): Internal.Class<any>;
        get coloredName(): Internal.Component;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    type TeamBase_ = TeamBase;
    class JsonArray extends Internal.JsonElement implements Internal.Iterable<Internal.JsonElement> {
        getAsFloat(): number;
        getClass(): Internal.Class<any>;
        getAsByte(): number;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        getAsBigDecimal(): Internal.BigDecimal;
        notifyAll(): void;
        getAsNumber(): Internal.Number;
        getAsCharacter(): string;
        getAsString(): string;
        isJsonArray(): boolean;
        notify(): void;
        getAsInt(): number;
        remove(arg0: number): Internal.JsonElement;
        remove(arg0: Internal.JsonElement_): boolean;
        isJsonPrimitive(): boolean;
        getAsLong(): number;
        iterator(): Internal.Iterator<Internal.JsonElement>;
        isJsonObject(): boolean;
        hashCode(): number;
        get(arg0: number): Internal.JsonElement;
        getAsBigInteger(): Internal.BigInteger;
        add(arg0: string): void;
        add(arg0: Internal.Number_): void;
        add(arg0: Internal.JsonElement_): void;
        add(arg0: boolean): void;
        getAsJsonObject(): Internal.JsonObject;
        set(arg0: number, arg1: Internal.JsonElement_): Internal.JsonElement;
        getAsJsonNull(): Internal.JsonNull;
        spliterator(): Internal.Spliterator<Internal.JsonElement>;
        forEach(arg0: Internal.Consumer_<Internal.JsonElement_>): void;
        isJsonNull(): boolean;
        isEmpty(): boolean;
        getAsDouble(): number;
        deepCopy(): Internal.JsonArray;
        contains(arg0: Internal.JsonElement_): boolean;
        getAsJsonArray(): Internal.JsonArray;
        size(): number;
        addAll(arg0: Internal.JsonArray_): void;
        getAsJsonPrimitive(): Internal.JsonPrimitive;
        getAsBoolean(): boolean;
        equals(arg0: any): boolean;
        toString(): string;
        getAsShort(): number;
        get asByte(): number;
        get asBigInteger(): Internal.BigInteger;
        get asJsonObject(): Internal.JsonObject;
        get asCharacter(): string;
        get jsonPrimitive(): boolean;
        get asNumber(): Internal.Number;
        get asBigDecimal(): Internal.BigDecimal;
        get jsonNull(): boolean;
        get asFloat(): number;
        get empty(): boolean;
        get asLong(): number;
        get asInt(): number;
        get asJsonPrimitive(): Internal.JsonPrimitive;
        get asJsonNull(): Internal.JsonNull;
        get asShort(): number;
        get asDouble(): number;
        get asJsonArray(): Internal.JsonArray;
        get asString(): string;
        get jsonObject(): boolean;
        get class(): Internal.Class<any>;
        get jsonArray(): boolean;
        get asBoolean(): boolean;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    type JsonArray_ = JsonArray;
    interface ErrorReporter {
        runtimeError(arg0: string, arg1: string, arg2: number, arg3: string, arg4: number): Internal.EvaluatorException;
        warning(arg0: string, arg1: string, arg2: number, arg3: string, arg4: number): void;
        error(arg0: string, arg1: string, arg2: number, arg3: string, arg4: number): void;
    }
    type ErrorReporter_ = ErrorReporter;
    class ParsedCommandNode <S> {
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        getRange(): Internal.StringRange;
        hashCode(): number;
        notifyAll(): void;
        equals(arg0: any): boolean;
        toString(): string;
        getNode(): Internal.CommandNode<S>;
        notify(): void;
        get node(): Internal.CommandNode<S>;
        get range(): Internal.StringRange;
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    type ParsedCommandNode_<S> = ParsedCommandNode<S>;
    interface AccessibleTable {
        getAccessibleRowHeader(): Internal.AccessibleTable;
        getSelectedAccessibleRows(): number[];
        getAccessibleColumnHeader(): Internal.AccessibleTable;
        getAccessibleColumnDescription(arg0: number): Internal.Accessible;
        getAccessibleSummary(): Internal.Accessible;
        setAccessibleRowDescription(arg0: number, arg1: Internal.Accessible_): void;
        setAccessibleColumnHeader(arg0: Internal.AccessibleTable_): void;
        getAccessibleRowDescription(arg0: number): Internal.Accessible;
        getAccessibleAt(arg0: number, arg1: number): Internal.Accessible;
        getSelectedAccessibleColumns(): number[];
        setAccessibleRowHeader(arg0: Internal.AccessibleTable_): void;
        getAccessibleRowExtentAt(arg0: number, arg1: number): number;
        getAccessibleColumnCount(): number;
        setAccessibleCaption(arg0: Internal.Accessible_): void;
        getAccessibleColumnExtentAt(arg0: number, arg1: number): number;
        getAccessibleRowCount(): number;
        isAccessibleSelected(arg0: number, arg1: number): boolean;
        setAccessibleColumnDescription(arg0: number, arg1: Internal.Accessible_): void;
        isAccessibleColumnSelected(arg0: number): boolean;
        getAccessibleCaption(): Internal.Accessible;
        setAccessibleSummary(arg0: Internal.Accessible_): void;
        isAccessibleRowSelected(arg0: number): boolean;
    }
    type AccessibleTable_ = AccessibleTable;
    interface IComponent {
        isValidFrontFacing(arg0: Internal.Direction_): boolean;
        setRendererObject(arg0: any): void;
        getDefinition(): Internal.ComponentDefinition;
        isFormed(): boolean;
        getRenderer(): Internal.IRenderer;
        use(arg0: Internal.Player_, arg1: Hand_, arg2: Internal.BlockHitResult_): Internal.InteractionResult;
        setFrontFacing(arg0: Internal.Direction_): void;
        getStatus(): string;
        setStatus(arg0: string): void;
        rotateTo(arg0: Internal.Rotation_): void;
        setOwner(arg0: Internal.UUID_): void;
        getFrontFacing(): Internal.Direction;
        getRendererObject(): any;
        canConnectRedstone(arg0: Internal.Direction_): boolean;
        onNeighborChange(): void;
        onDrops(arg0: Internal.NonNullList_<Internal.ItemStack_>, arg1: Internal.Player_): void;
        self(): Internal.BlockEntity;
    }
    type IComponent_ = IComponent;
    abstract class BaseComponent implements Internal.MutableComponent {
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        hashCode(): number;
        notifyAll(): void;
        equals(arg0: any): boolean;
        toString(): string;
        getString(): string;
        notify(): void;
        get string(): string;
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    type BaseComponent_ = BaseComponent;
    class Subject implements Internal.Serializable {
        getClass(): Internal.Class<any>;
        static getSubject(arg0: Internal.AccessControlContext_): Internal.Subject;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        getPrivateCredentials(): Internal.Set<any>;
        getPrivateCredentials<T_>(arg0: Internal.Class_<T_>): Internal.Set<T_>;
        notifyAll(): void;
        static callAs<T_>(arg0: Internal.Subject_, arg1: java_.util.concurrent.Callable_<T_>): T_;
        getPrincipals(): Internal.Set<Internal.Principal>;
        getPrincipals<T_>(arg0: Internal.Class_<T_>): Internal.Set<T_>;
        notify(): void;
        getPublicCredentials<T_>(arg0: Internal.Class_<T_>): Internal.Set<T_>;
        getPublicCredentials(): Internal.Set<any>;
        static doAsPrivileged<T_>(arg0: Internal.Subject_, arg1: Internal.PrivilegedExceptionAction_<T_>, arg2: Internal.AccessControlContext_): T_;
        static doAsPrivileged<T_>(arg0: Internal.Subject_, arg1: Internal.PrivilegedAction_<T_>, arg2: Internal.AccessControlContext_): T_;
        static doAs<T_>(arg0: Internal.Subject_, arg1: Internal.PrivilegedAction_<T_>): T_;
        static doAs<T_>(arg0: Internal.Subject_, arg1: Internal.PrivilegedExceptionAction_<T_>): T_;
        static current(): Internal.Subject;
        isReadOnly(): boolean;
        hashCode(): number;
        equals(arg0: any): boolean;
        toString(): string;
        setReadOnly(): void;
        get privateCredentials(): Internal.Set<any>;
        get principals(): Internal.Set<Internal.Principal>;
        get readOnly(): boolean;
        get class(): Internal.Class<any>;
        get publicCredentials(): Internal.Set<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    type Subject_ = Subject;
    interface SharedSuggestionProvider {
    }
    type SharedSuggestionProvider_ = SharedSuggestionProvider;
    interface IntSupplier {
        getAsInt(): number;
    }
    type IntSupplier_ = (() => number) | IntSupplier;
    interface BufferBuilderExt {
        setupBufferSlice(arg0: Internal.ByteBuffer_, arg1: Internal.BufferBuilder$DrawState_): void;
        teardownBufferSlice(): void;
        splitStrip(): void;
    }
    type BufferBuilderExt_ = BufferBuilderExt;
    abstract class IdScriptableObject extends Internal.ScriptableObject implements Internal.IdFunctionCall {
        getClass(): Internal.Class<any>;
        isSealed(): boolean;
        setParentScope(m: Internal.Scriptable_): void;
        static redefineProperty(obj: Internal.Scriptable_, name: string, isConst: boolean): void;
        putConst(name: string, start: Internal.Scriptable_, value: any): void;
        static getTypedProperty<T_>(s: Internal.Scriptable_, name: string, type: Internal.Class_<T_>): T_;
        static getTypedProperty<T_>(s: Internal.Scriptable_, index: number, type: Internal.Class_<T_>): T_;
        getIds(): any[];
        static getArrayPrototype(scope: Internal.Scriptable_): Internal.Scriptable;
        getAllIds(): any[];
        put(key: Internal.Symbol_, start: Internal.Scriptable_, value: any): void;
        put(name: string, start: Internal.Scriptable_, value: any): void;
        put(index: number, start: Internal.Scriptable_, value: any): void;
        static getDefaultValue(object: Internal.Scriptable_, typeHint: Internal.Class_<any>): any;
        getDefaultValue(typeHint: Internal.Class_<any>): any;
        defineOwnProperties(cx: Internal.Context_, props: Internal.ScriptableObject_): void;
        defineProperty(key: Internal.Symbol_, value: any, attributes: number): void;
        defineProperty(propertyName: string, clazz: Internal.Class_<any>, attributes: number): void;
        defineProperty(propertyName: string, delegateTo: any, getter: Internal.Method_, setter: Internal.Method_, attributes: number): void;
        defineProperty(propertyName: string, value: any, attributes: number): void;
        static defineProperty(destination: Internal.Scriptable_, propertyName: string, value: any, attributes: number): void;
        hasPrototypeMap(): boolean;
        setGetterOrSetter(name: string, index: number, getterOrSetter: Internal.Callable_, isSetter: boolean): void;
        avoidObjectDetection(): boolean;
        has(key: Internal.Symbol_, start: Internal.Scriptable_): boolean;
        has(name: string, start: Internal.Scriptable_): boolean;
        has(index: number, start: Internal.Scriptable_): boolean;
        getExternalArrayLength(): any;
        getAttributes(name: string): number;
        getAttributes(key: Internal.Symbol_): number;
        getAttributes(index: number): number;
        hasInstance(instance: Internal.Scriptable_): boolean;
        getAssociatedValue(key: any): any;
        execIdCall(f: Internal.IdFunctionObject_, cx: Internal.Context_, scope: Internal.Scriptable_, thisObj: Internal.Scriptable_, args: any[]): any;
        static getPropertyIds(obj: Internal.Scriptable_): any[];
        static hasProperty(obj: Internal.Scriptable_, name: string): boolean;
        static hasProperty(obj: Internal.Scriptable_, key: Internal.Symbol_): boolean;
        static hasProperty(obj: Internal.Scriptable_, index: number): boolean;
        getExternalArrayData(): Internal.ExternalArrayData;
        size(): number;
        initPrototypeMethod(tag: any, id: number, propertyName: string, functionName: string, arity: number): Internal.IdFunctionObject;
        initPrototypeMethod(tag: any, id: number, key: Internal.Symbol_, functionName: string, arity: number): Internal.IdFunctionObject;
        initPrototypeMethod(tag: any, id: number, name: string, arity: number): Internal.IdFunctionObject;
        defineOwnProperty(cx: Internal.Context_, key: any, desc: Internal.ScriptableObject_): void;
        initPrototypeValue(id: number, name: string, value: any, attributes: number): void;
        initPrototypeValue(id: number, key: Internal.Symbol_, value: any, attributes: number): void;
        static getFunctionPrototype(scope: Internal.Scriptable_): Internal.Scriptable;
        getClassName(): string;
        getParentScope(): Internal.Scriptable;
        preventExtensions(): void;
        setExternalArrayData(array: Internal.ExternalArrayData_): void;
        static callMethod(cx: Internal.Context_, obj: Internal.Scriptable_, methodName: string, args: any[]): any;
        static callMethod(obj: Internal.Scriptable_, methodName: string, args: any[]): any;
        enumerationIteratorNext(cx: Internal.Context_, currentId: Internal.Consumer_<any>): boolean;
        getTypeOf(): string;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        static getTopScopeValue(scope: Internal.Scriptable_, key: any): any;
        initPrototypeConstructor(f: Internal.IdFunctionObject_): void;
        notifyAll(): void;
        sealObject(): void;
        setAttributes(name: string, attributes: number): void;
        setAttributes(key: Internal.Symbol_, attributes: number): void;
        setAttributes(index: number, attributes: number): void;
        static putProperty(obj: Internal.Scriptable_, name: string, value: any): void;
        static putProperty(obj: Internal.Scriptable_, index: number, value: any): void;
        static putProperty(obj: Internal.Scriptable_, key: Internal.Symbol_, value: any): void;
        delete(key: Internal.Symbol_): void;
        delete(name: string): void;
        delete(index: number): void;
        notify(): void;
        associateValue(key: any, value: any): any;
        static deleteProperty(obj: Internal.Scriptable_, name: string): boolean;
        static deleteProperty(obj: Internal.Scriptable_, index: number): boolean;
        getPrototype(): Internal.Scriptable;
        static getObjectPrototype(scope: Internal.Scriptable_): Internal.Scriptable;
        isExtensible(): boolean;
        hashCode(): number;
        isConst(name: string): boolean;
        get(name: string, start: Internal.Scriptable_): any;
        get(key: Internal.Symbol_, start: Internal.Scriptable_): any;
        get(index: number, start: Internal.Scriptable_): any;
        get(key: any): any;
        static putConstProperty(obj: Internal.Scriptable_, name: string, value: any): void;
        getGetterOrSetter(name: string, index: number, isSetter: boolean): any;
        static getTopLevelScope(obj: Internal.Scriptable_): Internal.Scriptable;
        static getProperty(obj: Internal.Scriptable_, name: string): any;
        static getProperty(obj: Internal.Scriptable_, key: Internal.Symbol_): any;
        static getProperty(obj: Internal.Scriptable_, index: number): any;
        static defineClass<T_>(scope: Internal.Scriptable_, clazz: Internal.Class_<T_>, sealed: boolean): void;
        static defineClass<T_>(scope: Internal.Scriptable_, clazz: Internal.Class_<T_>): void;
        static defineClass<T_>(scope: Internal.Scriptable_, clazz: Internal.Class_<T_>, sealed: boolean, mapInheritance: boolean): string;
        activatePrototypeMap(maxPrototypeId: number): void;
        isEmpty(): boolean;
        defineFunctionProperties(names: string[], clazz: Internal.Class_<any>, attributes: number): void;
        static getClassPrototype(scope: Internal.Scriptable_, className: string): Internal.Scriptable;
        setPrototype(m: Internal.Scriptable_): void;
        exportAsJSClass(maxPrototypeId: number, scope: Internal.Scriptable_, sealed: boolean): Internal.IdFunctionObject;
        defineConst(name: string, start: Internal.Scriptable_): void;
        equals(arg0: any): boolean;
        static defineConstProperty(destination: Internal.Scriptable_, propertyName: string): void;
        toString(): string;
        enumerationIteratorHasNext(cx: Internal.Context_, currentId: Internal.Consumer_<any>): boolean;
        static getGeneratorFunctionPrototype(scope: Internal.Scriptable_): Internal.Scriptable;
        static readonly DONTENUM : 2;
        static readonly CONST : 13;
        static readonly NOT_FOUND : any;
        static readonly UNINITIALIZED_CONST : 8;
        static readonly EMPTY : 0;
        static readonly READONLY : 1;
        static readonly PERMANENT : 4;
        get sealed(): boolean;
        get externalArrayData(): Internal.ExternalArrayData;
        get parentScope(): Internal.Scriptable;
        get ids(): any[];
        get className(): string;
        get externalArrayLength(): any;
        get class(): Internal.Class<any>;
        get allIds(): any[];
        get prototype(): Internal.Scriptable;
        get extensible(): boolean;
        get typeOf(): string;
        get empty(): boolean;
        set externalArrayData(array: Internal.ExternalArrayData_);
        set parentScope(m: Internal.Scriptable_);
        set prototype(m: Internal.Scriptable_);
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    type IdScriptableObject_ = IdScriptableObject;
    class TwoHandedAnimation {
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        setTwoHanded(arg0: boolean): void;
        hashCode(): number;
        isTwoHanded(): boolean;
        notifyAll(): void;
        equals(arg0: any): boolean;
        toString(): string;
        notify(): void;
        get twoHanded(): boolean;
        get class(): Internal.Class<any>;
        set twoHanded(arg0: boolean);
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    type TwoHandedAnimation_ = TwoHandedAnimation;
    class Matcher implements Internal.MatchResult {
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        hasTransparentBounds(): boolean;
        requireEnd(): boolean;
        notifyAll(): void;
        useTransparentBounds(arg0: boolean): Internal.Matcher;
        pattern(): Internal.Pattern;
        replaceFirst(arg0: string): string;
        replaceFirst(arg0: java_.util.function_.Function_<Internal.MatchResult_, string>): string;
        regionStart(): number;
        replaceAll(arg0: string): string;
        replaceAll(arg0: java_.util.function_.Function_<Internal.MatchResult_, string>): string;
        notify(): void;
        lookingAt(): boolean;
        toMatchResult(): Internal.MatchResult;
        static quoteReplacement(arg0: string): string;
        hashCode(): number;
        find(): boolean;
        find(arg0: number): boolean;
        end(arg0: string): number;
        end(): number;
        end(arg0: number): number;
        results(): Internal.Stream<Internal.MatchResult>;
        group(arg0: number): string;
        group(): string;
        group(arg0: string): string;
        start(): number;
        start(arg0: string): number;
        start(arg0: number): number;
        regionEnd(): number;
        matches(): boolean;
        hasAnchoringBounds(): boolean;
        appendReplacement(arg0: Internal.StringBuffer_, arg1: string): Internal.Matcher;
        appendReplacement(arg0: Internal.StringBuilder_, arg1: string): Internal.Matcher;
        appendTail(arg0: Internal.StringBuilder_): Internal.StringBuilder;
        appendTail(arg0: Internal.StringBuffer_): Internal.StringBuffer;
        groupCount(): number;
        equals(arg0: any): boolean;
        reset(): Internal.Matcher;
        reset(arg0: Internal.CharSequence_): Internal.Matcher;
        toString(): string;
        region(arg0: number, arg1: number): Internal.Matcher;
        useAnchoringBounds(arg0: boolean): Internal.Matcher;
        hitEnd(): boolean;
        usePattern(arg0: Internal.Pattern_): Internal.Matcher;
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    type Matcher_ = Matcher;
    interface Reference2CharFunction <K> extends Internal.Function<K, string>, Internal.ToIntFunction<K> {
        getOrDefault(arg0: any, arg1: string): string;
        andThenShort(arg0: Internal.Char2ShortFunction_): Internal.Reference2ShortFunction<K>;
        removeChar(arg0: any): string;
        composeByte(arg0: Internal.Byte2ReferenceFunction_<K>): Internal.Byte2CharFunction;
        andThenInt(arg0: Internal.Char2IntFunction_): Internal.Reference2IntFunction<K>;
        composeReference<T_>(arg0: Internal.Reference2ReferenceFunction_<T_, K>): Internal.Reference2CharFunction<T_>;
        andThen<T_>(arg0: java_.util.function_.Function_<string, T_>): java_.util.function_.Function<K, T_>;
        put(arg0: K, arg1: string): string;
        remove(arg0: any): string;
        defaultReturnValue(): string;
        defaultReturnValue(arg0: string): void;
        andThenDouble(arg0: Internal.Char2DoubleFunction_): Internal.Reference2DoubleFunction<K>;
        andThenObject<T_>(arg0: Internal.Char2ObjectFunction_<T_>): Internal.Reference2ObjectFunction<K, T_>;
        get(arg0: any): string;
        andThenLong(arg0: Internal.Char2LongFunction_): Internal.Reference2LongFunction<K>;
        composeLong(arg0: Internal.Long2ReferenceFunction_<K>): Internal.Long2CharFunction;
        andThenByte(arg0: Internal.Char2ByteFunction_): Internal.Reference2ByteFunction<K>;
        andThenFloat(arg0: Internal.Char2FloatFunction_): Internal.Reference2FloatFunction<K>;
        applyAsInt(arg0: K): number;
        apply(arg0: K): string;
        containsKey(arg0: any): boolean;
        composeInt(arg0: Internal.Int2ReferenceFunction_<K>): Internal.Int2CharFunction;
        clear(): void;
        composeFloat(arg0: Internal.Float2ReferenceFunction_<K>): Internal.Float2CharFunction;
        andThenChar(arg0: Internal.Char2CharFunction_): Internal.Reference2CharFunction<K>;
        getChar(arg0: any): string;
        composeObject<T_>(arg0: Internal.Object2ReferenceFunction_<T_, K>): Internal.Object2CharFunction<T_>;
        size(): number;
        compose<V_>(arg0: java_.util.function_.Function_<V_, K>): java_.util.function_.Function<V_, string>;
        composeShort(arg0: Internal.Short2ReferenceFunction_<K>): Internal.Short2CharFunction;
        andThenReference<T_>(arg0: Internal.Char2ReferenceFunction_<T_>): Internal.Reference2ReferenceFunction<K, T_>;
        composeChar(arg0: Internal.Char2ReferenceFunction_<K>): Internal.Char2CharFunction;
        composeDouble(arg0: Internal.Double2ReferenceFunction_<K>): Internal.Double2CharFunction;
    }
    type Reference2CharFunction_<K> = ((arg0: any) => string) | Reference2CharFunction<K>;
    interface ScheduledExecutorService extends Internal.ExecutorService {
        scheduleAtFixedRate(arg0: Internal.Runnable_, arg1: number, arg2: number, arg3: Internal.TimeUnit_): Internal.ScheduledFuture<any>;
        schedule(arg0: Internal.Runnable_, arg1: number, arg2: Internal.TimeUnit_): Internal.ScheduledFuture<any>;
        schedule<V_>(arg0: java_.util.concurrent.Callable_<V_>, arg1: number, arg2: Internal.TimeUnit_): Internal.ScheduledFuture<V_>;
        submit(arg0: Internal.Runnable_): Internal.Future<any>;
        submit<T_>(arg0: Internal.Runnable_, arg1: T_): Internal.Future<T_>;
        submit<T_>(arg0: java_.util.concurrent.Callable_<T_>): Internal.Future<T_>;
        isTerminated(): boolean;
        scheduleWithFixedDelay(arg0: Internal.Runnable_, arg1: number, arg2: number, arg3: Internal.TimeUnit_): Internal.ScheduledFuture<any>;
        invokeAll<T_>(arg0: Internal.Collection_<java_.util.concurrent.Callable_<T_>>): Internal.List<Internal.Future<T_>>;
        invokeAll<T_>(arg0: Internal.Collection_<java_.util.concurrent.Callable_<T_>>, arg1: number, arg2: Internal.TimeUnit_): Internal.List<Internal.Future<T_>>;
        awaitTermination(arg0: number, arg1: Internal.TimeUnit_): boolean;
        shutdownNow(): Internal.List<Internal.Runnable>;
        invokeAny<T_>(arg0: Internal.Collection_<java_.util.concurrent.Callable_<T_>>, arg1: number, arg2: Internal.TimeUnit_): T_;
        invokeAny<T_>(arg0: Internal.Collection_<java_.util.concurrent.Callable_<T_>>): T_;
        execute(arg0: Internal.Runnable_): void;
        shutdown(): void;
        isShutdown(): boolean;
    }
    type ScheduledExecutorService_ = ScheduledExecutorService;
    class NativeContinuation extends Internal.IdScriptableObject implements dev.latvian.mods.rhino.Function {
        getClass(): Internal.Class<any>;
        isSealed(): boolean;
        setParentScope(m: Internal.Scriptable_): void;
        static redefineProperty(obj: Internal.Scriptable_, name: string, isConst: boolean): void;
        putConst(name: string, start: Internal.Scriptable_, value: any): void;
        static getTypedProperty<T_>(s: Internal.Scriptable_, name: string, type: Internal.Class_<T_>): T_;
        static getTypedProperty<T_>(s: Internal.Scriptable_, index: number, type: Internal.Class_<T_>): T_;
        getIds(): any[];
        static getArrayPrototype(scope: Internal.Scriptable_): Internal.Scriptable;
        construct(cx: Internal.Context_, scope: Internal.Scriptable_, args: any[]): Internal.Scriptable;
        getAllIds(): any[];
        put(key: Internal.Symbol_, start: Internal.Scriptable_, value: any): void;
        put(name: string, start: Internal.Scriptable_, value: any): void;
        put(index: number, start: Internal.Scriptable_, value: any): void;
        static getDefaultValue(object: Internal.Scriptable_, typeHint: Internal.Class_<any>): any;
        getDefaultValue(typeHint: Internal.Class_<any>): any;
        defineOwnProperties(cx: Internal.Context_, props: Internal.ScriptableObject_): void;
        defineProperty(key: Internal.Symbol_, value: any, attributes: number): void;
        defineProperty(propertyName: string, clazz: Internal.Class_<any>, attributes: number): void;
        defineProperty(propertyName: string, delegateTo: any, getter: Internal.Method_, setter: Internal.Method_, attributes: number): void;
        defineProperty(propertyName: string, value: any, attributes: number): void;
        static defineProperty(destination: Internal.Scriptable_, propertyName: string, value: any, attributes: number): void;
        hasPrototypeMap(): boolean;
        setGetterOrSetter(name: string, index: number, getterOrSetter: Internal.Callable_, isSetter: boolean): void;
        avoidObjectDetection(): boolean;
        has(key: Internal.Symbol_, start: Internal.Scriptable_): boolean;
        has(name: string, start: Internal.Scriptable_): boolean;
        has(index: number, start: Internal.Scriptable_): boolean;
        getExternalArrayLength(): any;
        static init(cx: Internal.Context_, scope: Internal.Scriptable_, sealed: boolean): void;
        getAttributes(name: string): number;
        getAttributes(key: Internal.Symbol_): number;
        getAttributes(index: number): number;
        hasInstance(instance: Internal.Scriptable_): boolean;
        getAssociatedValue(key: any): any;
        execIdCall(f: Internal.IdFunctionObject_, cx: Internal.Context_, scope: Internal.Scriptable_, thisObj: Internal.Scriptable_, args: any[]): any;
        static getPropertyIds(obj: Internal.Scriptable_): any[];
        static hasProperty(obj: Internal.Scriptable_, name: string): boolean;
        static hasProperty(obj: Internal.Scriptable_, key: Internal.Symbol_): boolean;
        static hasProperty(obj: Internal.Scriptable_, index: number): boolean;
        getExternalArrayData(): Internal.ExternalArrayData;
        size(): number;
        initPrototypeMethod(tag: any, id: number, propertyName: string, functionName: string, arity: number): Internal.IdFunctionObject;
        initPrototypeMethod(tag: any, id: number, key: Internal.Symbol_, functionName: string, arity: number): Internal.IdFunctionObject;
        initPrototypeMethod(tag: any, id: number, name: string, arity: number): Internal.IdFunctionObject;
        defineOwnProperty(cx: Internal.Context_, key: any, desc: Internal.ScriptableObject_): void;
        initPrototypeValue(id: number, name: string, value: any, attributes: number): void;
        initPrototypeValue(id: number, key: Internal.Symbol_, value: any, attributes: number): void;
        static equalImplementations(c1: Internal.NativeContinuation_, c2: Internal.NativeContinuation_): boolean;
        static getFunctionPrototype(scope: Internal.Scriptable_): Internal.Scriptable;
        getClassName(): string;
        getParentScope(): Internal.Scriptable;
        preventExtensions(): void;
        setExternalArrayData(array: Internal.ExternalArrayData_): void;
        static callMethod(cx: Internal.Context_, obj: Internal.Scriptable_, methodName: string, args: any[]): any;
        static callMethod(obj: Internal.Scriptable_, methodName: string, args: any[]): any;
        enumerationIteratorNext(cx: Internal.Context_, currentId: Internal.Consumer_<any>): boolean;
        getTypeOf(): string;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        static getTopScopeValue(scope: Internal.Scriptable_, key: any): any;
        initPrototypeConstructor(f: Internal.IdFunctionObject_): void;
        getImplementation(): any;
        notifyAll(): void;
        sealObject(): void;
        setAttributes(name: string, attributes: number): void;
        setAttributes(key: Internal.Symbol_, attributes: number): void;
        setAttributes(index: number, attributes: number): void;
        static putProperty(obj: Internal.Scriptable_, name: string, value: any): void;
        static putProperty(obj: Internal.Scriptable_, index: number, value: any): void;
        static putProperty(obj: Internal.Scriptable_, key: Internal.Symbol_, value: any): void;
        delete(key: Internal.Symbol_): void;
        delete(name: string): void;
        delete(index: number): void;
        initImplementation(implementation: any): void;
        notify(): void;
        associateValue(key: any, value: any): any;
        static deleteProperty(obj: Internal.Scriptable_, name: string): boolean;
        static deleteProperty(obj: Internal.Scriptable_, index: number): boolean;
        getPrototype(): Internal.Scriptable;
        static getObjectPrototype(scope: Internal.Scriptable_): Internal.Scriptable;
        isExtensible(): boolean;
        hashCode(): number;
        isConst(name: string): boolean;
        get(name: string, start: Internal.Scriptable_): any;
        get(key: Internal.Symbol_, start: Internal.Scriptable_): any;
        get(index: number, start: Internal.Scriptable_): any;
        get(key: any): any;
        static putConstProperty(obj: Internal.Scriptable_, name: string, value: any): void;
        getGetterOrSetter(name: string, index: number, isSetter: boolean): any;
        static getTopLevelScope(obj: Internal.Scriptable_): Internal.Scriptable;
        static getProperty(obj: Internal.Scriptable_, name: string): any;
        static getProperty(obj: Internal.Scriptable_, key: Internal.Symbol_): any;
        static getProperty(obj: Internal.Scriptable_, index: number): any;
        static defineClass<T_>(scope: Internal.Scriptable_, clazz: Internal.Class_<T_>, sealed: boolean): void;
        static defineClass<T_>(scope: Internal.Scriptable_, clazz: Internal.Class_<T_>): void;
        static defineClass<T_>(scope: Internal.Scriptable_, clazz: Internal.Class_<T_>, sealed: boolean, mapInheritance: boolean): string;
        activatePrototypeMap(maxPrototypeId: number): void;
        isEmpty(): boolean;
        defineFunctionProperties(names: string[], clazz: Internal.Class_<any>, attributes: number): void;
        static getClassPrototype(scope: Internal.Scriptable_, className: string): Internal.Scriptable;
        setPrototype(m: Internal.Scriptable_): void;
        exportAsJSClass(maxPrototypeId: number, scope: Internal.Scriptable_, sealed: boolean): Internal.IdFunctionObject;
        call(cx: Internal.Context_, scope: Internal.Scriptable_, thisObj: Internal.Scriptable_, args: any[]): any;
        defineConst(name: string, start: Internal.Scriptable_): void;
        equals(arg0: any): boolean;
        static defineConstProperty(destination: Internal.Scriptable_, propertyName: string): void;
        toString(): string;
        enumerationIteratorHasNext(cx: Internal.Context_, currentId: Internal.Consumer_<any>): boolean;
        static getGeneratorFunctionPrototype(scope: Internal.Scriptable_): Internal.Scriptable;
        static isContinuationConstructor(f: Internal.IdFunctionObject_): boolean;
        static readonly DONTENUM : 2;
        static readonly CONST : 13;
        static readonly NOT_FOUND : any;
        static readonly UNINITIALIZED_CONST : 8;
        static readonly EMPTY : 0;
        static readonly READONLY : 1;
        static readonly PERMANENT : 4;
        get sealed(): boolean;
        get externalArrayData(): Internal.ExternalArrayData;
        get implementation(): any;
        get className(): string;
        get prototype(): Internal.Scriptable;
        get empty(): boolean;
        get parentScope(): Internal.Scriptable;
        get ids(): any[];
        get externalArrayLength(): any;
        get class(): Internal.Class<any>;
        get allIds(): any[];
        get extensible(): boolean;
        get typeOf(): string;
        set externalArrayData(array: Internal.ExternalArrayData_);
        set parentScope(m: Internal.Scriptable_);
        set prototype(m: Internal.Scriptable_);
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    type NativeContinuation_ = NativeContinuation;
    interface AccessibleText {
        getSelectionStart(): number;
        getSelectedText(): string;
        getIndexAtPoint(arg0: Internal.Point_): number;
        getCharCount(): number;
        getCharacterAttribute(arg0: number): Internal.AttributeSet;
        getBeforeIndex(arg0: number, arg1: number): string;
        getAfterIndex(arg0: number, arg1: number): string;
        getSelectionEnd(): number;
        getAtIndex(arg0: number, arg1: number): string;
        getCaretPosition(): number;
        getCharacterBounds(arg0: number): Internal.Rectangle;
    }
    type AccessibleText_ = AccessibleText;
    interface Long2ObjectFunction <V> extends Internal.Function<number, V>, Internal.LongFunction<V> {
        getOrDefault(arg0: number, arg1: V): V;
        getOrDefault(arg0: any, arg1: V): V;
        andThenShort(arg0: Internal.Object2ShortFunction_<V>): Internal.Long2ShortFunction;
        composeByte(arg0: Internal.Byte2LongFunction_): Internal.Byte2ObjectFunction<V>;
        andThenInt(arg0: Internal.Object2IntFunction_<V>): Internal.Long2IntFunction;
        andThen<V_>(arg0: java_.util.function_.Function_<V, V_>): java_.util.function_.Function<number, V_>;
        composeReference<T_>(arg0: Internal.Reference2LongFunction_<T_>): Internal.Reference2ObjectFunction<T_, V>;
        put(arg0: number, arg1: V): V;
        remove(arg0: any): V;
        remove(arg0: number): V;
        defaultReturnValue(arg0: V): void;
        defaultReturnValue(): V;
        andThenDouble(arg0: Internal.Object2DoubleFunction_<V>): Internal.Long2DoubleFunction;
        andThenObject<T_>(arg0: Internal.Object2ObjectFunction_<V, T_>): Internal.Long2ObjectFunction<T_>;
        get(arg0: any): V;
        get(arg0: number): V;
        andThenLong(arg0: Internal.Object2LongFunction_<V>): Internal.Long2LongFunction;
        composeLong(arg0: Internal.Long2LongFunction_): Internal.Long2ObjectFunction<V>;
        andThenByte(arg0: Internal.Object2ByteFunction_<V>): Internal.Long2ByteFunction;
        andThenFloat(arg0: Internal.Object2FloatFunction_<V>): Internal.Long2FloatFunction;
        apply(arg0: number): V;
        containsKey(arg0: any): boolean;
        containsKey(arg0: number): boolean;
        composeInt(arg0: Internal.Int2LongFunction_): Internal.Int2ObjectFunction<V>;
        clear(): void;
        composeFloat(arg0: Internal.Float2LongFunction_): Internal.Float2ObjectFunction<V>;
        andThenChar(arg0: Internal.Object2CharFunction_<V>): Internal.Long2CharFunction;
        composeObject<T_>(arg0: Internal.Object2LongFunction_<T_>): Internal.Object2ObjectFunction<T_, V>;
        size(): number;
        compose<T_>(arg0: java_.util.function_.Function_<T_, number>): java_.util.function_.Function<T_, V>;
        composeShort(arg0: Internal.Short2LongFunction_): Internal.Short2ObjectFunction<V>;
        andThenReference<T_>(arg0: Internal.Object2ReferenceFunction_<V, T_>): Internal.Long2ReferenceFunction<T_>;
        composeChar(arg0: Internal.Char2LongFunction_): Internal.Char2ObjectFunction<V>;
        composeDouble(arg0: Internal.Double2LongFunction_): Internal.Double2ObjectFunction<V>;
    }
    type Long2ObjectFunction_<V> = ((arg0: number) => V) | Long2ObjectFunction<V>;
    class ZoneRules implements Internal.Serializable {
        getTransitions(): Internal.List<Internal.ZoneOffsetTransition>;
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        getDaylightSavings(arg0: Internal.Instant_): Internal.Duration;
        getTransitionRules(): Internal.List<Internal.ZoneOffsetTransitionRule>;
        previousTransition(arg0: Internal.Instant_): Internal.ZoneOffsetTransition;
        notifyAll(): void;
        getOffset(arg0: Internal.LocalDateTime_): Internal.ZoneOffset;
        getOffset(arg0: Internal.Instant_): Internal.ZoneOffset;
        notify(): void;
        isFixedOffset(): boolean;
        hashCode(): number;
        getValidOffsets(arg0: Internal.LocalDateTime_): Internal.List<Internal.ZoneOffset>;
        getTransition(arg0: Internal.LocalDateTime_): Internal.ZoneOffsetTransition;
        static of(arg0: Internal.ZoneOffset_, arg1: Internal.ZoneOffset_, arg2: Internal.List_<Internal.ZoneOffsetTransition_>, arg3: Internal.List_<Internal.ZoneOffsetTransition_>, arg4: Internal.List_<Internal.ZoneOffsetTransitionRule_>): Internal.ZoneRules;
        static of(arg0: Internal.ZoneOffset_): Internal.ZoneRules;
        equals(arg0: any): boolean;
        nextTransition(arg0: Internal.Instant_): Internal.ZoneOffsetTransition;
        getStandardOffset(arg0: Internal.Instant_): Internal.ZoneOffset;
        toString(): string;
        isDaylightSavings(arg0: Internal.Instant_): boolean;
        isValidOffset(arg0: Internal.LocalDateTime_, arg1: Internal.ZoneOffset_): boolean;
        get fixedOffset(): boolean;
        get transitionRules(): Internal.List<Internal.ZoneOffsetTransitionRule>;
        get transitions(): Internal.List<Internal.ZoneOffsetTransition>;
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    type ZoneRules_ = ZoneRules;
    interface RecipeType <T> {
    }
    type RecipeType_<T> = RecipeType<T>;
    interface Matrix4fExtended {
        rotate(arg0: Internal.Quaternion_): void;
        transformVecZ(arg0: number, arg1: number, arg2: number): number;
        transformVecY(arg0: number, arg1: number, arg2: number): number;
        transformVecX(arg0: number, arg1: number, arg2: number): number;
        translate(arg0: number, arg1: number, arg2: number): void;
    }
    type Matrix4fExtended_ = Matrix4fExtended;
    class AttributeModifier {
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        hashCode(): number;
        notifyAll(): void;
        equals(arg0: any): boolean;
        toString(): string;
        notify(): void;
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    type AttributeModifier_ = AttributeModifier;
    abstract class HitResult {
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        hashCode(): number;
        notifyAll(): void;
        equals(arg0: any): boolean;
        toString(): string;
        notify(): void;
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    type HitResult_ = HitResult;
    class EventJS {
        cancel(): void;
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        isCancelled(): boolean;
        post(t: Internal.ScriptType_, id: string, sub: string): boolean;
        post(t: Internal.ScriptType_, id: string): boolean;
        hashCode(): number;
        notifyAll(): void;
        equals(arg0: any): boolean;
        toString(): string;
        notify(): void;
        canCancel(): boolean;
        get cancelled(): boolean;
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    type EventJS_ = EventJS;
    class ComponentDefinition {
        getBlockProperties(): Internal.BlockBehaviour$Properties;
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        getRenderer(): Internal.IRenderer;
        needUpdateTick(): boolean;
        notifyAll(): void;
        getID(): string;
        getTileType(): Internal.BlockEntityType<Internal.BlockEntity>;
        notify(): void;
        registerTileEntity(arg0: Internal.Block_, arg1: Internal.IForgeRegistry_<Internal.BlockEntityType_<any>>): void;
        getStackForm(): Internal.ItemStack;
        hashCode(): number;
        createNewTileEntity(arg0: BlockPos_, arg1: Internal.BlockState_): Internal.BlockEntity;
        equals(arg0: any): boolean;
        getItemProperties(): Internal.Item$Properties;
        toString(): string;
        traits : Internal.JsonObject;
        baseRenderer : Internal.IMultiblockedRenderer;
        workingRenderer : Internal.IMultiblockedRenderer;
        showInJei : boolean;
        readonly location : ResourceLocation;
        formedRenderer : Internal.IMultiblockedRenderer;
        allowRotate : boolean;
        properties : Internal.CustomProperties;
        get tileType(): Internal.BlockEntityType<Internal.BlockEntity>;
        get renderer(): Internal.IRenderer;
        get blockProperties(): Internal.BlockBehaviour$Properties;
        get itemProperties(): Internal.Item$Properties;
        get iD(): string;
        get stackForm(): Internal.ItemStack;
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    type ComponentDefinition_ = ComponentDefinition;
    class BlockEntityWithoutLevelRenderer implements Internal.ResourceManagerReloadListener {
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        hashCode(): number;
        notifyAll(): void;
        equals(arg0: any): boolean;
        toString(): string;
        notify(): void;
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    type BlockEntityWithoutLevelRenderer_ = BlockEntityWithoutLevelRenderer;
    class PrintStream extends Internal.FilterOutputStream implements Internal.Appendable, Internal.Closeable {
        getClass(): Internal.Class<any>;
        charset(): Internal.Charset;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        notifyAll(): void;
        format(arg0: Internal.Locale_, arg1: string, arg2: any[]): Internal.PrintStream;
        format(arg0: string, arg1: any[]): Internal.PrintStream;
        checkError(): boolean;
        notify(): void;
        printf(arg0: Internal.Locale_, arg1: string, arg2: any[]): Internal.PrintStream;
        printf(arg0: string, arg1: any[]): Internal.PrintStream;
        print(arg0: boolean): void;
        print(arg0: string): void;
        print(arg0: number): void;
        print(arg0: string[]): void;
        print(arg0: any): void;
        println(arg0: string): void;
        println(arg0: any): void;
        println(arg0: number): void;
        println(arg0: string[]): void;
        println(arg0: boolean): void;
        println(): void;
        writeBytes(arg0: number[]): void;
        flush(): void;
        hashCode(): number;
        equals(arg0: any): boolean;
        toString(): string;
        static nullOutputStream(): Internal.OutputStream;
        close(): void;
        write(arg0: number[]): void;
        write(arg0: number): void;
        write(arg0: number[], arg1: number, arg2: number): void;
        append(arg0: Internal.CharSequence_): Internal.PrintStream;
        append(arg0: Internal.CharSequence_, arg1: number, arg2: number): Internal.PrintStream;
        append(arg0: string): Internal.PrintStream;
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    type PrintStream_ = PrintStream;
    class AccessibleStateSet {
        add(arg0: Internal.AccessibleState_): boolean;
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        contains(arg0: Internal.AccessibleState_): boolean;
        addAll(arg0: Internal.AccessibleState_[]): void;
        hashCode(): number;
        notifyAll(): void;
        equals(arg0: any): boolean;
        toArray(): Internal.AccessibleState[];
        clear(): void;
        toString(): string;
        notify(): void;
        remove(arg0: Internal.AccessibleState_): boolean;
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    type AccessibleStateSet_ = AccessibleStateSet;
    class WidgetGroup extends com.lowdragmc.lowdraglib.gui.widget.Widget implements Internal.IGhostIngredientTarget, Internal.IIngredientSlot {
        getClass(): Internal.Class<any>;
        mouseWheelMove(arg0: number, arg1: number, arg2: number): boolean;
        mouseDragged(arg0: number, arg1: number, arg2: number, arg3: number, arg4: number): boolean;
        drawInForeground(arg0: Internal.PoseStack_, arg1: number, arg2: number, arg3: number): void;
        readUpdateInfo(arg0: number, arg1: Internal.FriendlyByteBuf_): void;
        toRectangleBox(): Internal.Rect2i;
        isActive(): boolean;
        getGui(): Internal.ModularUI;
        updateScreen(): void;
        clearAllWidgets(): void;
        mouseMoved(arg0: number, arg1: number): void;
        isChild(arg0: com.lowdragmc.lowdraglib.gui.widget.Widget_): boolean;
        setVisible(arg0: boolean): void;
        static isMouseOver(arg0: number, arg1: number, arg2: number, arg3: number, arg4: number, arg5: number): boolean;
        addSelfPosition(arg0: number, arg1: number): Internal.Position;
        isParent(arg0: Internal.WidgetGroup_): boolean;
        keyPressed(arg0: number, arg1: number, arg2: number): boolean;
        setHoverTexture(arg0: Internal.IGuiTexture_[]): com.lowdragmc.lowdraglib.gui.widget.Widget;
        isMouseOverElement(arg0: number, arg1: number): boolean;
        isVisible(): boolean;
        getSelfPosition(): Internal.Position;
        setClientSideWidget(): Internal.WidgetGroup;
        handleClientAction(arg0: number, arg1: Internal.FriendlyByteBuf_): void;
        mouseClicked(arg0: number, arg1: number, arg2: number): boolean;
        charTyped(arg0: string, arg1: number): boolean;
        removeWidget(arg0: com.lowdragmc.lowdraglib.gui.widget.Widget_): void;
        readInitialData(arg0: Internal.FriendlyByteBuf_): void;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        notifyAll(): void;
        isInitialized(): boolean;
        setBackground(arg0: Internal.IGuiTexture_[]): com.lowdragmc.lowdraglib.gui.widget.Widget;
        notify(): void;
        mouseReleased(arg0: number, arg1: number, arg2: number): boolean;
        setSize(arg0: Internal.Size_): void;
        initWidget(): void;
        hashCode(): number;
        getNativeWidgets(): Internal.List<Internal.SlotWidget>;
        keyReleased(arg0: number, arg1: number, arg2: number): boolean;
        waitToRemoved(arg0: com.lowdragmc.lowdraglib.gui.widget.Widget_): void;
        detectAndSendChanges(): void;
        getPhantomTargets(arg0: any): Internal.List<Internal.Target>;
        getParent(): Internal.WidgetGroup;
        setSelfPosition(arg0: Internal.Position_): void;
        isRemote(): boolean;
        setFocus(arg0: boolean): void;
        setUiAccess(arg0: Internal.WidgetUIAccess_): void;
        drawInBackground(arg0: Internal.PoseStack_, arg1: number, arg2: number, arg3: number): void;
        getParentPosition(): Internal.Position;
        getSize(): Internal.Size;
        setActive(arg0: boolean): void;
        getPosition(): Internal.Position;
        getIngredientOverMouse(arg0: number, arg1: number): any;
        isFocus(): boolean;
        equals(arg0: any): boolean;
        onFocusChanged(arg0: com.lowdragmc.lowdraglib.gui.widget.Widget_, arg1: com.lowdragmc.lowdraglib.gui.widget.Widget_): void;
        setHoverTooltips(arg0: Internal.List_<Internal.Component_>): com.lowdragmc.lowdraglib.gui.widget.Widget;
        setHoverTooltips(arg0: string[]): com.lowdragmc.lowdraglib.gui.widget.Widget;
        setHoverTooltips(arg0: Internal.Component_[]): com.lowdragmc.lowdraglib.gui.widget.Widget;
        writeInitialData(arg0: Internal.FriendlyByteBuf_): void;
        toString(): string;
        setParentPosition(arg0: Internal.Position_): void;
        addWidget(arg0: com.lowdragmc.lowdraglib.gui.widget.Widget_): Internal.WidgetGroup;
        addWidget(arg0: number, arg1: com.lowdragmc.lowdraglib.gui.widget.Widget_): Internal.WidgetGroup;
        setGui(arg0: Internal.ModularUI_): void;
        getContainedWidgets(arg0: boolean): Internal.List<com.lowdragmc.lowdraglib.gui.widget.Widget>;
        readonly widgets : Internal.List<com.lowdragmc.lowdraglib.gui.widget.Widget>;
        get selfPosition(): Internal.Position;
        get parent(): Internal.WidgetGroup;
        get visible(): boolean;
        get nativeWidgets(): Internal.List<Internal.SlotWidget>;
        get active(): boolean;
        get focus(): boolean;
        get remote(): boolean;
        get parentPosition(): Internal.Position;
        get size(): Internal.Size;
        get initialized(): boolean;
        get gui(): Internal.ModularUI;
        get position(): Internal.Position;
        get class(): Internal.Class<any>;
        set selfPosition(arg0: Internal.Position_);
        set parentPosition(arg0: Internal.Position_);
        set visible(arg0: boolean);
        set size(arg0: Internal.Size_);
        set hoverTexture(arg0: Internal.IGuiTexture_[]);
        set background(arg0: Internal.IGuiTexture_[]);
        set active(arg0: boolean);
        set focus(arg0: boolean);
        set gui(arg0: Internal.ModularUI_);
        set hoverTooltips(arg0: Internal.List_<Internal.Component_>);
        set uiAccess(arg0: Internal.WidgetUIAccess_);
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    type WidgetGroup_ = WidgetGroup;
    interface PathMatcher {
        matches(arg0: Internal.Path_): boolean;
    }
    type PathMatcher_ = ((arg0: Internal.Path) => boolean) | PathMatcher;
    interface AccessorGoalSelector {
        getAvailableGoals(): Internal.Set<Internal.WrappedGoal>;
    }
    type AccessorGoalSelector_ = AccessorGoalSelector;
    class ImmutableMultiset$Builder <E> extends Internal.ImmutableCollection$Builder<E> {
        add(arg0: E): Internal.ImmutableMultiset$Builder<E>;
        add(arg0: E[]): Internal.ImmutableMultiset$Builder<E>;
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        build(): Internal.ImmutableMultiset<E>;
        addAll(arg0: Internal.Iterable_<E>): Internal.ImmutableMultiset$Builder<E>;
        addAll(arg0: Internal.Iterator_<E>): Internal.ImmutableMultiset$Builder<E>;
        hashCode(): number;
        notifyAll(): void;
        equals(arg0: any): boolean;
        toString(): string;
        addCopies(arg0: E, arg1: number): Internal.ImmutableMultiset$Builder<E>;
        notify(): void;
        setCount(arg0: E, arg1: number): Internal.ImmutableMultiset$Builder<E>;
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    type ImmutableMultiset$Builder_<E> = ImmutableMultiset$Builder<E>;
    class DataOutputStream extends Internal.FilterOutputStream implements Internal.DataOutput {
        writeInt(arg0: number): void;
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        writeByte(arg0: number): void;
        notifyAll(): void;
        writeFloat(arg0: number): void;
        notify(): void;
        writeChar(arg0: number): void;
        writeLong(arg0: number): void;
        writeBytes(arg0: string): void;
        size(): number;
        flush(): void;
        hashCode(): number;
        equals(arg0: any): boolean;
        writeUTF(arg0: string): void;
        toString(): string;
        static nullOutputStream(): Internal.OutputStream;
        writeShort(arg0: number): void;
        writeChars(arg0: string): void;
        close(): void;
        write(arg0: number[], arg1: number, arg2: number): void;
        write(arg0: number): void;
        write(arg0: number[]): void;
        writeBoolean(arg0: boolean): void;
        writeDouble(arg0: number): void;
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    type DataOutputStream_ = DataOutputStream;
    interface LambDynamicLight {
        getDynamicLightY(): number;
        lambdynlights$scheduleTrackedChunksRebuild(arg0: Internal.LevelRenderer_): void;
        getDynamicLightZ(): number;
        resetDynamicLight(): void;
        setDynamicLightEnabled(arg0: boolean): void;
        getDynamicLightX(): number;
        shouldUpdateDynamicLight(): boolean;
        getLuminance(): number;
        isDynamicLightEnabled(): boolean;
        dynamicLightTick(): void;
        getDynamicLightWorld(): Internal.Level;
        lambdynlights$updateDynamicLight(arg0: Internal.LevelRenderer_): boolean;
    }
    type LambDynamicLight_ = LambDynamicLight;
    class NetworkEvent$Context {
        getClass(): Internal.Class<any>;
        getNetworkManager(): Internal.Connection;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        getDirection(): Internal.NetworkDirection;
        enqueueWork(arg0: Internal.Runnable_): Internal.CompletableFuture<void>;
        notifyAll(): void;
        notify(): void;
        getPacketHandled(): boolean;
        hashCode(): number;
        equals(arg0: any): boolean;
        toString(): string;
        setPacketHandled(arg0: boolean): void;
        getSender(): Internal.ServerPlayer;
        attr<T>(arg0: Internal.AttributeKey_<T>): io.netty.util.Attribute<T>;
        getPacketDispatcher(): Internal.NetworkEvent$PacketDispatcher;
        get networkManager(): Internal.Connection;
        get packetHandled(): boolean;
        get sender(): Internal.ServerPlayer;
        get class(): Internal.Class<any>;
        get direction(): Internal.NetworkDirection;
        get packetDispatcher(): Internal.NetworkEvent$PacketDispatcher;
        set packetHandled(arg0: boolean);
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    type NetworkEvent$Context_ = NetworkEvent$Context;
    class RightClickEvent extends Internal.EventJS {
        cancel(): void;
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        isCancelled(): boolean;
        getPlayer(): Internal.Player;
        getHand(): Hand;
        notifyAll(): void;
        notify(): void;
        post(t: Internal.ScriptType_, id: string, sub: string): boolean;
        post(t: Internal.ScriptType_, id: string): boolean;
        getHit(): Internal.BlockHitResult;
        hashCode(): number;
        equals(arg0: any): boolean;
        toString(): string;
        getComponent(): Internal.ComponentTileEntity<any>;
        canCancel(): boolean;
        static readonly ID : "mbd.right_click";
        get hit(): Internal.BlockHitResult;
        get component(): Internal.ComponentTileEntity<any>;
        get cancelled(): boolean;
        get class(): Internal.Class<any>;
        get player(): Internal.Player;
        get hand(): Hand;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    type RightClickEvent_ = RightClickEvent;
    interface PrimitiveIterator$OfDouble extends Internal.PrimitiveIterator<number, java_.util.function_.DoubleConsumer> {
        next(): number;
        hasNext(): boolean;
        forEachRemaining(arg0: java_.util.function_.DoubleConsumer_): void;
        forEachRemaining(arg0: Internal.Consumer_<number>): void;
        remove(): void;
        nextDouble(): number;
    }
    type PrimitiveIterator$OfDouble_ = PrimitiveIterator$OfDouble;
    abstract class AbstractByte2DoubleFunction implements Internal.Byte2DoubleFunction, Internal.Serializable {
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        getOrDefault(arg0: any, arg1: number): number;
        getOrDefault(arg0: number, arg1: number): number;
        applyAsDouble(arg0: number): number;
        notifyAll(): void;
        andThenShort(arg0: Internal.Double2ShortFunction_): Internal.Byte2ShortFunction;
        composeByte(arg0: Internal.Byte2ByteFunction_): Internal.Byte2DoubleFunction;
        andThenInt(arg0: Internal.Double2IntFunction_): Internal.Byte2IntFunction;
        composeReference<T_>(arg0: Internal.Reference2ByteFunction_<T_>): Internal.Reference2DoubleFunction<T_>;
        andThen<T_>(arg0: java_.util.function_.Function_<number, T_>): java_.util.function_.Function<number, T_>;
        put(arg0: number, arg1: number): number;
        remove(arg0: number): number;
        remove(arg0: any): number;
        notify(): void;
        defaultReturnValue(arg0: number): void;
        defaultReturnValue(): number;
        andThenDouble(arg0: Internal.Double2DoubleFunction_): Internal.Byte2DoubleFunction;
        andThenObject<T_>(arg0: Internal.Double2ObjectFunction_<T_>): Internal.Byte2ObjectFunction<T_>;
        hashCode(): number;
        get(arg0: any): number;
        get(arg0: number): number;
        andThenLong(arg0: Internal.Double2LongFunction_): Internal.Byte2LongFunction;
        composeLong(arg0: Internal.Long2ByteFunction_): Internal.Long2DoubleFunction;
        andThenByte(arg0: Internal.Double2ByteFunction_): Internal.Byte2ByteFunction;
        andThenFloat(arg0: Internal.Double2FloatFunction_): Internal.Byte2FloatFunction;
        apply(arg0: number): number;
        containsKey(arg0: any): boolean;
        containsKey(arg0: number): boolean;
        composeInt(arg0: Internal.Int2ByteFunction_): Internal.Int2DoubleFunction;
        clear(): void;
        composeFloat(arg0: Internal.Float2ByteFunction_): Internal.Float2DoubleFunction;
        andThenChar(arg0: Internal.Double2CharFunction_): Internal.Byte2CharFunction;
        composeObject<T_>(arg0: Internal.Object2ByteFunction_<T_>): Internal.Object2DoubleFunction<T_>;
        size(): number;
        compose<T_>(arg0: java_.util.function_.Function_<T_, number>): java_.util.function_.Function<T_, number>;
        composeShort(arg0: Internal.Short2ByteFunction_): Internal.Short2DoubleFunction;
        equals(arg0: any): boolean;
        andThenReference<T_>(arg0: Internal.Double2ReferenceFunction_<T_>): Internal.Byte2ReferenceFunction<T_>;
        composeChar(arg0: Internal.Char2ByteFunction_): Internal.Char2DoubleFunction;
        toString(): string;
        composeDouble(arg0: Internal.Double2ByteFunction_): Internal.Double2DoubleFunction;
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    type AbstractByte2DoubleFunction_ = AbstractByte2DoubleFunction;
    interface TeamPropertyType$FromNet <Y> {
        apply(arg0: ResourceLocation_, arg1: Internal.FriendlyByteBuf_): Internal.TeamProperty<Y>;
    }
    type TeamPropertyType$FromNet_<Y> = TeamPropertyType$FromNet<Y>;
    interface Object2CharFunction <K> extends Internal.Function<K, string>, Internal.ToIntFunction<K> {
        getOrDefault(arg0: any, arg1: string): string;
        andThenShort(arg0: Internal.Char2ShortFunction_): Internal.Object2ShortFunction<K>;
        removeChar(arg0: any): string;
        composeByte(arg0: Internal.Byte2ObjectFunction_<K>): Internal.Byte2CharFunction;
        andThenInt(arg0: Internal.Char2IntFunction_): Internal.Object2IntFunction<K>;
        composeReference<T_>(arg0: Internal.Reference2ObjectFunction_<T_, K>): Internal.Reference2CharFunction<T_>;
        andThen<T_>(arg0: java_.util.function_.Function_<string, T_>): java_.util.function_.Function<K, T_>;
        put(arg0: K, arg1: string): string;
        remove(arg0: any): string;
        defaultReturnValue(): string;
        defaultReturnValue(arg0: string): void;
        andThenDouble(arg0: Internal.Char2DoubleFunction_): Internal.Object2DoubleFunction<K>;
        andThenObject<T_>(arg0: Internal.Char2ObjectFunction_<T_>): Internal.Object2ObjectFunction<K, T_>;
        get(arg0: any): string;
        andThenLong(arg0: Internal.Char2LongFunction_): Internal.Object2LongFunction<K>;
        composeLong(arg0: Internal.Long2ObjectFunction_<K>): Internal.Long2CharFunction;
        andThenByte(arg0: Internal.Char2ByteFunction_): Internal.Object2ByteFunction<K>;
        andThenFloat(arg0: Internal.Char2FloatFunction_): Internal.Object2FloatFunction<K>;
        applyAsInt(arg0: K): number;
        apply(arg0: K): string;
        containsKey(arg0: any): boolean;
        composeInt(arg0: Internal.Int2ObjectFunction_<K>): Internal.Int2CharFunction;
        clear(): void;
        composeFloat(arg0: Internal.Float2ObjectFunction_<K>): Internal.Float2CharFunction;
        andThenChar(arg0: Internal.Char2CharFunction_): Internal.Object2CharFunction<K>;
        getChar(arg0: any): string;
        composeObject<T_>(arg0: Internal.Object2ObjectFunction_<T_, K>): Internal.Object2CharFunction<T_>;
        size(): number;
        compose<V_>(arg0: java_.util.function_.Function_<V_, K>): java_.util.function_.Function<V_, string>;
        composeShort(arg0: Internal.Short2ObjectFunction_<K>): Internal.Short2CharFunction;
        andThenReference<T_>(arg0: Internal.Char2ReferenceFunction_<T_>): Internal.Object2ReferenceFunction<K, T_>;
        composeChar(arg0: Internal.Char2ObjectFunction_<K>): Internal.Char2CharFunction;
        composeDouble(arg0: Internal.Double2ObjectFunction_<K>): Internal.Double2CharFunction;
    }
    type Object2CharFunction_<K> = ((arg0: any) => string) | Object2CharFunction<K>;
    interface IForgeEntity extends Internal.ICapabilitySerializable<Internal.CompoundTag> {
        shouldRiderSit(): boolean;
        canUpdate(arg0: boolean): void;
        canUpdate(): boolean;
        getPickedResult(arg0: Internal.HitResult_): Internal.ItemStack;
        getCapability<T_>(arg0: Internal.Capability_<T_>, arg1: Internal.Direction_): Internal.LazyOptional<T_>;
        getCapability<T_>(arg0: Internal.Capability_<T_>): Internal.LazyOptional<T_>;
        captureDrops(): Internal.Collection<Internal.ItemEntity>;
        captureDrops(arg0: Internal.Collection_<Internal.ItemEntity_>): Internal.Collection<Internal.ItemEntity>;
        onRemovedFromWorld(): void;
        isMultipartEntity(): boolean;
        canBeRiddenInWater(arg0: Internal.Entity_): boolean;
        deserializeNBT(arg0: Internal.CompoundTag_): void;
        getPersistentData(): Internal.CompoundTag;
        canRiderInteract(): boolean;
        serializeNBT(): Internal.CompoundTag;
        onAddedToWorld(): void;
        canTrample(arg0: Internal.BlockState_, arg1: BlockPos_, arg2: number): boolean;
        revive(): void;
        isAddedToWorld(): boolean;
        getClassification(arg0: boolean): Internal.MobCategory;
        getParts(): any[];
    }
    type IForgeEntity_ = IForgeEntity;
    interface AttributedCharacterIterator extends Internal.CharacterIterator {
        next(): string;
        getAttributes(): Internal.Map<Internal.AttributedCharacterIterator$Attribute, any>;
        getIndex(): number;
        previous(): string;
        last(): string;
        getRunLimit(arg0: Internal.Set_<Internal.AttributedCharacterIterator$Attribute_>): number;
        getRunLimit(arg0: Internal.AttributedCharacterIterator$Attribute_): number;
        getRunLimit(): number;
        getBeginIndex(): number;
        current(): string;
        getAttribute(arg0: Internal.AttributedCharacterIterator$Attribute_): any;
        setIndex(arg0: number): string;
        getEndIndex(): number;
        clone(): any;
        getRunStart(): number;
        getRunStart(arg0: Internal.Set_<Internal.AttributedCharacterIterator$Attribute_>): number;
        getRunStart(arg0: Internal.AttributedCharacterIterator$Attribute_): number;
        first(): string;
        getAllAttributeKeys(): Internal.Set<Internal.AttributedCharacterIterator$Attribute>;
    }
    type AttributedCharacterIterator_ = AttributedCharacterIterator;
    interface ReferenceCounted {
        refCnt(): number;
        release(arg0: number): boolean;
        release(): boolean;
        retain(): Internal.ReferenceCounted;
        retain(arg0: number): Internal.ReferenceCounted;
        touch(): Internal.ReferenceCounted;
        touch(arg0: any): Internal.ReferenceCounted;
    }
    type ReferenceCounted_ = ReferenceCounted;
    abstract class FlowingFluid extends Internal.Fluid {
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        getAttributes(): Internal.FluidAttributes;
        getExplosionResistance(arg0: Internal.FluidState_, arg1: Internal.BlockGetter_, arg2: BlockPos_, arg3: Internal.Explosion_): number;
        notifyAll(): void;
        getRegistryName(): ResourceLocation;
        setRegistryName(arg0: ResourceLocation_): Internal.Fluid;
        setRegistryName(arg0: string): Internal.Fluid;
        setRegistryName(arg0: string, arg1: string): Internal.Fluid;
        isEntityInside(arg0: Internal.FluidState_, arg1: Internal.LevelReader_, arg2: BlockPos_, arg3: Internal.Entity_, arg4: number, arg5: Internal.HolderSet_<Internal.Fluid_>, arg6: boolean): boolean;
        isAABBInsideMaterial(arg0: Internal.FluidState_, arg1: Internal.LevelReader_, arg2: BlockPos_, arg3: Internal.AABB_, arg4: Internal.Material_): boolean;
        notify(): void;
        isAABBInsideLiquid(arg0: Internal.FluidState_, arg1: Internal.LevelReader_, arg2: BlockPos_, arg3: Internal.AABB_): boolean;
        hashCode(): number;
        equals(arg0: any): boolean;
        getRegistryType(): Internal.Class<Internal.Fluid>;
        toString(): string;
        readonly delegate : Internal.IRegistryDelegate<Internal.Fluid>;
        get registryType(): Internal.Class<Internal.Fluid>;
        get attributes(): Internal.FluidAttributes;
        get registryName(): ResourceLocation;
        get class(): Internal.Class<any>;
        set registryName(arg0: ResourceLocation_);
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    type FlowingFluid_ = FlowingFluid;
    class VillagerProfession extends Internal.ForgeRegistryEntry<Internal.VillagerProfession> implements Internal.VillagerProfessionAccess {
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        hashCode(): number;
        notifyAll(): void;
        equals(arg0: any): boolean;
        getRegistryType(): Internal.Class<Internal.VillagerProfession>;
        getRegistryName(): ResourceLocation;
        setRegistryName(arg0: ResourceLocation_): Internal.VillagerProfession;
        setRegistryName(arg0: string): Internal.VillagerProfession;
        setRegistryName(arg0: string, arg1: string): Internal.VillagerProfession;
        toString(): string;
        notify(): void;
        readonly delegate : Internal.IRegistryDelegate<Internal.VillagerProfession>;
        blue_skies$updateSecondaryPoi : boolean;
        get registryType(): Internal.Class<Internal.VillagerProfession>;
        get registryName(): ResourceLocation;
        get class(): Internal.Class<any>;
        set registryName(arg0: ResourceLocation_);
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    type VillagerProfession_ = VillagerProfession;
    abstract class VarHandle implements Internal.Constable {
        getClass(): Internal.Class<any>;
        toMethodHandle(arg0: Internal.VarHandle$AccessMode_): Internal.MethodHandle;
        getAndBitwiseXor(arg0: any[]): any;
        static storeStoreFence(): void;
        compareAndExchange(arg0: any[]): any;
        getAndSetRelease(arg0: any[]): any;
        getAndBitwiseAnd(arg0: any[]): any;
        describeConstable(): Internal.Optional<Internal.VarHandle$VarHandleDesc>;
        varType(): Internal.Class<any>;
        getAndBitwiseOrAcquire(arg0: any[]): any;
        setVolatile(arg0: any[]): void;
        static releaseFence(): void;
        getAndAdd(arg0: any[]): any;
        weakCompareAndSetRelease(arg0: any[]): boolean;
        static loadLoadFence(): void;
        getAndAddAcquire(arg0: any[]): any;
        setOpaque(arg0: any[]): void;
        isAccessModeSupported(arg0: Internal.VarHandle$AccessMode_): boolean;
        compareAndExchangeRelease(arg0: any[]): any;
        compareAndSet(arg0: any[]): boolean;
        compareAndExchangeAcquire(arg0: any[]): any;
        getAndBitwiseXorRelease(arg0: any[]): any;
        withInvokeBehavior(): Internal.VarHandle;
        withInvokeExactBehavior(): Internal.VarHandle;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        coordinateTypes(): Internal.List<Internal.Class<any>>;
        weakCompareAndSetPlain(arg0: any[]): boolean;
        getVolatile(arg0: any[]): any;
        static fullFence(): void;
        notifyAll(): void;
        getAcquire(arg0: any[]): any;
        accessModeType(arg0: Internal.VarHandle$AccessMode_): Internal.MethodType;
        getAndBitwiseOr(arg0: any[]): any;
        static acquireFence(): void;
        hasInvokeExactBehavior(): boolean;
        notify(): void;
        getAndBitwiseOrRelease(arg0: any[]): any;
        getAndSetAcquire(arg0: any[]): any;
        getOpaque(arg0: any[]): any;
        getAndBitwiseXorAcquire(arg0: any[]): any;
        hashCode(): number;
        getAndBitwiseAndRelease(arg0: any[]): any;
        get(arg0: any[]): any;
        getAndSet(arg0: any[]): any;
        weakCompareAndSetAcquire(arg0: any[]): boolean;
        set(arg0: any[]): void;
        weakCompareAndSet(arg0: any[]): boolean;
        getAndAddRelease(arg0: any[]): any;
        equals(arg0: any): boolean;
        setRelease(arg0: any[]): void;
        toString(): string;
        getAndBitwiseAndAcquire(arg0: any[]): any;
        get class(): Internal.Class<any>;
        set opaque(arg0: any[]);
        set release(arg0: any[]);
        set volatile(arg0: any[]);
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    type VarHandle_ = VarHandle;
    interface AbstractContainerMenuInvoker {
        _moveItemStackTo(arg0: Internal.ItemStack_, arg1: number, arg2: number, arg3: boolean): boolean;
    }
    type AbstractContainerMenuInvoker_ = AbstractContainerMenuInvoker;
    /**
    * Fired when you need to remove worldgen.
    */
    class WorldgenRemoveEventJS extends Internal.StartupEventJS {
        cancel(): void;
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        isCancelled(): boolean;
        notifyAll(): void;
        printSpawns(): void;
        printSpawns(category: Internal.MobCategory_): void;
        removeFeatureById(type: DecorationGenerationStep_, ids: ResourceLocation_[]): void;
        removeFeatureById(filter: Internal.BiomeFilter_, decoration: DecorationGenerationStep_, ids: ResourceLocation_[]): void;
        removeAllFeatures(filter: Internal.BiomeFilter_): void;
        removeAllFeatures(filter: Internal.BiomeFilter_, type: DecorationGenerationStep_): void;
        removeAllFeatures(): void;
        removeOres(p: Internal.Consumer_<Internal.RemoveOresProperties_>): void;
        notify(): void;
        printFiltered(type: DecorationGenerationStep_, filter: Internal.BiomeFilter_): void;
        printFiltered(type: DecorationGenerationStep_): void;
        printFiltered(): void;
        removeAllSpawns(): void;
        printFeaturesForType(type: DecorationGenerationStep_, filter: Internal.BiomeFilter_, afterRemoval: boolean): void;
        post(id: string): boolean;
        post(id: string, sub: string): boolean;
        post(t: Internal.ScriptType_, id: string, sub: string): boolean;
        post(t: Internal.ScriptType_, id: string): boolean;
        hashCode(): number;
        equals(arg0: any): boolean;
        printFeatures(type: DecorationGenerationStep_): void;
        printFeatures(type: DecorationGenerationStep_, filter: Internal.BiomeFilter_): void;
        printFeatures(): void;
        toString(): string;
        removeSpawns(p: Internal.Consumer_<Internal.RemoveSpawnsProperties_>): void;
        canCancel(): boolean;
        get cancelled(): boolean;
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    /**
    * Fired when you need to remove worldgen.
    */
    type WorldgenRemoveEventJS_ = WorldgenRemoveEventJS;
    class WriteBufferWaterMark {
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        high(): number;
        low(): number;
        hashCode(): number;
        notifyAll(): void;
        equals(arg0: any): boolean;
        toString(): string;
        notify(): void;
        static readonly DEFAULT : Internal.WriteBufferWaterMark;
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    type WriteBufferWaterMark_ = WriteBufferWaterMark;
    interface EventListener {
    }
    type EventListener_ = EventListener;
    interface Char2DoubleFunction extends Internal.Function<string, number>, Internal.IntToDoubleFunction {
        getOrDefault(arg0: any, arg1: number): number;
        getOrDefault(arg0: string, arg1: number): number;
        applyAsDouble(arg0: number): number;
        andThenShort(arg0: Internal.Double2ShortFunction_): Internal.Char2ShortFunction;
        composeByte(arg0: Internal.Byte2CharFunction_): Internal.Byte2DoubleFunction;
        andThenInt(arg0: Internal.Double2IntFunction_): Internal.Char2IntFunction;
        composeReference<T_>(arg0: Internal.Reference2CharFunction_<T_>): Internal.Reference2DoubleFunction<T_>;
        andThen<T_>(arg0: java_.util.function_.Function_<number, T_>): java_.util.function_.Function<string, T_>;
        put(arg0: string, arg1: number): number;
        remove(arg0: string): number;
        remove(arg0: any): number;
        defaultReturnValue(): number;
        defaultReturnValue(arg0: number): void;
        andThenDouble(arg0: Internal.Double2DoubleFunction_): Internal.Char2DoubleFunction;
        andThenObject<T_>(arg0: Internal.Double2ObjectFunction_<T_>): Internal.Char2ObjectFunction<T_>;
        get(arg0: any): number;
        get(arg0: string): number;
        andThenLong(arg0: Internal.Double2LongFunction_): Internal.Char2LongFunction;
        composeLong(arg0: Internal.Long2CharFunction_): Internal.Long2DoubleFunction;
        andThenByte(arg0: Internal.Double2ByteFunction_): Internal.Char2ByteFunction;
        andThenFloat(arg0: Internal.Double2FloatFunction_): Internal.Char2FloatFunction;
        apply(arg0: string): number;
        containsKey(arg0: any): boolean;
        containsKey(arg0: string): boolean;
        composeInt(arg0: Internal.Int2CharFunction_): Internal.Int2DoubleFunction;
        clear(): void;
        composeFloat(arg0: Internal.Float2CharFunction_): Internal.Float2DoubleFunction;
        andThenChar(arg0: Internal.Double2CharFunction_): Internal.Char2CharFunction;
        composeObject<T_>(arg0: Internal.Object2CharFunction_<T_>): Internal.Object2DoubleFunction<T_>;
        size(): number;
        compose<T_>(arg0: java_.util.function_.Function_<T_, string>): java_.util.function_.Function<T_, number>;
        composeShort(arg0: Internal.Short2CharFunction_): Internal.Short2DoubleFunction;
        andThenReference<T_>(arg0: Internal.Double2ReferenceFunction_<T_>): Internal.Char2ReferenceFunction<T_>;
        composeChar(arg0: Internal.Char2CharFunction_): Internal.Char2DoubleFunction;
        composeDouble(arg0: Internal.Double2CharFunction_): Internal.Double2DoubleFunction;
    }
    type Char2DoubleFunction_ = ((arg0: string) => number) | Char2DoubleFunction;
    interface StackedContentsCompatible {
    }
    type StackedContentsCompatible_ = StackedContentsCompatible;
    class Biome$Precipitation extends Internal.Enum<Internal.Biome$Precipitation> implements Internal.StringRepresentable {
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        static valueOf(arg0: string): Internal.Biome$Precipitation;
        static valueOf<T_>(arg0: Internal.Class_<T_>, arg1: string): T_;
        notifyAll(): void;
        static values(): Internal.Biome$Precipitation[];
        compareTo(arg0: Internal.Biome$Precipitation_): number;
        describeConstable(): Internal.Optional<Internal.Enum$EnumDesc<Internal.Biome$Precipitation>>;
        notify(): void;
        getDeclaringClass(): Internal.Class<Internal.Biome$Precipitation>;
        hashCode(): number;
        equals(arg0: any): boolean;
        name(): string;
        toString(): string;
        ordinal(): number;
        static readonly RAIN : Internal.Biome$Precipitation;
        static readonly SNOW : Internal.Biome$Precipitation;
        static readonly NONE : Internal.Biome$Precipitation;
        get class(): Internal.Class<any>;
        get declaringClass(): Internal.Class<Internal.Biome$Precipitation>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    type Biome$Precipitation_ = "rain" | "snow" | "none" | Biome$Precipitation;
    abstract class BuilderBase <T> implements Internal.Supplier<T> {
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        clientRegistry(minecraft: Internal.Minecraft_): void;
        generateAssetJsons(generator: Internal.AssetJsonGenerator_): void;
        transformObject(obj: T): T;
        translationKey(key: string): Internal.BuilderBase<T>;
        getTranslationKeyGroup(): string;
        newID(pre: string, post: string): ResourceLocation;
        displayName(name: string): Internal.BuilderBase<T>;
        notifyAll(): void;
        generateLang(lang: Internal.Map_<string, string>): void;
        type(type: string): Internal.BuilderBase<T>;
        notify(): void;
        createAdditionalObjects(): void;
        createObject(): T;
        addResourcePackLocations(path: string, list: Internal.List_<ResourceLocation_>, packType: Internal.PackType_): void;
        hashCode(): number;
        equals(arg0: any): boolean;
        getRegistryType(): Internal.RegistryObjectBuilderTypes<T>;
        get(): T;
        toString(): string;
        tag(tag: ResourceLocation_): Internal.BuilderBase<T>;
        generateDataJsons(generator: Internal.DataJsonGenerator_): void;
        readonly id : ResourceLocation;
        get registryType(): Internal.RegistryObjectBuilderTypes<T>;
        get class(): Internal.Class<any>;
        get translationKeyGroup(): string;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    type BuilderBase_<T> = BuilderBase<T>;
    class ChronoUnit extends Internal.Enum<Internal.ChronoUnit> implements Internal.TemporalUnit {
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        static valueOf(arg0: string): Internal.ChronoUnit;
        static valueOf<T_>(arg0: Internal.Class_<T_>, arg1: string): T_;
        notifyAll(): void;
        static values(): Internal.ChronoUnit[];
        compareTo(arg0: Internal.ChronoUnit_): number;
        describeConstable(): Internal.Optional<Internal.Enum$EnumDesc<Internal.ChronoUnit>>;
        notify(): void;
        getDeclaringClass(): Internal.Class<Internal.ChronoUnit>;
        isDurationEstimated(): boolean;
        getDuration(): Internal.Duration;
        hashCode(): number;
        equals(arg0: any): boolean;
        isTimeBased(): boolean;
        name(): string;
        addTo<R_>(arg0: R_, arg1: number): R_;
        toString(): string;
        isDateBased(): boolean;
        between(arg0: Internal.Temporal_, arg1: Internal.Temporal_): number;
        ordinal(): number;
        isSupportedBy(arg0: Internal.Temporal_): boolean;
        static readonly FOREVER : Internal.ChronoUnit;
        static readonly MICROS : Internal.ChronoUnit;
        static readonly SECONDS : Internal.ChronoUnit;
        static readonly DECADES : Internal.ChronoUnit;
        static readonly MILLENNIA : Internal.ChronoUnit;
        static readonly DAYS : Internal.ChronoUnit;
        static readonly MILLIS : Internal.ChronoUnit;
        static readonly HALF_DAYS : Internal.ChronoUnit;
        static readonly MONTHS : Internal.ChronoUnit;
        static readonly YEARS : Internal.ChronoUnit;
        static readonly HOURS : Internal.ChronoUnit;
        static readonly WEEKS : Internal.ChronoUnit;
        static readonly NANOS : Internal.ChronoUnit;
        static readonly CENTURIES : Internal.ChronoUnit;
        static readonly MINUTES : Internal.ChronoUnit;
        static readonly ERAS : Internal.ChronoUnit;
        get duration(): Internal.Duration;
        get durationEstimated(): boolean;
        get timeBased(): boolean;
        get dateBased(): boolean;
        get class(): Internal.Class<any>;
        get declaringClass(): Internal.Class<Internal.ChronoUnit>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    type ChronoUnit_ = "centuries" | "hours" | "weeks" | "months" | "nanos" | "minutes" | "millennia" | "years" | "eras" | "seconds" | "micros" | "days" | "decades" | "half_days" | "millis" | "forever" | ChronoUnit;
    /**
    * Fired when you need to modify properties of a block.
    */
    class BlockModificationEventJS extends Internal.EventJS {
        cancel(): void;
        getClass(): Internal.Class<any>;
        modify(predicate: BlockStatePredicate_, c: Internal.Consumer_<Internal.BlockModificationProperties_>): void;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        isCancelled(): boolean;
        post(t: Internal.ScriptType_, id: string, sub: string): boolean;
        post(t: Internal.ScriptType_, id: string): boolean;
        hashCode(): number;
        notifyAll(): void;
        equals(arg0: any): boolean;
        toString(): string;
        notify(): void;
        canCancel(): boolean;
        get cancelled(): boolean;
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    /**
    * Fired when you need to modify properties of a block.
    */
    type BlockModificationEventJS_ = BlockModificationEventJS;
    /**
    */
    class ItemStack extends Internal.CapabilityProvider<Internal.ItemStack> implements Internal.IForgeItemStack, Internal.ItemFiltersStack, Internal.ItemStackKJS {
        getClass(): Internal.Class<any>;
        canElytraFly(arg0: Internal.LivingEntity_): boolean;
        getCapability<T_>(arg0: Internal.Capability_<T_>, arg1: Internal.Direction_): Internal.LazyOptional<T_>;
        getCapability<T_>(arg0: Internal.Capability_<T_>): Internal.LazyOptional<T_>;
        createDataIF(item: Internal.Item_): any;
        canPerformAction(arg0: Internal.ToolAction_): boolean;
        shouldCauseBlockBreakReset(arg0: Internal.ItemStack_): boolean;
        getItemEnchantability(): number;
        serializeNBT(): Internal.CompoundTag;
        invalidateCaps(): void;
        getInventoryFilterData(): Internal.ItemInventory;
        getXpRepairRatio(): number;
        readShareTag(arg0: Internal.CompoundTag_): void;
        onEntityItemUpdate(arg0: Internal.ItemEntity_): boolean;
        isBookEnchantable(arg0: Internal.ItemStack_): boolean;
        canDisableShield(arg0: Internal.ItemStack_, arg1: Internal.LivingEntity_, arg2: Internal.LivingEntity_): boolean;
        areCapsCompatible(arg0: Internal.CapabilityProvider_<Internal.ItemStack_>): boolean;
        areCapsCompatible(arg0: Internal.CapabilityDispatcher_): boolean;
        onUsingTick(arg0: Internal.LivingEntity_, arg1: number): void;
        isPiglinCurrency(): boolean;
        getSweepHitBox(arg0: Internal.Player_, arg1: Internal.Entity_): Internal.AABB;
        reviveCaps(): void;
        isRepairable(): boolean;
        getShareTag(): Internal.CompoundTag;
        getBurnTime(arg0: Internal.RecipeType_<any>): number;
        onDroppedByPlayer(arg0: Internal.Player_): boolean;
        onEntitySwing(arg0: Internal.LivingEntity_): boolean;
        elytraFlightTick(arg0: Internal.LivingEntity_, arg1: number): boolean;
        areShareTagsEqual(arg0: Internal.ItemStack_): boolean;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        canEquip(arg0: EquipmentSlot_, arg1: Internal.Entity_): boolean;
        notifyAll(): void;
        notify(): void;
        getStringValueFilterData(): Internal.StringValueData<any>;
        onBlockStartBreak(arg0: BlockPos_, arg1: Internal.Player_): boolean;
        onHorseArmorTick(arg0: Internal.Level_, arg1: Internal.Mob_): void;
        getEntityLifespan(arg0: Internal.Level_): number;
        hashCode(): number;
        getHighlightTip(arg0: Internal.Component_): Internal.Component;
        canWalkOnPowderedSnow(arg0: Internal.LivingEntity_): boolean;
        removeTagKJS(): void;
        onArmorTick(arg0: Internal.Level_, arg1: Internal.Player_): void;
        hasContainerItem(): boolean;
        getFoodProperties(arg0: Internal.LivingEntity_): Internal.FoodProperties;
        doesSneakBypassUse(arg0: Internal.LevelReader_, arg1: BlockPos_, arg2: Internal.Player_): boolean;
        onItemUseFirst(arg0: Internal.UseOnContext_): Internal.InteractionResult;
        getContainerItem(): Internal.ItemStack;
        deserializeNBT(arg0: Internal.CompoundTag_): void;
        getItemFiltersData(): any;
        asKJS(): any;
        onDestroyed(arg0: Internal.ItemEntity_, arg1: Internal.DamageSource_): void;
        getEquipmentSlot(): EquipmentSlot;
        equals(arg0: any): boolean;
        equals(arg0: Internal.ItemStack_, arg1: boolean): boolean;
        makesPiglinsNeutral(arg0: Internal.LivingEntity_): boolean;
        toString(): string;
        isEnderMask(arg0: Internal.Player_, arg1: Internal.EnderMan_): boolean;
        canApplyAtEnchantingTable(arg0: Internal.Enchantment_): boolean;
        get shareTag(): Internal.CompoundTag;
        get repairable(): boolean;
        get inventoryFilterData(): Internal.ItemInventory;
        get stringValueFilterData(): Internal.StringValueData<any>;
        get itemFiltersData(): any;
        get itemEnchantability(): number;
        get equipmentSlot(): EquipmentSlot;
        get piglinCurrency(): boolean;
        get containerItem(): Internal.ItemStack;
        get class(): Internal.Class<any>;
        get xpRepairRatio(): number;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    /**
    */
    type ItemStack_ = Internal.ItemStackJS_ | ItemStack;
    class JEISubtypesEventJS extends Internal.EventJS {
        cancel(): void;
        useNBTKey(items: Internal.IngredientJS_, key: string): void;
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        isCancelled(): boolean;
        registerInterpreter(id: any, interpreter: Internal.JEISubtypesEventJS$Interpreter_): void;
        notifyAll(): void;
        notify(): void;
        useNBT(items: Internal.IngredientJS_): void;
        post(t: Internal.ScriptType_, id: string, sub: string): boolean;
        post(t: Internal.ScriptType_, id: string): boolean;
        hashCode(): number;
        equals(arg0: any): boolean;
        toString(): string;
        canCancel(): boolean;
        get cancelled(): boolean;
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    type JEISubtypesEventJS_ = JEISubtypesEventJS;
    class SoundRegistryEventJS extends Internal.StartupEventJS {
        cancel(): void;
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        isCancelled(): boolean;
        post(id: string): boolean;
        post(id: string, sub: string): boolean;
        post(t: Internal.ScriptType_, id: string, sub: string): boolean;
        post(t: Internal.ScriptType_, id: string): boolean;
        hashCode(): number;
        notifyAll(): void;
        equals(arg0: any): boolean;
        toString(): string;
        notify(): void;
        canCancel(): boolean;
        register(r: ResourceLocation_): void;
        get cancelled(): boolean;
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    type SoundRegistryEventJS_ = SoundRegistryEventJS;
    interface FloatIterable extends Internal.Iterable<number> {
        iterator(): Internal.FloatIterator;
        spliterator(): Internal.FloatSpliterator;
        forEach(arg0: Internal.FloatConsumer_): void;
        forEach(arg0: Internal.Consumer_<number>): void;
        forEach(arg0: java_.util.function_.DoubleConsumer_): void;
        doubleSpliterator(): Internal.DoubleSpliterator;
        doubleIterator(): Internal.DoubleIterator;
    }
    type FloatIterable_ = FloatIterable;
    class Products$P9 <F, T1, T2, T3, T4, T5, T6, T7, T8, T9> {
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        apply<R>(arg0: Internal.Applicative_<F, any>, arg1: Internal.Function9_<T1, T2, T3, T4, T5, T6, T7, T8, T9, R>): Internal.App<F, R>;
        apply<R>(arg0: Internal.Applicative_<F, any>, arg1: Internal.App_<F, Internal.Function9_<T1, T2, T3, T4, T5, T6, T7, T8, T9, R>>): Internal.App<F, R>;
        hashCode(): number;
        notifyAll(): void;
        equals(arg0: any): boolean;
        toString(): string;
        notify(): void;
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    type Products$P9_<F, T1, T2, T3, T4, T5, T6, T7, T8, T9> = Products$P9<F, T1, T2, T3, T4, T5, T6, T7, T8, T9>;
    class ImmutableList$Builder <E> extends Internal.ImmutableCollection$Builder<E> {
        add(arg0: E): Internal.ImmutableList$Builder<E>;
        add(arg0: E[]): Internal.ImmutableList$Builder<E>;
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        build(): Internal.ImmutableList<E>;
        addAll(arg0: Internal.Iterator_<E>): Internal.ImmutableList$Builder<E>;
        addAll(arg0: Internal.Iterable_<E>): Internal.ImmutableList$Builder<E>;
        hashCode(): number;
        notifyAll(): void;
        equals(arg0: any): boolean;
        toString(): string;
        notify(): void;
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    type ImmutableList$Builder_<E> = ImmutableList$Builder<E>;
    interface Reference2ObjectFunction <K, V> extends Internal.Function<K, V> {
        getOrDefault(arg0: any, arg1: V): V;
        andThenShort(arg0: Internal.Object2ShortFunction_<V>): Internal.Reference2ShortFunction<K>;
        composeByte(arg0: Internal.Byte2ReferenceFunction_<K>): Internal.Byte2ObjectFunction<V>;
        andThenInt(arg0: Internal.Object2IntFunction_<V>): Internal.Reference2IntFunction<K>;
        andThen<V_>(arg0: java_.util.function_.Function_<V, V_>): java_.util.function_.Function<K, V_>;
        composeReference<T_>(arg0: Internal.Reference2ReferenceFunction_<T_, K>): Internal.Reference2ObjectFunction<T_, V>;
        put(arg0: K, arg1: V): V;
        remove(arg0: any): V;
        defaultReturnValue(arg0: V): void;
        defaultReturnValue(): V;
        andThenDouble(arg0: Internal.Object2DoubleFunction_<V>): Internal.Reference2DoubleFunction<K>;
        andThenObject<T_>(arg0: Internal.Object2ObjectFunction_<V, T_>): Internal.Reference2ObjectFunction<K, T_>;
        get(arg0: any): V;
        andThenLong(arg0: Internal.Object2LongFunction_<V>): Internal.Reference2LongFunction<K>;
        composeLong(arg0: Internal.Long2ReferenceFunction_<K>): Internal.Long2ObjectFunction<V>;
        andThenByte(arg0: Internal.Object2ByteFunction_<V>): Internal.Reference2ByteFunction<K>;
        andThenFloat(arg0: Internal.Object2FloatFunction_<V>): Internal.Reference2FloatFunction<K>;
        apply(arg0: K): V;
        containsKey(arg0: any): boolean;
        composeInt(arg0: Internal.Int2ReferenceFunction_<K>): Internal.Int2ObjectFunction<V>;
        clear(): void;
        composeFloat(arg0: Internal.Float2ReferenceFunction_<K>): Internal.Float2ObjectFunction<V>;
        andThenChar(arg0: Internal.Object2CharFunction_<V>): Internal.Reference2CharFunction<K>;
        composeObject<T_>(arg0: Internal.Object2ReferenceFunction_<T_, K>): Internal.Object2ObjectFunction<T_, V>;
        size(): number;
        compose<V_>(arg0: java_.util.function_.Function_<V_, K>): java_.util.function_.Function<V_, V>;
        composeShort(arg0: Internal.Short2ReferenceFunction_<K>): Internal.Short2ObjectFunction<V>;
        andThenReference<T_>(arg0: Internal.Object2ReferenceFunction_<V, T_>): Internal.Reference2ReferenceFunction<K, T_>;
        composeChar(arg0: Internal.Char2ReferenceFunction_<K>): Internal.Char2ObjectFunction<V>;
        composeDouble(arg0: Internal.Double2ReferenceFunction_<K>): Internal.Double2ObjectFunction<V>;
    }
    type Reference2ObjectFunction_<K, V> = ((arg0: any) => V) | Reference2ObjectFunction<K, V>;
    class PartAddedEvent extends Internal.EventJS {
        cancel(): void;
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        isCancelled(): boolean;
        post(t: Internal.ScriptType_, id: string, sub: string): boolean;
        post(t: Internal.ScriptType_, id: string): boolean;
        hashCode(): number;
        notifyAll(): void;
        equals(arg0: any): boolean;
        toString(): string;
        getController(): Internal.ControllerTileEntity;
        notify(): void;
        canCancel(): boolean;
        static readonly ID : "mbd.part_added";
        get controller(): Internal.ControllerTileEntity;
        get cancelled(): boolean;
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    type PartAddedEvent_ = PartAddedEvent;
    class WeightedEntry$IntrusiveBase implements Internal.WeightedEntry {
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        hashCode(): number;
        notifyAll(): void;
        equals(arg0: any): boolean;
        toString(): string;
        notify(): void;
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    type WeightedEntry$IntrusiveBase_ = WeightedEntry$IntrusiveBase;
    interface Config$Entry extends Internal.UnmodifiableConfig$Entry {
        getShortOrElse(arg0: number): number;
        getKey(): string;
        getByte(): number;
        getShort(): number;
        getOptionalInt(): Internal.OptionalInt;
        getRawValue<T_>(): T_;
        getCharOrElse(arg0: string): string;
        getLongOrElse(arg0: number): number;
        getByteOrElse(arg0: number): number;
        getLong(): number;
        getValue<T_>(): T_;
        getInt(): number;
        getChar(): string;
        getOptional<T_>(): Internal.Optional<T_>;
        isNull(): boolean;
        setValue<T_>(arg0: any): T_;
        getOrElse<T_>(arg0: T_): T_;
        getIntOrElse(arg0: number): number;
        getOptionalLong(): Internal.OptionalLong;
    }
    type Config$Entry_ = Config$Entry;
    interface NamespaceResourceManagerAccessor {
        repurposedstructures_callGetWrappedResource(arg0: ResourceLocation_, arg1: Internal.PackResources_): Internal.InputStream;
        repurposedstructures_getFallbacks(): Internal.List<Internal.PackResources>;
    }
    type NamespaceResourceManagerAccessor_ = NamespaceResourceManagerAccessor;
    class InterfaceAddress {
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        getBroadcast(): Internal.InetAddress;
        hashCode(): number;
        notifyAll(): void;
        equals(arg0: any): boolean;
        getNetworkPrefixLength(): number;
        getAddress(): Internal.InetAddress;
        toString(): string;
        notify(): void;
        get broadcast(): Internal.InetAddress;
        get address(): Internal.InetAddress;
        get class(): Internal.Class<any>;
        get networkPrefixLength(): number;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    type InterfaceAddress_ = InterfaceAddress;
    interface PublicKey extends Internal.Key {
        getEncoded(): number[];
        getAlgorithm(): string;
        getFormat(): string;
    }
    type PublicKey_ = PublicKey;
    class LiteralCommandNode <S> extends Internal.CommandNode<S> {
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        getName(): string;
        getRedirect(): Internal.CommandNode<S>;
        isValidInput(arg0: string): boolean;
        notifyAll(): void;
        compareTo(arg0: Internal.CommandNode_<S>): number;
        notify(): void;
        findAmbiguities(arg0: Internal.AmbiguityConsumer_<S>): void;
        listSuggestions(arg0: Internal.CommandContext_<S>, arg1: Internal.SuggestionsBuilder_): Internal.CompletableFuture<Internal.Suggestions>;
        createBuilder(): Internal.LiteralArgumentBuilder<S>;
        getLiteral(): string;
        hashCode(): number;
        getRedirectModifier(): Internal.RedirectModifier<S>;
        getRelevantNodes(arg0: Internal.StringReader_): Internal.Collection<Internal.CommandNode<S>>;
        getCommand(): Internal.Command<S>;
        getChild(arg0: string): Internal.CommandNode<S>;
        getExamples(): Internal.Collection<string>;
        getUsageText(): string;
        parse(arg0: Internal.StringReader_, arg1: Internal.CommandContextBuilder_<S>): void;
        isFork(): boolean;
        canUse(arg0: S): boolean;
        getChildren(): Internal.Collection<Internal.CommandNode<S>>;
        getRequirement(): Internal.Predicate<S>;
        equals(arg0: any): boolean;
        toString(): string;
        addChild(arg0: Internal.CommandNode_<S>): void;
        get redirect(): Internal.CommandNode<S>;
        get fork(): boolean;
        get examples(): Internal.Collection<string>;
        get children(): Internal.Collection<Internal.CommandNode<S>>;
        get name(): string;
        get usageText(): string;
        get requirement(): Internal.Predicate<S>;
        get redirectModifier(): Internal.RedirectModifier<S>;
        get class(): Internal.Class<any>;
        get command(): Internal.Command<S>;
        get literal(): string;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    type LiteralCommandNode_<S> = LiteralCommandNode<S>;
    class CommandContext <S> {
        getClass(): Internal.Class<any>;
        getRedirectModifier(): Internal.RedirectModifier<S>;
        copyFor(arg0: S): Internal.CommandContext<S>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        getNodes(): Internal.List<Internal.ParsedCommandNode<S>>;
        hasNodes(): boolean;
        getCommand(): Internal.Command<S>;
        notifyAll(): void;
        isForked(): boolean;
        getChild(): Internal.CommandContext<S>;
        getArgument<V>(arg0: string, arg1: Internal.Class_<V>): V;
        getInput(): string;
        notify(): void;
        getLastChild(): Internal.CommandContext<S>;
        getRange(): Internal.StringRange;
        getSource(): S;
        hashCode(): number;
        equals(arg0: any): boolean;
        toString(): string;
        getRootNode(): Internal.CommandNode<S>;
        get input(): string;
        get nodes(): Internal.List<Internal.ParsedCommandNode<S>>;
        get lastChild(): Internal.CommandContext<S>;
        get range(): Internal.StringRange;
        get source(): S;
        get redirectModifier(): Internal.RedirectModifier<S>;
        get class(): Internal.Class<any>;
        get command(): Internal.Command<S>;
        get forked(): boolean;
        get child(): Internal.CommandContext<S>;
        get rootNode(): Internal.CommandNode<S>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    type CommandContext_<S> = CommandContext<S>;
    /**
    */
    interface RecipeFilter extends Internal.Predicate<Internal.RecipeJS> {
        or(arg0: Internal.Predicate_<Internal.RecipeJS_>): Internal.Predicate<Internal.RecipeJS>;
        test(arg0: Internal.RecipeJS_): boolean;
        and(arg0: Internal.Predicate_<Internal.RecipeJS_>): Internal.Predicate<Internal.RecipeJS>;
        negate(): Internal.Predicate<Internal.RecipeJS>;
    }
    /**
    */
    type RecipeFilter_ = Internal.RecipeFilter_[] | {exact?: boolean, not?: Internal.RecipeFilter_, or?: Internal.RecipeFilter_[], id?: string | `/${string}/`, type?: string, group?: string, mod?: string, input?: Internal.IngredientJS_, output?: Internal.IngredientJS_} | ((arg0: Internal.RecipeJS) => boolean) | RecipeFilter;
    interface BiomeSeedProvider {
        getBiomeSeed(): number;
    }
    type BiomeSeedProvider_ = BiomeSeedProvider;
    interface Externalizable extends Internal.Serializable {
        writeExternal(arg0: Internal.ObjectOutput_): void;
        readExternal(arg0: Internal.ObjectInput_): void;
    }
    type Externalizable_ = Externalizable;
    interface DoubleStream$DoubleMapMultiConsumer {
        accept(arg0: number, arg1: java_.util.function_.DoubleConsumer_): void;
    }
    type DoubleStream$DoubleMapMultiConsumer_ = ((arg0: number, arg1: java_.util.function_.DoubleConsumer) => void) | DoubleStream$DoubleMapMultiConsumer;
    interface ValueUnwrapper {
        unwrap(arg0: Internal.Scriptable_, arg1: any): any;
    }
    type ValueUnwrapper_ = ((arg0: Internal.Scriptable, arg1: any) => any) | ValueUnwrapper;
    class PatternMatchContext {
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        getOrDefault<T>(arg0: string, arg1: T): T;
        set(arg0: string, arg1: any): void;
        containsKey(arg0: string): boolean;
        notifyAll(): void;
        increment(arg0: string, arg1: number): void;
        notify(): void;
        getInt(arg0: string): number;
        hashCode(): number;
        equals(arg0: any): boolean;
        get<T>(arg0: string): T;
        getOrPut<T>(arg0: string, arg1: T): T;
        getOrCreate<T>(arg0: string, arg1: Internal.Supplier_<T>): T;
        reset(): void;
        toString(): string;
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    type PatternMatchContext_ = PatternMatchContext;
    class RegistryEntry <T> implements Internal.IForgeRegistryEntry<any> {
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        hashCode(): number;
        notifyAll(): void;
        equals(arg0: any): boolean;
        getRegistryType(): Internal.Class<T>;
        getRegistryName(): ResourceLocation;
        toString(): string;
        setRegistryName(name: ResourceLocation_): T;
        notify(): void;
        get registryType(): Internal.Class<T>;
        get registryName(): ResourceLocation;
        get class(): Internal.Class<any>;
        set registryName(name: ResourceLocation_);
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    type RegistryEntry_<T> = RegistryEntry<T>;
    interface Reference2ReferenceFunction <K, V> extends Internal.Function<K, V> {
        getOrDefault(arg0: any, arg1: V): V;
        andThenShort(arg0: Internal.Reference2ShortFunction_<V>): Internal.Reference2ShortFunction<K>;
        composeByte(arg0: Internal.Byte2ReferenceFunction_<K>): Internal.Byte2ReferenceFunction<V>;
        andThenInt(arg0: Internal.Reference2IntFunction_<V>): Internal.Reference2IntFunction<K>;
        andThen<V_>(arg0: java_.util.function_.Function_<V, V_>): java_.util.function_.Function<K, V_>;
        composeReference<T_>(arg0: Internal.Reference2ReferenceFunction_<T_, K>): Internal.Reference2ReferenceFunction<T_, V>;
        put(arg0: K, arg1: V): V;
        remove(arg0: any): V;
        defaultReturnValue(arg0: V): void;
        defaultReturnValue(): V;
        andThenDouble(arg0: Internal.Reference2DoubleFunction_<V>): Internal.Reference2DoubleFunction<K>;
        andThenObject<T_>(arg0: Internal.Reference2ObjectFunction_<V, T_>): Internal.Reference2ObjectFunction<K, T_>;
        get(arg0: any): V;
        andThenLong(arg0: Internal.Reference2LongFunction_<V>): Internal.Reference2LongFunction<K>;
        composeLong(arg0: Internal.Long2ReferenceFunction_<K>): Internal.Long2ReferenceFunction<V>;
        andThenByte(arg0: Internal.Reference2ByteFunction_<V>): Internal.Reference2ByteFunction<K>;
        andThenFloat(arg0: Internal.Reference2FloatFunction_<V>): Internal.Reference2FloatFunction<K>;
        apply(arg0: K): V;
        containsKey(arg0: any): boolean;
        composeInt(arg0: Internal.Int2ReferenceFunction_<K>): Internal.Int2ReferenceFunction<V>;
        clear(): void;
        composeFloat(arg0: Internal.Float2ReferenceFunction_<K>): Internal.Float2ReferenceFunction<V>;
        andThenChar(arg0: Internal.Reference2CharFunction_<V>): Internal.Reference2CharFunction<K>;
        composeObject<T_>(arg0: Internal.Object2ReferenceFunction_<T_, K>): Internal.Object2ReferenceFunction<T_, V>;
        size(): number;
        compose<V_>(arg0: java_.util.function_.Function_<V_, K>): java_.util.function_.Function<V_, V>;
        composeShort(arg0: Internal.Short2ReferenceFunction_<K>): Internal.Short2ReferenceFunction<V>;
        andThenReference<T_>(arg0: Internal.Reference2ReferenceFunction_<V, T_>): Internal.Reference2ReferenceFunction<K, T_>;
        composeChar(arg0: Internal.Char2ReferenceFunction_<K>): Internal.Char2ReferenceFunction<V>;
        composeDouble(arg0: Internal.Double2ReferenceFunction_<K>): Internal.Double2ReferenceFunction<V>;
    }
    type Reference2ReferenceFunction_<K, V> = ((arg0: any) => V) | Reference2ReferenceFunction<K, V>;
    interface MouseMotionListener extends Internal.EventListener {
        mouseDragged(arg0: Internal.MouseEvent_): void;
        mouseMoved(arg0: Internal.MouseEvent_): void;
    }
    type MouseMotionListener_ = MouseMotionListener;
    class WrappedGoal extends Internal.Goal {
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        hashCode(): number;
        notifyAll(): void;
        equals(arg0: any): boolean;
        toString(): string;
        notify(): void;
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    type WrappedGoal_ = WrappedGoal;
    class TeamPropertyValue <T> {
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        hashCode(): number;
        notifyAll(): void;
        equals(arg0: any): boolean;
        toString(): string;
        copy(): Internal.TeamPropertyValue<T>;
        notify(): void;
        value : T;
        readonly key : Internal.TeamProperty<T>;
        consumer : ((arg0: T) => void);
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    type TeamPropertyValue_<T> = TeamPropertyValue<T>;
    interface Float2DoubleFunction extends Internal.Function<number, number>, Internal.DoubleUnaryOperator {
        getOrDefault(arg0: any, arg1: number): number;
        getOrDefault(arg0: number, arg1: number): number;
        applyAsDouble(arg0: number): number;
        andThenShort(arg0: Internal.Double2ShortFunction_): Internal.Float2ShortFunction;
        composeByte(arg0: Internal.Byte2FloatFunction_): Internal.Byte2DoubleFunction;
        andThenInt(arg0: Internal.Double2IntFunction_): Internal.Float2IntFunction;
        composeReference<T_>(arg0: Internal.Reference2FloatFunction_<T_>): Internal.Reference2DoubleFunction<T_>;
        andThen<T_>(arg0: java_.util.function_.Function_<number, T_>): java_.util.function_.Function<number, T_>;
        andThen(arg0: Internal.DoubleUnaryOperator_): Internal.DoubleUnaryOperator;
        put(arg0: number, arg1: number): number;
        remove(arg0: number): number;
        remove(arg0: any): number;
        defaultReturnValue(): number;
        defaultReturnValue(arg0: number): void;
        andThenDouble(arg0: Internal.Double2DoubleFunction_): Internal.Float2DoubleFunction;
        andThenObject<T_>(arg0: Internal.Double2ObjectFunction_<T_>): Internal.Float2ObjectFunction<T_>;
        get(arg0: any): number;
        get(arg0: number): number;
        andThenLong(arg0: Internal.Double2LongFunction_): Internal.Float2LongFunction;
        composeLong(arg0: Internal.Long2FloatFunction_): Internal.Long2DoubleFunction;
        andThenByte(arg0: Internal.Double2ByteFunction_): Internal.Float2ByteFunction;
        andThenFloat(arg0: Internal.Double2FloatFunction_): Internal.Float2FloatFunction;
        apply(arg0: number): number;
        containsKey(arg0: any): boolean;
        containsKey(arg0: number): boolean;
        composeInt(arg0: Internal.Int2FloatFunction_): Internal.Int2DoubleFunction;
        clear(): void;
        composeFloat(arg0: Internal.Float2FloatFunction_): Internal.Float2DoubleFunction;
        andThenChar(arg0: Internal.Double2CharFunction_): Internal.Float2CharFunction;
        composeObject<T_>(arg0: Internal.Object2FloatFunction_<T_>): Internal.Object2DoubleFunction<T_>;
        size(): number;
        compose<T_>(arg0: java_.util.function_.Function_<T_, number>): java_.util.function_.Function<T_, number>;
        compose(arg0: Internal.DoubleUnaryOperator_): Internal.DoubleUnaryOperator;
        composeShort(arg0: Internal.Short2FloatFunction_): Internal.Short2DoubleFunction;
        andThenReference<T_>(arg0: Internal.Double2ReferenceFunction_<T_>): Internal.Float2ReferenceFunction<T_>;
        composeChar(arg0: Internal.Char2FloatFunction_): Internal.Char2DoubleFunction;
        composeDouble(arg0: Internal.Double2FloatFunction_): Internal.Double2DoubleFunction;
    }
    type Float2DoubleFunction_ = ((arg0: number) => number) | Float2DoubleFunction;
    interface CustomEntityRenderData {
        setDimension(arg0: Internal.EntityDimensions_): void;
        getVisualScale(): number;
        setVisualScale(arg0: number): void;
    }
    type CustomEntityRenderData_ = CustomEntityRenderData;
    interface RecvByteBufAllocator$Handle {
        continueReading(): boolean;
        incMessagesRead(arg0: number): void;
        allocate(arg0: Internal.ByteBufAllocator_): Internal.ByteBuf;
        guess(): number;
        reset(arg0: Internal.ChannelConfig_): void;
        readComplete(): void;
        attemptedBytesRead(): number;
        attemptedBytesRead(arg0: number): void;
        lastBytesRead(): number;
        lastBytesRead(arg0: number): void;
    }
    type RecvByteBufAllocator$Handle_ = RecvByteBufAllocator$Handle;
    abstract class ChunkAccess implements Internal.BlockGetter, Internal.BiomeManager$NoiseBiomeSource, Internal.FeatureAccess, Internal.IChunkTimeSave, Internal.ChunkAccessAccess, Internal.ChunkRandom {
        getClass(): Internal.Class<any>;
        getNextSaveTime(): number;
        getWorldForge(): Internal.LevelAccessor;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        localvar$zek000$modifyHeightmapType(arg0: Internal.Heightmap$Types_): Internal.Heightmap$Types;
        getRandom(arg0: number): Internal.Random;
        setSaveTimePoint(arg0: number): void;
        hashCode(): number;
        notifyAll(): void;
        equals(arg0: any): boolean;
        getExistingBlockEntity(arg0: BlockPos_): Internal.BlockEntity;
        toString(): string;
        notify(): void;
        get nextSaveTime(): number;
        get worldForge(): Internal.LevelAccessor;
        get class(): Internal.Class<any>;
        set saveTimePoint(arg0: number);
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    type ChunkAccess_ = ChunkAccess;
    interface Float2LongFunction extends Internal.Function<number, number>, Internal.DoubleToLongFunction {
        getOrDefault(arg0: any, arg1: number): number;
        getOrDefault(arg0: number, arg1: number): number;
        andThenShort(arg0: Internal.Long2ShortFunction_): Internal.Float2ShortFunction;
        composeByte(arg0: Internal.Byte2FloatFunction_): Internal.Byte2LongFunction;
        andThenInt(arg0: Internal.Long2IntFunction_): Internal.Float2IntFunction;
        composeReference<T_>(arg0: Internal.Reference2FloatFunction_<T_>): Internal.Reference2LongFunction<T_>;
        andThen<T_>(arg0: java_.util.function_.Function_<number, T_>): java_.util.function_.Function<number, T_>;
        put(arg0: number, arg1: number): number;
        remove(arg0: number): number;
        remove(arg0: any): number;
        defaultReturnValue(): number;
        defaultReturnValue(arg0: number): void;
        andThenDouble(arg0: Internal.Long2DoubleFunction_): Internal.Float2DoubleFunction;
        andThenObject<T_>(arg0: Internal.Long2ObjectFunction_<T_>): Internal.Float2ObjectFunction<T_>;
        get(arg0: any): number;
        get(arg0: number): number;
        andThenLong(arg0: Internal.Long2LongFunction_): Internal.Float2LongFunction;
        composeLong(arg0: Internal.Long2FloatFunction_): Internal.Long2LongFunction;
        andThenByte(arg0: Internal.Long2ByteFunction_): Internal.Float2ByteFunction;
        andThenFloat(arg0: Internal.Long2FloatFunction_): Internal.Float2FloatFunction;
        apply(arg0: number): number;
        containsKey(arg0: any): boolean;
        containsKey(arg0: number): boolean;
        composeInt(arg0: Internal.Int2FloatFunction_): Internal.Int2LongFunction;
        clear(): void;
        composeFloat(arg0: Internal.Float2FloatFunction_): Internal.Float2LongFunction;
        andThenChar(arg0: Internal.Long2CharFunction_): Internal.Float2CharFunction;
        applyAsLong(arg0: number): number;
        composeObject<T_>(arg0: Internal.Object2FloatFunction_<T_>): Internal.Object2LongFunction<T_>;
        size(): number;
        compose<T_>(arg0: java_.util.function_.Function_<T_, number>): java_.util.function_.Function<T_, number>;
        composeShort(arg0: Internal.Short2FloatFunction_): Internal.Short2LongFunction;
        andThenReference<T_>(arg0: Internal.Long2ReferenceFunction_<T_>): Internal.Float2ReferenceFunction<T_>;
        composeChar(arg0: Internal.Char2FloatFunction_): Internal.Char2LongFunction;
        composeDouble(arg0: Internal.Double2FloatFunction_): Internal.Double2LongFunction;
    }
    type Float2LongFunction_ = ((arg0: number) => number) | Float2LongFunction;
    interface Readable {
        read(arg0: Internal.CharBuffer_): number;
    }
    type Readable_ = Readable;
    class TraceabilityPredicate {
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        or(arg0: Internal.TraceabilityPredicate_): Internal.TraceabilityPredicate;
        test(arg0: Internal.MultiblockState_): boolean;
        notifyAll(): void;
        setSlotName(arg0: string): Internal.TraceabilityPredicate;
        disableRenderFormed(): Internal.TraceabilityPredicate;
        setMinGlobalLimited(arg0: number, arg1: number): Internal.TraceabilityPredicate;
        setMinGlobalLimited(arg0: number): Internal.TraceabilityPredicate;
        setCenter(): Internal.TraceabilityPredicate;
        addTooltips(arg0: string[]): Internal.TraceabilityPredicate;
        setMaxGlobalLimited(arg0: number): Internal.TraceabilityPredicate;
        setMaxGlobalLimited(arg0: number, arg1: number): Internal.TraceabilityPredicate;
        sort(): Internal.TraceabilityPredicate;
        setIO(arg0: Internal.IO_): Internal.TraceabilityPredicate;
        notify(): void;
        setNBTParser(arg0: string): Internal.TraceabilityPredicate;
        hasAir(): boolean;
        hashCode(): number;
        equals(arg0: any): boolean;
        isSingle(): boolean;
        toString(): string;
        isAir(): boolean;
        setExactLimit(arg0: number): Internal.TraceabilityPredicate;
        isAny(): boolean;
        setPreviewCount(arg0: number): Internal.TraceabilityPredicate;
        isCenter : boolean;
        common : Internal.List<Internal.SimplePredicate>;
        limited : Internal.List<Internal.SimplePredicate>;
        get single(): boolean;
        get air(): boolean;
        get class(): Internal.Class<any>;
        get any(): boolean;
        set slotName(arg0: string);
        set iO(arg0: Internal.IO_);
        set exactLimit(arg0: number);
        set maxGlobalLimited(arg0: number);
        set previewCount(arg0: number);
        set nBTParser(arg0: string);
        set minGlobalLimited(arg0: number);
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    type TraceabilityPredicate_ = TraceabilityPredicate;
    interface TypeDescriptor$OfMethod <F, M> extends Internal.TypeDescriptor {
        parameterType(arg0: number): F;
        parameterArray(): F[];
        dropParameterTypes(arg0: number, arg1: number): M;
        parameterCount(): number;
        changeReturnType(arg0: F): M;
        descriptorString(): string;
        parameterList(): Internal.List<F>;
        insertParameterTypes(arg0: number, arg1: F[]): M;
        returnType(): F;
        changeParameterType(arg0: number, arg1: F): M;
    }
    type TypeDescriptor$OfMethod_<F, M> = TypeDescriptor$OfMethod<F, M>;
    interface Boolean2ObjectFunction <V> extends Internal.Function<boolean, V> {
        getOrDefault(arg0: any, arg1: V): V;
        getOrDefault(arg0: boolean, arg1: V): V;
        andThenShort(arg0: Internal.Object2ShortFunction_<V>): Internal.Boolean2ShortFunction;
        composeByte(arg0: Internal.Byte2BooleanFunction_): Internal.Byte2ObjectFunction<V>;
        andThenInt(arg0: Internal.Object2IntFunction_<V>): Internal.Boolean2IntFunction;
        andThen<V_>(arg0: java_.util.function_.Function_<V, V_>): java_.util.function_.Function<boolean, V_>;
        composeReference<T_>(arg0: Internal.Reference2BooleanFunction_<T_>): Internal.Reference2ObjectFunction<T_, V>;
        put(arg0: boolean, arg1: V): V;
        remove(arg0: any): V;
        remove(arg0: boolean): V;
        defaultReturnValue(): V;
        defaultReturnValue(arg0: V): void;
        andThenDouble(arg0: Internal.Object2DoubleFunction_<V>): Internal.Boolean2DoubleFunction;
        andThenObject<T_>(arg0: Internal.Object2ObjectFunction_<V, T_>): Internal.Boolean2ObjectFunction<T_>;
        get(arg0: any): V;
        get(arg0: boolean): V;
        andThenLong(arg0: Internal.Object2LongFunction_<V>): Internal.Boolean2LongFunction;
        composeLong(arg0: Internal.Long2BooleanFunction_): Internal.Long2ObjectFunction<V>;
        andThenByte(arg0: Internal.Object2ByteFunction_<V>): Internal.Boolean2ByteFunction;
        andThenFloat(arg0: Internal.Object2FloatFunction_<V>): Internal.Boolean2FloatFunction;
        apply(arg0: boolean): V;
        containsKey(arg0: boolean): boolean;
        containsKey(arg0: any): boolean;
        composeInt(arg0: Internal.Int2BooleanFunction_): Internal.Int2ObjectFunction<V>;
        clear(): void;
        composeFloat(arg0: Internal.Float2BooleanFunction_): Internal.Float2ObjectFunction<V>;
        andThenChar(arg0: Internal.Object2CharFunction_<V>): Internal.Boolean2CharFunction;
        composeObject<T_>(arg0: Internal.Object2BooleanFunction_<T_>): Internal.Object2ObjectFunction<T_, V>;
        size(): number;
        compose<T_>(arg0: java_.util.function_.Function_<T_, boolean>): java_.util.function_.Function<T_, V>;
        composeShort(arg0: Internal.Short2BooleanFunction_): Internal.Short2ObjectFunction<V>;
        andThenReference<T_>(arg0: Internal.Object2ReferenceFunction_<V, T_>): Internal.Boolean2ReferenceFunction<T_>;
        composeChar(arg0: Internal.Char2BooleanFunction_): Internal.Char2ObjectFunction<V>;
        composeDouble(arg0: Internal.Double2BooleanFunction_): Internal.Double2ObjectFunction<V>;
    }
    type Boolean2ObjectFunction_<V> = ((arg0: boolean) => V) | Boolean2ObjectFunction<V>;
    interface TemporalQuery <R> {
        queryFrom(arg0: Internal.TemporalAccessor_): R;
    }
    type TemporalQuery_<R> = ((arg0: Internal.TemporalAccessor) => R) | TemporalQuery<R>;
    interface TemporalAccessor {
        getLong(arg0: Internal.TemporalField_): number;
        query<R>(arg0: Internal.TemporalQuery_<R>): R;
        get(arg0: Internal.TemporalField_): number;
        range(arg0: Internal.TemporalField_): Internal.ValueRange;
        isSupported(arg0: Internal.TemporalField_): boolean;
    }
    type TemporalAccessor_ = TemporalAccessor;
    interface EventExecutorGroup extends Internal.ScheduledExecutorService, Internal.Iterable<Internal.EventExecutor> {
        scheduleAtFixedRate(arg0: Internal.Runnable_, arg1: number, arg2: number, arg3: Internal.TimeUnit_): io.netty.util.concurrent.ScheduledFuture<any>;
        scheduleAtFixedRate(arg0: Internal.Runnable_, arg1: number, arg2: number, arg3: Internal.TimeUnit_): Internal.ScheduledFuture<any>;
        next(): Internal.EventExecutor;
        terminationFuture(): io.netty.util.concurrent.Future<any>;
        shutdownGracefully(): io.netty.util.concurrent.Future<any>;
        shutdownGracefully(arg0: number, arg1: number, arg2: Internal.TimeUnit_): io.netty.util.concurrent.Future<any>;
        submit<T_>(arg0: Internal.Runnable_, arg1: T_): io.netty.util.concurrent.Future<T_>;
        submit<T_>(arg0: Internal.Runnable_, arg1: T_): Internal.Future<T_>;
        submit<T_>(arg0: java_.util.concurrent.Callable_<T_>): io.netty.util.concurrent.Future<T_>;
        submit<T_>(arg0: java_.util.concurrent.Callable_<T_>): Internal.Future<T_>;
        submit(arg0: Internal.Runnable_): io.netty.util.concurrent.Future<any>;
        submit(arg0: Internal.Runnable_): Internal.Future<any>;
        spliterator(): Internal.Spliterator<Internal.EventExecutor>;
        isTerminated(): boolean;
        forEach(arg0: Internal.Consumer_<Internal.EventExecutor_>): void;
        scheduleWithFixedDelay(arg0: Internal.Runnable_, arg1: number, arg2: number, arg3: Internal.TimeUnit_): io.netty.util.concurrent.ScheduledFuture<any>;
        scheduleWithFixedDelay(arg0: Internal.Runnable_, arg1: number, arg2: number, arg3: Internal.TimeUnit_): Internal.ScheduledFuture<any>;
        invokeAll<T_>(arg0: Internal.Collection_<java_.util.concurrent.Callable_<T_>>): Internal.List<Internal.Future<T_>>;
        invokeAll<T_>(arg0: Internal.Collection_<java_.util.concurrent.Callable_<T_>>, arg1: number, arg2: Internal.TimeUnit_): Internal.List<Internal.Future<T_>>;
        execute(arg0: Internal.Runnable_): void;
        schedule<V_>(arg0: java_.util.concurrent.Callable_<V_>, arg1: number, arg2: Internal.TimeUnit_): io.netty.util.concurrent.ScheduledFuture<V_>;
        schedule<V_>(arg0: java_.util.concurrent.Callable_<V_>, arg1: number, arg2: Internal.TimeUnit_): Internal.ScheduledFuture<V_>;
        schedule(arg0: Internal.Runnable_, arg1: number, arg2: Internal.TimeUnit_): io.netty.util.concurrent.ScheduledFuture<any>;
        schedule(arg0: Internal.Runnable_, arg1: number, arg2: Internal.TimeUnit_): Internal.ScheduledFuture<any>;
        isShuttingDown(): boolean;
        iterator(): Internal.Iterator<Internal.EventExecutor>;
        awaitTermination(arg0: number, arg1: Internal.TimeUnit_): boolean;
        invokeAny<T_>(arg0: Internal.Collection_<java_.util.concurrent.Callable_<T_>>, arg1: number, arg2: Internal.TimeUnit_): T_;
        invokeAny<T_>(arg0: Internal.Collection_<java_.util.concurrent.Callable_<T_>>): T_;
        shutdownNow(): Internal.List<Internal.Runnable>;
        shutdown(): void;
        isShutdown(): boolean;
    }
    type EventExecutorGroup_ = EventExecutorGroup;
    interface IPlantable {
        getPlantType(arg0: Internal.BlockGetter_, arg1: BlockPos_): Internal.PlantType;
        getPlant(arg0: Internal.BlockGetter_, arg1: BlockPos_): Internal.BlockState;
    }
    type IPlantable_ = IPlantable;
    interface Reference2LongFunction <K> extends Internal.Function<K, number>, Internal.ToLongFunction<K> {
        getOrDefault(arg0: any, arg1: number): number;
        andThenShort(arg0: Internal.Long2ShortFunction_): Internal.Reference2ShortFunction<K>;
        composeByte(arg0: Internal.Byte2ReferenceFunction_<K>): Internal.Byte2LongFunction;
        andThenInt(arg0: Internal.Long2IntFunction_): Internal.Reference2IntFunction<K>;
        composeReference<T_>(arg0: Internal.Reference2ReferenceFunction_<T_, K>): Internal.Reference2LongFunction<T_>;
        andThen<T_>(arg0: java_.util.function_.Function_<number, T_>): java_.util.function_.Function<K, T_>;
        put(arg0: K, arg1: number): number;
        remove(arg0: any): number;
        defaultReturnValue(): number;
        defaultReturnValue(arg0: number): void;
        andThenDouble(arg0: Internal.Long2DoubleFunction_): Internal.Reference2DoubleFunction<K>;
        andThenObject<T_>(arg0: Internal.Long2ObjectFunction_<T_>): Internal.Reference2ObjectFunction<K, T_>;
        removeLong(arg0: any): number;
        get(arg0: any): number;
        andThenLong(arg0: Internal.Long2LongFunction_): Internal.Reference2LongFunction<K>;
        composeLong(arg0: Internal.Long2ReferenceFunction_<K>): Internal.Long2LongFunction;
        andThenByte(arg0: Internal.Long2ByteFunction_): Internal.Reference2ByteFunction<K>;
        andThenFloat(arg0: Internal.Long2FloatFunction_): Internal.Reference2FloatFunction<K>;
        apply(arg0: K): number;
        containsKey(arg0: any): boolean;
        composeInt(arg0: Internal.Int2ReferenceFunction_<K>): Internal.Int2LongFunction;
        clear(): void;
        composeFloat(arg0: Internal.Float2ReferenceFunction_<K>): Internal.Float2LongFunction;
        andThenChar(arg0: Internal.Long2CharFunction_): Internal.Reference2CharFunction<K>;
        getLong(arg0: any): number;
        applyAsLong(arg0: K): number;
        composeObject<T_>(arg0: Internal.Object2ReferenceFunction_<T_, K>): Internal.Object2LongFunction<T_>;
        size(): number;
        compose<V_>(arg0: java_.util.function_.Function_<V_, K>): java_.util.function_.Function<V_, number>;
        composeShort(arg0: Internal.Short2ReferenceFunction_<K>): Internal.Short2LongFunction;
        andThenReference<T_>(arg0: Internal.Long2ReferenceFunction_<T_>): Internal.Reference2ReferenceFunction<K, T_>;
        composeChar(arg0: Internal.Char2ReferenceFunction_<K>): Internal.Char2LongFunction;
        composeDouble(arg0: Internal.Double2ReferenceFunction_<K>): Internal.Double2LongFunction;
    }
    type Reference2LongFunction_<K> = ((arg0: any) => number) | Reference2LongFunction<K>;
    class ChannelOutboundBuffer {
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        notifyAll(): void;
        isWritable(): boolean;
        notify(): void;
        addMessage(arg0: any, arg1: number, arg2: Internal.ChannelPromise_): void;
        remove(arg0: Internal.Throwable_): boolean;
        remove(): boolean;
        addFlush(): void;
        forEachFlushedMessage(arg0: Internal.ChannelOutboundBuffer$MessageProcessor_): void;
        totalPendingWriteBytes(): number;
        current(): any;
        setUserDefinedWritability(arg0: number, arg1: boolean): void;
        hashCode(): number;
        nioBufferSize(): number;
        recycle(): void;
        bytesBeforeWritable(): number;
        currentProgress(): number;
        bytesBeforeUnwritable(): number;
        getUserDefinedWritability(arg0: number): boolean;
        isEmpty(): boolean;
        nioBuffers(arg0: number, arg1: number): Internal.ByteBuffer[];
        nioBuffers(): Internal.ByteBuffer[];
        nioBufferCount(): number;
        removeBytes(arg0: number): void;
        size(): number;
        equals(arg0: any): boolean;
        progress(arg0: number): void;
        toString(): string;
        get class(): Internal.Class<any>;
        get writable(): boolean;
        get empty(): boolean;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    type ChannelOutboundBuffer_ = ChannelOutboundBuffer;
    interface Int2ObjectMap$Entry <V> extends Internal.Map$Entry<number, V> {
        getValue(): V;
        getIntKey(): number;
        getKey(): number;
        hashCode(): number;
        setValue(arg0: V): V;
        equals(arg0: any): boolean;
    }
    type Int2ObjectMap$Entry_<V> = Int2ObjectMap$Entry<V>;
    class Clipboard {
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        getName(): string;
        notifyAll(): void;
        addFlavorListener(arg0: Internal.FlavorListener_): void;
        isDataFlavorAvailable(arg0: Internal.DataFlavor_): boolean;
        notify(): void;
        hashCode(): number;
        equals(arg0: any): boolean;
        getAvailableDataFlavors(): Internal.DataFlavor[];
        getFlavorListeners(): Internal.FlavorListener[];
        getContents(arg0: any): Internal.Transferable;
        toString(): string;
        removeFlavorListener(arg0: Internal.FlavorListener_): void;
        setContents(arg0: Internal.Transferable_, arg1: Internal.ClipboardOwner_): void;
        getData(arg0: Internal.DataFlavor_): any;
        get flavorListeners(): Internal.FlavorListener[];
        get availableDataFlavors(): Internal.DataFlavor[];
        get name(): string;
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    type Clipboard_ = Clipboard;
    interface BakedModel extends Internal.IForgeBakedModel {
        doesHandlePerspectives(): boolean;
        getModelData(arg0: Internal.BlockAndTintGetter_, arg1: BlockPos_, arg2: Internal.BlockState_, arg3: Internal.IModelData_): Internal.IModelData;
        isLayered(): boolean;
        handlePerspective(arg0: Internal.ItemTransforms$TransformType_, arg1: Internal.PoseStack_): Internal.BakedModel;
        getQuads(arg0: Internal.BlockState_, arg1: Internal.Direction_, arg2: Internal.Random_, arg3: Internal.IModelData_): Internal.List<Internal.BakedQuad>;
        useAmbientOcclusion(arg0: Internal.BlockState_): boolean;
        getLayerModels(arg0: Internal.ItemStack_, arg1: boolean): Internal.List<Internal.Pair<Internal.BakedModel, Internal.RenderType>>;
        getParticleIcon(arg0: Internal.IModelData_): Internal.TextureAtlasSprite;
    }
    type BakedModel_ = BakedModel;
    interface IntConsumer extends Internal.Consumer<number>, java_.util.function_.IntConsumer {
        andThen(arg0: java_.util.function_.IntConsumer_): Internal.IntConsumer;
        andThen(arg0: Internal.Consumer_<number>): Internal.Consumer<number>;
        andThen(arg0: Internal.IntConsumer_): Internal.IntConsumer;
        accept(arg0: number): void;
    }
    type IntConsumer_ = ((arg0: number) => void) | IntConsumer;
    abstract class Executable extends Internal.AccessibleObject implements Internal.Member, Internal.GenericDeclaration {
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        getName(): string;
        getParameterCount(): number;
        isAnnotationPresent(arg0: Internal.Class_<Internal.Annotation_>): boolean;
        notifyAll(): void;
        isSynthetic(): boolean;
        getAnnotatedParameterTypes(): Internal.AnnotatedType[];
        getParameterTypes(): Internal.Class<any>[];
        getGenericExceptionTypes(): java_.lang.reflect.Type[];
        notify(): void;
        getAnnotatedReceiverType(): Internal.AnnotatedType;
        getDeclaredAnnotations(): Internal.Annotation[];
        getDeclaringClass(): Internal.Class<any>;
        getAnnotationsByType<T_>(arg0: Internal.Class_<T_>): T_[];
        hashCode(): number;
        canAccess(arg0: any): boolean;
        toGenericString(): string;
        getTypeParameters(): any[];
        getModifiers(): number;
        trySetAccessible(): boolean;
        isAccessible(): boolean;
        setAccessible(arg0: boolean): void;
        static setAccessible(arg0: Internal.AccessibleObject_[], arg1: boolean): void;
        isVarArgs(): boolean;
        getAnnotations(): Internal.Annotation[];
        getAnnotatedExceptionTypes(): Internal.AnnotatedType[];
        getExceptionTypes(): Internal.Class<any>[];
        getGenericParameterTypes(): java_.lang.reflect.Type[];
        getDeclaredAnnotationsByType<T_>(arg0: Internal.Class_<T_>): T_[];
        getAnnotation<T_>(arg0: Internal.Class_<T_>): T_;
        equals(arg0: any): boolean;
        getDeclaredAnnotation<T_>(arg0: Internal.Class_<T_>): T_;
        getParameters(): any[];
        toString(): string;
        getAnnotatedReturnType(): Internal.AnnotatedType;
        getParameterAnnotations(): Internal.Annotation[][];
        static readonly PUBLIC : 0;
        static readonly DECLARED : 1;
        get declaredAnnotations(): Internal.Annotation[];
        get accessible(): boolean;
        get annotatedReturnType(): Internal.AnnotatedType;
        get parameterTypes(): Internal.Class<any>[];
        get parameterCount(): number;
        get annotations(): Internal.Annotation[];
        get modifiers(): number;
        get typeParameters(): any[];
        get declaringClass(): Internal.Class<any>;
        get varArgs(): boolean;
        get synthetic(): boolean;
        get genericParameterTypes(): java_.lang.reflect.Type[];
        get exceptionTypes(): Internal.Class<any>[];
        get name(): string;
        get annotatedReceiverType(): Internal.AnnotatedType;
        get genericExceptionTypes(): java_.lang.reflect.Type[];
        get parameterAnnotations(): Internal.Annotation[][];
        get class(): Internal.Class<any>;
        get parameters(): any[];
        get annotatedExceptionTypes(): Internal.AnnotatedType[];
        get annotatedParameterTypes(): Internal.AnnotatedType[];
        set accessible(arg0: boolean);
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    type Executable_ = Executable;
    interface LevelStorageSourceLevelStorageAccessAccess {
        byg_getLevelPath(): Internal.Path;
    }
    type LevelStorageSourceLevelStorageAccessAccess_ = LevelStorageSourceLevelStorageAccessAccess;
    class InventoryFilterItem$FilterSlot {
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        hashCode(): number;
        notifyAll(): void;
        equals(arg0: any): boolean;
        toString(): string;
        notify(): void;
        readonly x : number;
        readonly y : number;
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    type InventoryFilterItem$FilterSlot_ = InventoryFilterItem$FilterSlot;
    interface Double2IntFunction extends Internal.Function<number, number>, Internal.DoubleToIntFunction {
        getOrDefault(arg0: any, arg1: number): number;
        getOrDefault(arg0: number, arg1: number): number;
        andThenShort(arg0: Internal.Int2ShortFunction_): Internal.Double2ShortFunction;
        composeByte(arg0: Internal.Byte2DoubleFunction_): Internal.Byte2IntFunction;
        andThenInt(arg0: Internal.Int2IntFunction_): Internal.Double2IntFunction;
        composeReference<T_>(arg0: Internal.Reference2DoubleFunction_<T_>): Internal.Reference2IntFunction<T_>;
        andThen<T_>(arg0: java_.util.function_.Function_<number, T_>): java_.util.function_.Function<number, T_>;
        put(arg0: number, arg1: number): number;
        remove(arg0: number): number;
        remove(arg0: any): number;
        defaultReturnValue(): number;
        defaultReturnValue(arg0: number): void;
        andThenDouble(arg0: Internal.Int2DoubleFunction_): Internal.Double2DoubleFunction;
        andThenObject<T_>(arg0: Internal.Int2ObjectFunction_<T_>): Internal.Double2ObjectFunction<T_>;
        get(arg0: any): number;
        get(arg0: number): number;
        andThenLong(arg0: Internal.Int2LongFunction_): Internal.Double2LongFunction;
        composeLong(arg0: Internal.Long2DoubleFunction_): Internal.Long2IntFunction;
        andThenByte(arg0: Internal.Int2ByteFunction_): Internal.Double2ByteFunction;
        andThenFloat(arg0: Internal.Int2FloatFunction_): Internal.Double2FloatFunction;
        applyAsInt(arg0: number): number;
        apply(arg0: number): number;
        containsKey(arg0: any): boolean;
        containsKey(arg0: number): boolean;
        composeInt(arg0: Internal.Int2DoubleFunction_): Internal.Int2IntFunction;
        clear(): void;
        composeFloat(arg0: Internal.Float2DoubleFunction_): Internal.Float2IntFunction;
        andThenChar(arg0: Internal.Int2CharFunction_): Internal.Double2CharFunction;
        composeObject<T_>(arg0: Internal.Object2DoubleFunction_<T_>): Internal.Object2IntFunction<T_>;
        size(): number;
        compose<T_>(arg0: java_.util.function_.Function_<T_, number>): java_.util.function_.Function<T_, number>;
        composeShort(arg0: Internal.Short2DoubleFunction_): Internal.Short2IntFunction;
        andThenReference<T_>(arg0: Internal.Int2ReferenceFunction_<T_>): Internal.Double2ReferenceFunction<T_>;
        composeChar(arg0: Internal.Char2DoubleFunction_): Internal.Char2IntFunction;
        composeDouble(arg0: Internal.Double2DoubleFunction_): Internal.Double2IntFunction;
    }
    type Double2IntFunction_ = ((arg0: number) => number) | Double2IntFunction;
    interface RecipeSerializer <T> extends Internal.IForgeRegistryEntry<Internal.RecipeSerializer<any>>, Internal.IForgeRecipeSerializer<T> {
        getRegistryType(): Internal.Class<Internal.RecipeSerializer<any>>;
        fromJson(arg0: ResourceLocation_, arg1: Internal.JsonObject_, arg2: Internal.ICondition$IContext_): T;
        getRegistryName(): ResourceLocation;
        setRegistryName(arg0: ResourceLocation_): Internal.RecipeSerializer<any>;
    }
    type RecipeSerializer_<T> = RecipeSerializer<T>;
    interface WidgetLayout {
        align(arg0: Internal.Panel_): number;
    }
    type WidgetLayout_ = ((arg0: Internal.Panel) => number) | WidgetLayout;
    class Biome extends Internal.ForgeRegistryEntry$UncheckedRegistryEntry<Internal.Biome> implements Internal.BiomeFTBC, Internal.BiomeAccess, Internal.AccessorBiome {
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        getFTBCBiomeColorIndex(): number;
        setFTBCBiomeColorIndex(c: number): void;
        hashCode(): number;
        notifyAll(): void;
        equals(arg0: any): boolean;
        getRegistryType(): Internal.Class<Internal.Biome>;
        getRegistryName(): ResourceLocation;
        toString(): string;
        setRegistryName(arg0: ResourceLocation_): Internal.Biome;
        setRegistryName(arg0: string): Internal.Biome;
        setRegistryName(arg0: string, arg1: string): Internal.Biome;
        notify(): void;
        readonly delegate : Internal.IRegistryDelegate<Internal.Biome>;
        get registryType(): Internal.Class<Internal.Biome>;
        get fTBCBiomeColorIndex(): number;
        get registryName(): ResourceLocation;
        get class(): Internal.Class<any>;
        set fTBCBiomeColorIndex(c: number);
        set registryName(arg0: ResourceLocation_);
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    type Biome_ = Biome;
    interface Tickable {
    }
    type Tickable_ = Tickable;
    interface Function9 <T1, T2, T3, T4, T5, T6, T7, T8, T9, R> {
        apply(arg0: T1, arg1: T2, arg2: T3, arg3: T4, arg4: T5, arg5: T6, arg6: T7, arg7: T8, arg8: T9): R;
        curry7(): Internal.Function7<T1, T2, T3, T4, T5, T6, T7, Internal.BiFunction<T8, T9, R>>;
        curry8(): Internal.Function8<T1, T2, T3, T4, T5, T6, T7, T8, java_.util.function_.Function<T9, R>>;
        curry5(): Internal.Function5<T1, T2, T3, T4, T5, Internal.Function4<T6, T7, T8, T9, R>>;
        curry6(): Internal.Function6<T1, T2, T3, T4, T5, T6, Internal.Function3<T7, T8, T9, R>>;
        curry3(): Internal.Function3<T1, T2, T3, Internal.Function6<T4, T5, T6, T7, T8, T9, R>>;
        curry4(): Internal.Function4<T1, T2, T3, T4, Internal.Function5<T5, T6, T7, T8, T9, R>>;
        curry2(): Internal.BiFunction<T1, T2, Internal.Function7<T3, T4, T5, T6, T7, T8, T9, R>>;
        curry(): java_.util.function_.Function<T1, Internal.Function8<T2, T3, T4, T5, T6, T7, T8, T9, R>>;
    }
    type Function9_<T1, T2, T3, T4, T5, T6, T7, T8, T9, R> = Function9<T1, T2, T3, T4, T5, T6, T7, T8, T9, R>;
    interface InstantSource {
        withZone(arg0: Internal.ZoneId_): Internal.Clock;
        millis(): number;
        instant(): Internal.Instant;
    }
    type InstantSource_ = InstantSource;
    class ServerJS implements Internal.MessageSender, Internal.WithAttachedData {
        getAdvancement(id: ResourceLocation_): Internal.AdvancementJS;
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        getPlayer(minecraftPlayer: Internal.Player_): Internal.ServerPlayerJS;
        getPlayer(name: string): Internal.ServerPlayerJS;
        getPlayer(uuid: Internal.UUID_): Internal.ServerPlayerJS;
        getName(): Internal.Text;
        updateWorldList(): void;
        release(): void;
        notifyAll(): void;
        tell(message: Internal.Component_): void;
        getAllLevels(): Internal.List<Internal.ServerLevelJS>;
        getHardcore(): boolean;
        getMotd(): string;
        getOverworld(): Internal.ServerLevelJS;
        notify(): void;
        runCommandSilent(command: string): number;
        scheduleInTicks(ticks: number, event: Internal.IScheduledEventCallback_): Internal.ScheduledEvent;
        scheduleInTicks(ticks: number, data: any, event: Internal.IScheduledEventCallback_): Internal.ScheduledEvent;
        isRunning(): boolean;
        hashCode(): number;
        setMotd(text: Internal.Component_): void;
        runCommand(command: string): number;
        isSinglePlayer(): boolean;
        getPlayers(): Internal.EntityArrayList;
        getData(): Internal.AttachedData;
        setStatusMessage(message: Internal.Component_): void;
        sendDataToAll(channel: string, data: Internal.CompoundTag_): void;
        isDedicated(): boolean;
        schedule(timer: number, event: Internal.IScheduledEventCallback_): Internal.ScheduledEvent;
        schedule(timer: number, data: any, event: Internal.IScheduledEventCallback_): Internal.ScheduledEvent;
        getLevel(minecraftLevel: Internal.Level_): Internal.LevelJS;
        getLevel(dimension: string): Internal.LevelJS;
        getMinecraftServer(): Internal.MinecraftServer;
        stop(): void;
        getDisplayName(): Internal.Text;
        equals(arg0: any): boolean;
        getEntities(filter: string): Internal.EntityArrayList;
        getEntities(): Internal.EntityArrayList;
        toString(): string;
        static instance : Internal.ServerJS;
        readonly persistentData : Internal.CompoundTag;
        overworld : Internal.ServerLevelJS;
        get singlePlayer(): boolean;
        get motd(): string;
        get dedicated(): boolean;
        get data(): Internal.AttachedData;
        get hardcore(): boolean;
        get players(): Internal.EntityArrayList;
        get displayName(): Internal.Text;
        get running(): boolean;
        get allLevels(): Internal.List<Internal.ServerLevelJS>;
        get entities(): Internal.EntityArrayList;
        get name(): Internal.Text;
        get minecraftServer(): Internal.MinecraftServer;
        get class(): Internal.Class<any>;
        set statusMessage(message: Internal.Component_);
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    type ServerJS_ = ServerJS;
    class PlayerTeam extends Internal.Team {
        msg(player: Internal.ServerPlayer_, message: string): number;
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        getPlayer(): Internal.ServerPlayer;
        getName(): Internal.Component;
        notifyAll(): void;
        getHighestRank(playerId: Internal.UUID_): Internal.TeamRank;
        save(): void;
        getId(): Internal.UUID;
        isMember(uuid: Internal.UUID_): boolean;
        getOwner(): Internal.UUID;
        isOfficer(profile: Internal.UUID_): boolean;
        getDescription(): string;
        notify(): void;
        getColoredName(): Internal.Component;
        serializeNBT(): Internal.SNBTCompoundTag;
        hashCode(): number;
        hasTeam(): boolean;
        info(source: Internal.CommandSourceStack_): number;
        settings(source: Internal.CommandSourceStack_, key: Internal.TeamProperty_<any>, value: string): number;
        updatePresence(): void;
        isAlly(profile: Internal.UUID_): boolean;
        getProperty<T_>(property: Internal.TeamProperty_<T_>): T_;
        isValid(): boolean;
        getExtraData(): Internal.CompoundTag;
        getColor(): number;
        sendMessage(from: Internal.UUID_, text: Internal.Component_): void;
        deserializeNBT(tag: Internal.CompoundTag_): void;
        getRanked(rank: Internal.TeamRank_): Internal.Map<Internal.UUID, Internal.TeamRank>;
        getOnlineRanked(rank: Internal.TeamRank_): Internal.List<Internal.ServerPlayer>;
        denyInvite(source: Internal.CommandSourceStack_): number;
        isFreeToJoin(): boolean;
        createParty(player: Internal.ServerPlayer_, name: string, description: string, color: number, invited: Internal.Set_<Internal.GameProfile_>): void;
        isInvited(profile: Internal.UUID_): boolean;
        getStringID(): string;
        getDisplayName(): string;
        getOnlineMembers(): Internal.List<Internal.ServerPlayer>;
        getType(): Internal.TeamType;
        setProperty<T_>(property: Internal.TeamProperty_<T_>, value: T_): void;
        equals(o: any): boolean;
        toString(): string;
        getMembers(): Internal.Set<Internal.UUID>;
        actualTeam : Internal.Team;
        static readonly FREE_TO_JOIN : Internal.BooleanProperty;
        readonly manager : Internal.TeamManager;
        playerName : string;
        static readonly DESCRIPTION : Internal.StringProperty;
        static readonly COLOR : Internal.ColorProperty;
        readonly messageHistory : Internal.List<Internal.TeamMessage>;
        online : boolean;
        static readonly DISPLAY_NAME : Internal.StringProperty;
        readonly properties : Internal.TeamProperties;
        get owner(): Internal.UUID;
        get onlineMembers(): Internal.List<Internal.ServerPlayer>;
        get color(): number;
        get extraData(): Internal.CompoundTag;
        get displayName(): string;
        get description(): string;
        get type(): Internal.TeamType;
        get freeToJoin(): boolean;
        get valid(): boolean;
        get stringID(): string;
        get members(): Internal.Set<Internal.UUID>;
        get name(): Internal.Component;
        get id(): Internal.UUID;
        get class(): Internal.Class<any>;
        get coloredName(): Internal.Component;
        get player(): Internal.ServerPlayer;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    type PlayerTeam_ = PlayerTeam;
    class ModuleDescriptor$Builder {
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        mainClass(arg0: string): Internal.ModuleDescriptor$Builder;
        exports(arg0: string): Internal.ModuleDescriptor$Builder;
        exports(arg0: Internal.Set_<Internal.ModuleDescriptor$Exports$Modifier_>, arg1: string, arg2: Internal.Set_<string>): Internal.ModuleDescriptor$Builder;
        exports(arg0: string, arg1: Internal.Set_<string>): Internal.ModuleDescriptor$Builder;
        exports(arg0: Internal.Set_<Internal.ModuleDescriptor$Exports$Modifier_>, arg1: string): Internal.ModuleDescriptor$Builder;
        exports(arg0: Internal.ModuleDescriptor$Exports_): Internal.ModuleDescriptor$Builder;
        notifyAll(): void;
        packages(arg0: Internal.Set_<string>): Internal.ModuleDescriptor$Builder;
        version(arg0: string): Internal.ModuleDescriptor$Builder;
        version(arg0: Internal.ModuleDescriptor$Version_): Internal.ModuleDescriptor$Builder;
        notify(): void;
        build(): Internal.ModuleDescriptor;
        hashCode(): number;
        provides(arg0: Internal.ModuleDescriptor$Provides_): Internal.ModuleDescriptor$Builder;
        provides(arg0: string, arg1: Internal.List_<string>): Internal.ModuleDescriptor$Builder;
        equals(arg0: any): boolean;
        opens(arg0: string): Internal.ModuleDescriptor$Builder;
        opens(arg0: Internal.Set_<Internal.ModuleDescriptor$Opens$Modifier_>, arg1: string, arg2: Internal.Set_<string>): Internal.ModuleDescriptor$Builder;
        opens(arg0: string, arg1: Internal.Set_<string>): Internal.ModuleDescriptor$Builder;
        opens(arg0: Internal.ModuleDescriptor$Opens_): Internal.ModuleDescriptor$Builder;
        opens(arg0: Internal.Set_<Internal.ModuleDescriptor$Opens$Modifier_>, arg1: string): Internal.ModuleDescriptor$Builder;
        toString(): string;
        uses(arg0: string): Internal.ModuleDescriptor$Builder;
        requires(arg0: Internal.ModuleDescriptor$Requires_): Internal.ModuleDescriptor$Builder;
        requires(arg0: Internal.Set_<Internal.ModuleDescriptor$Requires$Modifier_>, arg1: string, arg2: Internal.ModuleDescriptor$Version_): Internal.ModuleDescriptor$Builder;
        requires(arg0: string): Internal.ModuleDescriptor$Builder;
        requires(arg0: Internal.Set_<Internal.ModuleDescriptor$Requires$Modifier_>, arg1: string): Internal.ModuleDescriptor$Builder;
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    type ModuleDescriptor$Builder_ = ModuleDescriptor$Builder;
    class AffineTransform implements Internal.Cloneable, Internal.Serializable {
        setToIdentity(): void;
        getClass(): Internal.Class<any>;
        rotate(arg0: number, arg1: number, arg2: number, arg3: number): void;
        rotate(arg0: number, arg1: number): void;
        rotate(arg0: number, arg1: number, arg2: number): void;
        rotate(arg0: number): void;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        concatenate(arg0: Internal.AffineTransform_): void;
        preConcatenate(arg0: Internal.AffineTransform_): void;
        notifyAll(): void;
        scale(arg0: number, arg1: number): void;
        static getScaleInstance(arg0: number, arg1: number): Internal.AffineTransform;
        static getRotateInstance(arg0: number): Internal.AffineTransform;
        static getRotateInstance(arg0: number, arg1: number, arg2: number): Internal.AffineTransform;
        static getRotateInstance(arg0: number, arg1: number): Internal.AffineTransform;
        static getRotateInstance(arg0: number, arg1: number, arg2: number, arg3: number): Internal.AffineTransform;
        notify(): void;
        translate(arg0: number, arg1: number): void;
        setToQuadrantRotation(arg0: number): void;
        setToQuadrantRotation(arg0: number, arg1: number, arg2: number): void;
        setToRotation(arg0: number, arg1: number, arg2: number, arg3: number): void;
        setToRotation(arg0: number, arg1: number, arg2: number): void;
        setToRotation(arg0: number, arg1: number): void;
        setToRotation(arg0: number): void;
        transform(arg0: number[], arg1: number, arg2: number[], arg3: number, arg4: number): void;
        transform(arg0: Internal.Point2D_, arg1: Internal.Point2D_): Internal.Point2D;
        transform(arg0: Internal.Point2D_[], arg1: number, arg2: Internal.Point2D_[], arg3: number, arg4: number): void;
        getMatrix(arg0: number[]): void;
        quadrantRotate(arg0: number): void;
        quadrantRotate(arg0: number, arg1: number, arg2: number): void;
        setTransform(arg0: number, arg1: number, arg2: number, arg3: number, arg4: number, arg5: number): void;
        setTransform(arg0: Internal.AffineTransform_): void;
        inverseTransform(arg0: number[], arg1: number, arg2: number[], arg3: number, arg4: number): void;
        inverseTransform(arg0: Internal.Point2D_, arg1: Internal.Point2D_): Internal.Point2D;
        hashCode(): number;
        setToShear(arg0: number, arg1: number): void;
        getTranslateY(): number;
        getTranslateX(): number;
        getDeterminant(): number;
        shear(arg0: number, arg1: number): void;
        invert(): void;
        static getQuadrantRotateInstance(arg0: number): Internal.AffineTransform;
        static getQuadrantRotateInstance(arg0: number, arg1: number, arg2: number): Internal.AffineTransform;
        isIdentity(): boolean;
        createTransformedShape(arg0: Internal.Shape_): Internal.Shape;
        createInverse(): Internal.AffineTransform;
        getScaleY(): number;
        getShearX(): number;
        getScaleX(): number;
        static getTranslateInstance(arg0: number, arg1: number): Internal.AffineTransform;
        getShearY(): number;
        getType(): number;
        setToScale(arg0: number, arg1: number): void;
        equals(arg0: any): boolean;
        clone(): any;
        toString(): string;
        setToTranslation(arg0: number, arg1: number): void;
        deltaTransform(arg0: Internal.Point2D_, arg1: Internal.Point2D_): Internal.Point2D;
        deltaTransform(arg0: number[], arg1: number, arg2: number[], arg3: number, arg4: number): void;
        static getShearInstance(arg0: number, arg1: number): Internal.AffineTransform;
        static readonly TYPE_QUADRANT_ROTATION : 8;
        static readonly TYPE_TRANSLATION : 1;
        static readonly TYPE_IDENTITY : 0;
        static readonly TYPE_UNIFORM_SCALE : 2;
        static readonly TYPE_MASK_SCALE : 6;
        static readonly TYPE_MASK_ROTATION : 24;
        static readonly TYPE_GENERAL_SCALE : 4;
        static readonly TYPE_FLIP : 64;
        static readonly TYPE_GENERAL_ROTATION : 16;
        static readonly TYPE_GENERAL_TRANSFORM : 32;
        get scaleX(): number;
        get scaleY(): number;
        get shearX(): number;
        get translateY(): number;
        get identity(): boolean;
        get translateX(): number;
        get type(): number;
        get class(): Internal.Class<any>;
        get shearY(): number;
        get determinant(): number;
        set toQuadrantRotation(arg0: number);
        set toRotation(arg0: number);
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    type AffineTransform_ = AffineTransform;
    class FoodProperties {
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        hashCode(): number;
        notifyAll(): void;
        equals(arg0: any): boolean;
        toString(): string;
        notify(): void;
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    type FoodProperties_ = FoodProperties;
    abstract class Icon implements Internal.Drawable {
        drawStatic(matrixStack: Internal.PoseStack_, x: number, y: number, w: number, h: number): void;
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        withBorder(color: Internal.Color4I_, roundEdges: boolean): Internal.Icon;
        notifyAll(): void;
        withColor(color: Internal.Color4I_): Internal.Icon;
        isEmpty(): boolean;
        withUV(x: number, y: number, w: number, h: number, tw: number, th: number): Internal.Icon;
        withUV(u0: number, v0: number, u1: number, v1: number): Internal.Icon;
        draw(arg0: Internal.PoseStack_, arg1: number, arg2: number, arg3: number, arg4: number): void;
        withTint(color: Internal.Color4I_): Internal.Icon;
        draw3D(matrixStack: Internal.PoseStack_): void;
        notify(): void;
        static getIcon(json: Internal.JsonElement_): Internal.Icon;
        static getIcon(id: ResourceLocation_): Internal.Icon;
        static getIcon(id: string): Internal.Icon;
        createPixelBuffer(): Internal.PixelBuffer;
        getIngredient(): any;
        hashCode(): number;
        equals(o: any): boolean;
        withPadding(padding: number): Internal.Icon;
        toString(): string;
        copy(): Internal.Icon;
        hasPixelBuffer(): boolean;
        combineWith(icon: Internal.Icon_): Internal.Icon;
        combineWith(icons: Internal.Icon_[]): Internal.Icon;
        getJson(): Internal.JsonElement;
        static readonly EMPTY : Internal.Color4I;
        get ingredient(): any;
        get json(): Internal.JsonElement;
        get class(): Internal.Class<any>;
        get empty(): boolean;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    type Icon_ = Icon;
    abstract class RecipeJS {
        parseResultItemList(o: any): Internal.List<Internal.ItemStackJS>;
        getClass(): Internal.Class<any>;
        ingredientAction(filter: Internal.IngredientActionFilter_, action: Internal.IngredientAction_): Internal.RecipeJS;
        convertReplacedInput(index: number, oldIngredient: Internal.IngredientJS_, newIngredient: Internal.IngredientJS_): Internal.IngredientJS;
        getUniqueId(): string;
        replaceOutput(i: Internal.IngredientJS_, with_: Internal.ItemStackJS_, exact: boolean): boolean;
        replaceOutput(i: Internal.IngredientJS_, with_: Internal.ItemStackJS_, exact: boolean, func: Internal.BiFunction_<Internal.ItemStackJS_, Internal.ItemStackJS_, Internal.ItemStackJS_>): boolean;
        parseIngredientItemList(o: any): Internal.List<Internal.IngredientJS>;
        merge(data: any): Internal.RecipeJS;
        getPath(): string;
        create(arg0: Internal.ListJS_): void;
        parseIngredientItemStackList(o: any): Internal.List<Internal.IngredientStackJS>;
        id(_id: ResourceLocation_): Internal.RecipeJS;
        parseIngredientItem(o: any, key: string): Internal.IngredientJS;
        parseIngredientItem(o: any): Internal.IngredientJS;
        group(g: string): Internal.RecipeJS;
        getOriginalRecipeResult(): Internal.ItemStackJS;
        getOriginalRecipeIngredients(): Internal.List<Internal.IngredientJS>;
        getInputIndex(ingredient: Internal.IngredientJS_, exact: boolean): number;
        serialize(): void;
        setGroup(g: string): void;
        replaceInput(i: Internal.IngredientJS_, with_: Internal.IngredientJS_, exact: boolean, func: Internal.BiFunction_<Internal.IngredientJS_, Internal.IngredientJS_, Internal.IngredientJS_>): boolean;
        replaceInput(i: Internal.IngredientJS_, with_: Internal.IngredientJS_, exact: boolean): boolean;
        getType(): string;
        getGroup(): string;
        hasOutput(ingredient: Internal.IngredientJS_, exact: boolean): boolean;
        keepIngredient(filter: Internal.IngredientActionFilter_): Internal.RecipeJS;
        customIngredientAction(filter: Internal.IngredientActionFilter_, id: string): Internal.RecipeJS;
        modifyResult(callback: Internal.ModifyRecipeResultCallback_): Internal.RecipeJS;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        getMod(): string;
        notifyAll(): void;
        convertReplacedOutput(index: number, oldStack: Internal.ItemStackJS_, newStack: Internal.ItemStackJS_): Internal.ItemStackJS;
        save(): void;
        damageIngredient(filter: Internal.IngredientActionFilter_): Internal.RecipeJS;
        damageIngredient(filter: Internal.IngredientActionFilter_, damage: number): Internal.RecipeJS;
        getId(): string;
        dontAdd(): void;
        notify(): void;
        serializeJson(): void;
        createRecipe(): Internal.Recipe<any>;
        getFromToString(): string;
        hashCode(): number;
        deserializeJson(): void;
        getOrCreateId(): ResourceLocation;
        deserialize(): void;
        serializeNBTAsJson(): boolean;
        getOutputIndex(ingredient: Internal.IngredientJS_, exact: boolean): number;
        serializeIngredientStack(in_: Internal.IngredientStackJS_): Internal.JsonElement;
        resultFromRecipeJson(json: Internal.JsonObject_): Internal.ItemStackJS;
        stage(s: string): Internal.RecipeJS;
        equals(arg0: any): boolean;
        serializeItemStack(stack: Internal.ItemStackJS_): Internal.JsonElement;
        toString(): string;
        hasInput(ingredient: Internal.IngredientJS_, exact: boolean): boolean;
        parseResultItem(o: any): Internal.ItemStackJS;
        replaceIngredient(filter: Internal.IngredientActionFilter_, item: Internal.ItemStackJS_): Internal.RecipeJS;
        static currentRecipe : Internal.RecipeJS;
        originalJson : Internal.JsonObject;
        serializeOutputs : boolean;
        originalRecipe : Internal.Recipe<any>;
        readonly inputItems : Internal.List<((arg0: Internal.ItemStackJS) => boolean)>;
        static itemErrors : false;
        json : Internal.JsonObject;
        readonly outputItems : Internal.List<Internal.ItemStackJS>;
        type : Internal.RecipeTypeJS;
        serializeInputs : boolean;
        get path(): string;
        get originalRecipeIngredients(): Internal.List<Internal.IngredientJS>;
        get mod(): string;
        get originalRecipeResult(): Internal.ItemStackJS;
        get orCreateId(): ResourceLocation;
        get class(): Internal.Class<any>;
        get fromToString(): string;
        get uniqueId(): string;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    type RecipeJS_ = RecipeJS;
    class NamedPackage {
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        hashCode(): number;
        notifyAll(): void;
        equals(arg0: any): boolean;
        toString(): string;
        notify(): void;
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    type NamedPackage_ = NamedPackage;
    interface ExtendedEntityFlagsPredicate$IBuilder <T> {
        isBaby(arg0: boolean): Internal.ExtendedEntityFlagsPredicate$IBuilder<T>;
        isIllegarMob(arg0: boolean): Internal.ExtendedEntityFlagsPredicate$IBuilder<T>;
        isSwimming(arg0: boolean): Internal.ExtendedEntityFlagsPredicate$IBuilder<T>;
        isInWater(arg0: boolean): Internal.ExtendedEntityFlagsPredicate$IBuilder<T>;
        isWaterMob(arg0: boolean): Internal.ExtendedEntityFlagsPredicate$IBuilder<T>;
        isCrouching(arg0: boolean): Internal.ExtendedEntityFlagsPredicate$IBuilder<T>;
        isUnderWater(arg0: boolean): Internal.ExtendedEntityFlagsPredicate$IBuilder<T>;
        isSprinting(arg0: boolean): Internal.ExtendedEntityFlagsPredicate$IBuilder<T>;
        isUndeadMob(arg0: boolean): Internal.ExtendedEntityFlagsPredicate$IBuilder<T>;
        isCreature(arg0: boolean): Internal.ExtendedEntityFlagsPredicate$IBuilder<T>;
        build(): T;
        isMonster(arg0: boolean): Internal.ExtendedEntityFlagsPredicate$IBuilder<T>;
        isOnFire(arg0: boolean): Internal.ExtendedEntityFlagsPredicate$IBuilder<T>;
        isArthropodMob(arg0: boolean): Internal.ExtendedEntityFlagsPredicate$IBuilder<T>;
        isOnGround(arg0: boolean): Internal.ExtendedEntityFlagsPredicate$IBuilder<T>;
    }
    type ExtendedEntityFlagsPredicate$IBuilder_<T> = ExtendedEntityFlagsPredicate$IBuilder<T>;
    interface Command <S> {
        run(arg0: Internal.CommandContext_<S>): number;
    }
    type Command_<S> = ((arg0: Internal.CommandContext<S>) => number) | Command<S>;
    class ArrayList <E> extends Internal.AbstractList<E> implements Internal.List<E>, Internal.RandomAccess, Internal.Cloneable, Internal.Serializable {
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        notifyAll(): void;
        replaceAll(arg0: Internal.UnaryOperator_<E>): void;
        notify(): void;
        remove(arg0: any): boolean;
        remove(arg0: number): E;
        removeAll(arg0: Internal.Collection_<any>): boolean;
        iterator(): Internal.Iterator<E>;
        stream(): Internal.Stream<E>;
        hashCode(): number;
        get(arg0: number): E;
        toArray(): any[];
        toArray<T_>(arg0: T_[]): T_[];
        toArray<T_>(arg0: Internal.IntFunction_<T_[]>): T_[];
        parallelStream(): Internal.Stream<E>;
        indexOf(arg0: any): number;
        add(arg0: E): boolean;
        add(arg0: number, arg1: E): void;
        subList(arg0: number, arg1: number): Internal.List<E>;
        trimToSize(): void;
        set(arg0: number, arg1: E): E;
        spliterator(): Internal.Spliterator<E>;
        forEach(arg0: Internal.Consumer_<E>): void;
        containsAll(arg0: Internal.Collection_<any>): boolean;
        isEmpty(): boolean;
        clear(): void;
        sort(arg0: Internal.Comparator_<E>): void;
        removeIf(arg0: Internal.Predicate_<E>): boolean;
        lastIndexOf(arg0: any): number;
        contains(arg0: any): boolean;
        size(): number;
        addAll(arg0: number, arg1: Internal.Collection_<E>): boolean;
        addAll(arg0: Internal.Collection_<E>): boolean;
        equals(arg0: any): boolean;
        clone(): any;
        listIterator(): Internal.ListIterator<E>;
        listIterator(arg0: number): Internal.ListIterator<E>;
        toString(): string;
        ensureCapacity(arg0: number): void;
        retainAll(arg0: Internal.Collection_<any>): boolean;
        get class(): Internal.Class<any>;
        get empty(): boolean;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    type ArrayList_<E> = ArrayList<E>;
    class ChunkTracker {
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        loadChunk(x: number, z: number): boolean;
        hashCode(): number;
        notifyAll(): void;
        equals(arg0: any): boolean;
        hasMergedFlags(x: number, z: number, flags: number): boolean;
        unloadChunk(x: number, z: number): boolean;
        update(): void;
        toString(): string;
        getChunks(flags: number): Internal.LongStream;
        notify(): void;
        onLightDataAdded(x: number, z: number): void;
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    type ChunkTracker_ = ChunkTracker;
    interface Promise <V> extends io.netty.util.concurrent.Future<V> {
        cancel(arg0: boolean): boolean;
        isCancelled(): boolean;
        removeListeners(arg0: Internal.GenericFutureListener_<io.netty.util.concurrent.Future_<V>>[]): Internal.Promise<V>;
        removeListeners(arg0: Internal.GenericFutureListener_<io.netty.util.concurrent.Future_<V>>[]): io.netty.util.concurrent.Future<V>;
        getNow(): V;
        cause(): Internal.Throwable;
        awaitUninterruptibly(): Internal.Promise<V>;
        awaitUninterruptibly(): io.netty.util.concurrent.Future<V>;
        awaitUninterruptibly(arg0: number, arg1: Internal.TimeUnit_): boolean;
        awaitUninterruptibly(arg0: number): boolean;
        removeListener(arg0: Internal.GenericFutureListener_<io.netty.util.concurrent.Future_<V>>): Internal.Promise<V>;
        removeListener(arg0: Internal.GenericFutureListener_<io.netty.util.concurrent.Future_<V>>): io.netty.util.concurrent.Future<V>;
        tryFailure(arg0: Internal.Throwable_): boolean;
        isDone(): boolean;
        sync(): Internal.Promise<V>;
        sync(): io.netty.util.concurrent.Future<V>;
        setSuccess(arg0: V): Internal.Promise<V>;
        setFailure(arg0: Internal.Throwable_): Internal.Promise<V>;
        trySuccess(arg0: V): boolean;
        syncUninterruptibly(): Internal.Promise<V>;
        syncUninterruptibly(): io.netty.util.concurrent.Future<V>;
        get(arg0: number, arg1: Internal.TimeUnit_): V;
        get(): V;
        isCancellable(): boolean;
        await(): Internal.Promise<V>;
        await(): io.netty.util.concurrent.Future<V>;
        await(arg0: number, arg1: Internal.TimeUnit_): boolean;
        await(arg0: number): boolean;
        addListeners(arg0: Internal.GenericFutureListener_<io.netty.util.concurrent.Future_<V>>[]): Internal.Promise<V>;
        addListeners(arg0: Internal.GenericFutureListener_<io.netty.util.concurrent.Future_<V>>[]): io.netty.util.concurrent.Future<V>;
        isSuccess(): boolean;
        addListener(arg0: Internal.GenericFutureListener_<io.netty.util.concurrent.Future_<V>>): Internal.Promise<V>;
        addListener(arg0: Internal.GenericFutureListener_<io.netty.util.concurrent.Future_<V>>): io.netty.util.concurrent.Future<V>;
        setUncancellable(): boolean;
    }
    type Promise_<V> = Promise<V>;
    class StonePressurePlateBlockBuilder extends Internal.ShapedBlockBuilder {
        noItem(): Internal.BlockBuilder;
        suffocating(b: boolean): Internal.BlockBuilder;
        getClass(): Internal.Class<any>;
        translationKey(key: string): Internal.BuilderBase<Internal.Block>;
        newID(pre: string, post: string): ResourceLocation;
        type(type: string): Internal.BuilderBase<Internal.Block>;
        unbreakable(): Internal.BlockBuilder;
        model(m: string): Internal.BlockBuilder;
        tag(tag: ResourceLocation_): Internal.BlockBuilder;
        generateDataJsons(generator: Internal.DataJsonGenerator_): void;
        tagBoth(tag: ResourceLocation_): Internal.BlockBuilder;
        defaultCutout(): Internal.BlockBuilder;
        item(i: Internal.Consumer_<Internal.BlockItemBuilder_>): Internal.BlockBuilder;
        resistance(r: number): Internal.BlockBuilder;
        hardness(h: number): Internal.BlockBuilder;
        slipperiness(f: number): Internal.BlockBuilder;
        getRegistryType(): Internal.RegistryObjectBuilderTypes<Internal.Block>;
        textureSide(direction: Internal.Direction_, tex: string): Internal.BlockBuilder;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        clientRegistry(minecraft: Internal.Minecraft_): void;
        waterlogged(): Internal.BlockBuilder;
        transformObject(obj: Internal.Block_): Internal.Block;
        color(index: number, c: Internal.Color_): Internal.BlockBuilder;
        textureAll(tex: string): Internal.BlockBuilder;
        displayName(name: string): Internal.BuilderBase<Internal.Block>;
        notifyAll(): void;
        box(x0: number, y0: number, z0: number, x1: number, y1: number, z1: number): Internal.BlockBuilder;
        box(x0: number, y0: number, z0: number, x1: number, y1: number, z1: number, scale16: boolean): Internal.BlockBuilder;
        viewBlocking(b: boolean): Internal.BlockBuilder;
        notify(): void;
        transparent(b: boolean): Internal.BlockBuilder;
        createAdditionalObjects(): void;
        tagBlock(tag: ResourceLocation_): Internal.BlockBuilder;
        fullBlock(f: boolean): Internal.BlockBuilder;
        createProperties(): Internal.BlockBehaviour$Properties;
        notSolid(): Internal.BlockBuilder;
        generateBlockModels(builder: Internal.BlockBuilder_): Internal.Map<ResourceLocation, Internal.JsonObject>;
        hashCode(): number;
        noCollission(): Internal.BlockBuilder;
        get(): Internal.Block;
        requiresTool(f: boolean): Internal.BlockBuilder;
        renderType(l: string): Internal.BlockBuilder;
        jumpFactor(f: number): Internal.BlockBuilder;
        createShape(): Internal.VoxelShape;
        generateAssetJsons(generator: Internal.AssetJsonGenerator_): void;
        noCollision(): Internal.BlockBuilder;
        opaque(o: boolean): Internal.BlockBuilder;
        randomTick(randomTickCallback: Internal.Consumer_<Internal.RandomTickCallbackJS_>): Internal.BlockBuilder;
        getTranslationKeyGroup(): string;
        texture(id: string, tex: string): Internal.BlockBuilder;
        noDrops(): Internal.BlockBuilder;
        generateLang(lang: Internal.Map_<string, string>): void;
        tagItem(tag: ResourceLocation_): Internal.BlockBuilder;
        speedFactor(f: number): Internal.BlockBuilder;
        noValidSpawns(b: boolean): Internal.BlockBuilder;
        createObject(): Internal.Block;
        lightLevel(light: number): Internal.BlockBuilder;
        addResourcePackLocations(path: string, list: Internal.List_<ResourceLocation_>, packType: Internal.PackType_): void;
        defaultTranslucent(): Internal.BlockBuilder;
        material(m: Internal.MaterialJS_): Internal.BlockBuilder;
        equals(arg0: any): boolean;
        toString(): string;
        redstoneConductor(b: boolean): Internal.BlockBuilder;
        lootTable : ((arg0: Internal.LootBuilder) => void);
        modelJson : Internal.JsonObject;
        blockstateJson : Internal.JsonObject;
        readonly id : ResourceLocation;
        randomTickCallback : ((arg0: Internal.RandomTickCallbackJS) => void);
        get registryType(): Internal.RegistryObjectBuilderTypes<Internal.Block>;
        get class(): Internal.Class<any>;
        get translationKeyGroup(): string;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    type StonePressurePlateBlockBuilder_ = StonePressurePlateBlockBuilder;
    class VillagerProfessionBuilder extends Internal.BuilderBase<Internal.VillagerProfession> {
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        clientRegistry(minecraft: Internal.Minecraft_): void;
        transformObject(obj: Internal.VillagerProfession_): Internal.VillagerProfession;
        translationKey(key: string): Internal.BuilderBase<Internal.VillagerProfession>;
        newID(pre: string, post: string): ResourceLocation;
        displayName(name: string): Internal.BuilderBase<Internal.VillagerProfession>;
        notifyAll(): void;
        type(type: string): Internal.BuilderBase<Internal.VillagerProfession>;
        notify(): void;
        createAdditionalObjects(): void;
        hashCode(): number;
        get(): Internal.VillagerProfession;
        tag(tag: ResourceLocation_): Internal.BuilderBase<Internal.VillagerProfession>;
        generateDataJsons(generator: Internal.DataJsonGenerator_): void;
        generateAssetJsons(generator: Internal.AssetJsonGenerator_): void;
        getTranslationKeyGroup(): string;
        generateLang(lang: Internal.Map_<string, string>): void;
        workSound(t: Internal.SoundEvent_): Internal.VillagerProfessionBuilder;
        requestedItems(t: Internal.Item_[]): Internal.VillagerProfessionBuilder;
        createObject(): Internal.VillagerProfession;
        addResourcePackLocations(path: string, list: Internal.List_<ResourceLocation_>, packType: Internal.PackType_): void;
        equals(arg0: any): boolean;
        poiType(t: Internal.PoiType_): Internal.VillagerProfessionBuilder;
        getRegistryType(): Internal.RegistryObjectBuilderTypes<Internal.VillagerProfession>;
        secondaryPoi(t: Internal.Block_[]): Internal.VillagerProfessionBuilder;
        toString(): string;
        readonly id : ResourceLocation;
        get registryType(): Internal.RegistryObjectBuilderTypes<Internal.VillagerProfession>;
        get class(): Internal.Class<any>;
        get translationKeyGroup(): string;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    type VillagerProfessionBuilder_ = VillagerProfessionBuilder;
    interface Double2ByteFunction extends Internal.Function<number, number>, Internal.DoubleToIntFunction {
        getOrDefault(arg0: any, arg1: number): number;
        getOrDefault(arg0: number, arg1: number): number;
        andThenShort(arg0: Internal.Byte2ShortFunction_): Internal.Double2ShortFunction;
        composeByte(arg0: Internal.Byte2DoubleFunction_): Internal.Byte2ByteFunction;
        andThenInt(arg0: Internal.Byte2IntFunction_): Internal.Double2IntFunction;
        composeReference<T_>(arg0: Internal.Reference2DoubleFunction_<T_>): Internal.Reference2ByteFunction<T_>;
        andThen<T_>(arg0: java_.util.function_.Function_<number, T_>): java_.util.function_.Function<number, T_>;
        put(arg0: number, arg1: number): number;
        remove(arg0: number): number;
        remove(arg0: any): number;
        defaultReturnValue(): number;
        defaultReturnValue(arg0: number): void;
        andThenDouble(arg0: Internal.Byte2DoubleFunction_): Internal.Double2DoubleFunction;
        andThenObject<T_>(arg0: Internal.Byte2ObjectFunction_<T_>): Internal.Double2ObjectFunction<T_>;
        get(arg0: any): number;
        get(arg0: number): number;
        andThenLong(arg0: Internal.Byte2LongFunction_): Internal.Double2LongFunction;
        composeLong(arg0: Internal.Long2DoubleFunction_): Internal.Long2ByteFunction;
        andThenByte(arg0: Internal.Byte2ByteFunction_): Internal.Double2ByteFunction;
        andThenFloat(arg0: Internal.Byte2FloatFunction_): Internal.Double2FloatFunction;
        applyAsInt(arg0: number): number;
        apply(arg0: number): number;
        containsKey(arg0: any): boolean;
        containsKey(arg0: number): boolean;
        composeInt(arg0: Internal.Int2DoubleFunction_): Internal.Int2ByteFunction;
        clear(): void;
        composeFloat(arg0: Internal.Float2DoubleFunction_): Internal.Float2ByteFunction;
        andThenChar(arg0: Internal.Byte2CharFunction_): Internal.Double2CharFunction;
        composeObject<T_>(arg0: Internal.Object2DoubleFunction_<T_>): Internal.Object2ByteFunction<T_>;
        size(): number;
        compose<T_>(arg0: java_.util.function_.Function_<T_, number>): java_.util.function_.Function<T_, number>;
        composeShort(arg0: Internal.Short2DoubleFunction_): Internal.Short2ByteFunction;
        andThenReference<T_>(arg0: Internal.Byte2ReferenceFunction_<T_>): Internal.Double2ReferenceFunction<T_>;
        composeChar(arg0: Internal.Char2DoubleFunction_): Internal.Char2ByteFunction;
        composeDouble(arg0: Internal.Double2DoubleFunction_): Internal.Double2ByteFunction;
    }
    type Double2ByteFunction_ = ((arg0: number) => number) | Double2ByteFunction;
    class JobAttributes$DialogType extends Internal.AttributeValue {
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        notifyAll(): void;
        equals(arg0: any): boolean;
        notify(): void;
        static readonly NATIVE : Internal.JobAttributes$DialogType;
        static readonly COMMON : Internal.JobAttributes$DialogType;
        static readonly NONE : Internal.JobAttributes$DialogType;
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    type JobAttributes$DialogType_ = JobAttributes$DialogType;
    interface Callable {
        call(arg0: Internal.Context_, arg1: Internal.Scriptable_, arg2: Internal.Scriptable_, arg3: any[]): any;
    }
    type Callable_ = Callable;
    abstract class AbstractLongCollection extends Internal.AbstractCollection<number> implements Internal.LongCollection {
        getClass(): Internal.Class<any>;
        longIterator(): Internal.LongIterator;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        notifyAll(): void;
        notify(): void;
        remove(arg0: any): boolean;
        removeAll(arg0: Internal.LongCollection_): boolean;
        removeAll(arg0: Internal.Collection_<any>): boolean;
        iterator(): Internal.LongIterator;
        stream(): Internal.Stream<number>;
        hashCode(): number;
        toArray(arg0: number[]): number[];
        toArray(): any[];
        toArray<T_>(arg0: T_[]): T_[];
        toArray<T_>(arg0: Internal.IntFunction_<T_[]>): T_[];
        longStream(): Internal.LongStream;
        parallelStream(): Internal.Stream<number>;
        rem(arg0: number): boolean;
        add(arg0: number): boolean;
        longSpliterator(): Internal.LongSpliterator;
        toLongArray(arg0: number[]): number[];
        toLongArray(): number[];
        spliterator(): Internal.LongSpliterator;
        forEach(arg0: Internal.LongConsumer_): void;
        forEach(arg0: Internal.Consumer_<number>): void;
        forEach(arg0: java_.util.function_.LongConsumer_): void;
        containsAll(arg0: Internal.Collection_<any>): boolean;
        containsAll(arg0: Internal.LongCollection_): boolean;
        isEmpty(): boolean;
        clear(): void;
        longParallelStream(): Internal.LongStream;
        removeIf(arg0: it.unimi.dsi.fastutil.longs.LongPredicate_): boolean;
        removeIf(arg0: Internal.Predicate_<number>): boolean;
        removeIf(arg0: Internal.LongPredicate_): boolean;
        contains(arg0: number): boolean;
        contains(arg0: any): boolean;
        size(): number;
        addAll(arg0: Internal.LongCollection_): boolean;
        addAll(arg0: Internal.Collection_<number>): boolean;
        equals(arg0: any): boolean;
        toString(): string;
        retainAll(arg0: Internal.Collection_<any>): boolean;
        retainAll(arg0: Internal.LongCollection_): boolean;
        get class(): Internal.Class<any>;
        get empty(): boolean;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    type AbstractLongCollection_ = AbstractLongCollection;
    abstract class AbstractInt2ObjectMap <V> extends Internal.AbstractInt2ObjectFunction<V> implements Internal.Int2ObjectMap<V>, Internal.Serializable {
        getClass(): Internal.Class<any>;
        getOrDefault(arg0: number, arg1: V): V;
        getOrDefault(arg0: any, arg1: V): V;
        replace(arg0: number, arg1: V, arg2: V): boolean;
        replace(arg0: number, arg1: V): V;
        composeByte(arg0: Internal.Byte2IntFunction_): Internal.Byte2ObjectFunction<V>;
        andThen<V_>(arg0: java_.util.function_.Function_<V, V_>): java_.util.function_.Function<number, V_>;
        composeReference<T_>(arg0: Internal.Reference2IntFunction_<T_>): Internal.Reference2ObjectFunction<T_, V>;
        put(arg0: number, arg1: V): V;
        containsValue(arg0: any): boolean;
        compute(arg0: number, arg1: Internal.BiFunction_<number, V, V>): V;
        defaultReturnValue(arg0: V): void;
        defaultReturnValue(): V;
        andThenObject<T_>(arg0: Internal.Object2ObjectFunction_<V, T_>): Internal.Int2ObjectFunction<T_>;
        merge(arg0: number, arg1: V, arg2: Internal.BiFunction_<V, V, V>): V;
        composeLong(arg0: Internal.Long2IntFunction_): Internal.Long2ObjectFunction<V>;
        entrySet(): Internal.ObjectSet<Internal.Map$Entry<number, V>>;
        containsKey(arg0: number): boolean;
        containsKey(arg0: any): boolean;
        composeObject<T_>(arg0: Internal.Object2IntFunction_<T_>): Internal.Object2ObjectFunction<T_, V>;
        size(): number;
        compose<T_>(arg0: java_.util.function_.Function_<T_, number>): java_.util.function_.Function<T_, V>;
        composeShort(arg0: Internal.Short2IntFunction_): Internal.Short2ObjectFunction<V>;
        composeChar(arg0: Internal.Char2IntFunction_): Internal.Char2ObjectFunction<V>;
        composeDouble(arg0: Internal.Double2IntFunction_): Internal.Double2ObjectFunction<V>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        computeIfAbsent(arg0: number, arg1: Internal.Int2ObjectFunction_<V>): V;
        computeIfAbsent(arg0: number, arg1: Internal.IntFunction_<V>): V;
        computeIfAbsent(arg0: number, arg1: java_.util.function_.Function_<number, V>): V;
        notifyAll(): void;
        values(): Internal.ObjectCollection<V>;
        andThenShort(arg0: Internal.Object2ShortFunction_<V>): Internal.Int2ShortFunction;
        computeIfAbsentPartial(arg0: number, arg1: Internal.Int2ObjectFunction_<V>): V;
        replaceAll(arg0: Internal.BiFunction_<number, V, V>): void;
        andThenInt(arg0: Internal.Object2IntFunction_<V>): Internal.Int2IntFunction;
        remove(arg0: any): V;
        remove(arg0: number): V;
        remove(arg0: number, arg1: any): boolean;
        remove(arg0: any, arg1: any): boolean;
        notify(): void;
        andThenDouble(arg0: Internal.Object2DoubleFunction_<V>): Internal.Int2DoubleFunction;
        int2ObjectEntrySet(): Internal.ObjectSet<Internal.Int2ObjectMap$Entry<V>>;
        hashCode(): number;
        get(arg0: any): V;
        get(arg0: number): V;
        putAll(arg0: Internal.Map_<number, V>): void;
        andThenLong(arg0: Internal.Object2LongFunction_<V>): Internal.Int2LongFunction;
        keySet(): Internal.IntSet;
        andThenByte(arg0: Internal.Object2ByteFunction_<V>): Internal.Int2ByteFunction;
        andThenFloat(arg0: Internal.Object2FloatFunction_<V>): Internal.Int2FloatFunction;
        apply(arg0: number): V;
        forEach(arg0: Internal.BiConsumer_<number, V>): void;
        composeInt(arg0: Internal.Int2IntFunction_): Internal.Int2ObjectFunction<V>;
        clear(): void;
        isEmpty(): boolean;
        composeFloat(arg0: Internal.Float2IntFunction_): Internal.Float2ObjectFunction<V>;
        andThenChar(arg0: Internal.Object2CharFunction_<V>): Internal.Int2CharFunction;
        computeIfPresent(arg0: number, arg1: Internal.BiFunction_<number, V, V>): V;
        equals(arg0: any): boolean;
        andThenReference<T_>(arg0: Internal.Object2ReferenceFunction_<V, T_>): Internal.Int2ReferenceFunction<T_>;
        toString(): string;
        putIfAbsent(arg0: number, arg1: V): V;
        get class(): Internal.Class<any>;
        get empty(): boolean;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    type AbstractInt2ObjectMap_<V> = AbstractInt2ObjectMap<V>;
    interface Cloneable {
    }
    type Cloneable_ = Cloneable;
    interface NarratableEntry extends Internal.NarrationSupplier {
    }
    type NarratableEntry_ = NarratableEntry;
    interface FuncSupplier$Func1 extends Internal.FuncSupplier {
        create(args: Internal.List_<dev.latvian.mods.rhino.util.unit.Unit_>): dev.latvian.mods.rhino.util.unit.Unit;
        create1(arg0: dev.latvian.mods.rhino.util.unit.Unit_): dev.latvian.mods.rhino.util.unit.Unit;
    }
    type FuncSupplier$Func1_ = ((arg0: dev.latvian.mods.rhino.util.unit.Unit) => dev.latvian.mods.rhino.util.unit.Unit) | FuncSupplier$Func1;
    class JsonReader implements Internal.Closeable {
        skipValue(): void;
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        isLenient(): boolean;
        notifyAll(): void;
        hasNext(): boolean;
        nextInt(): number;
        nextString(): string;
        endArray(): void;
        nextLong(): number;
        setLenient(arg0: boolean): void;
        notify(): void;
        nextDouble(): number;
        endObject(): void;
        peek(): Internal.JsonToken;
        beginArray(): void;
        beginObject(): void;
        hashCode(): number;
        equals(arg0: any): boolean;
        getPath(): string;
        toString(): string;
        nextBoolean(): boolean;
        nextName(): string;
        close(): void;
        nextNull(): void;
        get path(): string;
        get class(): Internal.Class<any>;
        get lenient(): boolean;
        set lenient(arg0: boolean);
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    type JsonReader_ = JsonReader;
    class WeightedReward implements Internal.Comparable<Internal.WeightedReward> {
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        hashCode(): number;
        notifyAll(): void;
        equals(arg0: any): boolean;
        toString(): string;
        compareTo(o: Internal.WeightedReward_): number;
        notify(): void;
        static chanceString(weight: number, totalWeight: number, empty: boolean): string;
        static chanceString(weight: number, totalWeight: number): string;
        readonly reward : Internal.Reward;
        weight : number;
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    type WeightedReward_ = WeightedReward;
    class VarHandle$AccessMode extends Internal.Enum<Internal.VarHandle$AccessMode> {
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        static valueOf(arg0: string): Internal.VarHandle$AccessMode;
        static valueOf<T_>(arg0: Internal.Class_<T_>, arg1: string): T_;
        notifyAll(): void;
        static values(): Internal.VarHandle$AccessMode[];
        methodName(): string;
        compareTo(arg0: Internal.VarHandle$AccessMode_): number;
        describeConstable(): Internal.Optional<Internal.Enum$EnumDesc<Internal.VarHandle$AccessMode>>;
        notify(): void;
        getDeclaringClass(): Internal.Class<Internal.VarHandle$AccessMode>;
        hashCode(): number;
        equals(arg0: any): boolean;
        static valueFromMethodName(arg0: string): Internal.VarHandle$AccessMode;
        name(): string;
        toString(): string;
        ordinal(): number;
        static readonly WEAK_COMPARE_AND_SET : Internal.VarHandle$AccessMode;
        static readonly GET_VOLATILE : Internal.VarHandle$AccessMode;
        static readonly SET : Internal.VarHandle$AccessMode;
        static readonly GET_AND_BITWISE_OR_ACQUIRE : Internal.VarHandle$AccessMode;
        static readonly GET_AND_ADD : Internal.VarHandle$AccessMode;
        static readonly GET_AND_SET : Internal.VarHandle$AccessMode;
        static readonly GET_ACQUIRE : Internal.VarHandle$AccessMode;
        static readonly GET_AND_ADD_RELEASE : Internal.VarHandle$AccessMode;
        static readonly GET_AND_BITWISE_AND_ACQUIRE : Internal.VarHandle$AccessMode;
        static readonly GET_AND_BITWISE_XOR_ACQUIRE : Internal.VarHandle$AccessMode;
        static readonly GET_AND_ADD_ACQUIRE : Internal.VarHandle$AccessMode;
        static readonly GET_AND_BITWISE_OR_RELEASE : Internal.VarHandle$AccessMode;
        static readonly SET_OPAQUE : Internal.VarHandle$AccessMode;
        static readonly WEAK_COMPARE_AND_SET_ACQUIRE : Internal.VarHandle$AccessMode;
        static readonly COMPARE_AND_SET : Internal.VarHandle$AccessMode;
        static readonly COMPARE_AND_EXCHANGE_ACQUIRE : Internal.VarHandle$AccessMode;
        static readonly GET_AND_BITWISE_AND : Internal.VarHandle$AccessMode;
        static readonly SET_VOLATILE : Internal.VarHandle$AccessMode;
        static readonly COMPARE_AND_EXCHANGE_RELEASE : Internal.VarHandle$AccessMode;
        static readonly GET_AND_BITWISE_XOR : Internal.VarHandle$AccessMode;
        static readonly WEAK_COMPARE_AND_SET_PLAIN : Internal.VarHandle$AccessMode;
        static readonly SET_RELEASE : Internal.VarHandle$AccessMode;
        static readonly COMPARE_AND_EXCHANGE : Internal.VarHandle$AccessMode;
        static readonly GET_AND_BITWISE_OR : Internal.VarHandle$AccessMode;
        static readonly GET_AND_BITWISE_AND_RELEASE : Internal.VarHandle$AccessMode;
        static readonly WEAK_COMPARE_AND_SET_RELEASE : Internal.VarHandle$AccessMode;
        static readonly GET_AND_SET_RELEASE : Internal.VarHandle$AccessMode;
        static readonly GET : Internal.VarHandle$AccessMode;
        static readonly GET_AND_SET_ACQUIRE : Internal.VarHandle$AccessMode;
        static readonly GET_AND_BITWISE_XOR_RELEASE : Internal.VarHandle$AccessMode;
        static readonly GET_OPAQUE : Internal.VarHandle$AccessMode;
        get class(): Internal.Class<any>;
        get declaringClass(): Internal.Class<Internal.VarHandle$AccessMode>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    type VarHandle$AccessMode_ = "weak_compare_and_set_acquire" | "get_acquire" | "get_and_bitwise_xor_release" | "get_and_set_acquire" | "get_and_set_release" | "get_and_bitwise_or_release" | "compare_and_exchange_release" | "get" | "get_and_add_acquire" | "get_and_bitwise_and_acquire" | "get_and_bitwise_or" | "set" | "set_release" | "compare_and_exchange_acquire" | "compare_and_exchange" | "set_opaque" | "get_and_bitwise_or_acquire" | "get_opaque" | "compare_and_set" | "get_volatile" | "set_volatile" | "weak_compare_and_set" | "get_and_bitwise_xor_acquire" | "get_and_bitwise_and_release" | "get_and_bitwise_and" | "weak_compare_and_set_release" | "get_and_add_release" | "weak_compare_and_set_plain" | "get_and_set" | "get_and_add" | "get_and_bitwise_xor" | VarHandle$AccessMode;
    interface LootContextAccessor {
        repurposedstructures_setQueriedLootTableId(arg0: ResourceLocation_): void;
    }
    type LootContextAccessor_ = LootContextAccessor;
    class ShapedRecipeJS extends Internal.RecipeJS {
        parseResultItemList(o: any): Internal.List<Internal.ItemStackJS>;
        getClass(): Internal.Class<any>;
        ingredientAction(filter: Internal.IngredientActionFilter_, action: Internal.IngredientAction_): Internal.RecipeJS;
        convertReplacedInput(index: number, oldIngredient: Internal.IngredientJS_, newIngredient: Internal.IngredientJS_): Internal.IngredientJS;
        noShrink(): Internal.ShapedRecipeJS;
        getUniqueId(): string;
        replaceOutput(i: Internal.IngredientJS_, with_: Internal.ItemStackJS_, exact: boolean): boolean;
        replaceOutput(i: Internal.IngredientJS_, with_: Internal.ItemStackJS_, exact: boolean, func: Internal.BiFunction_<Internal.ItemStackJS_, Internal.ItemStackJS_, Internal.ItemStackJS_>): boolean;
        parseIngredientItemList(o: any): Internal.List<Internal.IngredientJS>;
        merge(data: any): Internal.RecipeJS;
        noMirror(): Internal.ShapedRecipeJS;
        getPath(): string;
        create(args: Internal.ListJS_): void;
        parseIngredientItemStackList(o: any): Internal.List<Internal.IngredientStackJS>;
        id(_id: ResourceLocation_): Internal.RecipeJS;
        parseIngredientItem(o: any, key: string): Internal.IngredientJS;
        parseIngredientItem(o: any): Internal.IngredientJS;
        group(g: string): Internal.RecipeJS;
        getOriginalRecipeResult(): Internal.ItemStackJS;
        getOriginalRecipeIngredients(): Internal.List<Internal.IngredientJS>;
        getInputIndex(ingredient: Internal.IngredientJS_, exact: boolean): number;
        setGroup(g: string): void;
        serialize(): void;
        replaceInput(i: Internal.IngredientJS_, with_: Internal.IngredientJS_, exact: boolean, func: Internal.BiFunction_<Internal.IngredientJS_, Internal.IngredientJS_, Internal.IngredientJS_>): boolean;
        replaceInput(i: Internal.IngredientJS_, with_: Internal.IngredientJS_, exact: boolean): boolean;
        getType(): string;
        getGroup(): string;
        hasOutput(ingredient: Internal.IngredientJS_, exact: boolean): boolean;
        keepIngredient(filter: Internal.IngredientActionFilter_): Internal.RecipeJS;
        customIngredientAction(filter: Internal.IngredientActionFilter_, id: string): Internal.RecipeJS;
        modifyResult(callback: Internal.ModifyRecipeResultCallback_): Internal.RecipeJS;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        getMod(): string;
        notifyAll(): void;
        convertReplacedOutput(index: number, oldStack: Internal.ItemStackJS_, newStack: Internal.ItemStackJS_): Internal.ItemStackJS;
        save(): void;
        damageIngredient(filter: Internal.IngredientActionFilter_): Internal.RecipeJS;
        damageIngredient(filter: Internal.IngredientActionFilter_, damage: number): Internal.RecipeJS;
        getId(): string;
        dontAdd(): void;
        notify(): void;
        serializeJson(): void;
        createRecipe(): Internal.Recipe<any>;
        getFromToString(): string;
        hashCode(): number;
        deserializeJson(): void;
        getOrCreateId(): ResourceLocation;
        deserialize(): void;
        serializeNBTAsJson(): boolean;
        getOutputIndex(ingredient: Internal.IngredientJS_, exact: boolean): number;
        serializeIngredientStack(in_: Internal.IngredientStackJS_): Internal.JsonElement;
        resultFromRecipeJson(json: Internal.JsonObject_): Internal.ItemStackJS;
        stage(s: string): Internal.RecipeJS;
        equals(arg0: any): boolean;
        serializeItemStack(stack: Internal.ItemStackJS_): Internal.JsonElement;
        toString(): string;
        hasInput(ingredient: Internal.IngredientJS_, exact: boolean): boolean;
        parseResultItem(o: any): Internal.ItemStackJS;
        replaceIngredient(filter: Internal.IngredientActionFilter_, item: Internal.ItemStackJS_): Internal.RecipeJS;
        static currentRecipe : Internal.RecipeJS;
        originalJson : Internal.JsonObject;
        serializeOutputs : boolean;
        originalRecipe : Internal.Recipe<any>;
        readonly inputItems : Internal.List<((arg0: Internal.ItemStackJS) => boolean)>;
        static itemErrors : false;
        json : Internal.JsonObject;
        readonly outputItems : Internal.List<Internal.ItemStackJS>;
        type : Internal.RecipeTypeJS;
        serializeInputs : boolean;
        get path(): string;
        get originalRecipeIngredients(): Internal.List<Internal.IngredientJS>;
        get mod(): string;
        get originalRecipeResult(): Internal.ItemStackJS;
        get orCreateId(): ResourceLocation;
        get class(): Internal.Class<any>;
        get fromToString(): string;
        get uniqueId(): string;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    type ShapedRecipeJS_ = ShapedRecipeJS;
    interface Double2ReferenceFunction <V> extends Internal.Function<number, V>, Internal.DoubleFunction<V> {
        getOrDefault(arg0: number, arg1: V): V;
        getOrDefault(arg0: any, arg1: V): V;
        andThenShort(arg0: Internal.Reference2ShortFunction_<V>): Internal.Double2ShortFunction;
        composeByte(arg0: Internal.Byte2DoubleFunction_): Internal.Byte2ReferenceFunction<V>;
        andThenInt(arg0: Internal.Reference2IntFunction_<V>): Internal.Double2IntFunction;
        andThen<V_>(arg0: java_.util.function_.Function_<V, V_>): java_.util.function_.Function<number, V_>;
        composeReference<T_>(arg0: Internal.Reference2DoubleFunction_<T_>): Internal.Reference2ReferenceFunction<T_, V>;
        put(arg0: number, arg1: V): V;
        remove(arg0: any): V;
        remove(arg0: number): V;
        defaultReturnValue(arg0: V): void;
        defaultReturnValue(): V;
        andThenDouble(arg0: Internal.Reference2DoubleFunction_<V>): Internal.Double2DoubleFunction;
        andThenObject<T_>(arg0: Internal.Reference2ObjectFunction_<V, T_>): Internal.Double2ObjectFunction<T_>;
        get(arg0: any): V;
        get(arg0: number): V;
        andThenLong(arg0: Internal.Reference2LongFunction_<V>): Internal.Double2LongFunction;
        composeLong(arg0: Internal.Long2DoubleFunction_): Internal.Long2ReferenceFunction<V>;
        andThenByte(arg0: Internal.Reference2ByteFunction_<V>): Internal.Double2ByteFunction;
        andThenFloat(arg0: Internal.Reference2FloatFunction_<V>): Internal.Double2FloatFunction;
        apply(arg0: number): V;
        containsKey(arg0: any): boolean;
        containsKey(arg0: number): boolean;
        composeInt(arg0: Internal.Int2DoubleFunction_): Internal.Int2ReferenceFunction<V>;
        clear(): void;
        composeFloat(arg0: Internal.Float2DoubleFunction_): Internal.Float2ReferenceFunction<V>;
        andThenChar(arg0: Internal.Reference2CharFunction_<V>): Internal.Double2CharFunction;
        composeObject<T_>(arg0: Internal.Object2DoubleFunction_<T_>): Internal.Object2ReferenceFunction<T_, V>;
        size(): number;
        compose<T_>(arg0: java_.util.function_.Function_<T_, number>): java_.util.function_.Function<T_, V>;
        composeShort(arg0: Internal.Short2DoubleFunction_): Internal.Short2ReferenceFunction<V>;
        andThenReference<T_>(arg0: Internal.Reference2ReferenceFunction_<V, T_>): Internal.Double2ReferenceFunction<T_>;
        composeChar(arg0: Internal.Char2DoubleFunction_): Internal.Char2ReferenceFunction<V>;
        composeDouble(arg0: Internal.Double2DoubleFunction_): Internal.Double2ReferenceFunction<V>;
    }
    type Double2ReferenceFunction_<V> = ((arg0: number) => V) | Double2ReferenceFunction<V>;
    abstract class AbstractChronology implements Internal.Chronology {
        localDateTime(arg0: Internal.TemporalAccessor_): Internal.ChronoLocalDateTime<Internal.ChronoLocalDate>;
        date(arg0: number, arg1: number, arg2: number): Internal.ChronoLocalDate;
        date(arg0: Internal.TemporalAccessor_): Internal.ChronoLocalDate;
        date(arg0: Internal.Era_, arg1: number, arg2: number, arg3: number): Internal.ChronoLocalDate;
        getClass(): Internal.Class<any>;
        period(arg0: number, arg1: number, arg2: number): Internal.ChronoPeriod;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        dateYearDay(arg0: Internal.Era_, arg1: number, arg2: number): Internal.ChronoLocalDate;
        dateYearDay(arg0: number, arg1: number): Internal.ChronoLocalDate;
        getCalendarType(): string;
        resolveDate(arg0: Internal.Map_<Internal.TemporalField_, number>, arg1: Internal.ResolverStyle_): Internal.ChronoLocalDate;
        notifyAll(): void;
        isLeapYear(arg0: number): boolean;
        range(arg0: Internal.ChronoField_): Internal.ValueRange;
        dateEpochDay(arg0: number): Internal.ChronoLocalDate;
        getId(): string;
        compareTo(arg0: Internal.Chronology_): number;
        dateNow(): Internal.ChronoLocalDate;
        dateNow(arg0: Internal.ZoneId_): Internal.ChronoLocalDate;
        dateNow(arg0: Internal.Clock_): Internal.ChronoLocalDate;
        notify(): void;
        eraOf(arg0: number): Internal.Era;
        eras(): Internal.List<Internal.Era>;
        prolepticYear(arg0: Internal.Era_, arg1: number): number;
        zonedDateTime(arg0: Internal.TemporalAccessor_): Internal.ChronoZonedDateTime<Internal.ChronoLocalDate>;
        zonedDateTime(arg0: Internal.Instant_, arg1: Internal.ZoneId_): Internal.ChronoZonedDateTime<Internal.ChronoLocalDate>;
        getDisplayName(arg0: Internal.TextStyle_, arg1: Internal.Locale_): string;
        hashCode(): number;
        equals(arg0: any): boolean;
        epochSecond(arg0: number, arg1: number, arg2: number, arg3: number, arg4: number, arg5: number, arg6: Internal.ZoneOffset_): number;
        epochSecond(arg0: Internal.Era_, arg1: number, arg2: number, arg3: number, arg4: number, arg5: number, arg6: number, arg7: Internal.ZoneOffset_): number;
        toString(): string;
        get calendarType(): string;
        get id(): string;
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    type AbstractChronology_ = AbstractChronology;
    interface PropertyChangeListener extends Internal.EventListener {
        propertyChange(arg0: Internal.PropertyChangeEvent_): void;
    }
    type PropertyChangeListener_ = PropertyChangeListener;
    class OptionalDouble {
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        notifyAll(): void;
        isEmpty(): boolean;
        isPresent(): boolean;
        getAsDouble(): number;
        orElse(arg0: number): number;
        notify(): void;
        orElseThrow<X>(arg0: Internal.Supplier_<X>): number;
        orElseThrow(): number;
        static empty(): Internal.OptionalDouble;
        orElseGet(arg0: Internal.DoubleSupplier_): number;
        stream(): Internal.DoubleStream;
        hashCode(): number;
        ifPresentOrElse(arg0: java_.util.function_.DoubleConsumer_, arg1: Internal.Runnable_): void;
        ifPresent(arg0: java_.util.function_.DoubleConsumer_): void;
        static of(arg0: number): Internal.OptionalDouble;
        equals(arg0: any): boolean;
        toString(): string;
        get asDouble(): number;
        get present(): boolean;
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    type OptionalDouble_ = OptionalDouble;
    class MinMaxBounds$Doubles extends Internal.MinMaxBounds<number> implements Internal.DoublesAccess {
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        hashCode(): number;
        notifyAll(): void;
        equals(arg0: any): boolean;
        toString(): string;
        notify(): void;
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    type MinMaxBounds$Doubles_ = MinMaxBounds$Doubles;
    interface IForgeMinecraft {
        popGuiLayer(): void;
        pushGuiLayer(arg0: Internal.Screen_): void;
    }
    type IForgeMinecraft_ = IForgeMinecraft;
    interface FlavorMap {
        getNativesForFlavors(arg0: Internal.DataFlavor_[]): Internal.Map<Internal.DataFlavor, string>;
        getFlavorsForNatives(arg0: string[]): Internal.Map<string, Internal.DataFlavor>;
    }
    type FlavorMap_ = FlavorMap;
    interface ChannelPromise extends Internal.ChannelFuture, Internal.Promise<void> {
        cancel(arg0: boolean): boolean;
        unvoid(): Internal.ChannelPromise;
        isCancelled(): boolean;
        removeListeners(arg0: Internal.GenericFutureListener_<io.netty.util.concurrent.Future_<void>>[]): Internal.ChannelPromise;
        removeListeners(arg0: Internal.GenericFutureListener_<io.netty.util.concurrent.Future_<void>>[]): Internal.ChannelFuture;
        removeListeners(arg0: Internal.GenericFutureListener_<io.netty.util.concurrent.Future_<void>>[]): io.netty.util.concurrent.Future<void>;
        removeListeners(arg0: Internal.GenericFutureListener_<io.netty.util.concurrent.Future_<void>>[]): Internal.Promise<void>;
        getNow(): void;
        channel(): io.netty.channel.Channel;
        cause(): Internal.Throwable;
        awaitUninterruptibly(): Internal.ChannelPromise;
        awaitUninterruptibly(): Internal.ChannelFuture;
        awaitUninterruptibly(): io.netty.util.concurrent.Future<void>;
        awaitUninterruptibly(): Internal.Promise<void>;
        awaitUninterruptibly(arg0: number, arg1: Internal.TimeUnit_): boolean;
        awaitUninterruptibly(arg0: number): boolean;
        removeListener(arg0: Internal.GenericFutureListener_<io.netty.util.concurrent.Future_<void>>): Internal.ChannelPromise;
        removeListener(arg0: Internal.GenericFutureListener_<io.netty.util.concurrent.Future_<void>>): Internal.ChannelFuture;
        removeListener(arg0: Internal.GenericFutureListener_<io.netty.util.concurrent.Future_<void>>): io.netty.util.concurrent.Future<void>;
        removeListener(arg0: Internal.GenericFutureListener_<io.netty.util.concurrent.Future_<void>>): Internal.Promise<void>;
        tryFailure(arg0: Internal.Throwable_): boolean;
        isDone(): boolean;
        sync(): Internal.ChannelPromise;
        sync(): Internal.ChannelFuture;
        sync(): io.netty.util.concurrent.Future<void>;
        sync(): Internal.Promise<void>;
        setSuccess(): Internal.ChannelPromise;
        setSuccess(arg0: void): Internal.ChannelPromise;
        setSuccess(arg0: void): Internal.Promise<void>;
        setFailure(arg0: Internal.Throwable_): Internal.ChannelPromise;
        setFailure(arg0: Internal.Throwable_): Internal.Promise<void>;
        isVoid(): boolean;
        trySuccess(): boolean;
        trySuccess(arg0: void): boolean;
        syncUninterruptibly(): Internal.ChannelPromise;
        syncUninterruptibly(): Internal.ChannelFuture;
        syncUninterruptibly(): io.netty.util.concurrent.Future<void>;
        syncUninterruptibly(): Internal.Promise<void>;
        get(arg0: number, arg1: Internal.TimeUnit_): void;
        get(): void;
        isCancellable(): boolean;
        await(): Internal.ChannelPromise;
        await(): Internal.ChannelFuture;
        await(): io.netty.util.concurrent.Future<void>;
        await(): Internal.Promise<void>;
        await(arg0: number, arg1: Internal.TimeUnit_): boolean;
        await(arg0: number): boolean;
        addListeners(arg0: Internal.GenericFutureListener_<io.netty.util.concurrent.Future_<void>>[]): Internal.ChannelPromise;
        addListeners(arg0: Internal.GenericFutureListener_<io.netty.util.concurrent.Future_<void>>[]): Internal.ChannelFuture;
        addListeners(arg0: Internal.GenericFutureListener_<io.netty.util.concurrent.Future_<void>>[]): io.netty.util.concurrent.Future<void>;
        addListeners(arg0: Internal.GenericFutureListener_<io.netty.util.concurrent.Future_<void>>[]): Internal.Promise<void>;
        setUncancellable(): boolean;
        isSuccess(): boolean;
        addListener(arg0: Internal.GenericFutureListener_<io.netty.util.concurrent.Future_<void>>): Internal.ChannelPromise;
        addListener(arg0: Internal.GenericFutureListener_<io.netty.util.concurrent.Future_<void>>): Internal.ChannelFuture;
        addListener(arg0: Internal.GenericFutureListener_<io.netty.util.concurrent.Future_<void>>): io.netty.util.concurrent.Future<void>;
        addListener(arg0: Internal.GenericFutureListener_<io.netty.util.concurrent.Future_<void>>): Internal.Promise<void>;
    }
    type ChannelPromise_ = ChannelPromise;
    class TeamData {
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        clearCachedProgress(): void;
        setCanEdit(mode: boolean): boolean;
        notifyAll(): void;
        setProgress(task: Internal.Task_, progress: number): void;
        save(): void;
        resetProgress(task: Internal.Task_): void;
        getProgress(task: Internal.Task_): number;
        getProgress(task: number): number;
        notify(): void;
        getCanEdit(): boolean;
        serializeNBT(): Internal.SNBTCompoundTag;
        getRewardClaimTime(player: Internal.UUID_, reward: Internal.Reward_): Internal.Date;
        getClaimType(player: Internal.UUID_, reward: Internal.Reward_): Internal.RewardClaimType;
        hashCode(): number;
        deleteReward(reward: Internal.Reward_): void;
        canStartTasks(quest: Internal.Quest_): boolean;
        setStarted(id: number, time: Internal.Date_): boolean;
        isLocked(): boolean;
        static get(player: Internal.Player_): Internal.TeamData;
        getStartedTime(id: number): Internal.Date;
        setAutoPin(auto: boolean): void;
        getCompletedTime(id: number): Internal.Date;
        write(buffer: Internal.FriendlyByteBuf_, self: boolean): void;
        isCompleted(object: Internal.QuestObject_): boolean;
        setQuestPinned(id: number, pinned: boolean): void;
        isQuestPinned(id: number): boolean;
        read(buffer: Internal.FriendlyByteBuf_, self: boolean): void;
        hasUnclaimedRewards(player: Internal.UUID_, object: Internal.QuestObject_): boolean;
        getRelativeProgress(object: Internal.QuestObject_): number;
        checkAutoCompletion(quest: Internal.Quest_): void;
        deserializeNBT(nbt: Internal.SNBTCompoundTag_): void;
        isStarted(object: Internal.QuestObject_): boolean;
        setCompleted(id: number, time: Internal.Date_): boolean;
        addProgress(task: Internal.Task_, p: number): void;
        setLocked(b: boolean): boolean;
        copyData(from: Internal.TeamData_): void;
        mergeData(from: Internal.TeamData_): void;
        resetReward(player: Internal.UUID_, reward: Internal.Reward_): boolean;
        areDependenciesComplete(quest: Internal.Quest_): boolean;
        getOnlineMembers(): Internal.List<Internal.ServerPlayer>;
        equals(arg0: any): boolean;
        isRewardClaimed(player: Internal.UUID_, reward: Internal.Reward_): boolean;
        getAutoPin(): boolean;
        claimReward(player: Internal.ServerPlayer_, reward: Internal.Reward_, notify: boolean): void;
        claimReward(player: Internal.UUID_, reward: Internal.Reward_, date: number): boolean;
        toString(): string;
        file : Internal.QuestFile;
        readonly pinnedQuests : Internal.LongOpenHashSet;
        static VERSION : 1;
        name : string;
        shouldSave : boolean;
        readonly uuid : Internal.UUID;
        get onlineMembers(): Internal.List<Internal.ServerPlayer>;
        get canEdit(): boolean;
        get locked(): boolean;
        get class(): Internal.Class<any>;
        get autoPin(): boolean;
        set canEdit(mode: boolean);
        set locked(b: boolean);
        set autoPin(auto: boolean);
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    type TeamData_ = TeamData;
    abstract class ColorSpace implements Internal.Serializable {
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        toCIEXYZ(arg0: number[]): number[];
        getName(arg0: number): string;
        fromCIEXYZ(arg0: number[]): number[];
        toRGB(arg0: number[]): number[];
        getNumComponents(): number;
        getMaxValue(arg0: number): number;
        notifyAll(): void;
        notify(): void;
        fromRGB(arg0: number[]): number[];
        getMinValue(arg0: number): number;
        isCS_sRGB(): boolean;
        getType(): number;
        hashCode(): number;
        equals(arg0: any): boolean;
        toString(): string;
        static getInstance(arg0: number): Internal.ColorSpace;
        static readonly TYPE_ECLR : 24;
        static readonly TYPE_Lab : 1;
        static readonly TYPE_Luv : 2;
        static readonly TYPE_RGB : 5;
        static readonly TYPE_GRAY : 6;
        static readonly TYPE_CMY : 11;
        static readonly TYPE_CCLR : 22;
        static readonly TYPE_ACLR : 20;
        static readonly TYPE_HSV : 7;
        static readonly TYPE_YCbCr : 3;
        static readonly TYPE_7CLR : 17;
        static readonly CS_LINEAR_RGB : 1004;
        static readonly TYPE_9CLR : 19;
        static readonly TYPE_5CLR : 15;
        static readonly CS_sRGB : 1000;
        static readonly TYPE_3CLR : 13;
        static readonly CS_PYCC : 1002;
        static readonly TYPE_XYZ : 0;
        static readonly TYPE_FCLR : 25;
        static readonly TYPE_DCLR : 23;
        static readonly TYPE_HLS : 8;
        static readonly TYPE_CMYK : 9;
        static readonly TYPE_BCLR : 21;
        static readonly CS_GRAY : 1003;
        static readonly TYPE_8CLR : 18;
        static readonly TYPE_6CLR : 16;
        static readonly TYPE_4CLR : 14;
        static readonly TYPE_Yxy : 4;
        static readonly TYPE_2CLR : 12;
        static readonly CS_CIEXYZ : 1001;
        get cS_sRGB(): boolean;
        get type(): number;
        get class(): Internal.Class<any>;
        get numComponents(): number;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    type ColorSpace_ = ColorSpace;
    class AddAttributesFunction$Builder implements Internal.LootItemFunction$Builder {
        add(arg0: Internal.AddAttributesFunction$Modifier_): Internal.AddAttributesFunction$Builder;
        add(arg0: Internal.Attribute_, arg1: Internal.NumberProvider_, arg2: Internal.Consumer_<Internal.AddAttributesFunction$Modifier$Builder_>): Internal.AddAttributesFunction$Builder;
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        forSlots(arg0: number, arg1: Internal.Attribute_, arg2: Internal.NumberProvider_, arg3: EquipmentSlot_[]): Internal.AddAttributesFunction$Builder;
        forSlots(arg0: Internal.Attribute_, arg1: Internal.NumberProvider_, arg2: EquipmentSlot_[]): Internal.AddAttributesFunction$Builder;
        preserveDefaults(arg0: boolean): Internal.AddAttributesFunction$Builder;
        build(): Internal.AddAttributesFunction;
        hashCode(): number;
        notifyAll(): void;
        equals(arg0: any): boolean;
        toString(): string;
        simple(arg0: Internal.Attribute_, arg1: Internal.NumberProvider_): Internal.AddAttributesFunction$Builder;
        simple(arg0: number, arg1: Internal.Attribute_, arg2: Internal.NumberProvider_): Internal.AddAttributesFunction$Builder;
        notify(): void;
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    type AddAttributesFunction$Builder_ = AddAttributesFunction$Builder;
    interface ContextAction <T> {
        run(arg0: Internal.Context_): T;
    }
    type ContextAction_<T> = ContextAction<T>;
    class AccessibleState extends Internal.AccessibleBundle {
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        toDisplayString(): string;
        toDisplayString(arg0: Internal.Locale_): string;
        hashCode(): number;
        notifyAll(): void;
        equals(arg0: any): boolean;
        toString(): string;
        notify(): void;
        static readonly ACTIVE : Internal.AccessibleState;
        static readonly MANAGES_DESCENDANTS : Internal.AccessibleState;
        static readonly EDITABLE : Internal.AccessibleState;
        static readonly FOCUSED : Internal.AccessibleState;
        static readonly CHECKED : Internal.AccessibleState;
        static readonly VISIBLE : Internal.AccessibleState;
        static readonly PRESSED : Internal.AccessibleState;
        static readonly SINGLE_LINE : Internal.AccessibleState;
        static readonly VERTICAL : Internal.AccessibleState;
        static readonly COLLAPSED : Internal.AccessibleState;
        static readonly INDETERMINATE : Internal.AccessibleState;
        static readonly ARMED : Internal.AccessibleState;
        static readonly SHOWING : Internal.AccessibleState;
        static readonly FOCUSABLE : Internal.AccessibleState;
        static readonly BUSY : Internal.AccessibleState;
        static readonly EXPANDED : Internal.AccessibleState;
        static readonly MULTISELECTABLE : Internal.AccessibleState;
        static readonly ICONIFIED : Internal.AccessibleState;
        static readonly RESIZABLE : Internal.AccessibleState;
        static readonly SELECTABLE : Internal.AccessibleState;
        static readonly EXPANDABLE : Internal.AccessibleState;
        static readonly MODAL : Internal.AccessibleState;
        static readonly SELECTED : Internal.AccessibleState;
        static readonly TRUNCATED : Internal.AccessibleState;
        static readonly OPAQUE : Internal.AccessibleState;
        static readonly ENABLED : Internal.AccessibleState;
        static readonly HORIZONTAL : Internal.AccessibleState;
        static readonly TRANSIENT : Internal.AccessibleState;
        static readonly MULTI_LINE : Internal.AccessibleState;
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    type AccessibleState_ = AccessibleState;
    class AddSpawnProperties {
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        setCategory(s: string): void;
        hashCode(): number;
        notifyAll(): void;
        equals(arg0: any): boolean;
        toString(): string;
        notify(): void;
        setEntity(s: string): void;
        biomes : ((arg0: Internal.BiomeModifications$BiomeContext) => boolean);
        weight : number;
        _category : Internal.MobCategory;
        minCount : number;
        maxCount : number;
        _entity : Internal.EntityType<any>;
        get class(): Internal.Class<any>;
        set category(s: string);
        set entity(s: string);
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    type AddSpawnProperties_ = AddSpawnProperties;
    interface IForgeLevel extends Internal.ICapabilityProvider {
        getCapability<T_>(arg0: Internal.Capability_<T_>, arg1: Internal.Direction_): Internal.LazyOptional<T_>;
        getCapability<T_>(arg0: Internal.Capability_<T_>): Internal.LazyOptional<T_>;
        increaseMaxEntityRadius(arg0: number): number;
        getMaxEntityRadius(): number;
    }
    type IForgeLevel_ = IForgeLevel;
    interface IScheduledEventCallback {
        onCallback(arg0: Internal.ScheduledEvent_): void;
    }
    type IScheduledEventCallback_ = ((arg0: Internal.ScheduledEvent) => void) | IScheduledEventCallback;
    interface IdEnumerationIterator {
        enumerationIteratorNext(arg0: Internal.Context_, arg1: Internal.Consumer_<any>): boolean;
        enumerationIteratorHasNext(arg0: Internal.Context_, arg1: Internal.Consumer_<any>): boolean;
    }
    type IdEnumerationIterator_ = IdEnumerationIterator;
    class TextAttribute extends Internal.AttributedCharacterIterator$Attribute {
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        hashCode(): number;
        notifyAll(): void;
        equals(arg0: any): boolean;
        toString(): string;
        notify(): void;
        static readonly WEIGHT_BOLD : 2.0;
        static readonly UNDERLINE_LOW_GRAY : 4;
        static readonly NUMERIC_SHAPING : Internal.TextAttribute;
        static readonly WIDTH_SEMI_CONDENSED : 0.875;
        static readonly WIDTH_REGULAR : 1.0;
        static readonly SWAP_COLORS : Internal.TextAttribute;
        static readonly WIDTH_SEMI_EXTENDED : 1.25;
        static readonly RUN_DIRECTION : Internal.TextAttribute;
        static readonly WIDTH_EXTENDED : 1.5;
        static readonly CHAR_REPLACEMENT : Internal.TextAttribute;
        static readonly BIDI_EMBEDDING : Internal.TextAttribute;
        static readonly UNDERLINE_LOW_DASHED : 5;
        static readonly INPUT_METHOD_HIGHLIGHT : Internal.TextAttribute;
        static readonly STRIKETHROUGH_ON : true;
        static readonly TRANSFORM : Internal.TextAttribute;
        static readonly WEIGHT : Internal.TextAttribute;
        static readonly SWAP_COLORS_ON : true;
        static readonly JUSTIFICATION_FULL : 1.0;
        static readonly LANGUAGE : Internal.AttributedCharacterIterator$Attribute;
        static readonly WEIGHT_HEAVY : 2.25;
        static readonly SIZE : Internal.TextAttribute;
        static readonly POSTURE_REGULAR : 0.0;
        static readonly KERNING_ON : 1;
        static readonly BACKGROUND : Internal.TextAttribute;
        static readonly RUN_DIRECTION_LTR : false;
        static readonly RUN_DIRECTION_RTL : true;
        static readonly WIDTH_CONDENSED : 0.75;
        static readonly LIGATURES_ON : 1;
        static readonly SUPERSCRIPT : Internal.TextAttribute;
        static readonly JUSTIFICATION : Internal.TextAttribute;
        static readonly KERNING : Internal.TextAttribute;
        static readonly WEIGHT_SEMIBOLD : 1.25;
        static readonly INPUT_METHOD_SEGMENT : Internal.AttributedCharacterIterator$Attribute;
        static readonly LIGATURES : Internal.TextAttribute;
        static readonly WEIGHT_DEMILIGHT : 0.875;
        static readonly WEIGHT_ULTRABOLD : 2.75;
        static readonly JUSTIFICATION_NONE : 0.0;
        static readonly UNDERLINE_LOW_ONE_PIXEL : 1;
        static readonly UNDERLINE_ON : 0;
        static readonly POSTURE_OBLIQUE : 0.2;
        static readonly WEIGHT_REGULAR : 1.0;
        static readonly WIDTH : Internal.TextAttribute;
        static readonly SUPERSCRIPT_SUPER : 1;
        static readonly UNDERLINE : Internal.TextAttribute;
        static readonly FAMILY : Internal.TextAttribute;
        static readonly WEIGHT_LIGHT : 0.75;
        static readonly POSTURE : Internal.TextAttribute;
        static readonly TRACKING_LOOSE : 0.04;
        static readonly WEIGHT_EXTRA_LIGHT : 0.5;
        static readonly TRACKING : Internal.TextAttribute;
        static readonly READING : Internal.AttributedCharacterIterator$Attribute;
        static readonly INPUT_METHOD_UNDERLINE : Internal.TextAttribute;
        static readonly TRACKING_TIGHT : -0.04;
        static readonly UNDERLINE_LOW_DOTTED : 3;
        static readonly SUPERSCRIPT_SUB : -1;
        static readonly FONT : Internal.TextAttribute;
        static readonly FOREGROUND : Internal.TextAttribute;
        static readonly STRIKETHROUGH : Internal.TextAttribute;
        static readonly WEIGHT_DEMIBOLD : 1.75;
        static readonly WEIGHT_EXTRABOLD : 2.5;
        static readonly WEIGHT_MEDIUM : 1.5;
        static readonly UNDERLINE_LOW_TWO_PIXEL : 2;
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    type TextAttribute_ = TextAttribute;
    class CommandContextBuilder <S> {
        withChild(arg0: Internal.CommandContextBuilder_<S>): Internal.CommandContextBuilder<S>;
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        withNode(arg0: Internal.CommandNode_<S>, arg1: Internal.StringRange_): Internal.CommandContextBuilder<S>;
        getNodes(): Internal.List<Internal.ParsedCommandNode<S>>;
        getCommand(): Internal.Command<S>;
        notifyAll(): void;
        getDispatcher(): Internal.CommandDispatcher<S>;
        getChild(): Internal.CommandContextBuilder<S>;
        withArgument(arg0: string, arg1: Internal.ParsedArgument_<S, any>): Internal.CommandContextBuilder<S>;
        withCommand(arg0: Internal.Command_<S>): Internal.CommandContextBuilder<S>;
        notify(): void;
        getLastChild(): Internal.CommandContextBuilder<S>;
        findSuggestionContext(arg0: number): Internal.SuggestionContext<S>;
        build(arg0: string): Internal.CommandContext<S>;
        hashCode(): number;
        getRange(): Internal.StringRange;
        getSource(): S;
        equals(arg0: any): boolean;
        getArguments(): Internal.Map<string, Internal.ParsedArgument<S, any>>;
        toString(): string;
        withSource(arg0: S): Internal.CommandContextBuilder<S>;
        copy(): Internal.CommandContextBuilder<S>;
        getRootNode(): Internal.CommandNode<S>;
        get nodes(): Internal.List<Internal.ParsedCommandNode<S>>;
        get lastChild(): Internal.CommandContextBuilder<S>;
        get range(): Internal.StringRange;
        get arguments(): Internal.Map<string, Internal.ParsedArgument<S, any>>;
        get source(): S;
        get class(): Internal.Class<any>;
        get dispatcher(): Internal.CommandDispatcher<S>;
        get command(): Internal.Command<S>;
        get child(): Internal.CommandContextBuilder<S>;
        get rootNode(): Internal.CommandNode<S>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    type CommandContextBuilder_<S> = CommandContextBuilder<S>;
    interface RegistrarBuilder <T> {
        saveToDisc(): Internal.RegistrarBuilder<T>;
        build(): Internal.Registrar<T>;
        syncToClients(): Internal.RegistrarBuilder<T>;
        option(arg0: Internal.RegistrarOption_): Internal.RegistrarBuilder<T>;
    }
    type RegistrarBuilder_<T> = RegistrarBuilder<T>;
    class Vec2 {
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        hashCode(): number;
        notifyAll(): void;
        equals(arg0: any): boolean;
        toString(): string;
        notify(): void;
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    type Vec2_ = Vec2;
    interface TypeAdapterFactory {
        create<T>(arg0: Internal.Gson_, arg1: Internal.TypeToken_<T>): Internal.TypeAdapter<T>;
    }
    type TypeAdapterFactory_ = TypeAdapterFactory;
    abstract class FileStore {
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        getUsableSpace(): number;
        notifyAll(): void;
        type(): string;
        notify(): void;
        getTotalSpace(): number;
        getAttribute(arg0: string): any;
        isReadOnly(): boolean;
        getBlockSize(): number;
        hashCode(): number;
        supportsFileAttributeView(arg0: Internal.Class_<Internal.FileAttributeView_>): boolean;
        supportsFileAttributeView(arg0: string): boolean;
        equals(arg0: any): boolean;
        name(): string;
        toString(): string;
        getUnallocatedSpace(): number;
        getFileStoreAttributeView<V>(arg0: Internal.Class_<V>): V;
        get unallocatedSpace(): number;
        get readOnly(): boolean;
        get usableSpace(): number;
        get totalSpace(): number;
        get class(): Internal.Class<any>;
        get blockSize(): number;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    type FileStore_ = FileStore;
    class AttributedCharacterIterator$Attribute implements Internal.Serializable {
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        hashCode(): number;
        notifyAll(): void;
        equals(arg0: any): boolean;
        toString(): string;
        notify(): void;
        static readonly LANGUAGE : Internal.AttributedCharacterIterator$Attribute;
        static readonly INPUT_METHOD_SEGMENT : Internal.AttributedCharacterIterator$Attribute;
        static readonly READING : Internal.AttributedCharacterIterator$Attribute;
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    type AttributedCharacterIterator$Attribute_ = AttributedCharacterIterator$Attribute;
    abstract class LongBuffer extends Internal.Buffer implements Internal.Comparable<Internal.LongBuffer> {
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        compact(): Internal.LongBuffer;
        notifyAll(): void;
        compareTo(arg0: Internal.LongBuffer_): number;
        notify(): void;
        asReadOnlyBuffer(): Internal.LongBuffer;
        put(arg0: number[]): Internal.LongBuffer;
        put(arg0: number, arg1: number[], arg2: number, arg3: number): Internal.LongBuffer;
        put(arg0: number, arg1: number[]): Internal.LongBuffer;
        put(arg0: number[], arg1: number, arg2: number): Internal.LongBuffer;
        put(arg0: number, arg1: Internal.LongBuffer_, arg2: number, arg3: number): Internal.LongBuffer;
        put(arg0: Internal.LongBuffer_): Internal.LongBuffer;
        put(arg0: number, arg1: number): Internal.LongBuffer;
        put(arg0: number): Internal.LongBuffer;
        capacity(): number;
        isReadOnly(): boolean;
        slice(arg0: number, arg1: number): Internal.LongBuffer;
        slice(): Internal.LongBuffer;
        array(): number[];
        hashCode(): number;
        get(): number;
        get(arg0: number, arg1: number[]): Internal.LongBuffer;
        get(arg0: number): number;
        get(arg0: number, arg1: number[], arg2: number, arg3: number): Internal.LongBuffer;
        get(arg0: number[], arg1: number, arg2: number): Internal.LongBuffer;
        get(arg0: number[]): Internal.LongBuffer;
        limit(arg0: number): Internal.LongBuffer;
        limit(): number;
        arrayOffset(): number;
        flip(): Internal.LongBuffer;
        order(): Internal.ByteOrder;
        hasArray(): boolean;
        hasRemaining(): boolean;
        clear(): Internal.LongBuffer;
        duplicate(): Internal.LongBuffer;
        remaining(): number;
        static allocate(arg0: number): Internal.LongBuffer;
        rewind(): Internal.LongBuffer;
        mismatch(arg0: Internal.LongBuffer_): number;
        equals(arg0: any): boolean;
        reset(): Internal.LongBuffer;
        toString(): string;
        position(arg0: number): Internal.LongBuffer;
        position(): number;
        isDirect(): boolean;
        static wrap(arg0: number[]): Internal.LongBuffer;
        static wrap(arg0: number[], arg1: number, arg2: number): Internal.LongBuffer;
        mark(): Internal.LongBuffer;
        get direct(): boolean;
        get readOnly(): boolean;
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    type LongBuffer_ = LongBuffer;
    interface VerticalAnchor {
    }
    type VerticalAnchor_ = VerticalAnchor;
    interface ITooltipCallback <T> {
        onTooltip(arg0: number, arg1: boolean, arg2: T, arg3: Internal.List_<Internal.Component_>): void;
    }
    type ITooltipCallback_<T> = ((arg0: number, arg1: boolean, arg2: T, arg3: Internal.List<Internal.Component>) => void) | ITooltipCallback<T>;
    interface Boolean2CharFunction extends Internal.Function<boolean, string> {
        getOrDefault(arg0: any, arg1: string): string;
        getOrDefault(arg0: boolean, arg1: string): string;
        andThenShort(arg0: Internal.Char2ShortFunction_): Internal.Boolean2ShortFunction;
        composeByte(arg0: Internal.Byte2BooleanFunction_): Internal.Byte2CharFunction;
        andThenInt(arg0: Internal.Char2IntFunction_): Internal.Boolean2IntFunction;
        composeReference<T_>(arg0: Internal.Reference2BooleanFunction_<T_>): Internal.Reference2CharFunction<T_>;
        andThen<T_>(arg0: java_.util.function_.Function_<string, T_>): java_.util.function_.Function<boolean, T_>;
        put(arg0: boolean, arg1: string): string;
        remove(arg0: any): string;
        remove(arg0: boolean): string;
        defaultReturnValue(): string;
        defaultReturnValue(arg0: string): void;
        andThenDouble(arg0: Internal.Char2DoubleFunction_): Internal.Boolean2DoubleFunction;
        andThenObject<T_>(arg0: Internal.Char2ObjectFunction_<T_>): Internal.Boolean2ObjectFunction<T_>;
        get(arg0: any): string;
        get(arg0: boolean): string;
        andThenLong(arg0: Internal.Char2LongFunction_): Internal.Boolean2LongFunction;
        composeLong(arg0: Internal.Long2BooleanFunction_): Internal.Long2CharFunction;
        andThenByte(arg0: Internal.Char2ByteFunction_): Internal.Boolean2ByteFunction;
        andThenFloat(arg0: Internal.Char2FloatFunction_): Internal.Boolean2FloatFunction;
        apply(arg0: boolean): string;
        containsKey(arg0: boolean): boolean;
        containsKey(arg0: any): boolean;
        composeInt(arg0: Internal.Int2BooleanFunction_): Internal.Int2CharFunction;
        clear(): void;
        composeFloat(arg0: Internal.Float2BooleanFunction_): Internal.Float2CharFunction;
        andThenChar(arg0: Internal.Char2CharFunction_): Internal.Boolean2CharFunction;
        composeObject<T_>(arg0: Internal.Object2BooleanFunction_<T_>): Internal.Object2CharFunction<T_>;
        size(): number;
        compose<T_>(arg0: java_.util.function_.Function_<T_, boolean>): java_.util.function_.Function<T_, string>;
        composeShort(arg0: Internal.Short2BooleanFunction_): Internal.Short2CharFunction;
        andThenReference<T_>(arg0: Internal.Char2ReferenceFunction_<T_>): Internal.Boolean2ReferenceFunction<T_>;
        composeChar(arg0: Internal.Char2BooleanFunction_): Internal.Char2CharFunction;
        composeDouble(arg0: Internal.Double2BooleanFunction_): Internal.Double2CharFunction;
    }
    type Boolean2CharFunction_ = ((arg0: boolean) => string) | Boolean2CharFunction;
    interface WindowEventHandler {
    }
    type WindowEventHandler_ = WindowEventHandler;
    class BlockComponent extends Internal.Block implements Internal.IBlockRendererProvider, Internal.EntityBlock {
        getClass(): Internal.Class<any>;
        rotate(arg0: Internal.BlockState_, arg1: Internal.LevelAccessor_, arg2: BlockPos_, arg3: Internal.Rotation_): Internal.BlockState;
        getStateAtViewpoint(arg0: Internal.BlockState_, arg1: Internal.BlockGetter_, arg2: BlockPos_, arg3: Vec3_): Internal.BlockState;
        onBlockExploded(arg0: Internal.BlockState_, arg1: Internal.Level_, arg2: BlockPos_, arg3: Internal.Explosion_): void;
        getBedDirection(arg0: Internal.BlockState_, arg1: Internal.LevelReader_, arg2: BlockPos_): Internal.Direction;
        isBed(arg0: Internal.BlockState_, arg1: Internal.BlockGetter_, arg2: BlockPos_, arg3: Internal.Entity_): boolean;
        canHarvestBlock(arg0: Internal.BlockState_, arg1: Internal.BlockGetter_, arg2: BlockPos_, arg3: Internal.Player_): boolean;
        makesOpenTrapdoorAboveClimbable(arg0: Internal.BlockState_, arg1: Internal.LevelReader_, arg2: BlockPos_, arg3: Internal.BlockState_): boolean;
        isLadder(arg0: Internal.BlockState_, arg1: Internal.LevelReader_, arg2: BlockPos_, arg3: Internal.LivingEntity_): boolean;
        shouldDisplayFluidOverlay(arg0: Internal.BlockState_, arg1: Internal.BlockAndTintGetter_, arg2: BlockPos_, arg3: Internal.FluidState_): boolean;
        canStickTo(arg0: Internal.BlockState_, arg1: Internal.BlockState_): boolean;
        onNeighborChange(arg0: Internal.BlockState_, arg1: Internal.LevelReader_, arg2: BlockPos_, arg3: BlockPos_): void;
        getWeakChanges(arg0: Internal.BlockState_, arg1: Internal.LevelReader_, arg2: BlockPos_): boolean;
        canEntityDestroy(arg0: Internal.BlockState_, arg1: Internal.BlockGetter_, arg2: BlockPos_, arg3: Internal.Entity_): boolean;
        isBurning(arg0: Internal.BlockState_, arg1: Internal.BlockGetter_, arg2: BlockPos_): boolean;
        getFriction(arg0: Internal.BlockState_, arg1: Internal.LevelReader_, arg2: BlockPos_, arg3: Internal.Entity_): number;
        isValidSpawn(arg0: Internal.BlockState_, arg1: Internal.BlockGetter_, arg2: BlockPos_, arg3: Internal.SpawnPlacements$Type_, arg4: Internal.EntityType_<any>): boolean;
        isPortalFrame(arg0: Internal.BlockState_, arg1: Internal.BlockGetter_, arg2: BlockPos_): boolean;
        getExplosionResistance(arg0: Internal.BlockState_, arg1: Internal.BlockGetter_, arg2: BlockPos_, arg3: Internal.Explosion_): number;
        isScaffolding(arg0: Internal.BlockState_, arg1: Internal.LevelReader_, arg2: BlockPos_, arg3: Internal.LivingEntity_): boolean;
        canSustainPlant(arg0: Internal.BlockState_, arg1: Internal.BlockGetter_, arg2: BlockPos_, arg3: Internal.Direction_, arg4: Internal.IPlantable_): boolean;
        canDropFromExplosion(arg0: Internal.BlockState_, arg1: Internal.BlockGetter_, arg2: BlockPos_, arg3: Internal.Explosion_): boolean;
        isStickyBlock(arg0: Internal.BlockState_): boolean;
        isFertile(arg0: Internal.BlockState_, arg1: Internal.BlockGetter_, arg2: BlockPos_): boolean;
        getAiPathNodeType(arg0: Internal.BlockState_, arg1: Internal.BlockGetter_, arg2: BlockPos_, arg3: Internal.Mob_): Internal.BlockPathTypes;
        getBlockBuilderKJS(): Internal.BlockBuilder;
        isSlimeBlock(arg0: Internal.BlockState_): boolean;
        getRegistryType(): Internal.Class<Internal.Block>;
        getFireSpreadSpeed(arg0: Internal.BlockState_, arg1: Internal.BlockGetter_, arg2: BlockPos_, arg3: Internal.Direction_): number;
        getComponent(arg0: Internal.BlockGetter_, arg1: BlockPos_): Internal.IComponent;
        getToolModifiedState(arg0: Internal.BlockState_, arg1: Internal.Level_, arg2: BlockPos_, arg3: Internal.Player_, arg4: Internal.ItemStack_, arg5: Internal.ToolAction_): Internal.BlockState;
        getToolModifiedState(arg0: Internal.BlockState_, arg1: Internal.UseOnContext_, arg2: Internal.ToolAction_, arg3: boolean): Internal.BlockState;
        getBeaconColorMultiplier(arg0: Internal.BlockState_, arg1: Internal.LevelReader_, arg2: BlockPos_, arg3: BlockPos_): number[];
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        getExpDrop(arg0: Internal.BlockState_, arg1: Internal.LevelReader_, arg2: BlockPos_, arg3: number, arg4: number): number;
        isConduitFrame(arg0: Internal.BlockState_, arg1: Internal.LevelReader_, arg2: BlockPos_, arg3: BlockPos_): boolean;
        notifyAll(): void;
        getLightEmission(arg0: Internal.BlockState_, arg1: Internal.BlockGetter_, arg2: BlockPos_): number;
        onDestroyedByPlayer(arg0: Internal.BlockState_, arg1: Internal.Level_, arg2: BlockPos_, arg3: Internal.Player_, arg4: boolean, arg5: Internal.FluidState_): boolean;
        getId(): string;
        getLightingMap(arg0: Internal.BlockAndTintGetter_, arg1: Internal.BlockState_, arg2: BlockPos_): number;
        shouldCheckWeakPower(arg0: Internal.BlockState_, arg1: Internal.LevelReader_, arg2: BlockPos_, arg3: Internal.Direction_): boolean;
        collisionExtendsVertically(arg0: Internal.BlockState_, arg1: Internal.BlockGetter_, arg2: BlockPos_, arg3: Internal.Entity_): boolean;
        notify(): void;
        supportsExternalFaceHiding(arg0: Internal.BlockState_): boolean;
        addLandingEffects(arg0: Internal.BlockState_, arg1: Internal.ServerLevel_, arg2: BlockPos_, arg3: Internal.BlockState_, arg4: Internal.LivingEntity_, arg5: number): boolean;
        getRenderPropertiesInternal(): any;
        getSoundType(arg0: Internal.BlockState_, arg1: Internal.LevelReader_, arg2: BlockPos_, arg3: Internal.Entity_): Internal.SoundType;
        hashCode(): number;
        addRunningEffects(arg0: Internal.BlockState_, arg1: Internal.Level_, arg2: BlockPos_, arg3: Internal.Entity_): boolean;
        hidesNeighborFace(arg0: Internal.BlockGetter_, arg1: BlockPos_, arg2: Internal.BlockState_, arg3: Internal.BlockState_, arg4: Internal.Direction_): boolean;
        initializeClient(arg0: Internal.Consumer_<Internal.IBlockRenderProperties_>): void;
        getCloneItemStack(arg0: Internal.BlockState_, arg1: Internal.HitResult_, arg2: Internal.BlockGetter_, arg3: BlockPos_, arg4: Internal.Player_): Internal.ItemStack;
        getBlockStatesKJS(): Internal.List<Internal.BlockState>;
        isFlammable(arg0: Internal.BlockState_, arg1: Internal.BlockGetter_, arg2: BlockPos_, arg3: Internal.Direction_): boolean;
        getRenderer(arg0: Internal.BlockState_, arg1: BlockPos_, arg2: Internal.BlockAndTintGetter_): Internal.IRenderer;
        onCaughtFire(arg0: Internal.BlockState_, arg1: Internal.Level_, arg2: BlockPos_, arg3: Internal.Direction_, arg4: Internal.LivingEntity_): void;
        getEnchantPowerBonus(arg0: Internal.BlockState_, arg1: Internal.LevelReader_, arg2: BlockPos_): number;
        getRegistryName(): ResourceLocation;
        setBedOccupied(arg0: Internal.BlockState_, arg1: Internal.Level_, arg2: BlockPos_, arg3: Internal.LivingEntity_, arg4: boolean): void;
        setRegistryName(arg0: ResourceLocation_): Internal.Block;
        setRegistryName(arg0: string): Internal.Block;
        setRegistryName(arg0: string, arg1: string): Internal.Block;
        isFireSource(arg0: Internal.BlockState_, arg1: Internal.LevelReader_, arg2: BlockPos_, arg3: Internal.Direction_): boolean;
        getRespawnPosition(arg0: Internal.BlockState_, arg1: Internal.EntityType_<any>, arg2: Internal.LevelReader_, arg3: BlockPos_, arg4: number, arg5: Internal.LivingEntity_): Internal.Optional<Vec3>;
        equals(arg0: any): boolean;
        setBlockBuilderKJS(b: Internal.BlockBuilder_): void;
        canConnectRedstone(arg0: Internal.BlockState_, arg1: Internal.BlockGetter_, arg2: BlockPos_, arg3: Internal.Direction_): boolean;
        getTypeData(): Internal.CompoundTag;
        toString(): string;
        getFlammability(arg0: Internal.BlockState_, arg1: Internal.BlockGetter_, arg2: BlockPos_, arg3: Internal.Direction_): number;
        readonly delegate : Internal.IRegistryDelegate<Internal.Block>;
        definition : Internal.ComponentDefinition;
        get registryType(): Internal.Class<Internal.Block>;
        get blockBuilderKJS(): Internal.BlockBuilder;
        get renderPropertiesInternal(): any;
        get blockStatesKJS(): Internal.List<Internal.BlockState>;
        get id(): string;
        get registryName(): ResourceLocation;
        get typeData(): Internal.CompoundTag;
        get class(): Internal.Class<any>;
        set blockBuilderKJS(b: Internal.BlockBuilder_);
        set registryName(arg0: ResourceLocation_);
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    type BlockComponent_ = BlockComponent;
    interface DataInput {
        readLine(): string;
        readChar(): string;
        skipBytes(arg0: number): number;
        readLong(): number;
        readUTF(): string;
        readShort(): number;
        readDouble(): number;
        readFully(arg0: number[]): void;
        readFully(arg0: number[], arg1: number, arg2: number): void;
        readFloat(): number;
        readBoolean(): boolean;
        readByte(): number;
        readInt(): number;
        readUnsignedByte(): number;
        readUnsignedShort(): number;
    }
    type DataInput_ = DataInput;
    /**
    * Fired when the gift loot table (cat, villager, etc.) is registering.
    */
    class GiftLootEventJS extends Internal.LootEventJS {
        cancel(): void;
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        isCancelled(): boolean;
        notifyAll(): void;
        addJson(id: ResourceLocation_, json: Internal.JsonObject_): void;
        notify(): void;
        modify(id: ResourceLocation_, b: Internal.Consumer_<Internal.LootBuilder_>): void;
        removeAll(): void;
        post(t: Internal.ScriptType_, id: string, sub: string): boolean;
        post(t: Internal.ScriptType_, id: string): boolean;
        addGift(id: ResourceLocation_, b: Internal.Consumer_<Internal.LootBuilder_>): void;
        getType(): string;
        hashCode(): number;
        equals(arg0: any): boolean;
        toString(): string;
        getDirectory(): string;
        canCancel(): boolean;
        get cancelled(): boolean;
        get type(): string;
        get class(): Internal.Class<any>;
        get directory(): string;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    /**
    * Fired when the gift loot table (cat, villager, etc.) is registering.
    */
    type GiftLootEventJS_ = GiftLootEventJS;
    class HoverEvent {
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        hashCode(): number;
        notifyAll(): void;
        equals(arg0: any): boolean;
        toString(): string;
        notify(): void;
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    type HoverEvent_ = HoverEvent;
    class Enchantment$Rarity extends Internal.Enum<Internal.Enchantment$Rarity> {
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        static valueOf(arg0: string): Internal.Enchantment$Rarity;
        static valueOf<T_>(arg0: Internal.Class_<T_>, arg1: string): T_;
        notifyAll(): void;
        static values(): Internal.Enchantment$Rarity[];
        compareTo(arg0: Internal.Enchantment$Rarity_): number;
        describeConstable(): Internal.Optional<Internal.Enum$EnumDesc<Internal.Enchantment$Rarity>>;
        notify(): void;
        getDeclaringClass(): Internal.Class<Internal.Enchantment$Rarity>;
        hashCode(): number;
        equals(arg0: any): boolean;
        name(): string;
        toString(): string;
        ordinal(): number;
        static readonly RARE : Internal.Enchantment$Rarity;
        static readonly VERY_RARE : Internal.Enchantment$Rarity;
        static readonly UNCOMMON : Internal.Enchantment$Rarity;
        static readonly COMMON : Internal.Enchantment$Rarity;
        get class(): Internal.Class<any>;
        get declaringClass(): Internal.Class<Internal.Enchantment$Rarity>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    type Enchantment$Rarity_ = "uncommon" | "common" | "rare" | "very_rare" | Enchantment$Rarity;
    interface IModBusEvent {
    }
    type IModBusEvent_ = IModBusEvent;
    interface IVertexConsumer {
        setQuadOrientation(arg0: Internal.Direction_): void;
        setTexture(arg0: Internal.TextureAtlasSprite_): void;
        setApplyDiffuseLighting(arg0: boolean): void;
        setQuadTint(arg0: number): void;
        getVertexFormat(): Internal.VertexFormat;
        put(arg0: number, arg1: number[]): void;
    }
    type IVertexConsumer_ = IVertexConsumer;
    class DeferredRegister <T> implements Internal.Iterable<Internal.RegistrySupplier<T>> {
        getRegistrar(): Internal.Registrar<Internal.RegistrySupplier<Internal.RegistrySupplier<T>>>;
        getRegistries(): Internal.Registries;
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        spliterator(): Internal.Spliterator<Internal.RegistrySupplier<Internal.RegistrySupplier<T>>>;
        forEach(arg0: Internal.Consumer_<Internal.RegistrySupplier_<Internal.RegistrySupplier_<T>>>): void;
        notifyAll(): void;
        notify(): void;
        iterator(): Internal.Iterator<Internal.RegistrySupplier<Internal.RegistrySupplier<Internal.RegistrySupplier<T>>>>;
        hashCode(): number;
        equals(arg0: any): boolean;
        static create<T_>(modId: string, key: Internal.ResourceKey_<Internal.Registry_<T_>>): Internal.DeferredRegister<T_>;
        toString(): string;
        register<R_>(id: ResourceLocation_, supplier: Internal.Supplier_<R_>): Internal.RegistrySupplier<R_>;
        register(): void;
        register<R_>(id: string, supplier: Internal.Supplier_<R_>): Internal.RegistrySupplier<R_>;
        get registrar(): Internal.Registrar<Internal.RegistrySupplier<Internal.RegistrySupplier<T>>>;
        get registries(): Internal.Registries;
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    type DeferredRegister_<T> = DeferredRegister<T>;
    interface Short2LongFunction extends Internal.Function<number, number>, Internal.IntToLongFunction {
        getOrDefault(arg0: any, arg1: number): number;
        getOrDefault(arg0: number, arg1: number): number;
        andThenShort(arg0: Internal.Long2ShortFunction_): Internal.Short2ShortFunction;
        composeByte(arg0: Internal.Byte2ShortFunction_): Internal.Byte2LongFunction;
        andThenInt(arg0: Internal.Long2IntFunction_): Internal.Short2IntFunction;
        composeReference<T_>(arg0: Internal.Reference2ShortFunction_<T_>): Internal.Reference2LongFunction<T_>;
        andThen<T_>(arg0: java_.util.function_.Function_<number, T_>): java_.util.function_.Function<number, T_>;
        put(arg0: number, arg1: number): number;
        remove(arg0: number): number;
        remove(arg0: any): number;
        defaultReturnValue(): number;
        defaultReturnValue(arg0: number): void;
        andThenDouble(arg0: Internal.Long2DoubleFunction_): Internal.Short2DoubleFunction;
        andThenObject<T_>(arg0: Internal.Long2ObjectFunction_<T_>): Internal.Short2ObjectFunction<T_>;
        get(arg0: any): number;
        get(arg0: number): number;
        andThenLong(arg0: Internal.Long2LongFunction_): Internal.Short2LongFunction;
        composeLong(arg0: Internal.Long2ShortFunction_): Internal.Long2LongFunction;
        andThenByte(arg0: Internal.Long2ByteFunction_): Internal.Short2ByteFunction;
        andThenFloat(arg0: Internal.Long2FloatFunction_): Internal.Short2FloatFunction;
        apply(arg0: number): number;
        containsKey(arg0: any): boolean;
        containsKey(arg0: number): boolean;
        composeInt(arg0: Internal.Int2ShortFunction_): Internal.Int2LongFunction;
        clear(): void;
        composeFloat(arg0: Internal.Float2ShortFunction_): Internal.Float2LongFunction;
        andThenChar(arg0: Internal.Long2CharFunction_): Internal.Short2CharFunction;
        applyAsLong(arg0: number): number;
        composeObject<T_>(arg0: Internal.Object2ShortFunction_<T_>): Internal.Object2LongFunction<T_>;
        size(): number;
        compose<T_>(arg0: java_.util.function_.Function_<T_, number>): java_.util.function_.Function<T_, number>;
        composeShort(arg0: Internal.Short2ShortFunction_): Internal.Short2LongFunction;
        andThenReference<T_>(arg0: Internal.Long2ReferenceFunction_<T_>): Internal.Short2ReferenceFunction<T_>;
        composeChar(arg0: Internal.Char2ShortFunction_): Internal.Char2LongFunction;
        composeDouble(arg0: Internal.Double2ShortFunction_): Internal.Double2LongFunction;
    }
    type Short2LongFunction_ = ((arg0: number) => number) | Short2LongFunction;
    interface FloatCollection extends Internal.Collection<number>, Internal.FloatIterable {
        doubleSpliterator(): Internal.DoubleSpliterator;
        toFloatArray(): number[];
        toFloatArray(arg0: number[]): number[];
        remove(arg0: any): boolean;
        removeAll(arg0: Internal.FloatCollection_): boolean;
        removeAll(arg0: Internal.Collection_<any>): boolean;
        iterator(): Internal.FloatIterator;
        stream(): Internal.Stream<number>;
        hashCode(): number;
        toArray(arg0: number[]): number[];
        toArray<T_>(arg0: T_[]): T_[];
        toArray<T_>(arg0: Internal.IntFunction_<T_[]>): T_[];
        toArray(): any[];
        parallelStream(): Internal.Stream<number>;
        rem(arg0: number): boolean;
        doubleIterator(): Internal.DoubleIterator;
        add(arg0: number): boolean;
        spliterator(): Internal.FloatSpliterator;
        forEach(arg0: Internal.Consumer_<number>): void;
        forEach(arg0: Internal.FloatConsumer_): void;
        forEach(arg0: java_.util.function_.DoubleConsumer_): void;
        containsAll(arg0: Internal.FloatCollection_): boolean;
        containsAll(arg0: Internal.Collection_<any>): boolean;
        isEmpty(): boolean;
        clear(): void;
        doubleStream(): Internal.DoubleStream;
        removeIf(arg0: Internal.FloatPredicate_): boolean;
        removeIf(arg0: Internal.Predicate_<number>): boolean;
        removeIf(arg0: java_.util.function_.DoublePredicate_): boolean;
        doubleParallelStream(): Internal.DoubleStream;
        contains(arg0: number): boolean;
        contains(arg0: any): boolean;
        size(): number;
        addAll(arg0: Internal.FloatCollection_): boolean;
        addAll(arg0: Internal.Collection_<number>): boolean;
        equals(arg0: any): boolean;
        retainAll(arg0: Internal.FloatCollection_): boolean;
        retainAll(arg0: Internal.Collection_<any>): boolean;
    }
    type FloatCollection_ = FloatCollection;
    interface ChannelOutboundBuffer$MessageProcessor {
        processMessage(arg0: any): boolean;
    }
    type ChannelOutboundBuffer$MessageProcessor_ = ChannelOutboundBuffer$MessageProcessor;
    interface AccessibleEditableText extends Internal.AccessibleText {
        getSelectionStart(): number;
        getSelectedText(): string;
        replaceText(arg0: number, arg1: number, arg2: string): void;
        cut(arg0: number, arg1: number): void;
        getCharCount(): number;
        selectText(arg0: number, arg1: number): void;
        getBeforeIndex(arg0: number, arg1: number): string;
        setTextContents(arg0: string): void;
        paste(arg0: number): void;
        setAttributes(arg0: number, arg1: number, arg2: Internal.AttributeSet_): void;
        getCaretPosition(): number;
        delete(arg0: number, arg1: number): void;
        getTextRange(arg0: number, arg1: number): string;
        getIndexAtPoint(arg0: Internal.Point_): number;
        getCharacterAttribute(arg0: number): Internal.AttributeSet;
        getAfterIndex(arg0: number, arg1: number): string;
        insertTextAtIndex(arg0: number, arg1: string): void;
        getSelectionEnd(): number;
        getAtIndex(arg0: number, arg1: number): string;
        getCharacterBounds(arg0: number): Internal.Rectangle;
    }
    type AccessibleEditableText_ = AccessibleEditableText;
    class MultiblockShapeInfo$Builder {
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        build(): Internal.MultiblockShapeInfo;
        hashCode(): number;
        notifyAll(): void;
        equals(arg0: any): boolean;
        toString(): string;
        where(arg0: string, arg1: Internal.Supplier_<any>): Internal.MultiblockShapeInfo$Builder;
        where(arg0: string, arg1: Internal.BlockInfo_): Internal.MultiblockShapeInfo$Builder;
        where(arg0: string, arg1: Internal.BlockState_): Internal.MultiblockShapeInfo$Builder;
        aisle(arg0: string[]): Internal.MultiblockShapeInfo$Builder;
        notify(): void;
        shallowCopy(): Internal.MultiblockShapeInfo$Builder;
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    type MultiblockShapeInfo$Builder_ = MultiblockShapeInfo$Builder;
    abstract class CharBuffer extends Internal.Buffer implements Internal.Comparable<Internal.CharBuffer>, Internal.Appendable, Internal.CharSequence, Internal.Readable {
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        compact(): Internal.CharBuffer;
        notifyAll(): void;
        compareTo(arg0: Internal.CharBuffer_): number;
        notify(): void;
        asReadOnlyBuffer(): Internal.CharBuffer;
        put(arg0: Internal.CharBuffer_): Internal.CharBuffer;
        put(arg0: string, arg1: number, arg2: number): Internal.CharBuffer;
        put(arg0: number, arg1: string[]): Internal.CharBuffer;
        put(arg0: number, arg1: string): Internal.CharBuffer;
        put(arg0: number, arg1: string[], arg2: number, arg3: number): Internal.CharBuffer;
        put(arg0: string[]): Internal.CharBuffer;
        put(arg0: string[], arg1: number, arg2: number): Internal.CharBuffer;
        put(arg0: number, arg1: Internal.CharBuffer_, arg2: number, arg3: number): Internal.CharBuffer;
        put(arg0: string): Internal.CharBuffer;
        capacity(): number;
        isReadOnly(): boolean;
        slice(): Internal.CharBuffer;
        slice(arg0: number, arg1: number): Internal.CharBuffer;
        array(): string[];
        hashCode(): number;
        get(): string;
        get(arg0: number): string;
        get(arg0: string[], arg1: number, arg2: number): Internal.CharBuffer;
        get(arg0: string[]): Internal.CharBuffer;
        get(arg0: number, arg1: string[]): Internal.CharBuffer;
        get(arg0: number, arg1: string[], arg2: number, arg3: number): Internal.CharBuffer;
        limit(arg0: number): Internal.CharBuffer;
        limit(): number;
        arrayOffset(): number;
        flip(): Internal.CharBuffer;
        codePoints(): Internal.IntStream;
        order(): Internal.ByteOrder;
        hasArray(): boolean;
        read(arg0: Internal.CharBuffer_): number;
        hasRemaining(): boolean;
        isEmpty(): boolean;
        clear(): Internal.CharBuffer;
        length(): number;
        duplicate(): Internal.CharBuffer;
        subSequence(arg0: number, arg1: number): Internal.CharBuffer;
        remaining(): number;
        static allocate(arg0: number): Internal.CharBuffer;
        rewind(): Internal.CharBuffer;
        mismatch(arg0: Internal.CharBuffer_): number;
        equals(arg0: any): boolean;
        reset(): Internal.CharBuffer;
        toString(): string;
        position(arg0: number): Internal.CharBuffer;
        position(): number;
        isDirect(): boolean;
        static wrap(arg0: string[], arg1: number, arg2: number): Internal.CharBuffer;
        static wrap(arg0: string[]): Internal.CharBuffer;
        static wrap(arg0: Internal.CharSequence_): Internal.CharBuffer;
        static wrap(arg0: Internal.CharSequence_, arg1: number, arg2: number): Internal.CharBuffer;
        mark(): Internal.CharBuffer;
        chars(): Internal.IntStream;
        charAt(arg0: number): string;
        append(arg0: Internal.CharSequence_, arg1: number, arg2: number): Internal.CharBuffer;
        append(arg0: Internal.CharSequence_): Internal.CharBuffer;
        append(arg0: string): Internal.CharBuffer;
        get direct(): boolean;
        get readOnly(): boolean;
        get class(): Internal.Class<any>;
        get empty(): boolean;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    type CharBuffer_ = CharBuffer;
    class AirItem extends Internal.Item {
        getClass(): Internal.Class<any>;
        canElytraFly(arg0: Internal.ItemStack_, arg1: Internal.LivingEntity_): boolean;
        setBurnTime(i: number): void;
        setDamage(arg0: Internal.ItemStack_, arg1: number): void;
        canPerformAction(arg0: Internal.ItemStack_, arg1: Internal.ToolAction_): boolean;
        damageItem<T_>(arg0: Internal.ItemStack_, arg1: number, arg2: T_, arg3: Internal.Consumer_<T_>): number;
        shouldCauseBlockBreakReset(arg0: Internal.ItemStack_, arg1: Internal.ItemStack_): boolean;
        getItemEnchantability(arg0: Internal.ItemStack_): number;
        getPlacer(): Internal.BlockPlacerItem;
        shouldCauseReequipAnimation(arg0: Internal.ItemStack_, arg1: Internal.ItemStack_, arg2: boolean): boolean;
        getXpRepairRatio(arg0: Internal.ItemStack_): number;
        readShareTag(arg0: Internal.ItemStack_, arg1: Internal.CompoundTag_): void;
        handler$bcn000$overrideOtherStackedOnMe(arg0: Internal.ItemStack_, arg1: Internal.ItemStack_, arg2: Internal.Slot_, arg3: Internal.ClickAction_, arg4: Internal.Player_, arg5: Internal.SlotAccess_, arg6: Internal.CallbackInfoReturnable_<any>): void;
        onEntityItemUpdate(arg0: Internal.ItemStack_, arg1: Internal.ItemEntity_): boolean;
        getDamage(arg0: Internal.ItemStack_): number;
        isBookEnchantable(arg0: Internal.ItemStack_, arg1: Internal.ItemStack_): boolean;
        canDisableShield(arg0: Internal.ItemStack_, arg1: Internal.ItemStack_, arg2: Internal.LivingEntity_, arg3: Internal.LivingEntity_): boolean;
        onUsingTick(arg0: Internal.ItemStack_, arg1: Internal.LivingEntity_, arg2: number): void;
        isPiglinCurrency(arg0: Internal.ItemStack_): boolean;
        getCreativeTabs(): Internal.Collection<Internal.CreativeModeTab>;
        createEntity(arg0: Internal.Level_, arg1: Internal.Entity_, arg2: Internal.ItemStack_): Internal.Entity;
        getSweepHitBox(arg0: Internal.ItemStack_, arg1: Internal.Player_, arg2: Internal.Entity_): Internal.AABB;
        isRepairable(arg0: Internal.ItemStack_): boolean;
        getPlaceableBlock(): Internal.Block;
        getShareTag(arg0: Internal.ItemStack_): Internal.CompoundTag;
        getBurnTime(arg0: Internal.ItemStack_, arg1: Internal.RecipeType_<any>): number;
        onDroppedByPlayer(arg0: Internal.ItemStack_, arg1: Internal.Player_): boolean;
        isDamageable(arg0: Internal.ItemStack_): boolean;
        onEntitySwing(arg0: Internal.ItemStack_, arg1: Internal.LivingEntity_): boolean;
        getRegistryType(): Internal.Class<Internal.Item>;
        setItemBuilderKJS(b: Internal.ItemBuilder_): void;
        elytraFlightTick(arg0: Internal.ItemStack_, arg1: Internal.LivingEntity_, arg2: number): boolean;
        getItemBuilderKJS(): Internal.ItemBuilder;
        handler$bcn000$overrideStackedOnOther(arg0: Internal.ItemStack_, arg1: Internal.Slot_, arg2: Internal.ClickAction_, arg3: Internal.Player_, arg4: Internal.CallbackInfoReturnable_<any>): void;
        getAttributeModifiers(arg0: EquipmentSlot_, arg1: Internal.ItemStack_): Internal.Multimap<Internal.Attribute, Internal.AttributeModifier>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        onLeftClickEntity(arg0: Internal.ItemStack_, arg1: Internal.Player_, arg2: Internal.Entity_): boolean;
        canEquip(arg0: Internal.ItemStack_, arg1: EquipmentSlot_, arg2: Internal.Entity_): boolean;
        notifyAll(): void;
        getId(): string;
        notify(): void;
        onBlockStartBreak(arg0: Internal.ItemStack_, arg1: BlockPos_, arg2: Internal.Player_): boolean;
        onHorseArmorTick(arg0: Internal.ItemStack_, arg1: Internal.Level_, arg2: Internal.Mob_): void;
        canContinueUsing(arg0: Internal.ItemStack_, arg1: Internal.ItemStack_): boolean;
        getEntityLifespan(arg0: Internal.ItemStack_, arg1: Internal.Level_): number;
        getRenderPropertiesInternal(): any;
        getArmorTexture(arg0: Internal.ItemStack_, arg1: Internal.Entity_, arg2: EquipmentSlot_, arg3: string): string;
        getDefaultTooltipHideFlags(arg0: Internal.ItemStack_): number;
        hashCode(): number;
        hasCustomEntity(arg0: Internal.ItemStack_): boolean;
        getHighlightTip(arg0: Internal.ItemStack_, arg1: Internal.Component_): Internal.Component;
        canWalkOnPowderedSnow(arg0: Internal.ItemStack_, arg1: Internal.LivingEntity_): boolean;
        initializeClient(arg0: Internal.Consumer_<Internal.IItemRenderProperties_>): void;
        getMaxDamage(arg0: Internal.ItemStack_): number;
        getCreatorModId(arg0: Internal.ItemStack_): string;
        isDamaged(arg0: Internal.ItemStack_): boolean;
        onArmorTick(arg0: Internal.ItemStack_, arg1: Internal.Level_, arg2: Internal.Player_): void;
        hasContainerItem(arg0: Internal.ItemStack_): boolean;
        getFoodProperties(arg0: Internal.ItemStack_, arg1: Internal.LivingEntity_): Internal.FoodProperties;
        doesSneakBypassUse(arg0: Internal.ItemStack_, arg1: Internal.LevelReader_, arg2: BlockPos_, arg3: Internal.Player_): boolean;
        makePlaceable(arg0: Internal.Block_): void;
        onItemUseFirst(arg0: Internal.ItemStack_, arg1: Internal.UseOnContext_): Internal.InteractionResult;
        getContainerItem(arg0: Internal.ItemStack_): Internal.ItemStack;
        getRegistryName(): ResourceLocation;
        setRegistryName(arg0: ResourceLocation_): Internal.Item;
        setRegistryName(arg0: string): Internal.Item;
        setRegistryName(arg0: string, arg1: string): Internal.Item;
        onDestroyed(arg0: Internal.ItemEntity_, arg1: Internal.DamageSource_): void;
        isCorrectToolForDrops(arg0: Internal.ItemStack_, arg1: Internal.BlockState_): boolean;
        getEquipmentSlot(arg0: Internal.ItemStack_): EquipmentSlot;
        getItemStackLimit(arg0: Internal.ItemStack_): number;
        initCapabilities(arg0: Internal.ItemStack_, arg1: Internal.CompoundTag_): Internal.ICapabilityProvider;
        equals(arg0: any): boolean;
        makesPiglinsNeutral(arg0: Internal.ItemStack_, arg1: Internal.LivingEntity_): boolean;
        getTypeData(): Internal.CompoundTag;
        toString(): string;
        isEnderMask(arg0: Internal.ItemStack_, arg1: Internal.Player_, arg2: Internal.EnderMan_): boolean;
        canApplyAtEnchantingTable(arg0: Internal.ItemStack_, arg1: Internal.Enchantment_): boolean;
        readonly delegate : Internal.IRegistryDelegate<Internal.Item>;
        renderProperties : any;
        get registryType(): Internal.Class<Internal.Item>;
        get itemBuilderKJS(): Internal.ItemBuilder;
        get renderPropertiesInternal(): any;
        get placer(): Internal.BlockPlacerItem;
        get placeableBlock(): Internal.Block;
        get creativeTabs(): Internal.Collection<Internal.CreativeModeTab>;
        get id(): string;
        get registryName(): ResourceLocation;
        get typeData(): Internal.CompoundTag;
        get class(): Internal.Class<any>;
        set itemBuilderKJS(b: Internal.ItemBuilder_);
        set burnTime(i: number);
        set registryName(arg0: ResourceLocation_);
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    type AirItem_ = AirItem;
    class Polygon implements Internal.Shape, Internal.Serializable {
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        intersects(arg0: Internal.Rectangle2D_): boolean;
        intersects(arg0: number, arg1: number, arg2: number, arg3: number): boolean;
        notifyAll(): void;
        invalidate(): void;
        inside(arg0: number, arg1: number): boolean;
        getBoundingBox(): Internal.Rectangle;
        notify(): void;
        translate(arg0: number, arg1: number): void;
        addPoint(arg0: number, arg1: number): void;
        getBounds(): Internal.Rectangle;
        contains(arg0: number, arg1: number): boolean;
        contains(arg0: Internal.Point_): boolean;
        contains(arg0: Internal.Point2D_): boolean;
        contains(arg0: number, arg1: number, arg2: number, arg3: number): boolean;
        contains(arg0: Internal.Rectangle2D_): boolean;
        getPathIterator(arg0: Internal.AffineTransform_): Internal.PathIterator;
        getPathIterator(arg0: Internal.AffineTransform_, arg1: number): Internal.PathIterator;
        hashCode(): number;
        equals(arg0: any): boolean;
        getBounds2D(): Internal.Rectangle2D;
        reset(): void;
        toString(): string;
        ypoints : number[];
        xpoints : number[];
        npoints : number;
        get boundingBox(): Internal.Rectangle;
        get bounds(): Internal.Rectangle;
        get bounds2D(): Internal.Rectangle2D;
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    type Polygon_ = Polygon;
    interface Object2ReferenceFunction <K, V> extends Internal.Function<K, V> {
        getOrDefault(arg0: any, arg1: V): V;
        andThenShort(arg0: Internal.Reference2ShortFunction_<V>): Internal.Object2ShortFunction<K>;
        composeByte(arg0: Internal.Byte2ObjectFunction_<K>): Internal.Byte2ReferenceFunction<V>;
        andThenInt(arg0: Internal.Reference2IntFunction_<V>): Internal.Object2IntFunction<K>;
        andThen<V_>(arg0: java_.util.function_.Function_<V, V_>): java_.util.function_.Function<K, V_>;
        composeReference<T_>(arg0: Internal.Reference2ObjectFunction_<T_, K>): Internal.Reference2ReferenceFunction<T_, V>;
        put(arg0: K, arg1: V): V;
        remove(arg0: any): V;
        defaultReturnValue(arg0: V): void;
        defaultReturnValue(): V;
        andThenDouble(arg0: Internal.Reference2DoubleFunction_<V>): Internal.Object2DoubleFunction<K>;
        andThenObject<T_>(arg0: Internal.Reference2ObjectFunction_<V, T_>): Internal.Object2ObjectFunction<K, T_>;
        get(arg0: any): V;
        andThenLong(arg0: Internal.Reference2LongFunction_<V>): Internal.Object2LongFunction<K>;
        composeLong(arg0: Internal.Long2ObjectFunction_<K>): Internal.Long2ReferenceFunction<V>;
        andThenByte(arg0: Internal.Reference2ByteFunction_<V>): Internal.Object2ByteFunction<K>;
        andThenFloat(arg0: Internal.Reference2FloatFunction_<V>): Internal.Object2FloatFunction<K>;
        apply(arg0: K): V;
        containsKey(arg0: any): boolean;
        composeInt(arg0: Internal.Int2ObjectFunction_<K>): Internal.Int2ReferenceFunction<V>;
        clear(): void;
        composeFloat(arg0: Internal.Float2ObjectFunction_<K>): Internal.Float2ReferenceFunction<V>;
        andThenChar(arg0: Internal.Reference2CharFunction_<V>): Internal.Object2CharFunction<K>;
        composeObject<T_>(arg0: Internal.Object2ObjectFunction_<T_, K>): Internal.Object2ReferenceFunction<T_, V>;
        size(): number;
        compose<V_>(arg0: java_.util.function_.Function_<V_, K>): java_.util.function_.Function<V_, V>;
        composeShort(arg0: Internal.Short2ObjectFunction_<K>): Internal.Short2ReferenceFunction<V>;
        andThenReference<T_>(arg0: Internal.Reference2ReferenceFunction_<V, T_>): Internal.Object2ReferenceFunction<K, T_>;
        composeChar(arg0: Internal.Char2ObjectFunction_<K>): Internal.Char2ReferenceFunction<V>;
        composeDouble(arg0: Internal.Double2ObjectFunction_<K>): Internal.Double2ReferenceFunction<V>;
    }
    type Object2ReferenceFunction_<K, V> = ((arg0: any) => V) | Object2ReferenceFunction<K, V>;
    interface IFocus <V> {
        getValue(): V;
        checkedCast<T>(arg0: Internal.IIngredientType_<T>): Internal.Optional<Internal.IFocus<T>>;
        getRole(): Internal.RecipeIngredientRole;
        getTypedValue(): Internal.ITypedIngredient<V>;
        getMode(): Internal.IFocus$Mode;
    }
    type IFocus_<V> = IFocus<V>;
    interface LongToIntFunction {
        applyAsInt(arg0: number): number;
    }
    type LongToIntFunction_ = ((arg0: number) => number) | LongToIntFunction;
    interface DirectoryStream$Filter <T> {
        accept(arg0: T): boolean;
    }
    type DirectoryStream$Filter_<T> = ((arg0: T) => boolean) | DirectoryStream$Filter<T>;
    interface BooleanSupplier {
        getAsBoolean(): boolean;
    }
    type BooleanSupplier_ = (() => boolean) | BooleanSupplier;
    class Thread$State extends Internal.Enum<Internal.Thread$State> {
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        static valueOf(arg0: string): Internal.Thread$State;
        static valueOf<T_>(arg0: Internal.Class_<T_>, arg1: string): T_;
        notifyAll(): void;
        static values(): Internal.Thread$State[];
        compareTo(arg0: Internal.Thread$State_): number;
        describeConstable(): Internal.Optional<Internal.Enum$EnumDesc<Internal.Thread$State>>;
        notify(): void;
        getDeclaringClass(): Internal.Class<Internal.Thread$State>;
        hashCode(): number;
        equals(arg0: any): boolean;
        name(): string;
        toString(): string;
        ordinal(): number;
        static readonly NEW : Internal.Thread$State;
        static readonly TERMINATED : Internal.Thread$State;
        static readonly RUNNABLE : Internal.Thread$State;
        static readonly BLOCKED : Internal.Thread$State;
        static readonly WAITING : Internal.Thread$State;
        static readonly TIMED_WAITING : Internal.Thread$State;
        get class(): Internal.Class<any>;
        get declaringClass(): Internal.Class<Internal.Thread$State>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    type Thread$State_ = "new" | "runnable" | "blocked" | "waiting" | "terminated" | "timed_waiting" | Thread$State;
    class LootActionsBuilderJS implements Internal.LootConditionsContainer<Internal.LootActionsBuilderJS>, Internal.LootFunctionsContainer<Internal.LootActionsBuilderJS>, Internal.LootActionsContainer<Internal.LootActionsBuilderJS> {
        killerPredicate(arg0: Internal.Predicate_<Internal.Entity_>): Internal.LootActionsBuilderJS;
        getClass(): Internal.Class<any>;
        functions(arg0: ItemFilter_, arg1: Internal.Consumer_<Internal.LootFunctionsContainer_<Internal.LootActionsBuilderJS_>>): Internal.LootActionsBuilderJS;
        triggerExplosion(arg0: number, arg1: boolean, arg2: boolean): Internal.LootActionsBuilderJS;
        addAttributes(arg0: Internal.Consumer_<Internal.AddAttributesFunction$Builder_>): Internal.LootActionsBuilderJS;
        createConditions(arg0: Internal.Consumer_<Internal.LootConditionsContainer_<Internal.LootActionsBuilderJS_>>): Internal.List<Internal.ILootCondition>;
        thenRemove(arg0: Internal.IngredientJS_): Internal.LootActionsBuilderJS;
        addCondition(arg0: Internal.ILootCondition_): Internal.LootActionsBuilderJS;
        addCondition(arg0: Internal.LootItemCondition$Builder_): Internal.LootActionsBuilderJS;
        applyBinomialDistributionBonus(arg0: Internal.Enchantment_, arg1: number, arg2: number): Internal.LootActionsBuilderJS;
        getLogName(arg0: string): string;
        directKillerPredicate(arg0: Internal.Predicate_<Internal.Entity_>): Internal.LootActionsBuilderJS;
        thenAddWeighted(arg0: Internal.MinMaxBounds$Ints_, arg1: boolean, arg2: any_[]): Internal.LootActionsBuilderJS;
        thenAddWeighted(arg0: Internal.MinMaxBounds$Ints_, arg1: any_[]): Internal.LootActionsBuilderJS;
        thenAddWeighted(arg0: any_[]): Internal.LootActionsBuilderJS;
        applyOreBonus(arg0: Internal.Enchantment_): Internal.LootActionsBuilderJS;
        matchLoot(arg0: ItemFilter_): Internal.LootActionsBuilderJS;
        matchLoot(arg0: ItemFilter_, arg1: boolean): Internal.LootActionsBuilderJS;
        anyBiome(arg0: Internal.Resolver_[]): Internal.LootActionsBuilderJS;
        entityPredicate(arg0: Internal.Predicate_<Internal.Entity_>): Internal.LootActionsBuilderJS;
        smeltLoot(): Internal.LootActionsBuilderJS;
        thenApply(arg0: Internal.Consumer_<Internal.LootContextJS_>): Internal.LootActionsBuilderJS;
        simulateExplosionDecay(): Internal.LootActionsBuilderJS;
        addWeightedLoot(arg0: any_[]): Internal.LootActionsBuilderJS;
        addWeightedLoot(arg0: Internal.NumberProvider_, arg1: boolean, arg2: any_[]): Internal.LootActionsBuilderJS;
        addWeightedLoot(arg0: Internal.NumberProvider_, arg1: any_[]): Internal.LootActionsBuilderJS;
        anyDimension(arg0: ResourceLocation_[]): Internal.LootActionsBuilderJS;
        killedByPlayer(): Internal.LootActionsBuilderJS;
        addFunction(arg0: Internal.LootItemFunction$Builder_): Internal.LootActionsBuilderJS;
        matchOffHand(arg0: ItemFilter_): Internal.LootActionsBuilderJS;
        randomChance(arg0: number): Internal.LootActionsBuilderJS;
        timeCheck(arg0: number, arg1: number, arg2: number): Internal.LootActionsBuilderJS;
        timeCheck(arg0: number, arg1: number): Internal.LootActionsBuilderJS;
        limitCount(arg0: Internal.NumberProvider_, arg1: Internal.NumberProvider_): Internal.LootActionsBuilderJS;
        playerAction(arg0: Internal.Consumer_<Internal.ServerPlayer_>): Internal.LootActionsBuilderJS;
        pool(arg0: Internal.Consumer_<Internal.LootPoolBuilder_>): Internal.LootActionsBuilderJS;
        weatherCheck(arg0: Internal.Map_<string, boolean>): Internal.LootActionsBuilderJS;
        matchDirectKiller(arg0: Internal.Consumer_<Internal.EntityPredicateBuilderJS_>): Internal.LootActionsBuilderJS;
        addLore(arg0: Internal.Component_[]): Internal.LootActionsBuilderJS;
        modifyLoot(arg0: ItemFilter_, arg1: Internal.ModifyLootAction$Callback_): Internal.LootActionsBuilderJS;
        logName(arg0: string): Internal.LootActionsBuilderJS;
        customCondition(arg0: Internal.JsonObject_): Internal.LootActionsBuilderJS;
        biome(arg0: Internal.Resolver_[]): Internal.LootActionsBuilderJS;
        randomChanceWithLooting(arg0: number, arg1: number): Internal.LootActionsBuilderJS;
        thenLightningStrike(arg0: boolean): Internal.LootActionsBuilderJS;
        removeLoot(arg0: ItemFilter_): Internal.LootActionsBuilderJS;
        addPotion(arg0: Internal.Potion_): Internal.LootActionsBuilderJS;
        enchantRandomly(): Internal.LootActionsBuilderJS;
        enchantRandomly(arg0: Internal.Enchantment_[]): Internal.LootActionsBuilderJS;
        anyStructure(arg0: ResourceLocation_[], arg1: boolean): Internal.LootActionsBuilderJS;
        matchDamageSource(arg0: Internal.Consumer_<Internal.DamageSourcePredicateBuilderJS_>): Internal.LootActionsBuilderJS;
        thenModify(arg0: Internal.IngredientJS_, arg1: java_.util.function_.Function_<Internal.ItemStackJS_, Internal.ItemStackJS_>): Internal.LootActionsBuilderJS;
        setName(arg0: Internal.Component_): Internal.LootActionsBuilderJS;
        enchantWithLevels(arg0: Internal.NumberProvider_): Internal.LootActionsBuilderJS;
        enchantWithLevels(arg0: Internal.NumberProvider_, arg1: boolean): Internal.LootActionsBuilderJS;
        damage(arg0: Internal.NumberProvider_): Internal.LootActionsBuilderJS;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        survivesExplosion(): Internal.LootActionsBuilderJS;
        notifyAll(): void;
        thenAdd(arg0: Internal.ItemStackJS_[]): Internal.LootActionsBuilderJS;
        matchFluid(arg0: Internal.Resolver_): Internal.LootActionsBuilderJS;
        customDistanceToPlayer(arg0: Internal.Consumer_<Internal.DistancePredicateBuilder_>): Internal.LootActionsBuilderJS;
        notify(): void;
        addAction(arg0: Internal.ILootAction_): Internal.LootActionsBuilderJS;
        not(arg0: Internal.Consumer_<Internal.LootConditionsContainer_<Internal.LootActionsBuilderJS_>>): Internal.LootActionsBuilderJS;
        matchEquip(arg0: EquipmentSlot_, arg1: ItemFilter_): Internal.LootActionsBuilderJS;
        and(arg0: Internal.Consumer_<Internal.LootConditionsContainer_<Internal.LootActionsBuilderJS_>>): Internal.LootActionsBuilderJS;
        hashCode(): number;
        thenRollPool(arg0: Internal.MinMaxBounds$Ints_, arg1: Internal.Consumer_<Internal.LootActionsBuilderJS_>): Internal.LootActionsBuilderJS;
        thenRollPool(arg0: Internal.Consumer_<Internal.LootActionsBuilderJS_>): Internal.LootActionsBuilderJS;
        distanceToKiller(arg0: Internal.MinMaxBounds$Doubles_): Internal.LootActionsBuilderJS;
        replaceLoot(arg0: ItemFilter_, arg1: Internal.ItemStack_): Internal.LootActionsBuilderJS;
        applyLootingBonus(arg0: Internal.NumberProvider_): Internal.LootActionsBuilderJS;
        matchEntity(arg0: Internal.Consumer_<Internal.EntityPredicateBuilderJS_>): Internal.LootActionsBuilderJS;
        or(arg0: Internal.Consumer_<Internal.LootConditionsContainer_<Internal.LootActionsBuilderJS_>>): Internal.LootActionsBuilderJS;
        playerPredicate(arg0: Internal.Predicate_<Internal.ServerPlayer_>): Internal.LootActionsBuilderJS;
        apply(arg0: Internal.Consumer_<Internal.LootContextJS_>): Internal.LootActionsBuilderJS;
        triggerLightningStrike(arg0: boolean): Internal.LootActionsBuilderJS;
        applyBonus(arg0: Internal.Enchantment_, arg1: number): Internal.LootActionsBuilderJS;
        addNBT(arg0: Internal.CompoundTag_): Internal.LootActionsBuilderJS;
        addNbt(arg0: Internal.CompoundTag_): Internal.LootActionsBuilderJS;
        replaceLore(arg0: Internal.Component_[]): Internal.LootActionsBuilderJS;
        thenExplode(arg0: number, arg1: boolean, arg2: boolean): Internal.LootActionsBuilderJS;
        matchBlockState(arg0: Internal.Block_, arg1: Internal.Map_<string, string>): Internal.LootActionsBuilderJS;
        addLoot(arg0: Internal.ItemStack_[]): Internal.LootActionsBuilderJS;
        matchMainHand(arg0: ItemFilter_): Internal.LootActionsBuilderJS;
        matchPlayer(arg0: Internal.Consumer_<Internal.EntityPredicateBuilderJS_>): Internal.LootActionsBuilderJS;
        lightLevel(arg0: number, arg1: number): Internal.LootActionsBuilderJS;
        equals(arg0: any): boolean;
        matchKiller(arg0: Internal.Consumer_<Internal.EntityPredicateBuilderJS_>): Internal.LootActionsBuilderJS;
        hasAnyStage(arg0: string[]): Internal.LootActionsBuilderJS;
        toString(): string;
        thenReplace(arg0: Internal.IngredientJS_, arg1: Internal.ItemStackJS_): Internal.LootActionsBuilderJS;
        randomChanceWithEnchantment(arg0: Internal.Enchantment_, arg1: number[]): Internal.LootActionsBuilderJS;
        static readonly DEPRECATED_MSG : "1.18.2-2.3.0 Will be removed in future versions. Please use ";
        get class(): Internal.Class<any>;
        set name(arg0: Internal.Component_);
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    type LootActionsBuilderJS_ = LootActionsBuilderJS;
    interface Int2ByteFunction extends Internal.Function<number, number>, Internal.IntUnaryOperator {
        getOrDefault(arg0: any, arg1: number): number;
        getOrDefault(arg0: number, arg1: number): number;
        andThenShort(arg0: Internal.Byte2ShortFunction_): Internal.Int2ShortFunction;
        composeByte(arg0: Internal.Byte2IntFunction_): Internal.Byte2ByteFunction;
        andThenInt(arg0: Internal.Byte2IntFunction_): Internal.Int2IntFunction;
        composeReference<T_>(arg0: Internal.Reference2IntFunction_<T_>): Internal.Reference2ByteFunction<T_>;
        andThen<T_>(arg0: java_.util.function_.Function_<number, T_>): java_.util.function_.Function<number, T_>;
        andThen(arg0: Internal.IntUnaryOperator_): Internal.IntUnaryOperator;
        put(arg0: number, arg1: number): number;
        remove(arg0: number): number;
        remove(arg0: any): number;
        defaultReturnValue(): number;
        defaultReturnValue(arg0: number): void;
        andThenDouble(arg0: Internal.Byte2DoubleFunction_): Internal.Int2DoubleFunction;
        andThenObject<T_>(arg0: Internal.Byte2ObjectFunction_<T_>): Internal.Int2ObjectFunction<T_>;
        get(arg0: any): number;
        get(arg0: number): number;
        andThenLong(arg0: Internal.Byte2LongFunction_): Internal.Int2LongFunction;
        composeLong(arg0: Internal.Long2IntFunction_): Internal.Long2ByteFunction;
        andThenByte(arg0: Internal.Byte2ByteFunction_): Internal.Int2ByteFunction;
        andThenFloat(arg0: Internal.Byte2FloatFunction_): Internal.Int2FloatFunction;
        applyAsInt(arg0: number): number;
        apply(arg0: number): number;
        containsKey(arg0: any): boolean;
        containsKey(arg0: number): boolean;
        composeInt(arg0: Internal.Int2IntFunction_): Internal.Int2ByteFunction;
        clear(): void;
        composeFloat(arg0: Internal.Float2IntFunction_): Internal.Float2ByteFunction;
        andThenChar(arg0: Internal.Byte2CharFunction_): Internal.Int2CharFunction;
        composeObject<T_>(arg0: Internal.Object2IntFunction_<T_>): Internal.Object2ByteFunction<T_>;
        size(): number;
        compose<T_>(arg0: java_.util.function_.Function_<T_, number>): java_.util.function_.Function<T_, number>;
        compose(arg0: Internal.IntUnaryOperator_): Internal.IntUnaryOperator;
        composeShort(arg0: Internal.Short2IntFunction_): Internal.Short2ByteFunction;
        andThenReference<T_>(arg0: Internal.Byte2ReferenceFunction_<T_>): Internal.Int2ReferenceFunction<T_>;
        composeChar(arg0: Internal.Char2IntFunction_): Internal.Char2ByteFunction;
        composeDouble(arg0: Internal.Double2IntFunction_): Internal.Double2ByteFunction;
    }
    type Int2ByteFunction_ = ((arg0: number) => number) | Int2ByteFunction;
    interface MapLike <T> {
        entries(): Internal.Stream<Internal.Pair<T, T>>;
        get(arg0: T): T;
        get(arg0: string): T;
    }
    type MapLike_<T> = MapLike<T>;
    interface PhasedParticleEngine {
        setParticleRenderingPhase(arg0: Internal.ParticleRenderingPhase_): void;
    }
    type PhasedParticleEngine_ = PhasedParticleEngine;
    interface IntBinaryOperator {
        applyAsInt(arg0: number, arg1: number): number;
    }
    type IntBinaryOperator_ = ((arg0: number, arg1: number) => number) | IntBinaryOperator;
    interface MouseWheelListener extends Internal.EventListener {
        mouseWheelMoved(arg0: Internal.MouseWheelEvent_): void;
    }
    type MouseWheelListener_ = MouseWheelListener;
    /**
    * Fired when you need to modify properties of an item.
    */
    class ItemModificationEventJS extends Internal.EventJS {
        cancel(): void;
        getClass(): Internal.Class<any>;
        modify(in_: Internal.IngredientJS_, c: Internal.Consumer_<Internal.ItemModificationProperties_>): void;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        isCancelled(): boolean;
        post(t: Internal.ScriptType_, id: string, sub: string): boolean;
        post(t: Internal.ScriptType_, id: string): boolean;
        hashCode(): number;
        notifyAll(): void;
        equals(arg0: any): boolean;
        toString(): string;
        notify(): void;
        canCancel(): boolean;
        get cancelled(): boolean;
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    /**
    * Fired when you need to modify properties of an item.
    */
    type ItemModificationEventJS_ = ItemModificationEventJS;
    class Suggestion implements Internal.Comparable<Internal.Suggestion> {
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        apply(arg0: string): string;
        getText(): string;
        notifyAll(): void;
        compareTo(arg0: Internal.Suggestion_): number;
        notify(): void;
        expand(arg0: string, arg1: Internal.StringRange_): Internal.Suggestion;
        getTooltip(): Internal.Message;
        getRange(): Internal.StringRange;
        hashCode(): number;
        equals(arg0: any): boolean;
        toString(): string;
        compareToIgnoreCase(arg0: Internal.Suggestion_): number;
        get tooltip(): Internal.Message;
        get range(): Internal.StringRange;
        get text(): string;
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    type Suggestion_ = Suggestion;
    class Insets implements Internal.Cloneable, Internal.Serializable {
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        set(arg0: number, arg1: number, arg2: number, arg3: number): void;
        hashCode(): number;
        notifyAll(): void;
        equals(arg0: any): boolean;
        clone(): any;
        toString(): string;
        notify(): void;
        top : number;
        left : number;
        bottom : number;
        right : number;
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    type Insets_ = Insets;
    abstract class Entity extends Internal.CapabilityProvider<Internal.Entity> implements Internal.Nameable, Internal.EntityAccess, Internal.CommandSource, Internal.IForgeEntity, Internal.AccessorEntity, Internal.CustomEntityRenderData, Internal.LambDynamicLight, vazkii.botania.mixin.AccessorEntity, Internal.EntityKJS {
        getClass(): Internal.Class<any>;
        resetDynamicLight(): void;
        getCapability<T_>(arg0: Internal.Capability_<T_>, arg1: Internal.Direction_): Internal.LazyOptional<T_>;
        getCapability<T_>(arg0: Internal.Capability_<T_>): Internal.LazyOptional<T_>;
        captureDrops(arg0: Internal.Collection_<Internal.ItemEntity_>): Internal.Collection<Internal.ItemEntity>;
        captureDrops(): Internal.Collection<Internal.ItemEntity>;
        canBeRiddenInWater(arg0: Internal.Entity_): boolean;
        isDynamicLightEnabled(): boolean;
        changeDimension(arg0: Internal.ServerLevel_, arg1: Internal.ITeleporter_): Internal.Entity;
        serializeNBT(): Internal.CompoundTag;
        invalidateCaps(): void;
        setDynamicLightEnabled(arg0: boolean): void;
        shouldUpdateDynamicLight(): boolean;
        revive(): void;
        setVisualScale(arg0: number): void;
        dynamicLightTick(): void;
        getPersistentDataKJS(): Internal.CompoundTag;
        canUpdate(): boolean;
        canUpdate(arg0: boolean): void;
        getDynamicLightY(): number;
        getDynamicLightZ(): number;
        getDynamicLightX(): number;
        areCapsCompatible(arg0: Internal.CapabilityProvider_<Internal.Entity_>): boolean;
        areCapsCompatible(arg0: Internal.CapabilityDispatcher_): boolean;
        getEyeHeightAccess(arg0: Internal.Pose_, arg1: Internal.EntityDimensions_): number;
        reviveCaps(): void;
        lambdynlights$updateDynamicLight(arg0: Internal.LevelRenderer_): boolean;
        handler$bih000$removed(arg0: Internal.CallbackInfo_): void;
        canRiderInteract(): boolean;
        lambdynlights$scheduleTrackedChunksRebuild(arg0: Internal.LevelRenderer_): void;
        handler$bih001$onTick(arg0: Internal.CallbackInfo_): void;
        onAddedToWorld(): void;
        canTrample(arg0: Internal.BlockState_, arg1: BlockPos_, arg2: number): boolean;
        getClassification(arg0: boolean): Internal.MobCategory;
        handler$bih000$onRemove(arg0: Internal.CallbackInfo_): void;
        shouldRiderSit(): boolean;
        getPickedResult(arg0: Internal.HitResult_): Internal.ItemStack;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        notifyAll(): void;
        getPersistentData(): Internal.CompoundTag;
        notify(): void;
        hashCode(): number;
        setDimension(arg0: Internal.EntityDimensions_): void;
        isAddedToWorld(): boolean;
        getParts(): any[];
        getDynamicLightWorld(): Internal.Level;
        onRemovedFromWorld(): void;
        getLuminance(): number;
        isMultipartEntity(): boolean;
        deserializeNBT(arg0: Internal.CompoundTag_): void;
        asKJS(): any;
        equals(arg0: any): boolean;
        toString(): string;
        getVisualScale(): number;
        get luminance(): number;
        get dynamicLightEnabled(): boolean;
        get persistentData(): Internal.CompoundTag;
        get multipartEntity(): boolean;
        get addedToWorld(): boolean;
        get dynamicLightY(): number;
        get dynamicLightZ(): number;
        get dynamicLightX(): number;
        get visualScale(): number;
        get persistentDataKJS(): Internal.CompoundTag;
        get parts(): any[];
        get class(): Internal.Class<any>;
        get dynamicLightWorld(): Internal.Level;
        set dynamicLightEnabled(arg0: boolean);
        set visualScale(arg0: number);
        set dimension(arg0: Internal.EntityDimensions_);
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    type Entity_ = Entity;
    class ContextMenu extends Internal.Panel {
        static isMouseButtonDown(button: Internal.MouseButton_): boolean;
        closeGui(openPrevScreen: boolean): void;
        closeGui(): void;
        getClass(): Internal.Class<any>;
        setY(v: number): void;
        collidesWith(x: number, y: number, w: number, h: number): boolean;
        setX(v: number): void;
        shouldDraw(): boolean;
        acceptGhostIngredient(ingredient: any): void;
        getContentHeight(): number;
        isGhostIngredientTarget(ingredient: any): boolean;
        run(): void;
        isDefaultScrollVertical(): boolean;
        align(layout: Internal.WidgetLayout_): number;
        getGui(): Internal.BaseScreen;
        mousePressed(button: Internal.MouseButton_): boolean;
        setPos(x: number, y: number): void;
        getTitle(): Internal.Component;
        static getClipboardString(): string;
        setOffset(flag: boolean): void;
        drawBackground(matrixStack: Internal.PoseStack_, theme: Internal.Theme_, x: number, y: number, w: number, h: number): void;
        static isCtrlKeyDown(): boolean;
        drawOffsetBackground(matrixStack: Internal.PoseStack_, theme: Internal.Theme_, x: number, y: number, w: number, h: number): void;
        updateMouseOver(mouseX: number, mouseY: number): void;
        getScrollStep(): number;
        getScreen(): Internal.Window;
        getMouseY(): number;
        add(widget: dev.ftb.mods.ftblibrary.ui.Widget_): void;
        isMouseOver(): boolean;
        onClosed(): void;
        getMouseX(): number;
        keyPressed(key: dev.ftb.mods.ftblibrary.ui.input.Key_): boolean;
        getWidget(index: number): dev.ftb.mods.ftblibrary.ui.Widget;
        openGui(): void;
        setOnlyInteractWithWidgetsInside(value: boolean): void;
        setPosAndSize(x: number, y: number, w: number, h: number): dev.ftb.mods.ftblibrary.ui.Widget;
        setOnlyRenderWidgetsInside(value: boolean): void;
        tick(): void;
        setHeight(v: number): void;
        addMouseOverText(list: Internal.TooltipList_): void;
        playClickSound(): void;
        handleClick(click: string): boolean;
        handleClick(scheme: string, path: string): boolean;
        isEnabled(): boolean;
        refreshWidgets(): void;
        isOffset(): boolean;
        charTyped(c: string, modifiers: Internal.KeyModifiers_): boolean;
        alignWidgets(): void;
        mouseDoubleClicked(button: Internal.MouseButton_): boolean;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        mouseScrolled(scroll: number): boolean;
        drawWidget(matrixStack: Internal.PoseStack_, theme: Internal.Theme_, widget: dev.ftb.mods.ftblibrary.ui.Widget_, index: number, x: number, y: number, w: number, h: number): void;
        notifyAll(): void;
        shouldAddMouseOverText(): boolean;
        openAfter(runnable: Internal.Runnable_): Internal.Runnable;
        closeContextMenu(): void;
        notify(): void;
        isMouseOverAnyWidget(): boolean;
        mouseReleased(button: Internal.MouseButton_): void;
        getScrollX(): number;
        getScrollY(): number;
        getContentWidth(): number;
        setSize(w: number, h: number): void;
        hashCode(): number;
        getPartialTicks(): number;
        openGuiLater(): void;
        static isKeyDown(key: number): boolean;
        clearWidgets(): void;
        keyReleased(key: dev.ftb.mods.ftblibrary.ui.input.Key_): void;
        static setClipboardString(string: string): void;
        static isShiftKeyDown(): boolean;
        getCursor(): Internal.CursorType;
        setScrollStep(s: number): void;
        getWidgetType(): Internal.WidgetType;
        movePanelScroll(dx: number, dy: number): boolean;
        draw(matrixStack: Internal.PoseStack_, theme: Internal.Theme_, x: number, y: number, w: number, h: number): void;
        checkMouseOver(mouseX: number, mouseY: number): boolean;
        setWidth(v: number): void;
        getOnlyRenderWidgetsInside(): boolean;
        getOnlyInteractWithWidgetsInside(): boolean;
        addWidgets(): void;
        openContextMenu(panel: Internal.Panel_): void;
        getX(): number;
        getY(): number;
        addAll(list: Internal.Iterable_<dev.ftb.mods.ftblibrary.ui.Widget_>): void;
        equals(arg0: any): boolean;
        scrollPanel(scroll: number): boolean;
        toString(): string;
        setScrollX(scroll: number): void;
        getIngredientUnderMouse(): any;
        setScrollY(scroll: number): void;
        posX : number;
        parent : Internal.Panel;
        posY : number;
        hasIcons : boolean;
        attachedScrollbar : Internal.PanelScrollBar;
        width : number;
        contentWidthExtra : number;
        readonly widgets : Internal.List<dev.ftb.mods.ftblibrary.ui.Widget>;
        contentHeightExtra : number;
        readonly items : Internal.List<Internal.ContextMenuItem>;
        height : number;
        get mouseX(): number;
        get cursor(): Internal.CursorType;
        get ingredientUnderMouse(): any;
        get mouseY(): number;
        get shiftKeyDown(): boolean;
        get screen(): Internal.Window;
        get scrollStep(): number;
        get title(): Internal.Component;
        get enabled(): boolean;
        get contentWidth(): number;
        get mouseOverAnyWidget(): boolean;
        get class(): Internal.Class<any>;
        get defaultScrollVertical(): boolean;
        get onlyInteractWithWidgetsInside(): boolean;
        get clipboardString(): string;
        get offset(): boolean;
        get mouseOver(): boolean;
        get widgetType(): Internal.WidgetType;
        get contentHeight(): number;
        get ctrlKeyDown(): boolean;
        get onlyRenderWidgetsInside(): boolean;
        get x(): number;
        get y(): number;
        get gui(): Internal.BaseScreen;
        get scrollY(): number;
        get scrollX(): number;
        get partialTicks(): number;
        set onlyInteractWithWidgetsInside(value: boolean);
        set clipboardString(string: string);
        set offset(flag: boolean);
        set onlyRenderWidgetsInside(value: boolean);
        set x(v: number);
        set y(v: number);
        set scrollY(scroll: number);
        set scrollStep(s: number);
        set scrollX(scroll: number);
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    type ContextMenu_ = ContextMenu;
    class Biome$BiomeCategory extends Internal.Enum<Internal.Biome$BiomeCategory> implements Internal.StringRepresentable {
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        static valueOf(arg0: string): Internal.Biome$BiomeCategory;
        static valueOf<T_>(arg0: Internal.Class_<T_>, arg1: string): T_;
        notifyAll(): void;
        static values(): Internal.Biome$BiomeCategory[];
        compareTo(arg0: Internal.Biome$BiomeCategory_): number;
        describeConstable(): Internal.Optional<Internal.Enum$EnumDesc<Internal.Biome$BiomeCategory>>;
        notify(): void;
        getDeclaringClass(): Internal.Class<Internal.Biome$BiomeCategory>;
        hashCode(): number;
        equals(arg0: any): boolean;
        name(): string;
        toString(): string;
        ordinal(): number;
        static readonly BEACH : Internal.Biome$BiomeCategory;
        static readonly UNDERGROUND : Internal.Biome$BiomeCategory;
        static readonly MESA : Internal.Biome$BiomeCategory;
        static readonly SAVANNA : Internal.Biome$BiomeCategory;
        static readonly THEEND : Internal.Biome$BiomeCategory;
        static readonly JUNGLE : Internal.Biome$BiomeCategory;
        static readonly OCEAN : Internal.Biome$BiomeCategory;
        static readonly TAIGA : Internal.Biome$BiomeCategory;
        static readonly MOUNTAIN : Internal.Biome$BiomeCategory;
        static readonly DESERT : Internal.Biome$BiomeCategory;
        static readonly RIVER : Internal.Biome$BiomeCategory;
        static readonly FOREST : Internal.Biome$BiomeCategory;
        static readonly MUSHROOM : Internal.Biome$BiomeCategory;
        static readonly NETHER : Internal.Biome$BiomeCategory;
        static readonly PLAINS : Internal.Biome$BiomeCategory;
        static readonly SWAMP : Internal.Biome$BiomeCategory;
        static readonly NONE : Internal.Biome$BiomeCategory;
        static readonly EXTREME_HILLS : Internal.Biome$BiomeCategory;
        static readonly ICY : Internal.Biome$BiomeCategory;
        get class(): Internal.Class<any>;
        get declaringClass(): Internal.Class<Internal.Biome$BiomeCategory>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    type Biome$BiomeCategory_ = "forest" | "nether" | "taiga" | "none" | "swamp" | "theend" | "mountain" | "ocean" | "mesa" | "underground" | "extreme_hills" | "plains" | "savanna" | "beach" | "jungle" | "river" | "desert" | "mushroom" | "icy" | Biome$BiomeCategory;
    class DataResult$Mu implements Internal.K1 {
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        hashCode(): number;
        notifyAll(): void;
        equals(arg0: any): boolean;
        toString(): string;
        notify(): void;
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    type DataResult$Mu_ = DataResult$Mu;
    abstract class EffectRenderer {
        renderInventoryEffect(arg0: Internal.MobEffectInstance_, arg1: Internal.EffectRenderingInventoryScreen_<any>, arg2: Internal.PoseStack_, arg3: number, arg4: number, arg5: number): void;
        getClass(): Internal.Class<any>;
        shouldRenderHUD(arg0: Internal.MobEffectInstance_): boolean;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        hashCode(): number;
        notifyAll(): void;
        equals(arg0: any): boolean;
        toString(): string;
        shouldRender(arg0: Internal.MobEffectInstance_): boolean;
        shouldRenderInvText(arg0: Internal.MobEffectInstance_): boolean;
        notify(): void;
        renderHUDEffect(arg0: Internal.MobEffectInstance_, arg1: Internal.GuiComponent_, arg2: Internal.PoseStack_, arg3: number, arg4: number, arg5: number, arg6: number): void;
        static readonly DUMMY : Internal.EffectRenderer;
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    type EffectRenderer_ = EffectRenderer;
    interface DensityFunction$ContextProvider {
    }
    type DensityFunction$ContextProvider_ = DensityFunction$ContextProvider;
    interface Long2ObjectMap$Entry <V> extends Internal.Map$Entry<number, V> {
        getValue(): V;
        getKey(): number;
        hashCode(): number;
        setValue(arg0: V): V;
        equals(arg0: any): boolean;
        getLongKey(): number;
    }
    type Long2ObjectMap$Entry_<V> = Long2ObjectMap$Entry<V>;
    interface Byte2DoubleMap$Entry extends Internal.Map$Entry<number, number> {
        getKey(): number;
        getValue(): number;
        hashCode(): number;
        equals(arg0: any): boolean;
        setValue(arg0: number): number;
        getDoubleValue(): number;
        getByteKey(): number;
    }
    type Byte2DoubleMap$Entry_ = Byte2DoubleMap$Entry;
    class SPacketUIWidgetUpdate implements Internal.IPacket {
        encode(arg0: Internal.FriendlyByteBuf_): void;
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        hashCode(): number;
        notifyAll(): void;
        equals(arg0: any): boolean;
        toString(): string;
        decode(arg0: Internal.FriendlyByteBuf_): void;
        execute(arg0: Internal.NetworkEvent$Context_): void;
        notify(): void;
        updateData : Internal.FriendlyByteBuf;
        windowId : number;
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    type SPacketUIWidgetUpdate_ = SPacketUIWidgetUpdate;
    class ShaderInstance implements Internal.Shader, Internal.AutoCloseable, Internal.ShaderInstanceInterface {
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        iris$createGeometryShader(arg0: Internal.ResourceProvider_, arg1: ResourceLocation_): void;
        hashCode(): number;
        notifyAll(): void;
        equals(arg0: any): boolean;
        handler$zka000$oculus$setupGeometryShader(arg0: Internal.ResourceProvider_, arg1: ResourceLocation_, arg2: Internal.VertexFormat_, arg3: Internal.CallbackInfo_): void;
        toString(): string;
        redirect$zka000$iris$redirectBindAttributeLocation(arg0: number, arg1: number, arg2: Internal.CharSequence_): void;
        close(): void;
        notify(): void;
        handler$zka000$iris$setupGeometryShader(arg0: Internal.ResourceProvider_, arg1: string, arg2: Internal.VertexFormat_, arg3: Internal.CallbackInfo_): void;
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    type ShaderInstance_ = ShaderInstance;
    class NetworkDirection extends Internal.Enum<Internal.NetworkDirection> {
        getEvent(arg0: Internal.ICustomPacket_<any>, arg1: Internal.Supplier_<Internal.NetworkEvent$Context_>): Internal.NetworkEvent;
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        static directionFor<T_>(arg0: Internal.Class_<T_>): Internal.NetworkDirection;
        static valueOf(arg0: string): Internal.NetworkDirection;
        static valueOf<T_>(arg0: Internal.Class_<T_>, arg1: string): T_;
        notifyAll(): void;
        static values(): Internal.NetworkDirection[];
        compareTo(arg0: Internal.NetworkDirection_): number;
        describeConstable(): Internal.Optional<Internal.Enum$EnumDesc<Internal.NetworkDirection>>;
        notify(): void;
        getOriginationSide(): Internal.LogicalSide;
        getReceptionSide(): Internal.LogicalSide;
        getDeclaringClass(): Internal.Class<Internal.NetworkDirection>;
        buildPacket<T_>(arg0: org.apache.commons.lang3.tuple.Pair_<Internal.FriendlyByteBuf_, number>, arg1: ResourceLocation_): Internal.ICustomPacket<T_>;
        hashCode(): number;
        equals(arg0: any): boolean;
        name(): string;
        toString(): string;
        reply(): Internal.NetworkDirection;
        ordinal(): number;
        static readonly LOGIN_TO_CLIENT : Internal.NetworkDirection;
        static readonly PLAY_TO_SERVER : Internal.NetworkDirection;
        static readonly LOGIN_TO_SERVER : Internal.NetworkDirection;
        static readonly PLAY_TO_CLIENT : Internal.NetworkDirection;
        get receptionSide(): Internal.LogicalSide;
        get originationSide(): Internal.LogicalSide;
        get class(): Internal.Class<any>;
        get declaringClass(): Internal.Class<Internal.NetworkDirection>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    type NetworkDirection_ = "play_to_server" | "login_to_client" | "play_to_client" | "login_to_server" | NetworkDirection;
    class Constructor <T> extends Internal.Executable {
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        getName(): string;
        getParameterCount(): number;
        isAnnotationPresent(arg0: Internal.Class_<Internal.Annotation_>): boolean;
        notifyAll(): void;
        isSynthetic(): boolean;
        getAnnotatedParameterTypes(): Internal.AnnotatedType[];
        getParameterTypes(): Internal.Class<any>[];
        getGenericExceptionTypes(): java_.lang.reflect.Type[];
        notify(): void;
        getAnnotatedReceiverType(): Internal.AnnotatedType;
        getDeclaredAnnotations(): Internal.Annotation[];
        getDeclaringClass(): Internal.Class<T>;
        getAnnotationsByType<T_>(arg0: Internal.Class_<T_>): T_[];
        hashCode(): number;
        canAccess(arg0: any): boolean;
        toGenericString(): string;
        getTypeParameters(): any[];
        getModifiers(): number;
        trySetAccessible(): boolean;
        isAccessible(): boolean;
        setAccessible(arg0: boolean): void;
        static setAccessible(arg0: Internal.AccessibleObject_[], arg1: boolean): void;
        isVarArgs(): boolean;
        newInstance(arg0: any[]): T;
        getAnnotations(): Internal.Annotation[];
        getAnnotatedExceptionTypes(): Internal.AnnotatedType[];
        getExceptionTypes(): Internal.Class<any>[];
        getGenericParameterTypes(): java_.lang.reflect.Type[];
        getDeclaredAnnotationsByType<T_>(arg0: Internal.Class_<T_>): T_[];
        getAnnotation<T_>(arg0: Internal.Class_<T_>): T_;
        equals(arg0: any): boolean;
        getDeclaredAnnotation<T_>(arg0: Internal.Class_<T_>): T_;
        getParameters(): any[];
        toString(): string;
        getAnnotatedReturnType(): Internal.AnnotatedType;
        getParameterAnnotations(): Internal.Annotation[][];
        static readonly PUBLIC : 0;
        static readonly DECLARED : 1;
        get declaredAnnotations(): Internal.Annotation[];
        get accessible(): boolean;
        get annotatedReturnType(): Internal.AnnotatedType;
        get parameterTypes(): Internal.Class<any>[];
        get parameterCount(): number;
        get annotations(): Internal.Annotation[];
        get modifiers(): number;
        get typeParameters(): any[];
        get declaringClass(): Internal.Class<T>;
        get varArgs(): boolean;
        get synthetic(): boolean;
        get genericParameterTypes(): java_.lang.reflect.Type[];
        get exceptionTypes(): Internal.Class<any>[];
        get name(): string;
        get annotatedReceiverType(): Internal.AnnotatedType;
        get genericExceptionTypes(): java_.lang.reflect.Type[];
        get parameterAnnotations(): Internal.Annotation[][];
        get class(): Internal.Class<any>;
        get parameters(): any[];
        get annotatedExceptionTypes(): Internal.AnnotatedType[];
        get annotatedParameterTypes(): Internal.AnnotatedType[];
        set accessible(arg0: boolean);
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    type Constructor_<T> = Constructor<T>;
    interface OpSupplier {
        create(arg0: dev.latvian.mods.rhino.util.unit.Unit_, arg1: dev.latvian.mods.rhino.util.unit.Unit_): dev.latvian.mods.rhino.util.unit.Unit;
    }
    type OpSupplier_ = ((arg0: dev.latvian.mods.rhino.util.unit.Unit, arg1: dev.latvian.mods.rhino.util.unit.Unit) => dev.latvian.mods.rhino.util.unit.Unit) | OpSupplier;
    class ClientLevelJS extends Internal.LevelJS {
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        getPlayer(entity: Internal.Entity_): Internal.PlayerJS<any>;
        getEntitiesWithin(aabb: Internal.AABB_): Internal.EntityArrayList;
        getPlayerData(player: Internal.Player_): Internal.ClientPlayerDataJS;
        spawnFireworks(x: number, y: number, z: number, f: Internal.FireworksJS_): void;
        getTime(): number;
        notifyAll(): void;
        getSide(): Internal.ScriptType;
        getGameRules(): Internal.GameRulesJS;
        notify(): void;
        setRainStrength(strength: number): void;
        getMinecraftPlayer(): Internal.LocalPlayer;
        hashCode(): number;
        getDimension(): string;
        isDaytime(): boolean;
        createEntityList(entities: Internal.Collection_<Internal.Entity_>): Internal.EntityArrayList;
        getPlayers(): Internal.EntityArrayList;
        getData(): Internal.AttachedData;
        getMinecraftLevel(): Internal.ClientLevel;
        getServer(): Internal.ServerJS;
        getLivingEntity(entity: Internal.Entity_): Internal.LivingEntityJS;
        getBlock(x: number, y: number, z: number): Internal.BlockContainerJS;
        getBlock(pos: BlockPos_): Internal.BlockContainerJS;
        getBlock(blockEntity: Internal.BlockEntity_): Internal.BlockContainerJS;
        isOverworld(): boolean;
        createExplosion(x: number, y: number, z: number): Internal.ExplosionJS;
        getEntity(e: Internal.Entity_): Internal.EntityJS;
        getMinecraft(): Internal.Minecraft;
        createEntity(id: ResourceLocation_): Internal.EntityJS;
        spawnLightning(x: number, y: number, z: number, effectOnly: boolean, player: Internal.EntityJS_): void;
        spawnLightning(x: number, y: number, z: number, effectOnly: boolean): void;
        getLocalTime(): number;
        equals(arg0: any): boolean;
        isThundering(): boolean;
        getEntities(): Internal.EntityArrayList;
        toString(): string;
        static getInstance(): Internal.ClientLevelJS;
        isRaining(): boolean;
        static setInstance(instance: Internal.ClientLevelJS_): void;
        readonly clientPlayerData : Internal.ClientPlayerDataJS;
        readonly minecraftLevel : Internal.Level;
        get minecraft(): Internal.Minecraft;
        get server(): Internal.ServerJS;
        get side(): Internal.ScriptType;
        get instance(): Internal.ClientLevelJS;
        get data(): Internal.AttachedData;
        get minecraftPlayer(): Internal.LocalPlayer;
        get players(): Internal.EntityArrayList;
        get raining(): boolean;
        get thundering(): boolean;
        get overworld(): boolean;
        get gameRules(): Internal.GameRulesJS;
        get localTime(): number;
        get entities(): Internal.EntityArrayList;
        get time(): number;
        get class(): Internal.Class<any>;
        get dimension(): string;
        get daytime(): boolean;
        set instance(instance: Internal.ClientLevelJS_);
        set rainStrength(strength: number);
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    type ClientLevelJS_ = ClientLevelJS;
    class DefaultChapterGroup extends Internal.ChapterGroup {
        getClass(): Internal.Class<any>;
        isDefaultGroup(): boolean;
        getIndex(): number;
        getMutableTitle(): Internal.MutableComponent;
        getTags(): Internal.Set<string>;
        static getCodeString(object: Internal.QuestObjectBase_): string;
        getCodeString(): string;
        static getCodeString(id: number): string;
        writeData(nbt: Internal.CompoundTag_): void;
        createSubGroup(group: Internal.ConfigGroup_): Internal.ConfigGroup;
        editedFromGUIOnServer(): void;
        forceProgress(teamData: Internal.TeamData_, progressChange: Internal.ProgressChange_): void;
        isCompletedRaw(data: Internal.TeamData_): boolean;
        getTitle(): Internal.Component;
        getPath(): string;
        clearCachedData(): void;
        static parseCodeString(id: string): number;
        readData(nbt: Internal.CompoundTag_): void;
        editedFromGUI(): void;
        hasTag(tag: string): boolean;
        onCompleted(data: Internal.QuestProgressEventData_<any>): void;
        static getID(object: Internal.QuestObjectBase_): number;
        isVisible(data: Internal.TeamData_): boolean;
        onEditButtonClicked(gui: Internal.Runnable_): void;
        getChildren(): Internal.Collection<Internal.QuestObject>;
        onStarted(data: Internal.QuestProgressEventData_<any>): void;
        getAltTitle(): Internal.Component;
        getVisibleChapters(data: Internal.TeamData_): Internal.List<Internal.Chapter>;
        deleteSelf(): void;
        cacheProgress(): boolean;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        deleteChildren(): void;
        readNetData(buffer: Internal.FriendlyByteBuf_): void;
        notifyAll(): void;
        notify(): void;
        getRelativeProgressFromChildren(data: Internal.TeamData_): number;
        static getRelativeProgressFromChildren(progressSum: number, count: number): number;
        hashCode(): number;
        getAltIcon(): Internal.Icon;
        getObjectType(): Internal.QuestObjectType;
        hasUnclaimedRewardsRaw(teamData: Internal.TeamData_, player: Internal.UUID_): boolean;
        getParentID(): number;
        getProgressColor(data: Internal.TeamData_, dim: boolean): Internal.Color4I;
        getProgressColor(data: Internal.TeamData_): Internal.Color4I;
        refreshJEI(): number;
        getQuestChapter(): Internal.Chapter;
        getFirstVisibleChapter(data: Internal.TeamData_): Internal.Chapter;
        getQuestFile(): Internal.QuestFile;
        writeNetData(buffer: Internal.FriendlyByteBuf_): void;
        getConfig(config: Internal.ConfigGroup_): void;
        getIcon(): Internal.Icon;
        forceProgressRaw(teamData: Internal.TeamData_, progressChange: Internal.ProgressChange_): void;
        static isNull(object: Internal.QuestObjectBase_): boolean;
        equals(object: any): boolean;
        toString(): string;
        static titleToID(s: string): Internal.Optional<string>;
        onCreated(): void;
        disableToast : boolean;
        readonly file : Internal.QuestFile;
        readonly chapters : Internal.List<Internal.Chapter>;
        invalid : boolean;
        icon : Internal.ItemStack;
        static sendNotifications : Internal.Tristate;
        id : number;
        title : string;
        guiCollapsed : boolean;
        get codeString(): string;
        get index(): number;
        get questFile(): Internal.QuestFile;
        get parentID(): number;
        get mutableTitle(): Internal.MutableComponent;
        get tags(): Internal.Set<string>;
        get altIcon(): Internal.Icon;
        get objectType(): Internal.QuestObjectType;
        get path(): string;
        get defaultGroup(): boolean;
        get children(): Internal.Collection<Internal.QuestObject>;
        get altTitle(): Internal.Component;
        get class(): Internal.Class<any>;
        get questChapter(): Internal.Chapter;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    type DefaultChapterGroup_ = DefaultChapterGroup;
    abstract class ColorModel implements Internal.Transparency {
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        getNumColorComponents(): number;
        notifyAll(): void;
        coerceData(arg0: Internal.WritableRaster_, arg1: boolean): Internal.ColorModel;
        notify(): void;
        getAlpha(arg0: any): number;
        getAlpha(arg0: number): number;
        getUnnormalizedComponents(arg0: number[], arg1: number, arg2: number[], arg3: number): number[];
        getRed(arg0: any): number;
        getRed(arg0: number): number;
        getDataElement(arg0: number[], arg1: number): number;
        getTransferType(): number;
        createCompatibleSampleModel(arg0: number, arg1: number): Internal.SampleModel;
        hashCode(): number;
        getComponents(arg0: number, arg1: number[], arg2: number): number[];
        getComponents(arg0: any, arg1: number[], arg2: number): number[];
        static getRGBdefault(): Internal.ColorModel;
        hasAlpha(): boolean;
        getAlphaRaster(arg0: Internal.WritableRaster_): Internal.WritableRaster;
        getRGB(arg0: number): number;
        getRGB(arg0: any): number;
        isCompatibleSampleModel(arg0: Internal.SampleModel_): boolean;
        getNumComponents(): number;
        getPixelSize(): number;
        getBlue(arg0: number): number;
        getBlue(arg0: any): number;
        getColorSpace(): Internal.ColorSpace;
        createCompatibleWritableRaster(arg0: number, arg1: number): Internal.WritableRaster;
        isAlphaPremultiplied(): boolean;
        getTransparency(): number;
        getNormalizedComponents(arg0: any, arg1: number[], arg2: number): number[];
        getNormalizedComponents(arg0: number[], arg1: number, arg2: number[], arg3: number): number[];
        getGreen(arg0: number): number;
        getGreen(arg0: any): number;
        equals(arg0: any): boolean;
        getDataElements(arg0: number, arg1: any): any;
        getDataElements(arg0: number[], arg1: number, arg2: any): any;
        toString(): string;
        isCompatibleRaster(arg0: Internal.Raster_): boolean;
        getComponentSize(arg0: number): number;
        getComponentSize(): number[];
        static readonly OPAQUE : 1;
        static readonly TRANSLUCENT : 3;
        static readonly BITMASK : 2;
        get colorSpace(): Internal.ColorSpace;
        get rGBdefault(): Internal.ColorModel;
        get alphaPremultiplied(): boolean;
        get transparency(): number;
        get transferType(): number;
        get componentSize(): number[];
        get numColorComponents(): number;
        get class(): Internal.Class<any>;
        get pixelSize(): number;
        get numComponents(): number;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    type ColorModel_ = ColorModel;
    interface ResourceProvider {
    }
    type ResourceProvider_ = ResourceProvider;
    interface PrimitiveIterator$OfLong extends Internal.PrimitiveIterator<number, java_.util.function_.LongConsumer> {
        next(): number;
        hasNext(): boolean;
        forEachRemaining(arg0: java_.util.function_.LongConsumer_): void;
        forEachRemaining(arg0: Internal.Consumer_<number>): void;
        nextLong(): number;
        remove(): void;
    }
    type PrimitiveIterator$OfLong_ = PrimitiveIterator$OfLong;
    interface PaintContext {
        getColorModel(): Internal.ColorModel;
        dispose(): void;
        getRaster(arg0: number, arg1: number, arg2: number, arg3: number): Internal.Raster;
    }
    type PaintContext_ = PaintContext;
    interface Short2CharFunction extends Internal.Function<number, string>, Internal.IntUnaryOperator {
        getOrDefault(arg0: any, arg1: string): string;
        getOrDefault(arg0: number, arg1: string): string;
        andThenShort(arg0: Internal.Char2ShortFunction_): Internal.Short2ShortFunction;
        composeByte(arg0: Internal.Byte2ShortFunction_): Internal.Byte2CharFunction;
        andThenInt(arg0: Internal.Char2IntFunction_): Internal.Short2IntFunction;
        composeReference<T_>(arg0: Internal.Reference2ShortFunction_<T_>): Internal.Reference2CharFunction<T_>;
        andThen<T_>(arg0: java_.util.function_.Function_<string, T_>): java_.util.function_.Function<number, T_>;
        andThen(arg0: Internal.IntUnaryOperator_): Internal.IntUnaryOperator;
        put(arg0: number, arg1: string): string;
        remove(arg0: number): string;
        remove(arg0: any): string;
        defaultReturnValue(): string;
        defaultReturnValue(arg0: string): void;
        andThenDouble(arg0: Internal.Char2DoubleFunction_): Internal.Short2DoubleFunction;
        andThenObject<T_>(arg0: Internal.Char2ObjectFunction_<T_>): Internal.Short2ObjectFunction<T_>;
        get(arg0: any): string;
        get(arg0: number): string;
        andThenLong(arg0: Internal.Char2LongFunction_): Internal.Short2LongFunction;
        composeLong(arg0: Internal.Long2ShortFunction_): Internal.Long2CharFunction;
        andThenByte(arg0: Internal.Char2ByteFunction_): Internal.Short2ByteFunction;
        andThenFloat(arg0: Internal.Char2FloatFunction_): Internal.Short2FloatFunction;
        applyAsInt(arg0: number): number;
        apply(arg0: number): string;
        containsKey(arg0: any): boolean;
        containsKey(arg0: number): boolean;
        composeInt(arg0: Internal.Int2ShortFunction_): Internal.Int2CharFunction;
        clear(): void;
        composeFloat(arg0: Internal.Float2ShortFunction_): Internal.Float2CharFunction;
        andThenChar(arg0: Internal.Char2CharFunction_): Internal.Short2CharFunction;
        composeObject<T_>(arg0: Internal.Object2ShortFunction_<T_>): Internal.Object2CharFunction<T_>;
        size(): number;
        compose<T_>(arg0: java_.util.function_.Function_<T_, number>): java_.util.function_.Function<T_, string>;
        compose(arg0: Internal.IntUnaryOperator_): Internal.IntUnaryOperator;
        composeShort(arg0: Internal.Short2ShortFunction_): Internal.Short2CharFunction;
        andThenReference<T_>(arg0: Internal.Char2ReferenceFunction_<T_>): Internal.Short2ReferenceFunction<T_>;
        composeChar(arg0: Internal.Char2ShortFunction_): Internal.Char2CharFunction;
        composeDouble(arg0: Internal.Double2ShortFunction_): Internal.Double2CharFunction;
    }
    type Short2CharFunction_ = ((arg0: number) => string) | Short2CharFunction;
    class CompostablesRecipeEventJS extends Internal.EventJS {
        cancel(): void;
        add(ingredient: Internal.IngredientJS_, f: number): void;
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        isCancelled(): boolean;
        notifyAll(): void;
        notify(): void;
        remove(ingredient: Internal.IngredientJS_): void;
        removeAll(): void;
        post(t: Internal.ScriptType_, id: string, sub: string): boolean;
        post(t: Internal.ScriptType_, id: string): boolean;
        hashCode(): number;
        equals(arg0: any): boolean;
        toString(): string;
        canCancel(): boolean;
        static originalMap : {};
        get cancelled(): boolean;
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    type CompostablesRecipeEventJS_ = CompostablesRecipeEventJS;
    interface ItemBuilder$UseCallback {
        use(arg0: Internal.LevelJS_, arg1: Internal.PlayerJS_<any>, arg2: Hand_): boolean;
    }
    type ItemBuilder$UseCallback_ = ((arg0: Internal.LevelJS, arg1: Internal.PlayerJS<any>, arg2: Hand) => boolean) | ItemBuilder$UseCallback;
    interface IntPredicate extends Internal.Predicate<number>, java_.util.function_.IntPredicate {
        or(arg0: Internal.Predicate_<number>): Internal.Predicate<number>;
        or(arg0: java_.util.function_.IntPredicate_): Internal.IntPredicate;
        or(arg0: Internal.IntPredicate_): Internal.IntPredicate;
        test(arg0: number): boolean;
        and(arg0: java_.util.function_.IntPredicate_): Internal.IntPredicate;
        and(arg0: Internal.IntPredicate_): Internal.IntPredicate;
        and(arg0: Internal.Predicate_<number>): Internal.Predicate<number>;
        negate(): Internal.IntPredicate;
    }
    type IntPredicate_ = ((arg0: number) => boolean) | IntPredicate;
    class LootBuilder implements Internal.FunctionContainer, Internal.ConditionContainer {
        enchantWithLevels(levels: Internal.NumberProvider_, treasure: boolean): Internal.FunctionContainer;
        damage(damage: Internal.NumberProvider_): Internal.FunctionContainer;
        nbt(tag: Internal.CompoundTag_): Internal.FunctionContainer;
        getClass(): Internal.Class<any>;
        clearFunctions(): void;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        survivesExplosion(): Internal.ConditionContainer;
        notifyAll(): void;
        addConditionalFunction(func: Internal.Consumer_<Internal.ConditionalFunction_>): Internal.FunctionContainer;
        addCondition(o: Internal.JsonObject_): Internal.LootBuilder;
        notify(): void;
        lootTable(table: ResourceLocation_, seed: number): Internal.FunctionContainer;
        addPool(p: Internal.Consumer_<Internal.LootBuilderPool_>): void;
        hashCode(): number;
        killedByPlayer(): Internal.ConditionContainer;
        randomChance(chance: number): Internal.ConditionContainer;
        addFunction(o: Internal.JsonObject_): Internal.LootBuilder;
        count(count: Internal.NumberProvider_): Internal.FunctionContainer;
        lootingEnchant(count: Internal.NumberProvider_, limit: number): Internal.FunctionContainer;
        toJson(): Internal.JsonObject;
        entityScores(entity: Internal.LootContext$EntityTarget_, scores: Internal.Map_<string, any>): Internal.ConditionContainer;
        copyName(source: Internal.CopyNameFunction$NameSource_): Internal.FunctionContainer;
        clearPools(): void;
        equals(arg0: any): boolean;
        name(name: Internal.Text_, entity: Internal.LootContext$EntityTarget_): Internal.FunctionContainer;
        name(name: Internal.Text_): Internal.FunctionContainer;
        randomChanceWithLooting(chance: number, multiplier: number): Internal.ConditionContainer;
        furnaceSmelt(): Internal.FunctionContainer;
        toString(): string;
        enchantRandomly(enchantments: ResourceLocation_[]): Internal.FunctionContainer;
        entityProperties(entity: Internal.LootContext$EntityTarget_, properties: Internal.JsonObject_): Internal.ConditionContainer;
        clearConditions(): void;
        functions : Internal.JsonArray;
        pools : Internal.JsonArray;
        type : string;
        conditions : Internal.JsonArray;
        customId : ResourceLocation;
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    type LootBuilder_ = LootBuilder;
    interface DoubleUnaryOperator {
        applyAsDouble(arg0: number): number;
        compose(arg0: Internal.DoubleUnaryOperator_): Internal.DoubleUnaryOperator;
        andThen(arg0: Internal.DoubleUnaryOperator_): Internal.DoubleUnaryOperator;
    }
    type DoubleUnaryOperator_ = ((arg0: number) => number) | DoubleUnaryOperator;
    interface FloatConsumer extends Internal.Consumer<number>, java_.util.function_.DoubleConsumer {
        andThen(arg0: Internal.Consumer_<number>): Internal.Consumer<number>;
        andThen(arg0: java_.util.function_.DoubleConsumer_): Internal.FloatConsumer;
        andThen(arg0: Internal.FloatConsumer_): Internal.FloatConsumer;
        accept(arg0: number): void;
    }
    type FloatConsumer_ = ((arg0: number) => void) | FloatConsumer;
    class LivingEntityJS extends Internal.EntityJS {
        getLastAttackedEntity(): Internal.LivingEntityJS;
        setY(y: number): void;
        setX(x: number): void;
        isOnScoreboardTeam(teamID: string): boolean;
        isLiving(): boolean;
        isSprinting(): boolean;
        getItem(): Internal.ItemStackJS;
        getRevengeTarget(): Internal.LivingEntityJS;
        getTags(): Internal.Set<string>;
        getOffHandItem(): Internal.ItemStackJS;
        setGlowing(glowing: boolean): void;
        setZ(z: number): void;
        getHasCustomName(): boolean;
        setInvisible(invisible: boolean): void;
        runCommandSilent(command: string): number;
        getIdleTime(): number;
        getMovementSpeed(): number;
        getDistanceSq(pos: BlockPos_): number;
        getDistanceSq(x: number, y: number, z: number): number;
        isBoss(): boolean;
        setDefaultMovementSpeedMultiplier(speed: number): void;
        setMovementSpeedAddition(speed: number): void;
        isGlowing(): boolean;
        getHorizontalFacing(): Internal.Direction;
        setLegsArmorItem(item: Internal.ItemStackJS_): void;
        getHealth(): number;
        getServer(): Internal.ServerJS;
        setFeetArmorItem(item: Internal.ItemStackJS_): void;
        getAttributeBaseValue(attribute: Internal.Attribute_): number;
        setMaxHealth(hp: number): void;
        setMotion(x: number, y: number, z: number): void;
        getProfile(): Internal.GameProfile;
        setRotation(yaw: number, pitch: number): void;
        setAbsorptionAmount(amount: number): void;
        isOnSameTeam(e: Internal.EntityJS_): boolean;
        isAnimal(): boolean;
        getDisplayName(): Internal.Text;
        getType(): string;
        setCustomNameAlwaysVisible(b: boolean): void;
        setOffHandItem(item: Internal.ItemStackJS_): void;
        addMotion(x: number, y: number, z: number): void;
        isInvisible(): boolean;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        getMaxHealth(): number;
        isUnderWater(): boolean;
        getHeldItem(hand: Hand_): Internal.ItemStackJS;
        getEyeHeight(): number;
        getEquipment(slot: EquipmentSlot_): Internal.ItemStackJS;
        notify(): void;
        getFallDistance(): number;
        damageHeldItem(hand: Hand_, amount: number): void;
        damageHeldItem(hand: Hand_, amount: number, onBroken: Internal.Consumer_<Internal.ItemStackJS_>): void;
        damageHeldItem(): void;
        setOnFire(seconds: number): void;
        setTotalMovementSpeedMultiplier(speed: number): void;
        removePassengers(): void;
        attack(source: string, hp: number): void;
        attack(hp: number): void;
        isOnLadder(): boolean;
        isUndead(): boolean;
        playSound(id: Internal.SoundEvent_, volume: number, pitch: number): void;
        playSound(id: Internal.SoundEvent_): void;
        getDistance(x: number, y: number, z: number): number;
        getDistance(pos: BlockPos_): number;
        setStatusMessage(message: Internal.Component_): void;
        getLastDamageSource(): Internal.DamageSource;
        isSwimming(): boolean;
        getReachDistance(): number;
        getCustomName(): Internal.Text;
        getStepHeight(): number;
        mergeFullNBT(tag: Internal.CompoundTag_): Internal.EntityJS;
        getDefaultMovementSpeed(): number;
        kill(): void;
        getRidingEntity(): Internal.EntityJS;
        setPositionAndRotation(x: number, y: number, z: number, yaw: number, pitch: number): void;
        getLevel(): Internal.LevelJS;
        getPitch(): number;
        getPassengers(): Internal.EntityArrayList;
        getLastAttackedEntityTime(): number;
        isMonster(): boolean;
        equals(arg0: any): boolean;
        setPitch(pitch: number): void;
        getFacing(): Internal.Direction;
        isOnGround(): boolean;
        toString(): string;
        isSilent(): boolean;
        isPassenger(e: Internal.EntityJS_): boolean;
        getClass(): Internal.Class<any>;
        getRecursivePassengers(): Internal.EntityArrayList;
        getNbt(): Internal.CompoundTag;
        setFallDistance(fallDistance: number): void;
        getName(): Internal.Text;
        getFeetArmorItem(): Internal.ItemStackJS;
        setCustomName(name: Internal.Component_): void;
        setMainHandItem(item: Internal.ItemStackJS_): void;
        setStepHeight(stepHeight: number): void;
        tell(message: Internal.Component_): void;
        getTeamId(): string;
        isWaterCreature(): boolean;
        setNoClip(noClip: boolean): void;
        setPosition(x: number, y: number, z: number): void;
        setPosition(block: Internal.BlockContainerJS_): void;
        extinguish(): void;
        getAttributeTotalValue(attribute: Internal.Attribute_): number;
        setInvulnerable(invulnerable: boolean): void;
        setRevengeTarget(target: Internal.LivingEntityJS_): void;
        setMovementSpeed(speed: number): void;
        isChild(): boolean;
        setDefaultMovementSpeed(speed: number): void;
        setEquipment(slot: EquipmentSlot_, item: Internal.ItemStackJS_): void;
        getLegsArmorItem(): Internal.ItemStackJS;
        setFullNBT(nbt: Internal.CompoundTag_): void;
        getAttackingEntity(): Internal.LivingEntityJS;
        isHoldingInAnyHand(ingredient: any): boolean;
        getFullNBT(): Internal.CompoundTag;
        getNoClip(): boolean;
        setYaw(yaw: number): void;
        damageEquipment(slot: EquipmentSlot_): void;
        damageEquipment(slot: EquipmentSlot_, amount: number, onBroken: Internal.Consumer_<Internal.ItemStackJS_>): void;
        damageEquipment(slot: EquipmentSlot_, amount: number): void;
        getYaw(): number;
        isAlive(): boolean;
        modifyAttribute(attribute: Internal.Attribute_, identifier: string, d: number, operation: Internal.AttributeModifier$Operation_): void;
        getTotalMovementSpeed(): number;
        getHeadArmorItem(): Internal.ItemStackJS;
        setNoGravity(noGravity: boolean): void;
        setHeldItem(hand: Hand_, item: Internal.ItemStackJS_): void;
        isPlayer(): boolean;
        setAttributeBaseValue(attribute: Internal.Attribute_, value: number): void;
        getRevengeTimer(): number;
        getAbsorptionAmount(): number;
        isCrouching(): boolean;
        notifyAll(): void;
        getId(): Internal.UUID;
        getTicksExisted(): number;
        setSilent(isSilent: boolean): void;
        hashCode(): number;
        getChestArmorItem(): Internal.ItemStackJS;
        isFrame(): boolean;
        heal(hp: number): void;
        startRiding(e: Internal.EntityJS_, force: boolean): boolean;
        runCommand(command: string): number;
        setChestArmorItem(item: Internal.ItemStackJS_): void;
        getCustomNameAlwaysVisible(): boolean;
        removeAttribute(attribute: Internal.Attribute_, identifier: string): void;
        getMainHandItem(): Internal.ItemStackJS;
        setHealth(hp: number): void;
        setMotionZ(z: number): void;
        setMotionY(y: number): void;
        getBlock(): Internal.BlockContainerJS;
        setMotionX(x: number): void;
        isElytraFlying(): boolean;
        isInWater(): boolean;
        dismountRidingEntity(): void;
        isSleeping(): boolean;
        isAmbientCreature(): boolean;
        swingArm(hand: Hand_): void;
        getPotionEffects(): Internal.EntityPotionEffectsJS;
        rayTrace(): Internal.RayTraceResultJS;
        rayTrace(distance: number): Internal.RayTraceResultJS;
        isInvulnerable(): boolean;
        setHeadArmorItem(item: Internal.ItemStackJS_): void;
        canEntityBeSeen(entity: Internal.LivingEntityJS_): boolean;
        getX(): number;
        spawn(): void;
        getY(): number;
        getZ(): number;
        isPeacefulCreature(): boolean;
        getMotionZ(): number;
        getMotionX(): number;
        getMotionY(): number;
        getNoGravity(): boolean;
        static readonly PLAYER_CUSTOM_SPEED : Internal.UUID;
        static readonly PLAYER_CUSTOM_SPEED_NAME : "kubejs.player.speed.modifier";
        readonly persistentData : Internal.CompoundTag;
        readonly minecraftEntity : Internal.Entity;
        readonly minecraftLivingEntity : Internal.LivingEntity;
        get invisible(): boolean;
        get customNameAlwaysVisible(): boolean;
        get movementSpeed(): number;
        get type(): string;
        get defaultMovementSpeed(): number;
        get idleTime(): number;
        get legsArmorItem(): Internal.ItemStackJS;
        get revengeTarget(): Internal.LivingEntityJS;
        get hasCustomName(): boolean;
        get undead(): boolean;
        get lastAttackedEntity(): Internal.LivingEntityJS;
        get maxHealth(): number;
        get block(): Internal.BlockContainerJS;
        get pitch(): number;
        get id(): Internal.UUID;
        get potionEffects(): Internal.EntityPotionEffectsJS;
        get item(): Internal.ItemStackJS;
        get passengers(): Internal.EntityArrayList;
        get level(): Internal.LevelJS;
        get profile(): Internal.GameProfile;
        get onLadder(): boolean;
        get feetArmorItem(): Internal.ItemStackJS;
        get offHandItem(): Internal.ItemStackJS;
        get customName(): Internal.Text;
        get lastAttackedEntityTime(): number;
        get horizontalFacing(): Internal.Direction;
        get tags(): Internal.Set<string>;
        get sprinting(): boolean;
        get crouching(): boolean;
        get noGravity(): boolean;
        get fullNBT(): Internal.CompoundTag;
        get name(): Internal.Text;
        get animal(): boolean;
        get peacefulCreature(): boolean;
        get lastDamageSource(): Internal.DamageSource;
        get stepHeight(): number;
        get child(): boolean;
        get frame(): boolean;
        get noClip(): boolean;
        get server(): Internal.ServerJS;
        get nbt(): Internal.CompoundTag;
        get boss(): boolean;
        get alive(): boolean;
        get ticksExisted(): number;
        get displayName(): Internal.Text;
        get fallDistance(): number;
        get revengeTimer(): number;
        get mainHandItem(): Internal.ItemStackJS;
        get facing(): Internal.Direction;
        get ambientCreature(): boolean;
        get elytraFlying(): boolean;
        get sleeping(): boolean;
        get swimming(): boolean;
        get waterCreature(): boolean;
        get invulnerable(): boolean;
        get eyeHeight(): number;
        get headArmorItem(): Internal.ItemStackJS;
        get underWater(): boolean;
        get class(): Internal.Class<any>;
        get reachDistance(): number;
        get player(): boolean;
        get absorptionAmount(): number;
        get motionZ(): number;
        get silent(): boolean;
        get living(): boolean;
        get motionY(): number;
        get motionX(): number;
        get ridingEntity(): Internal.EntityJS;
        get health(): number;
        get inWater(): boolean;
        get chestArmorItem(): Internal.ItemStackJS;
        get recursivePassengers(): Internal.EntityArrayList;
        get yaw(): number;
        get monster(): boolean;
        get attackingEntity(): Internal.LivingEntityJS;
        get glowing(): boolean;
        get onGround(): boolean;
        get totalMovementSpeed(): number;
        get teamId(): string;
        get x(): number;
        get y(): number;
        get z(): number;
        set noClip(noClip: boolean);
        set fallDistance(fallDistance: number);
        set mainHandItem(item: Internal.ItemStackJS_);
        set invisible(invisible: boolean);
        set customNameAlwaysVisible(b: boolean);
        set defaultMovementSpeed(speed: number);
        set movementSpeed(speed: number);
        set invulnerable(invulnerable: boolean);
        set legsArmorItem(item: Internal.ItemStackJS_);
        set totalMovementSpeedMultiplier(speed: number);
        set revengeTarget(target: Internal.LivingEntityJS_);
        set maxHealth(hp: number);
        set headArmorItem(item: Internal.ItemStackJS_);
        set pitch(pitch: number);
        set movementSpeedAddition(speed: number);
        set motionZ(z: number);
        set absorptionAmount(amount: number);
        set silent(isSilent: boolean);
        set motionY(y: number);
        set motionX(x: number);
        set health(hp: number);
        set feetArmorItem(item: Internal.ItemStackJS_);
        set offHandItem(item: Internal.ItemStackJS_);
        set chestArmorItem(item: Internal.ItemStackJS_);
        set onFire(seconds: number);
        set defaultMovementSpeedMultiplier(speed: number);
        set yaw(yaw: number);
        set statusMessage(message: Internal.Component_);
        set glowing(glowing: boolean);
        set noGravity(noGravity: boolean);
        set fullNBT(nbt: Internal.CompoundTag_);
        set x(x: number);
        set y(y: number);
        set z(z: number);
        set position(block: Internal.BlockContainerJS_);
        set stepHeight(stepHeight: number);
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    type LivingEntityJS_ = LivingEntityJS;
    class LootTableEntry implements Internal.FunctionContainer, Internal.ConditionContainer {
        enchantWithLevels(levels: Internal.NumberProvider_, treasure: boolean): Internal.FunctionContainer;
        damage(damage: Internal.NumberProvider_): Internal.FunctionContainer;
        nbt(tag: Internal.CompoundTag_): Internal.FunctionContainer;
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        survivesExplosion(): Internal.ConditionContainer;
        notifyAll(): void;
        addConditionalFunction(func: Internal.Consumer_<Internal.ConditionalFunction_>): Internal.FunctionContainer;
        addCondition(o: Internal.JsonObject_): Internal.LootTableEntry;
        notify(): void;
        lootTable(table: ResourceLocation_, seed: number): Internal.FunctionContainer;
        hashCode(): number;
        killedByPlayer(): Internal.ConditionContainer;
        randomChance(chance: number): Internal.ConditionContainer;
        addFunction(o: Internal.JsonObject_): Internal.LootTableEntry;
        count(count: Internal.NumberProvider_): Internal.FunctionContainer;
        weight(weight: number): Internal.LootTableEntry;
        quality(quality: number): Internal.LootTableEntry;
        lootingEnchant(count: Internal.NumberProvider_, limit: number): Internal.FunctionContainer;
        entityScores(entity: Internal.LootContext$EntityTarget_, scores: Internal.Map_<string, any>): Internal.ConditionContainer;
        copyName(source: Internal.CopyNameFunction$NameSource_): Internal.FunctionContainer;
        equals(arg0: any): boolean;
        name(name: Internal.Text_, entity: Internal.LootContext$EntityTarget_): Internal.FunctionContainer;
        name(name: Internal.Text_): Internal.FunctionContainer;
        randomChanceWithLooting(chance: number, multiplier: number): Internal.ConditionContainer;
        furnaceSmelt(): Internal.FunctionContainer;
        toString(): string;
        enchantRandomly(enchantments: ResourceLocation_[]): Internal.FunctionContainer;
        entityProperties(entity: Internal.LootContext$EntityTarget_, properties: Internal.JsonObject_): Internal.ConditionContainer;
        readonly json : Internal.JsonObject;
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    type LootTableEntry_ = LootTableEntry;
    class StageCreationEvent {
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        getPlayer(): Internal.Player;
        setPlayerStages(s: Internal.Stages_): void;
        hashCode(): number;
        notifyAll(): void;
        equals(arg0: any): boolean;
        toString(): string;
        notify(): void;
        getPlayerStages(): Internal.Stages;
        get playerStages(): Internal.Stages;
        get class(): Internal.Class<any>;
        get player(): Internal.Player;
        set playerStages(s: Internal.Stages_);
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    type StageCreationEvent_ = StageCreationEvent;
    interface Matrix4fAccess {
        copyIntoArray(): number[];
        copyFromArray(arg0: number[]): void;
    }
    type Matrix4fAccess_ = Matrix4fAccess;
    class EntityPredicate {
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        hashCode(): number;
        notifyAll(): void;
        equals(arg0: any): boolean;
        toString(): string;
        notify(): void;
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    type EntityPredicate_ = EntityPredicate;
    abstract class Line2D implements Internal.Shape, Internal.Cloneable {
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        relativeCCW(arg0: Internal.Point2D_): number;
        static relativeCCW(arg0: number, arg1: number, arg2: number, arg3: number, arg4: number, arg5: number): number;
        relativeCCW(arg0: number, arg1: number): number;
        intersects(arg0: Internal.Rectangle2D_): boolean;
        intersects(arg0: number, arg1: number, arg2: number, arg3: number): boolean;
        notifyAll(): void;
        ptLineDistSq(arg0: number, arg1: number): number;
        ptLineDistSq(arg0: Internal.Point2D_): number;
        static ptLineDistSq(arg0: number, arg1: number, arg2: number, arg3: number, arg4: number, arg5: number): number;
        notify(): void;
        ptLineDist(arg0: Internal.Point2D_): number;
        static ptLineDist(arg0: number, arg1: number, arg2: number, arg3: number, arg4: number, arg5: number): number;
        ptLineDist(arg0: number, arg1: number): number;
        getBounds(): Internal.Rectangle;
        getY2(): number;
        getPathIterator(arg0: Internal.AffineTransform_): Internal.PathIterator;
        getPathIterator(arg0: Internal.AffineTransform_, arg1: number): Internal.PathIterator;
        getY1(): number;
        hashCode(): number;
        getP2(): Internal.Point2D;
        static linesIntersect(arg0: number, arg1: number, arg2: number, arg3: number, arg4: number, arg5: number, arg6: number, arg7: number): boolean;
        getX2(): number;
        getP1(): Internal.Point2D;
        ptSegDistSq(arg0: number, arg1: number): number;
        ptSegDistSq(arg0: Internal.Point2D_): number;
        static ptSegDistSq(arg0: number, arg1: number, arg2: number, arg3: number, arg4: number, arg5: number): number;
        intersectsLine(arg0: Internal.Line2D_): boolean;
        intersectsLine(arg0: number, arg1: number, arg2: number, arg3: number): boolean;
        contains(arg0: Internal.Point2D_): boolean;
        contains(arg0: number, arg1: number, arg2: number, arg3: number): boolean;
        contains(arg0: Internal.Rectangle2D_): boolean;
        contains(arg0: number, arg1: number): boolean;
        getX1(): number;
        ptSegDist(arg0: number, arg1: number): number;
        static ptSegDist(arg0: number, arg1: number, arg2: number, arg3: number, arg4: number, arg5: number): number;
        ptSegDist(arg0: Internal.Point2D_): number;
        equals(arg0: any): boolean;
        getBounds2D(): Internal.Rectangle2D;
        clone(): any;
        toString(): string;
        setLine(arg0: number, arg1: number, arg2: number, arg3: number): void;
        setLine(arg0: Internal.Line2D_): void;
        setLine(arg0: Internal.Point2D_, arg1: Internal.Point2D_): void;
        get p1(): Internal.Point2D;
        get p2(): Internal.Point2D;
        get bounds(): Internal.Rectangle;
        get y1(): number;
        get y2(): number;
        get x1(): number;
        get x2(): number;
        get bounds2D(): Internal.Rectangle2D;
        get class(): Internal.Class<any>;
        set line(arg0: Internal.Line2D_);
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    type Line2D_ = Line2D;
    interface OrderedEventExecutor extends Internal.EventExecutor {
        scheduleAtFixedRate(arg0: Internal.Runnable_, arg1: number, arg2: number, arg3: Internal.TimeUnit_): io.netty.util.concurrent.ScheduledFuture<any>;
        scheduleAtFixedRate(arg0: Internal.Runnable_, arg1: number, arg2: number, arg3: Internal.TimeUnit_): Internal.ScheduledFuture<any>;
        next(): Internal.EventExecutor;
        terminationFuture(): io.netty.util.concurrent.Future<any>;
        parent(): Internal.EventExecutorGroup;
        newProgressivePromise<V_>(): Internal.ProgressivePromise<V_>;
        shutdownGracefully(): io.netty.util.concurrent.Future<any>;
        shutdownGracefully(arg0: number, arg1: number, arg2: Internal.TimeUnit_): io.netty.util.concurrent.Future<any>;
        submit<T_>(arg0: Internal.Runnable_, arg1: T_): io.netty.util.concurrent.Future<T_>;
        submit<T_>(arg0: Internal.Runnable_, arg1: T_): Internal.Future<T_>;
        submit<T_>(arg0: java_.util.concurrent.Callable_<T_>): io.netty.util.concurrent.Future<T_>;
        submit<T_>(arg0: java_.util.concurrent.Callable_<T_>): Internal.Future<T_>;
        submit(arg0: Internal.Runnable_): io.netty.util.concurrent.Future<any>;
        submit(arg0: Internal.Runnable_): Internal.Future<any>;
        spliterator(): Internal.Spliterator<Internal.EventExecutor>;
        isTerminated(): boolean;
        forEach(arg0: Internal.Consumer_<Internal.EventExecutor_>): void;
        scheduleWithFixedDelay(arg0: Internal.Runnable_, arg1: number, arg2: number, arg3: Internal.TimeUnit_): io.netty.util.concurrent.ScheduledFuture<any>;
        scheduleWithFixedDelay(arg0: Internal.Runnable_, arg1: number, arg2: number, arg3: Internal.TimeUnit_): Internal.ScheduledFuture<any>;
        invokeAll<T_>(arg0: Internal.Collection_<java_.util.concurrent.Callable_<T_>>): Internal.List<Internal.Future<T_>>;
        invokeAll<T_>(arg0: Internal.Collection_<java_.util.concurrent.Callable_<T_>>, arg1: number, arg2: Internal.TimeUnit_): Internal.List<Internal.Future<T_>>;
        newFailedFuture<V_>(arg0: Internal.Throwable_): io.netty.util.concurrent.Future<V_>;
        execute(arg0: Internal.Runnable_): void;
        inEventLoop(): boolean;
        inEventLoop(arg0: Internal.Thread_): boolean;
        schedule<V_>(arg0: java_.util.concurrent.Callable_<V_>, arg1: number, arg2: Internal.TimeUnit_): io.netty.util.concurrent.ScheduledFuture<V_>;
        schedule<V_>(arg0: java_.util.concurrent.Callable_<V_>, arg1: number, arg2: Internal.TimeUnit_): Internal.ScheduledFuture<V_>;
        schedule(arg0: Internal.Runnable_, arg1: number, arg2: Internal.TimeUnit_): io.netty.util.concurrent.ScheduledFuture<any>;
        schedule(arg0: Internal.Runnable_, arg1: number, arg2: Internal.TimeUnit_): Internal.ScheduledFuture<any>;
        isShuttingDown(): boolean;
        iterator(): Internal.Iterator<Internal.EventExecutor>;
        newSucceededFuture<V_>(arg0: V_): io.netty.util.concurrent.Future<V_>;
        awaitTermination(arg0: number, arg1: Internal.TimeUnit_): boolean;
        invokeAny<T_>(arg0: Internal.Collection_<java_.util.concurrent.Callable_<T_>>, arg1: number, arg2: Internal.TimeUnit_): T_;
        invokeAny<T_>(arg0: Internal.Collection_<java_.util.concurrent.Callable_<T_>>): T_;
        shutdownNow(): Internal.List<Internal.Runnable>;
        shutdown(): void;
        isShutdown(): boolean;
        newPromise<V_>(): Internal.Promise<V_>;
    }
    type OrderedEventExecutor_ = OrderedEventExecutor;
    interface Registrar <T> extends Internal.Iterable<T> {
        getKey(arg0: T): Internal.Optional<Internal.ResourceKey<T>>;
        byRawId(arg0: number): T;
        spliterator(): Internal.Spliterator<T>;
        entrySet(): Internal.Set<Internal.Map$Entry<Internal.ResourceKey<T>, T>>;
        forEach(arg0: Internal.Consumer_<T>): void;
        getIds(): Internal.Set<ResourceLocation>;
        getId(arg0: T): ResourceLocation;
        containsValue(arg0: T): boolean;
        listen(arg0: ResourceLocation_, arg1: Internal.Consumer_<T>): void;
        listen<R_>(supplier: Internal.RegistrySupplier_<R_>, callback: Internal.Consumer_<R_>): void;
        delegate(arg0: ResourceLocation_): Internal.RegistrySupplier<T>;
        iterator(): Internal.Iterator<T>;
        contains(arg0: ResourceLocation_): boolean;
        get(arg0: ResourceLocation_): T;
        getRawId(arg0: T): number;
        wrap<R_>(obj: R_): Internal.RegistrySupplier<R_>;
        key(): Internal.ResourceKey<Internal.Registry<T>>;
        register<E_>(arg0: ResourceLocation_, arg1: Internal.Supplier_<E_>): Internal.RegistrySupplier<E_>;
    }
    type Registrar_<T> = Registrar<T>;
    abstract class CompressorHolder implements Internal.Compressable {
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        keys<T_>(arg0: Internal.DynamicOps_<T_>): Internal.Stream<T_>;
        hashCode(): number;
        notifyAll(): void;
        equals(arg0: any): boolean;
        toString(): string;
        notify(): void;
        compressor<T_>(arg0: Internal.DynamicOps_<T_>): Internal.KeyCompressor<T_>;
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    type CompressorHolder_ = CompressorHolder;
    interface Cancellable {
        cancel(): void;
        isCancelled(): boolean;
        isCancellable(): boolean;
    }
    type Cancellable_ = Cancellable;
    abstract class ImmutableMultiset <E> extends Internal.ImmutableMultisetGwtSerializationDependencies<E> implements Internal.Multiset<E> {
        getClass(): Internal.Class<any>;
        forEachEntry(arg0: Internal.ObjIntConsumer_<E>): void;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        notifyAll(): void;
        notify(): void;
        asList(): Internal.ImmutableList<E>;
        remove(arg0: any, arg1: number): number;
        remove(arg0: any): boolean;
        removeAll(arg0: Internal.Collection_<any>): boolean;
        iterator(): Internal.UnmodifiableIterator<E>;
        stream(): Internal.Stream<E>;
        elementSet(): Internal.ImmutableSet<E>;
        hashCode(): number;
        static of<E_>(arg0: E_, arg1: E_, arg2: E_): Internal.ImmutableMultiset<E_>;
        static of<E_>(arg0: E_): Internal.ImmutableMultiset<E_>;
        static of<E_>(arg0: E_, arg1: E_): Internal.ImmutableMultiset<E_>;
        static of<E_>(): Internal.ImmutableMultiset<E_>;
        static of<E_>(arg0: E_, arg1: E_, arg2: E_, arg3: E_, arg4: E_): Internal.ImmutableMultiset<E_>;
        static of<E_>(arg0: E_, arg1: E_, arg2: E_, arg3: E_, arg4: E_, arg5: E_, arg6: E_[]): Internal.ImmutableMultiset<E_>;
        static of<E_>(arg0: E_, arg1: E_, arg2: E_, arg3: E_): Internal.ImmutableMultiset<E_>;
        toArray(): any[];
        toArray<T_>(arg0: T_[]): T_[];
        toArray<T_>(arg0: Internal.IntFunction_<T_[]>): T_[];
        static builder<E_>(): Internal.ImmutableMultiset$Builder<E_>;
        parallelStream(): Internal.Stream<E>;
        setCount(arg0: E, arg1: number, arg2: number): boolean;
        setCount(arg0: E, arg1: number): number;
        add(arg0: E, arg1: number): number;
        add(arg0: E): boolean;
        static toImmutableMultiset<T_, E_>(arg0: java_.util.function_.Function_<T_, E_>, arg1: Internal.ToIntFunction_<T_>): Internal.Collector<T_, any, Internal.ImmutableMultiset<E_>>;
        static toImmutableMultiset<E_>(): Internal.Collector<E_, any, Internal.ImmutableMultiset<E_>>;
        spliterator(): Internal.Spliterator<E>;
        entrySet(): Internal.ImmutableSet<Internal.Multiset$Entry<E>>;
        forEach(arg0: Internal.Consumer_<E>): void;
        containsAll(arg0: Internal.Collection_<any>): boolean;
        count(arg0: any): number;
        isEmpty(): boolean;
        clear(): void;
        static copyOf<E_>(arg0: Internal.Iterator_<E_>): Internal.ImmutableMultiset<E_>;
        static copyOf<E_>(arg0: E_[]): Internal.ImmutableMultiset<E_>;
        static copyOf<E_>(arg0: Internal.Iterable_<E_>): Internal.ImmutableMultiset<E_>;
        removeIf(arg0: Internal.Predicate_<E>): boolean;
        contains(arg0: any): boolean;
        size(): number;
        addAll(arg0: Internal.Collection_<E>): boolean;
        equals(arg0: any): boolean;
        toString(): string;
        retainAll(arg0: Internal.Collection_<any>): boolean;
        get class(): Internal.Class<any>;
        get empty(): boolean;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    type ImmutableMultiset_<E> = ImmutableMultiset<E>;
    class BlockBehaviour$Properties {
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        lootFrom(arg0: Internal.Supplier_<Internal.Block_>): Internal.BlockBehaviour$Properties;
        hashCode(): number;
        notifyAll(): void;
        equals(arg0: any): boolean;
        toString(): string;
        notify(): void;
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    type BlockBehaviour$Properties_ = BlockBehaviour$Properties;
    interface LivingEntityAccessor {
        quark$createLootContext(arg0: boolean, arg1: Internal.DamageSource_): Internal.LootContext$Builder;
        quark$lastHurtByPlayerTime(): number;
    }
    type LivingEntityAccessor_ = LivingEntityAccessor;
    interface CustomJavaToJsWrapper {
        convertJavaToJs(arg0: Internal.Context_, arg1: Internal.Scriptable_, arg2: Internal.Class_<any>): Internal.Scriptable;
    }
    type CustomJavaToJsWrapper_ = ((arg0: Internal.Context, arg1: Internal.Scriptable, arg2: Internal.Class<any>) => Internal.Scriptable) | CustomJavaToJsWrapper;
    class RemoveOresProperties {
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        hashCode(): number;
        notifyAll(): void;
        equals(arg0: any): boolean;
        toString(): string;
        notify(): void;
        biomes : ((arg0: Internal.BiomeModifications$BiomeContext) => boolean);
        blocks : BlockStatePredicate;
        worldgenLayer : DecorationGenerationStep;
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    type RemoveOresProperties_ = RemoveOresProperties;
    interface LongConsumer extends Internal.Consumer<number>, java_.util.function_.LongConsumer {
        andThen(arg0: java_.util.function_.LongConsumer_): Internal.LongConsumer;
        andThen(arg0: Internal.Consumer_<number>): Internal.Consumer<number>;
        andThen(arg0: Internal.LongConsumer_): Internal.LongConsumer;
        accept(arg0: number): void;
    }
    type LongConsumer_ = ((arg0: number) => void) | LongConsumer;
    interface DataOutput {
        writeChar(arg0: number): void;
        writeInt(arg0: number): void;
        writeLong(arg0: number): void;
        writeByte(arg0: number): void;
        writeBytes(arg0: string): void;
        writeUTF(arg0: string): void;
        writeShort(arg0: number): void;
        writeChars(arg0: string): void;
        writeFloat(arg0: number): void;
        write(arg0: number[], arg1: number, arg2: number): void;
        write(arg0: number[]): void;
        write(arg0: number): void;
        writeBoolean(arg0: boolean): void;
        writeDouble(arg0: number): void;
    }
    type DataOutput_ = DataOutput;
    class Period implements Internal.ChronoPeriod, Internal.Serializable {
        getClass(): Internal.Class<any>;
        minus(arg0: Internal.TemporalAmount_): Internal.Period;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        negated(): Internal.Period;
        normalized(): Internal.Period;
        notifyAll(): void;
        static ofYears(arg0: number): Internal.Period;
        notify(): void;
        getMonths(): number;
        plusDays(arg0: number): Internal.Period;
        multipliedBy(arg0: number): Internal.Period;
        getYears(): number;
        hashCode(): number;
        static of(arg0: number, arg1: number, arg2: number): Internal.Period;
        get(arg0: Internal.TemporalUnit_): number;
        isZero(): boolean;
        static from(arg0: Internal.TemporalAmount_): Internal.Period;
        withDays(arg0: number): Internal.Period;
        getChronology(): Internal.IsoChronology;
        static between(arg0: Internal.LocalDate_, arg1: Internal.LocalDate_): Internal.Period;
        isNegative(): boolean;
        withMonths(arg0: number): Internal.Period;
        minusYears(arg0: number): Internal.Period;
        plusMonths(arg0: number): Internal.Period;
        plusYears(arg0: number): Internal.Period;
        static ofDays(arg0: number): Internal.Period;
        static parse(arg0: Internal.CharSequence_): Internal.Period;
        toTotalMonths(): number;
        plus(arg0: Internal.TemporalAmount_): Internal.Period;
        minusDays(arg0: number): Internal.Period;
        minusMonths(arg0: number): Internal.Period;
        static ofWeeks(arg0: number): Internal.Period;
        getDays(): number;
        subtractFrom(arg0: Internal.Temporal_): Internal.Temporal;
        equals(arg0: any): boolean;
        getUnits(): Internal.List<Internal.TemporalUnit>;
        static ofMonths(arg0: number): Internal.Period;
        addTo(arg0: Internal.Temporal_): Internal.Temporal;
        toString(): string;
        withYears(arg0: number): Internal.Period;
        static readonly ZERO : Internal.Period;
        get zero(): boolean;
        get negative(): boolean;
        get months(): number;
        get chronology(): Internal.IsoChronology;
        get days(): number;
        get units(): Internal.List<Internal.TemporalUnit>;
        get class(): Internal.Class<any>;
        get years(): number;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    type Period_ = Period;
    class ModuleDescriptor implements Internal.Comparable<Internal.ModuleDescriptor> {
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        toNameAndVersion(): string;
        mainClass(): Internal.Optional<string>;
        exports(): Internal.Set<Internal.ModuleDescriptor$Exports>;
        notifyAll(): void;
        compareTo(arg0: Internal.ModuleDescriptor_): number;
        modifiers(): Internal.Set<Internal.ModuleDescriptor$Modifier>;
        notify(): void;
        provides(): Internal.Set<Internal.ModuleDescriptor$Provides>;
        hashCode(): number;
        static newOpenModule(arg0: string): Internal.ModuleDescriptor$Builder;
        static newModule(arg0: string, arg1: Internal.Set_<Internal.ModuleDescriptor$Modifier_>): Internal.ModuleDescriptor$Builder;
        static newModule(arg0: string): Internal.ModuleDescriptor$Builder;
        isAutomatic(): boolean;
        static read(arg0: Internal.InputStream_, arg1: Internal.Supplier_<Internal.Set_<string>>): Internal.ModuleDescriptor;
        static read(arg0: Internal.InputStream_): Internal.ModuleDescriptor;
        static read(arg0: Internal.ByteBuffer_, arg1: Internal.Supplier_<Internal.Set_<string>>): Internal.ModuleDescriptor;
        static read(arg0: Internal.ByteBuffer_): Internal.ModuleDescriptor;
        rawVersion(): Internal.Optional<string>;
        packages(): Internal.Set<string>;
        version(): Internal.Optional<Internal.ModuleDescriptor$Version>;
        static newAutomaticModule(arg0: string): Internal.ModuleDescriptor$Builder;
        isOpen(): boolean;
        equals(arg0: any): boolean;
        name(): string;
        opens(): Internal.Set<Internal.ModuleDescriptor$Opens>;
        uses(): Internal.Set<string>;
        toString(): string;
        requires(): Internal.Set<Internal.ModuleDescriptor$Requires>;
        get automatic(): boolean;
        get class(): Internal.Class<any>;
        get open(): boolean;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    type ModuleDescriptor_ = ModuleDescriptor;
    interface ByteIterable extends Internal.Iterable<number> {
        iterator(): Internal.ByteIterator;
        spliterator(): Internal.ByteSpliterator;
        forEach(arg0: Internal.ByteConsumer_): void;
        forEach(arg0: Internal.Consumer_<number>): void;
        forEach(arg0: java_.util.function_.IntConsumer_): void;
        intIterator(): Internal.IntIterator;
        intSpliterator(): Internal.IntSpliterator;
    }
    type ByteIterable_ = ByteIterable;
    interface ReloadableResourceManagerImplAccessor {
        repurposedstructures_getNamespacedManagers(): Internal.Map<string, Internal.FallbackResourceManager>;
    }
    type ReloadableResourceManagerImplAccessor_ = ReloadableResourceManagerImplAccessor;
    class WindowEvent extends Internal.ComponentEvent {
        getClass(): Internal.Class<any>;
        setSource(arg0: any): void;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        getWindow(): java_.awt.Window;
        notifyAll(): void;
        getID(): number;
        getOldState(): number;
        notify(): void;
        getNewState(): number;
        paramString(): string;
        hashCode(): number;
        getSource(): any;
        equals(arg0: any): boolean;
        getOppositeWindow(): java_.awt.Window;
        toString(): string;
        getComponent(): java_.awt.Component;
        static readonly ADJUSTMENT_EVENT_MASK : 256;
        static readonly MOUSE_EVENT_MASK : 16;
        static readonly WINDOW_CLOSED : 202;
        static readonly COMPONENT_EVENT_MASK : 1;
        static readonly PAINT_EVENT_MASK : 8192;
        static readonly COMPONENT_HIDDEN : 103;
        static readonly INPUT_METHOD_EVENT_MASK : 2048;
        static readonly HIERARCHY_BOUNDS_EVENT_MASK : 65536;
        static readonly COMPONENT_LAST : 103;
        static readonly FOCUS_EVENT_MASK : 4;
        static readonly WINDOW_ICONIFIED : 203;
        static readonly WINDOW_GAINED_FOCUS : 207;
        static readonly WINDOW_DEICONIFIED : 204;
        static readonly INVOCATION_EVENT_MASK : 16384;
        static readonly WINDOW_CLOSING : 201;
        static readonly KEY_EVENT_MASK : 8;
        static readonly RESERVED_ID_MAX : 1999;
        static readonly WINDOW_OPENED : 200;
        static readonly CONTAINER_EVENT_MASK : 2;
        static readonly WINDOW_EVENT_MASK : 64;
        static readonly WINDOW_LOST_FOCUS : 208;
        static readonly MOUSE_WHEEL_EVENT_MASK : 131072;
        static readonly MOUSE_MOTION_EVENT_MASK : 32;
        static readonly COMPONENT_FIRST : 100;
        static readonly WINDOW_FOCUS_EVENT_MASK : 524288;
        static readonly COMPONENT_MOVED : 100;
        static readonly WINDOW_STATE_CHANGED : 209;
        static readonly COMPONENT_SHOWN : 102;
        static readonly TEXT_EVENT_MASK : 1024;
        static readonly WINDOW_ACTIVATED : 205;
        static readonly WINDOW_DEACTIVATED : 206;
        static readonly ACTION_EVENT_MASK : 128;
        static readonly WINDOW_LAST : 209;
        static readonly ITEM_EVENT_MASK : 512;
        static readonly WINDOW_FIRST : 200;
        static readonly HIERARCHY_EVENT_MASK : 32768;
        static readonly WINDOW_STATE_EVENT_MASK : 262144;
        static readonly COMPONENT_RESIZED : 101;
        get component(): java_.awt.Component;
        get oldState(): number;
        get window(): java_.awt.Window;
        get iD(): number;
        get source(): any;
        get oppositeWindow(): java_.awt.Window;
        get class(): Internal.Class<any>;
        get newState(): number;
        set source(arg0: any);
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    type WindowEvent_ = WindowEvent;
    interface LongStream$LongMapMultiConsumer {
        accept(arg0: number, arg1: java_.util.function_.LongConsumer_): void;
    }
    type LongStream$LongMapMultiConsumer_ = ((arg0: number, arg1: java_.util.function_.LongConsumer) => void) | LongStream$LongMapMultiConsumer;
    interface CommandSourceStackAccess {
        byg_getSource(): Internal.CommandSource;
    }
    type CommandSourceStackAccess_ = CommandSourceStackAccess;
    interface Constant <T> extends Internal.Comparable<T> {
        name(): string;
        compareTo(arg0: T): number;
        id(): number;
    }
    type Constant_<T> = Constant<T>;
    interface CharSequence {
        isEmpty(): boolean;
        length(): number;
        toString(): string;
        subSequence(arg0: number, arg1: number): Internal.CharSequence;
        chars(): Internal.IntStream;
        charAt(arg0: number): string;
        codePoints(): Internal.IntStream;
    }
    type CharSequence_ = CharSequence;
    class StringBuilder extends Internal.AbstractStringBuilder implements Internal.Serializable, Internal.Comparable<Internal.StringBuilder>, Internal.CharSequence {
        deleteCharAt(arg0: number): Internal.StringBuilder;
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        notifyAll(): void;
        isEmpty(): boolean;
        replace(arg0: number, arg1: number, arg2: string): Internal.StringBuilder;
        insert(arg0: number, arg1: number): Internal.StringBuilder;
        insert(arg0: number, arg1: string): Internal.StringBuilder;
        insert(arg0: number, arg1: any): Internal.StringBuilder;
        insert(arg0: number, arg1: string[], arg2: number, arg3: number): Internal.StringBuilder;
        insert(arg0: number, arg1: Internal.CharSequence_, arg2: number, arg3: number): Internal.StringBuilder;
        insert(arg0: number, arg1: Internal.CharSequence_): Internal.StringBuilder;
        insert(arg0: number, arg1: string[]): Internal.StringBuilder;
        insert(arg0: number, arg1: boolean): Internal.StringBuilder;
        compareTo(arg0: Internal.StringBuilder_): number;
        reverse(): Internal.StringBuilder;
        delete(arg0: number, arg1: number): Internal.StringBuilder;
        notify(): void;
        appendCodePoint(arg0: number): Internal.StringBuilder;
        lastIndexOf(arg0: string, arg1: number): number;
        lastIndexOf(arg0: string): number;
        hashCode(): number;
        equals(arg0: any): boolean;
        toString(): string;
        indexOf(arg0: string): number;
        indexOf(arg0: string, arg1: number): number;
        append(arg0: Internal.StringBuffer_): Internal.StringBuilder;
        append(arg0: Internal.CharSequence_): Internal.StringBuilder;
        append(arg0: Internal.CharSequence_, arg1: number, arg2: number): Internal.StringBuilder;
        append(arg0: string[]): Internal.StringBuilder;
        append(arg0: any): Internal.StringBuilder;
        append(arg0: string): Internal.StringBuilder;
        append(arg0: number): Internal.StringBuilder;
        append(arg0: boolean): Internal.StringBuilder;
        append(arg0: string[], arg1: number, arg2: number): Internal.StringBuilder;
        get class(): Internal.Class<any>;
        get empty(): boolean;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    type StringBuilder_ = StringBuilder;
    interface Short2ByteFunction extends Internal.Function<number, number>, Internal.IntUnaryOperator {
        getOrDefault(arg0: any, arg1: number): number;
        getOrDefault(arg0: number, arg1: number): number;
        andThenShort(arg0: Internal.Byte2ShortFunction_): Internal.Short2ShortFunction;
        composeByte(arg0: Internal.Byte2ShortFunction_): Internal.Byte2ByteFunction;
        andThenInt(arg0: Internal.Byte2IntFunction_): Internal.Short2IntFunction;
        composeReference<T_>(arg0: Internal.Reference2ShortFunction_<T_>): Internal.Reference2ByteFunction<T_>;
        andThen<T_>(arg0: java_.util.function_.Function_<number, T_>): java_.util.function_.Function<number, T_>;
        andThen(arg0: Internal.IntUnaryOperator_): Internal.IntUnaryOperator;
        put(arg0: number, arg1: number): number;
        remove(arg0: number): number;
        remove(arg0: any): number;
        defaultReturnValue(): number;
        defaultReturnValue(arg0: number): void;
        andThenDouble(arg0: Internal.Byte2DoubleFunction_): Internal.Short2DoubleFunction;
        andThenObject<T_>(arg0: Internal.Byte2ObjectFunction_<T_>): Internal.Short2ObjectFunction<T_>;
        get(arg0: any): number;
        get(arg0: number): number;
        andThenLong(arg0: Internal.Byte2LongFunction_): Internal.Short2LongFunction;
        composeLong(arg0: Internal.Long2ShortFunction_): Internal.Long2ByteFunction;
        andThenByte(arg0: Internal.Byte2ByteFunction_): Internal.Short2ByteFunction;
        andThenFloat(arg0: Internal.Byte2FloatFunction_): Internal.Short2FloatFunction;
        applyAsInt(arg0: number): number;
        apply(arg0: number): number;
        containsKey(arg0: any): boolean;
        containsKey(arg0: number): boolean;
        composeInt(arg0: Internal.Int2ShortFunction_): Internal.Int2ByteFunction;
        clear(): void;
        composeFloat(arg0: Internal.Float2ShortFunction_): Internal.Float2ByteFunction;
        andThenChar(arg0: Internal.Byte2CharFunction_): Internal.Short2CharFunction;
        composeObject<T_>(arg0: Internal.Object2ShortFunction_<T_>): Internal.Object2ByteFunction<T_>;
        size(): number;
        compose<T_>(arg0: java_.util.function_.Function_<T_, number>): java_.util.function_.Function<T_, number>;
        compose(arg0: Internal.IntUnaryOperator_): Internal.IntUnaryOperator;
        composeShort(arg0: Internal.Short2ShortFunction_): Internal.Short2ByteFunction;
        andThenReference<T_>(arg0: Internal.Byte2ReferenceFunction_<T_>): Internal.Short2ReferenceFunction<T_>;
        composeChar(arg0: Internal.Char2ShortFunction_): Internal.Char2ByteFunction;
        composeDouble(arg0: Internal.Double2ShortFunction_): Internal.Double2ByteFunction;
    }
    type Short2ByteFunction_ = ((arg0: number) => number) | Short2ByteFunction;
    abstract class DynamicConstantDesc <T> implements Internal.ConstantDesc {
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        static ofCanonical<T_>(arg0: Internal.DirectMethodHandleDesc_, arg1: string, arg2: Internal.ClassDesc_, arg3: Internal.ConstantDesc_[]): Internal.ConstantDesc;
        bootstrapMethod(): Internal.DirectMethodHandleDesc;
        constantName(): string;
        notifyAll(): void;
        bootstrapArgsList(): Internal.List<Internal.ConstantDesc>;
        resolveConstantDesc(arg0: Internal.MethodHandles$Lookup_): T;
        notify(): void;
        constantType(): Internal.ClassDesc;
        hashCode(): number;
        bootstrapArgs(): Internal.ConstantDesc[];
        static of<T_>(arg0: Internal.DirectMethodHandleDesc_, arg1: Internal.ConstantDesc_[]): Internal.DynamicConstantDesc<T_>;
        static of<T_>(arg0: Internal.DirectMethodHandleDesc_): Internal.DynamicConstantDesc<T_>;
        equals(arg0: any): boolean;
        static ofNamed<T_>(arg0: Internal.DirectMethodHandleDesc_, arg1: string, arg2: Internal.ClassDesc_, arg3: Internal.ConstantDesc_[]): Internal.DynamicConstantDesc<T_>;
        toString(): string;
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    type DynamicConstantDesc_<T> = DynamicConstantDesc<T>;
    interface PlayerData {
        setItemSwapAnimationTimer(arg0: number): void;
        disableBodyRotation(arg0: boolean): void;
        getSideSword(): Internal.ItemStack;
        setSideSword(arg0: Internal.ItemStack_): void;
        isUpdated(arg0: number): boolean;
        getLastHeldItems(): Internal.ItemStack[];
        setLastAnimationSwapTick(arg0: number): void;
        setPoseOverwrite(arg0: Internal.Pose_): void;
        lastUpdate(): number;
        getItemSwapAnimationTimer(): number;
        isBodyRotationDisabled(): boolean;
        getPoseOverwrite(): Internal.Pose;
        setUpdated(arg0: number): void;
        getLastRotations(): number[];
        getLastAnimationSwapTick(): number;
        getData<T>(arg0: Internal.DataHolder_<T>, arg1: Internal.Supplier_<T>): T;
    }
    type PlayerData_ = PlayerData;
    class AdvancementJS {
        hasDisplay(): boolean;
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        getParent(): Internal.AdvancementJS;
        notifyAll(): void;
        getId(): ResourceLocation;
        getDescription(): Internal.Text;
        notify(): void;
        getChildren(): Internal.Set<Internal.AdvancementJS>;
        getTitle(): Internal.Text;
        hashCode(): number;
        equals(o: any): boolean;
        toString(): string;
        id(): ResourceLocation;
        addChild(a: Internal.AdvancementJS_): void;
        getDisplayText(): Internal.Text;
        readonly advancement : Internal.Advancement;
        get parent(): Internal.AdvancementJS;
        get displayText(): Internal.Text;
        get children(): Internal.Set<Internal.AdvancementJS>;
        get description(): Internal.Text;
        get title(): Internal.Text;
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    type AdvancementJS_ = AdvancementJS;
    class PlayMessages$SpawnEntity {
        static encode(arg0: Internal.PlayMessages$SpawnEntity_, arg1: Internal.FriendlyByteBuf_): void;
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        getAdditionalData(): Internal.FriendlyByteBuf;
        notifyAll(): void;
        static handle(arg0: Internal.PlayMessages$SpawnEntity_, arg1: Internal.Supplier_<Internal.NetworkEvent$Context_>): void;
        getEntity(): Internal.Entity;
        static decode(arg0: Internal.FriendlyByteBuf_): Internal.PlayMessages$SpawnEntity;
        getHeadYaw(): number;
        getTypeId(): number;
        notify(): void;
        getYaw(): number;
        getPitch(): number;
        getVelY(): number;
        getVelZ(): number;
        hashCode(): number;
        equals(arg0: any): boolean;
        getVelX(): number;
        getUuid(): Internal.UUID;
        getPosZ(): number;
        toString(): string;
        getEntityId(): number;
        getPosX(): number;
        getPosY(): number;
        get headYaw(): number;
        get velZ(): number;
        get entityId(): number;
        get velY(): number;
        get velX(): number;
        get uuid(): Internal.UUID;
        get yaw(): number;
        get posX(): number;
        get posY(): number;
        get posZ(): number;
        get typeId(): number;
        get additionalData(): Internal.FriendlyByteBuf;
        get pitch(): number;
        get class(): Internal.Class<any>;
        get entity(): Internal.Entity;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    type PlayMessages$SpawnEntity_ = PlayMessages$SpawnEntity;
    /**
    */
    class ShovelItemBuilder extends Internal.HandheldItemBuilder {
        barWidth(barWidth: Internal.ToIntFunction_<Internal.ItemStackJS_>): Internal.ItemBuilder;
        getClass(): Internal.Class<any>;
        maxStackSize(v: number): Internal.ItemBuilder;
        translationKey(key: string): Internal.BuilderBase<Internal.Item>;
        newID(pre: string, post: string): ResourceLocation;
        use(use: Internal.ItemBuilder$UseCallback_): Internal.ItemBuilder;
        maxDamage(v: number): Internal.ItemBuilder;
        textureJson(json: Internal.JsonObject_): Internal.ItemBuilder;
        tooltip(text: Internal.Component_): Internal.ItemBuilder;
        modifyTier(callback: Internal.Consumer_<Internal.MutableToolTier_>): Internal.HandheldItemBuilder;
        type(type: string): Internal.BuilderBase<Internal.Item>;
        containerItem(id: string): Internal.ItemBuilder;
        subtypes(fn: java_.util.function_.Function_<Internal.ItemStackJS_, Internal.Collection_<Internal.ItemStackJS_>>): Internal.ItemBuilder;
        modelJson(json: Internal.JsonObject_): Internal.ItemBuilder;
        burnTime(v: number): Internal.ItemBuilder;
        useDuration(useDuration: Internal.ToIntFunction_<Internal.ItemStackJS_>): Internal.ItemBuilder;
        tag(tag: ResourceLocation_): Internal.BuilderBase<Internal.Item>;
        parentModel(m: string): Internal.ItemBuilder;
        generateDataJsons(generator: Internal.DataJsonGenerator_): void;
        group(g: string): Internal.ItemBuilder;
        static ofArmorMaterial(o: any): Internal.ArmorMaterial;
        /**
        */
        modifyAttribute(attribute: net.minecraft.world.entity.ai.attributes.Attribute_, identifier: string, d: number, operation: Internal.AttributeModifier$Operation_): Internal.ItemBuilder;
        getRegistryType(): Internal.RegistryObjectBuilderTypes<Internal.Item>;
        attackDamageBonus(f: number): Internal.HandheldItemBuilder;
        glow(v: boolean): Internal.ItemBuilder;
        useAnimation(animation: Internal.UseAnim_): Internal.ItemBuilder;
        rarity(v: Rarity_): Internal.ItemBuilder;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        clientRegistry(minecraft: Internal.Minecraft_): void;
        transformObject(obj: Internal.Item_): Internal.Item;
        color(callback: Internal.ItemBuilder$ItemColorJS_): Internal.ItemBuilder;
        color(index: number, c: Internal.Color_): Internal.ItemBuilder;
        displayName(name: string): Internal.BuilderBase<Internal.Item>;
        notifyAll(): void;
        barColor(barColor: java_.util.function_.Function_<Internal.ItemStackJS_, Internal.Color_>): Internal.ItemBuilder;
        notify(): void;
        createAdditionalObjects(): void;
        speed(f: number): Internal.HandheldItemBuilder;
        tier(t: Internal.Tier_): Internal.HandheldItemBuilder;
        hashCode(): number;
        get(): Internal.Item;
        speedBaseline(f: number): Internal.HandheldItemBuilder;
        generateAssetJsons(generator: Internal.AssetJsonGenerator_): void;
        getTranslationKeyGroup(): string;
        texture(key: string, tex: string): Internal.ItemBuilder;
        texture(tex: string): Internal.ItemBuilder;
        generateLang(lang: Internal.Map_<string, string>): void;
        food(b: Internal.Consumer_<Internal.FoodBuilder_>): Internal.ItemBuilder;
        createObject(): Internal.Item;
        releaseUsing(releaseUsing: Internal.ItemBuilder$ReleaseUsingCallback_): Internal.ItemBuilder;
        attackDamageBaseline(f: number): Internal.HandheldItemBuilder;
        unstackable(): Internal.ItemBuilder;
        addResourcePackLocations(path: string, list: Internal.List_<ResourceLocation_>, packType: Internal.PackType_): void;
        equals(arg0: any): boolean;
        toString(): string;
        finishUsing(finishUsing: Internal.ItemBuilder$FinishUsingCallback_): Internal.ItemBuilder;
        createItemProperties(): Internal.Item$Properties;
        static readonly TOOL_TIERS : {"gold":any,"diamond":any,"iron":any,"wood":any,"stone":any,"netherite":any};
        static readonly ARMOR_TIERS : {"gold":any,"chain":any,"diamond":any,"turtle":any,"iron":any,"leather":any,"netherite":any};
        readonly id : ResourceLocation;
        get registryType(): Internal.RegistryObjectBuilderTypes<Internal.Item>;
        get class(): Internal.Class<any>;
        get translationKeyGroup(): string;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    /**
    */
    type ShovelItemBuilder_ = ShovelItemBuilder;
    class AddAttributesFunction$Modifier$Builder {
        setSlots(arg0: EquipmentSlot_[]): void;
        setName(arg0: string): void;
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        build(): Internal.AddAttributesFunction$Modifier;
        hashCode(): number;
        notifyAll(): void;
        equals(arg0: any): boolean;
        setOperation(arg0: Internal.AttributeModifier$Operation_): void;
        toString(): string;
        setProbability(arg0: number): void;
        setUuid(arg0: Internal.UUID_): void;
        notify(): void;
        get class(): Internal.Class<any>;
        set slots(arg0: EquipmentSlot_[]);
        set probability(arg0: number);
        set name(arg0: string);
        set uuid(arg0: Internal.UUID_);
        set operation(arg0: Internal.AttributeModifier$Operation_);
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    type AddAttributesFunction$Modifier$Builder_ = AddAttributesFunction$Modifier$Builder;
    class BooleanConfig extends Internal.ConfigWithVariants<boolean> {
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        getName(): string;
        setCanEdit(e: boolean): Internal.ConfigValue<boolean>;
        notifyAll(): void;
        isEqual(v1: boolean, v2: boolean): boolean;
        compareTo(o: Internal.ConfigValue_<boolean>): number;
        notify(): void;
        getCanEdit(): boolean;
        getTooltip(): string;
        getIteration(v: boolean, next: boolean): boolean;
        hashCode(): number;
        getStringForGUI(v: boolean): Internal.Component;
        getPath(): string;
        copy(value: boolean): boolean;
        static info(key: string, value: any): Internal.Component;
        init(g: Internal.ConfigGroup_, i: string, v: boolean, c: Internal.Consumer_<boolean>, def: boolean): Internal.ConfigValue<boolean>;
        getColor(v: boolean): Internal.Color4I;
        addInfo(list: Internal.TooltipList_): void;
        getIcon(v: boolean): Internal.Icon;
        setIcon(i: Internal.Icon_): Internal.ConfigValue<boolean>;
        setOrder(o: number): Internal.ConfigValue<boolean>;
        getNameKey(): string;
        setNameKey(key: string): Internal.ConfigValue<boolean>;
        equals(arg0: any): boolean;
        onClicked(button: Internal.MouseButton_, callback: Internal.ConfigCallback_): void;
        toString(): string;
        setCurrentValue(v: boolean): boolean;
        defaultValue : boolean;
        static readonly TRUE_TEXT : Internal.TextComponent;
        static readonly FALSE_TEXT : Internal.TextComponent;
        id : string;
        static readonly NULL_TEXT : Internal.TextComponent;
        setter : ((arg0: boolean) => void);
        value : boolean;
        group : Internal.ConfigGroup;
        get path(): string;
        get nameKey(): string;
        get canEdit(): boolean;
        get name(): string;
        get tooltip(): string;
        get class(): Internal.Class<any>;
        set nameKey(key: string);
        set canEdit(e: boolean);
        set icon(i: Internal.Icon_);
        set currentValue(v: boolean);
        set order(o: number);
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    type BooleanConfig_ = BooleanConfig;
    abstract class DefaultedVertexConsumer implements Internal.VertexConsumer {
        getClass(): Internal.Class<any>;
        applyBakedLighting(arg0: number, arg1: Internal.ByteBuffer_): number;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        createSink(factory: Internal.VertexType_<any>): Internal.VertexSink;
        hashCode(): number;
        notifyAll(): void;
        equals(arg0: any): boolean;
        toString(): string;
        putBulkData(arg0: Internal.PoseStack$Pose_, arg1: Internal.BakedQuad_, arg2: number[], arg3: number, arg4: number, arg5: number, arg6: number, arg7: number[], arg8: number, arg9: boolean): void;
        putBulkData(arg0: Internal.PoseStack$Pose_, arg1: Internal.BakedQuad_, arg2: number, arg3: number, arg4: number, arg5: number, arg6: number, arg7: number, arg8: boolean): void;
        putBulkData(arg0: Internal.PoseStack$Pose_, arg1: Internal.BakedQuad_, arg2: number, arg3: number, arg4: number, arg5: number, arg6: number, arg7: number): void;
        putBulkData(arg0: Internal.PoseStack$Pose_, arg1: Internal.BakedQuad_, arg2: number, arg3: number, arg4: number, arg5: number, arg6: number, arg7: boolean): void;
        applyBakedNormals(arg0: Internal.Vector3f_, arg1: Internal.ByteBuffer_, arg2: Internal.Matrix3f_): void;
        notify(): void;
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    type DefaultedVertexConsumer_ = DefaultedVertexConsumer;
    interface ConfigSpec$CorrectionListener {
        onCorrect(arg0: Internal.ConfigSpec$CorrectionAction_, arg1: Internal.List_<string>, arg2: any, arg3: any): void;
    }
    type ConfigSpec$CorrectionListener_ = ((arg0: Internal.ConfigSpec$CorrectionAction, arg1: Internal.List<string>, arg2: any, arg3: any) => void) | ConfigSpec$CorrectionListener;
    interface AttributeView {
        name(): string;
    }
    type AttributeView_ = AttributeView;
    class ItemStackConfig extends Internal.ConfigValue<Internal.ItemStack> {
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        getName(): string;
        setCanEdit(e: boolean): Internal.ConfigValue<Internal.ItemStack>;
        notifyAll(): void;
        isEqual(v1: Internal.ItemStack_, v2: Internal.ItemStack_): boolean;
        compareTo(o: Internal.ConfigValue_<Internal.ItemStack_>): number;
        notify(): void;
        getCanEdit(): boolean;
        getTooltip(): string;
        hashCode(): number;
        getStringForGUI(v: Internal.ItemStack_): Internal.Component;
        getPath(): string;
        copy(value: Internal.ItemStack_): Internal.ItemStack;
        static info(key: string, value: any): Internal.Component;
        init(g: Internal.ConfigGroup_, i: string, v: Internal.ItemStack_, c: Internal.Consumer_<Internal.ItemStack_>, def: Internal.ItemStack_): Internal.ConfigValue<Internal.ItemStack>;
        getColor(v: Internal.ItemStack_): Internal.Color4I;
        addInfo(list: Internal.TooltipList_): void;
        getIcon(v: Internal.ItemStack_): Internal.Icon;
        setIcon(i: Internal.Icon_): Internal.ConfigValue<Internal.ItemStack>;
        setOrder(o: number): Internal.ConfigValue<Internal.ItemStack>;
        getNameKey(): string;
        setNameKey(key: string): Internal.ConfigValue<Internal.ItemStack>;
        equals(arg0: any): boolean;
        onClicked(button: Internal.MouseButton_, callback: Internal.ConfigCallback_): void;
        toString(): string;
        setCurrentValue(v: Internal.ItemStack_): boolean;
        readonly allowEmpty : boolean;
        defaultValue : Internal.ItemStack;
        id : string;
        readonly singleItemOnly : boolean;
        static readonly NULL_TEXT : Internal.TextComponent;
        setter : ((arg0: Internal.ItemStack) => void);
        value : Internal.ItemStack;
        group : Internal.ConfigGroup;
        get path(): string;
        get nameKey(): string;
        get canEdit(): boolean;
        get name(): string;
        get tooltip(): string;
        get class(): Internal.Class<any>;
        set nameKey(key: string);
        set canEdit(e: boolean);
        set icon(i: Internal.Icon_);
        set currentValue(v: Internal.ItemStack_);
        set order(o: number);
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    type ItemStackConfig_ = ItemStackConfig;
    interface Boolean2DoubleFunction extends Internal.Function<boolean, number> {
        getOrDefault(arg0: any, arg1: number): number;
        getOrDefault(arg0: boolean, arg1: number): number;
        andThenShort(arg0: Internal.Double2ShortFunction_): Internal.Boolean2ShortFunction;
        composeByte(arg0: Internal.Byte2BooleanFunction_): Internal.Byte2DoubleFunction;
        andThenInt(arg0: Internal.Double2IntFunction_): Internal.Boolean2IntFunction;
        composeReference<T_>(arg0: Internal.Reference2BooleanFunction_<T_>): Internal.Reference2DoubleFunction<T_>;
        andThen<T_>(arg0: java_.util.function_.Function_<number, T_>): java_.util.function_.Function<boolean, T_>;
        put(arg0: boolean, arg1: number): number;
        remove(arg0: any): number;
        remove(arg0: boolean): number;
        defaultReturnValue(): number;
        defaultReturnValue(arg0: number): void;
        andThenDouble(arg0: Internal.Double2DoubleFunction_): Internal.Boolean2DoubleFunction;
        andThenObject<T_>(arg0: Internal.Double2ObjectFunction_<T_>): Internal.Boolean2ObjectFunction<T_>;
        get(arg0: any): number;
        get(arg0: boolean): number;
        andThenLong(arg0: Internal.Double2LongFunction_): Internal.Boolean2LongFunction;
        composeLong(arg0: Internal.Long2BooleanFunction_): Internal.Long2DoubleFunction;
        andThenByte(arg0: Internal.Double2ByteFunction_): Internal.Boolean2ByteFunction;
        andThenFloat(arg0: Internal.Double2FloatFunction_): Internal.Boolean2FloatFunction;
        apply(arg0: boolean): number;
        containsKey(arg0: boolean): boolean;
        containsKey(arg0: any): boolean;
        composeInt(arg0: Internal.Int2BooleanFunction_): Internal.Int2DoubleFunction;
        clear(): void;
        composeFloat(arg0: Internal.Float2BooleanFunction_): Internal.Float2DoubleFunction;
        andThenChar(arg0: Internal.Double2CharFunction_): Internal.Boolean2CharFunction;
        composeObject<T_>(arg0: Internal.Object2BooleanFunction_<T_>): Internal.Object2DoubleFunction<T_>;
        size(): number;
        compose<T_>(arg0: java_.util.function_.Function_<T_, boolean>): java_.util.function_.Function<T_, number>;
        composeShort(arg0: Internal.Short2BooleanFunction_): Internal.Short2DoubleFunction;
        andThenReference<T_>(arg0: Internal.Double2ReferenceFunction_<T_>): Internal.Boolean2ReferenceFunction<T_>;
        composeChar(arg0: Internal.Char2BooleanFunction_): Internal.Char2DoubleFunction;
        composeDouble(arg0: Internal.Double2BooleanFunction_): Internal.Double2DoubleFunction;
    }
    type Boolean2DoubleFunction_ = ((arg0: boolean) => number) | Boolean2DoubleFunction;
    class Registries {
        getClass(): Internal.Class<any>;
        forRegistry<T>(key: Internal.ResourceKey_<Internal.Registry_<T>>, callback: Internal.Consumer_<Internal.Registrar_<T>>): void;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        hashCode(): number;
        getModId(): string;
        notifyAll(): void;
        equals(arg0: any): boolean;
        get<T>(registry: Internal.Registry_<T>): Internal.Registrar<T>;
        static get(modId: string): Internal.Registries;
        get<T>(key: Internal.ResourceKey_<Internal.Registry_<T>>): Internal.Registrar<T>;
        builder<T>(registryId: ResourceLocation_, typeGetter: T[]): Internal.RegistrarBuilder<T>;
        static getRegistryName<T>(object: T): ResourceLocation;
        toString(): string;
        static getId<T>(object: T, fallback: Internal.Registry_<T>): ResourceLocation;
        static getId<T>(object: T, fallback: Internal.ResourceKey_<Internal.Registry_<T>>): ResourceLocation;
        notify(): void;
        get class(): Internal.Class<any>;
        get modId(): string;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    type Registries_ = Registries;
    interface Annotation {
        hashCode(): number;
        equals(arg0: any): boolean;
        annotationType(): Internal.Class<Internal.Annotation>;
        toString(): string;
    }
    type Annotation_ = Annotation;
    interface CommonLevelAccessor extends Internal.EntityGetter, Internal.LevelReader, Internal.LevelSimulatedRW {
        getExistingBlockEntity(arg0: BlockPos_): Internal.BlockEntity;
        isAreaLoaded(arg0: BlockPos_, arg1: number): boolean;
    }
    type CommonLevelAccessor_ = CommonLevelAccessor;
    interface AccessibleComponent {
        requestFocus(): void;
        getLocation(): Internal.Point;
        addFocusListener(arg0: Internal.FocusListener_): void;
        getLocationOnScreen(): Internal.Point;
        isFocusTraversable(): boolean;
        setBackground(arg0: java_.awt.Color_): void;
        getAccessibleAt(arg0: Internal.Point_): Internal.Accessible;
        getBounds(): Internal.Rectangle;
        getFontMetrics(arg0: Internal.Font_): Internal.FontMetrics;
        isShowing(): boolean;
        setSize(arg0: Internal.Dimension_): void;
        setLocation(arg0: Internal.Point_): void;
        setFont(arg0: Internal.Font_): void;
        removeFocusListener(arg0: Internal.FocusListener_): void;
        setVisible(arg0: boolean): void;
        getCursor(): Internal.Cursor;
        setForeground(arg0: java_.awt.Color_): void;
        isVisible(): boolean;
        setBounds(arg0: Internal.Rectangle_): void;
        getForeground(): java_.awt.Color;
        setEnabled(arg0: boolean): void;
        getSize(): Internal.Dimension;
        contains(arg0: Internal.Point_): boolean;
        isEnabled(): boolean;
        setCursor(arg0: Internal.Cursor_): void;
        getFont(): Internal.Font;
        getBackground(): java_.awt.Color;
    }
    type AccessibleComponent_ = AccessibleComponent;
    interface ToDoubleFunction <T> {
        applyAsDouble(arg0: T): number;
    }
    type ToDoubleFunction_<T> = ((arg0: T) => number) | ToDoubleFunction<T>;
    abstract class RenderStateShard implements net.coderbot.iris.mixin.rendertype.RenderStateShardAccessor, Internal.RenderStateShardAccessor {
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        hashCode(): number;
        notifyAll(): void;
        equals(arg0: any): boolean;
        toString(): string;
        notify(): void;
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    type RenderStateShard_ = RenderStateShard;
    class ScriptPack {
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        hashCode(): number;
        notifyAll(): void;
        equals(arg0: any): boolean;
        toString(): string;
        notify(): void;
        readonly manager : Internal.ScriptManager;
        scope : Internal.Scriptable;
        context : Internal.Context;
        readonly scripts : Internal.List<Internal.ScriptFile>;
        readonly info : Internal.ScriptPackInfo;
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    type ScriptPack_ = ScriptPack;
    abstract class Screen extends Internal.AbstractContainerEventHandler implements Internal.Widget, Internal.ScreenAccessor, Internal.AccessorScreen, Internal.ScreenAccess, Internal.AccessScreen {
        renderComponentTooltip(arg0: Internal.PoseStack_, arg1: Internal.List_<Internal.FormattedText_>, arg2: number, arg3: number, arg4: net.minecraft.client.gui.Font_): void;
        renderComponentTooltip(arg0: Internal.PoseStack_, arg1: Internal.List_<Internal.FormattedText_>, arg2: number, arg3: number, arg4: Internal.ItemStack_): void;
        renderComponentTooltip(arg0: Internal.PoseStack_, arg1: Internal.List_<Internal.FormattedText_>, arg2: number, arg3: number, arg4: net.minecraft.client.gui.Font_, arg5: Internal.ItemStack_): void;
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        renderTooltip(arg0: Internal.PoseStack_, arg1: Internal.List_<Internal.Component_>, arg2: Internal.Optional_<Internal.TooltipComponent_>, arg3: number, arg4: number, arg5: Internal.ItemStack_): void;
        renderTooltip(arg0: Internal.PoseStack_, arg1: Internal.List_<Internal.Component_>, arg2: Internal.Optional_<Internal.TooltipComponent_>, arg3: number, arg4: number, arg5: net.minecraft.client.gui.Font_): void;
        renderTooltip(arg0: Internal.PoseStack_, arg1: Internal.List_<Internal.Component_>, arg2: Internal.Optional_<Internal.TooltipComponent_>, arg3: number, arg4: number, arg5: net.minecraft.client.gui.Font_, arg6: Internal.ItemStack_): void;
        renderTooltip(arg0: Internal.PoseStack_, arg1: Internal.List_<Internal.FormattedCharSequence_>, arg2: number, arg3: number, arg4: net.minecraft.client.gui.Font_): void;
        hashCode(): number;
        notifyAll(): void;
        equals(arg0: any): boolean;
        toString(): string;
        getMinecraft(): Internal.Minecraft;
        notify(): void;
        tooltipFont : net.minecraft.client.gui.Font;
        get minecraft(): Internal.Minecraft;
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    type Screen_ = Screen;
    interface PrivilegedExceptionAction <T> {
        run(): T;
    }
    type PrivilegedExceptionAction_<T> = (() => T) | PrivilegedExceptionAction<T>;
    interface Widget {
    }
    type Widget_ = Widget;
    interface IAntiqueTextProvider {
        setAntiqueInk(arg0: boolean): void;
        hasAntiqueInk(): boolean;
    }
    type IAntiqueTextProvider_ = IAntiqueTextProvider;
    interface Double2CharFunction extends Internal.Function<number, string>, Internal.DoubleToIntFunction {
        getOrDefault(arg0: any, arg1: string): string;
        getOrDefault(arg0: number, arg1: string): string;
        andThenShort(arg0: Internal.Char2ShortFunction_): Internal.Double2ShortFunction;
        composeByte(arg0: Internal.Byte2DoubleFunction_): Internal.Byte2CharFunction;
        andThenInt(arg0: Internal.Char2IntFunction_): Internal.Double2IntFunction;
        composeReference<T_>(arg0: Internal.Reference2DoubleFunction_<T_>): Internal.Reference2CharFunction<T_>;
        andThen<T_>(arg0: java_.util.function_.Function_<string, T_>): java_.util.function_.Function<number, T_>;
        put(arg0: number, arg1: string): string;
        remove(arg0: number): string;
        remove(arg0: any): string;
        defaultReturnValue(): string;
        defaultReturnValue(arg0: string): void;
        andThenDouble(arg0: Internal.Char2DoubleFunction_): Internal.Double2DoubleFunction;
        andThenObject<T_>(arg0: Internal.Char2ObjectFunction_<T_>): Internal.Double2ObjectFunction<T_>;
        get(arg0: any): string;
        get(arg0: number): string;
        andThenLong(arg0: Internal.Char2LongFunction_): Internal.Double2LongFunction;
        composeLong(arg0: Internal.Long2DoubleFunction_): Internal.Long2CharFunction;
        andThenByte(arg0: Internal.Char2ByteFunction_): Internal.Double2ByteFunction;
        andThenFloat(arg0: Internal.Char2FloatFunction_): Internal.Double2FloatFunction;
        applyAsInt(arg0: number): number;
        apply(arg0: number): string;
        containsKey(arg0: any): boolean;
        containsKey(arg0: number): boolean;
        composeInt(arg0: Internal.Int2DoubleFunction_): Internal.Int2CharFunction;
        clear(): void;
        composeFloat(arg0: Internal.Float2DoubleFunction_): Internal.Float2CharFunction;
        andThenChar(arg0: Internal.Char2CharFunction_): Internal.Double2CharFunction;
        composeObject<T_>(arg0: Internal.Object2DoubleFunction_<T_>): Internal.Object2CharFunction<T_>;
        size(): number;
        compose<T_>(arg0: java_.util.function_.Function_<T_, number>): java_.util.function_.Function<T_, string>;
        composeShort(arg0: Internal.Short2DoubleFunction_): Internal.Short2CharFunction;
        andThenReference<T_>(arg0: Internal.Char2ReferenceFunction_<T_>): Internal.Double2ReferenceFunction<T_>;
        composeChar(arg0: Internal.Char2DoubleFunction_): Internal.Char2CharFunction;
        composeDouble(arg0: Internal.Double2DoubleFunction_): Internal.Double2CharFunction;
    }
    type Double2CharFunction_ = ((arg0: number) => string) | Double2CharFunction;
    interface AccessorItem {
        bookshelf$setCraftingRemainder(arg0: Internal.Item_): void;
        bookshelf$setCreativeTab(arg0: Internal.CreativeModeTab_): void;
    }
    type AccessorItem_ = AccessorItem;
    interface ItemColor {
    }
    type ItemColor_ = ItemColor;
    interface MapDecoder <A> extends Internal.Keyable {
        flatMap<B_>(arg0: java_.util.function_.Function_<A, Internal.DataResult_<B_>>): Internal.MapDecoder<B_>;
        compressedDecode<T_>(arg0: Internal.DynamicOps_<T_>, arg1: T_): Internal.DataResult<A>;
        keys<T_>(arg0: Internal.DynamicOps_<T_>): Internal.Stream<T_>;
        decoder(): Internal.Decoder<A>;
        withLifecycle(arg0: Internal.Lifecycle_): Internal.MapDecoder<A>;
        decode<T_>(arg0: Internal.DynamicOps_<T_>, arg1: Internal.MapLike_<T_>): Internal.DataResult<A>;
        map<B_>(arg0: java_.util.function_.Function_<A, B_>): Internal.MapDecoder<B_>;
        compressor<T_>(arg0: Internal.DynamicOps_<T_>): Internal.KeyCompressor<T_>;
        ap<E_>(arg0: Internal.MapDecoder_<java_.util.function_.Function_<A, E_>>): Internal.MapDecoder<E_>;
    }
    type MapDecoder_<A> = MapDecoder<A>;
    abstract class ImmutableList <E> extends Internal.ImmutableCollection<E> implements Internal.List<E>, Internal.RandomAccess {
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        notifyAll(): void;
        replaceAll(arg0: Internal.UnaryOperator_<E>): void;
        notify(): void;
        asList(): Internal.ImmutableList<E>;
        remove(arg0: number): E;
        remove(arg0: any): boolean;
        static sortedCopyOf<E_>(arg0: Internal.Iterable_<E_>): Internal.ImmutableList<E_>;
        static sortedCopyOf<E_>(arg0: Internal.Comparator_<E_>, arg1: Internal.Iterable_<E_>): Internal.ImmutableList<E_>;
        removeAll(arg0: Internal.Collection_<any>): boolean;
        iterator(): Internal.UnmodifiableIterator<E>;
        stream(): Internal.Stream<E>;
        hashCode(): number;
        get(arg0: number): E;
        static of<E_>(arg0: E_, arg1: E_, arg2: E_, arg3: E_): Internal.ImmutableList<E_>;
        static of<E_>(arg0: E_, arg1: E_, arg2: E_, arg3: E_, arg4: E_): Internal.ImmutableList<E_>;
        static of<E_>(arg0: E_, arg1: E_, arg2: E_, arg3: E_, arg4: E_, arg5: E_): Internal.ImmutableList<E_>;
        static of<E_>(): Internal.ImmutableList<E_>;
        static of<E_>(arg0: E_): Internal.ImmutableList<E_>;
        static of<E_>(arg0: E_, arg1: E_): Internal.ImmutableList<E_>;
        static of<E_>(arg0: E_, arg1: E_, arg2: E_): Internal.ImmutableList<E_>;
        static of<E_>(arg0: E_, arg1: E_, arg2: E_, arg3: E_, arg4: E_, arg5: E_, arg6: E_, arg7: E_, arg8: E_, arg9: E_): Internal.ImmutableList<E_>;
        static of<E_>(arg0: E_, arg1: E_, arg2: E_, arg3: E_, arg4: E_, arg5: E_, arg6: E_, arg7: E_, arg8: E_): Internal.ImmutableList<E_>;
        static of<E_>(arg0: E_, arg1: E_, arg2: E_, arg3: E_, arg4: E_, arg5: E_, arg6: E_, arg7: E_): Internal.ImmutableList<E_>;
        static of<E_>(arg0: E_, arg1: E_, arg2: E_, arg3: E_, arg4: E_, arg5: E_, arg6: E_): Internal.ImmutableList<E_>;
        static of<E_>(arg0: E_, arg1: E_, arg2: E_, arg3: E_, arg4: E_, arg5: E_, arg6: E_, arg7: E_, arg8: E_, arg9: E_, arg10: E_, arg11: E_, arg12: E_[]): Internal.ImmutableList<E_>;
        static of<E_>(arg0: E_, arg1: E_, arg2: E_, arg3: E_, arg4: E_, arg5: E_, arg6: E_, arg7: E_, arg8: E_, arg9: E_, arg10: E_): Internal.ImmutableList<E_>;
        toArray(): any[];
        toArray<T_>(arg0: T_[]): T_[];
        toArray<T_>(arg0: Internal.IntFunction_<T_[]>): T_[];
        static builder<E_>(): Internal.ImmutableList$Builder<E_>;
        parallelStream(): Internal.Stream<E>;
        indexOf(arg0: any): number;
        add(arg0: number, arg1: E): void;
        add(arg0: E): boolean;
        subList(arg0: number, arg1: number): Internal.ImmutableList<E>;
        set(arg0: number, arg1: E): E;
        spliterator(): Internal.Spliterator<E>;
        forEach(arg0: Internal.Consumer_<E>): void;
        containsAll(arg0: Internal.Collection_<any>): boolean;
        isEmpty(): boolean;
        clear(): void;
        sort(arg0: Internal.Comparator_<E>): void;
        reverse(): Internal.ImmutableList<E>;
        static copyOf<E_>(arg0: Internal.Iterable_<E_>): Internal.ImmutableList<E_>;
        static copyOf<E_>(arg0: E_[]): Internal.ImmutableList<E_>;
        static copyOf<E_>(arg0: Internal.Collection_<E_>): Internal.ImmutableList<E_>;
        static copyOf<E_>(arg0: Internal.Iterator_<E_>): Internal.ImmutableList<E_>;
        removeIf(arg0: Internal.Predicate_<E>): boolean;
        static builderWithExpectedSize<E_>(arg0: number): Internal.ImmutableList$Builder<E_>;
        lastIndexOf(arg0: any): number;
        contains(arg0: any): boolean;
        size(): number;
        addAll(arg0: number, arg1: Internal.Collection_<E>): boolean;
        addAll(arg0: Internal.Collection_<E>): boolean;
        equals(arg0: any): boolean;
        static toImmutableList<E_>(): Internal.Collector<E_, any, Internal.ImmutableList<E_>>;
        listIterator(arg0: number): Internal.UnmodifiableListIterator<E>;
        listIterator(): Internal.UnmodifiableListIterator<E>;
        toString(): string;
        retainAll(arg0: Internal.Collection_<any>): boolean;
        get class(): Internal.Class<any>;
        get empty(): boolean;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    type ImmutableList_<E> = ImmutableList<E>;
    class Pair$Mu <S> implements Internal.K1 {
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        hashCode(): number;
        notifyAll(): void;
        equals(arg0: any): boolean;
        toString(): string;
        notify(): void;
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    type Pair$Mu_<S> = Pair$Mu<S>;
    class ClientPlayerDataJS extends Internal.PlayerDataJS<Internal.Player, Internal.ClientPlayerJS> {
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        getPlayer(): Internal.ClientPlayerJS;
        getName(): string;
        notifyAll(): void;
        getProfile(): Internal.GameProfile;
        getId(): Internal.UUID;
        getOverworld(): Internal.LevelJS;
        notify(): void;
        getLevel(): Internal.ClientLevelJS;
        getMinecraftPlayer(): Internal.Player;
        hashCode(): number;
        equals(arg0: any): boolean;
        hasClientMod(): boolean;
        toString(): string;
        getData(): Internal.AttachedData;
        get data(): Internal.AttachedData;
        get level(): Internal.ClientLevelJS;
        get minecraftPlayer(): Internal.Player;
        get profile(): Internal.GameProfile;
        get name(): string;
        get id(): Internal.UUID;
        get overworld(): Internal.LevelJS;
        get class(): Internal.Class<any>;
        get player(): Internal.ClientPlayerJS;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    type ClientPlayerDataJS_ = ClientPlayerDataJS;
    /**
    */
    class BasicItemJS$Builder extends Internal.ItemBuilder {
        barWidth(barWidth: Internal.ToIntFunction_<Internal.ItemStackJS_>): Internal.ItemBuilder;
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        clientRegistry(minecraft: Internal.Minecraft_): void;
        maxStackSize(v: number): Internal.ItemBuilder;
        transformObject(obj: Internal.Item_): Internal.Item;
        translationKey(key: string): Internal.BuilderBase<Internal.Item>;
        color(callback: Internal.ItemBuilder$ItemColorJS_): Internal.ItemBuilder;
        color(index: number, c: Internal.Color_): Internal.ItemBuilder;
        newID(pre: string, post: string): ResourceLocation;
        displayName(name: string): Internal.BuilderBase<Internal.Item>;
        use(use: Internal.ItemBuilder$UseCallback_): Internal.ItemBuilder;
        notifyAll(): void;
        maxDamage(v: number): Internal.ItemBuilder;
        textureJson(json: Internal.JsonObject_): Internal.ItemBuilder;
        tooltip(text: Internal.Component_): Internal.ItemBuilder;
        type(type: string): Internal.BuilderBase<Internal.Item>;
        barColor(barColor: java_.util.function_.Function_<Internal.ItemStackJS_, Internal.Color_>): Internal.ItemBuilder;
        containerItem(id: string): Internal.ItemBuilder;
        notify(): void;
        createAdditionalObjects(): void;
        subtypes(fn: java_.util.function_.Function_<Internal.ItemStackJS_, Internal.Collection_<Internal.ItemStackJS_>>): Internal.ItemBuilder;
        modelJson(json: Internal.JsonObject_): Internal.ItemBuilder;
        hashCode(): number;
        burnTime(v: number): Internal.ItemBuilder;
        get(): Internal.Item;
        useDuration(useDuration: Internal.ToIntFunction_<Internal.ItemStackJS_>): Internal.ItemBuilder;
        tag(tag: ResourceLocation_): Internal.BuilderBase<Internal.Item>;
        parentModel(m: string): Internal.ItemBuilder;
        generateDataJsons(generator: Internal.DataJsonGenerator_): void;
        group(g: string): Internal.ItemBuilder;
        generateAssetJsons(generator: Internal.AssetJsonGenerator_): void;
        getTranslationKeyGroup(): string;
        texture(key: string, tex: string): Internal.ItemBuilder;
        texture(tex: string): Internal.ItemBuilder;
        generateLang(lang: Internal.Map_<string, string>): void;
        static ofArmorMaterial(o: any): Internal.ArmorMaterial;
        food(b: Internal.Consumer_<Internal.FoodBuilder_>): Internal.ItemBuilder;
        createObject(): Internal.Item;
        releaseUsing(releaseUsing: Internal.ItemBuilder$ReleaseUsingCallback_): Internal.ItemBuilder;
        unstackable(): Internal.ItemBuilder;
        addResourcePackLocations(path: string, list: Internal.List_<ResourceLocation_>, packType: Internal.PackType_): void;
        /**
        */
        modifyAttribute(attribute: net.minecraft.world.entity.ai.attributes.Attribute_, identifier: string, d: number, operation: Internal.AttributeModifier$Operation_): Internal.ItemBuilder;
        equals(arg0: any): boolean;
        getRegistryType(): Internal.RegistryObjectBuilderTypes<Internal.Item>;
        toString(): string;
        finishUsing(finishUsing: Internal.ItemBuilder$FinishUsingCallback_): Internal.ItemBuilder;
        glow(v: boolean): Internal.ItemBuilder;
        useAnimation(animation: Internal.UseAnim_): Internal.ItemBuilder;
        rarity(v: Rarity_): Internal.ItemBuilder;
        createItemProperties(): Internal.Item$Properties;
        static readonly TOOL_TIERS : {"gold":any,"diamond":any,"iron":any,"wood":any,"stone":any,"netherite":any};
        static readonly ARMOR_TIERS : {"gold":any,"chain":any,"diamond":any,"turtle":any,"iron":any,"leather":any,"netherite":any};
        readonly id : ResourceLocation;
        get registryType(): Internal.RegistryObjectBuilderTypes<Internal.Item>;
        get class(): Internal.Class<any>;
        get translationKeyGroup(): string;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    /**
    */
    type BasicItemJS$Builder_ = BasicItemJS$Builder;
    class Properties extends Internal.Hashtable<any, any> {
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        getOrDefault(arg0: any, arg1: any): any;
        loadFromXML(arg0: Internal.InputStream_): void;
        keys(): Internal.Enumeration<any>;
        notifyAll(): void;
        computeIfAbsent(arg0: any, arg1: java_.util.function_.Function_<any, any>): any;
        values(): Internal.Collection<any>;
        save(arg0: Internal.OutputStream_, arg1: string): void;
        replace(arg0: any, arg1: any): any;
        replace(arg0: any, arg1: any, arg2: any): boolean;
        replaceAll(arg0: Internal.BiFunction_<any, any, any>): void;
        notify(): void;
        containsValue(arg0: any): boolean;
        put(arg0: any, arg1: any): any;
        remove(arg0: any, arg1: any): boolean;
        remove(arg0: any): any;
        compute(arg0: any, arg1: Internal.BiFunction_<any, any, any>): any;
        load(arg0: Internal.Reader_): void;
        load(arg0: Internal.InputStream_): void;
        hashCode(): number;
        putAll(arg0: Internal.Map_<any, any>): void;
        merge(arg0: any, arg1: any, arg2: Internal.BiFunction_<any, any, any>): any;
        get(arg0: any): any;
        keySet(): Internal.Set<any>;
        getProperty(arg0: string, arg1: string): string;
        getProperty(arg0: string): string;
        entrySet(): Internal.Set<Internal.Map$Entry<any, any>>;
        containsKey(arg0: any): boolean;
        forEach(arg0: Internal.BiConsumer_<any, any>): void;
        stringPropertyNames(): Internal.Set<string>;
        isEmpty(): boolean;
        clear(): void;
        store(arg0: Internal.OutputStream_, arg1: string): void;
        store(arg0: Internal.Writer_, arg1: string): void;
        list(arg0: Internal.PrintWriter_): void;
        list(arg0: Internal.PrintStream_): void;
        storeToXML(arg0: Internal.OutputStream_, arg1: string, arg2: string): void;
        storeToXML(arg0: Internal.OutputStream_, arg1: string, arg2: Internal.Charset_): void;
        storeToXML(arg0: Internal.OutputStream_, arg1: string): void;
        contains(arg0: any): boolean;
        computeIfPresent(arg0: any, arg1: Internal.BiFunction_<any, any, any>): any;
        size(): number;
        propertyNames(): Internal.Enumeration<any>;
        setProperty(arg0: string, arg1: string): any;
        elements(): Internal.Enumeration<any>;
        equals(arg0: any): boolean;
        clone(): any;
        toString(): string;
        putIfAbsent(arg0: any, arg1: any): any;
        get class(): Internal.Class<any>;
        get empty(): boolean;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    type Properties_ = Properties;
    class ModularUI {
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        widget(arg0: com.lowdragmc.lowdraglib.gui.widget.Widget_): Internal.ModularUI;
        notifyAll(): void;
        getScreenWidth(): number;
        getWidth(): number;
        setModularUIGui(arg0: Internal.ModularUIGuiContainer_): void;
        getGuiTop(): number;
        updateScreenSize(arg0: number, arg1: number): void;
        getGuiLeft(): number;
        initWidgets(): void;
        notify(): void;
        getScreenHeight(): number;
        getModularUIContainer(): Internal.ModularUIContainer;
        setModularUIContainer(arg0: Internal.ModularUIContainer_): void;
        getHeight(): number;
        triggerCloseListeners(): void;
        toScreenCoords(arg0: Internal.Rectangle_): Internal.Rectangle;
        setSize(arg0: number, arg1: number): void;
        hashCode(): number;
        equals(arg0: any): boolean;
        getModularUIGui(): Internal.ModularUIGuiContainer;
        registerCloseListener(arg0: Internal.Runnable_): void;
        toString(): string;
        getFlatVisibleWidgetCollection(): Internal.List<com.lowdragmc.lowdraglib.gui.widget.Widget>;
        readonly mainGroup : Internal.WidgetGroup;
        readonly entityPlayer : Internal.Player;
        readonly holder : Internal.IUIHolder;
        get flatVisibleWidgetCollection(): Internal.List<com.lowdragmc.lowdraglib.gui.widget.Widget>;
        get screenWidth(): number;
        get guiLeft(): number;
        get screenHeight(): number;
        get width(): number;
        get modularUIGui(): Internal.ModularUIGuiContainer;
        get class(): Internal.Class<any>;
        get guiTop(): number;
        get modularUIContainer(): Internal.ModularUIContainer;
        get height(): number;
        set modularUIGui(arg0: Internal.ModularUIGuiContainer_);
        set modularUIContainer(arg0: Internal.ModularUIContainer_);
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    type ModularUI_ = ModularUI;
    class ChapterImage implements Internal.Movable {
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        move(to: Internal.Chapter_, _x: number, _y: number): void;
        readData(nbt: Internal.CompoundTag_): void;
        readNetData(buffer: Internal.FriendlyByteBuf_): void;
        notifyAll(): void;
        getShape(): string;
        getWidth(): number;
        writeData(nbt: Internal.CompoundTag_): void;
        notify(): void;
        getChapter(): Internal.Chapter;
        writeNetData(buffer: Internal.FriendlyByteBuf_): void;
        getConfig(config: Internal.ConfigGroup_): void;
        drawMoved(matrixStack: Internal.PoseStack_): void;
        getHeight(): number;
        getX(): number;
        getY(): number;
        hashCode(): number;
        equals(arg0: any): boolean;
        toString(): string;
        chapter : Internal.Chapter;
        image : Internal.Icon;
        hover : Internal.List<string>;
        dev : boolean;
        corner : boolean;
        dependency : Internal.Quest;
        rotation : number;
        x : number;
        width : number;
        y : number;
        click : string;
        height : number;
        get shape(): string;
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    type ChapterImage_ = ChapterImage;
    abstract class BlockBehaviour$BlockStateBase extends Internal.StateHolder<Internal.Block, Internal.BlockState> implements Internal.BlockStateKJS {
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        hashCode(): number;
        notifyAll(): void;
        equals(arg0: any): boolean;
        toString(): string;
        notify(): void;
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    type BlockBehaviour$BlockStateBase_ = BlockBehaviour$BlockStateBase;
    class ForgeConfigSpec$Builder {
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        notifyAll(): void;
        defineEnum<V>(arg0: string, arg1: V, arg2: V[]): Internal.ForgeConfigSpec$EnumValue<V>;
        defineEnum<V>(arg0: Internal.List_<string>, arg1: V, arg2: Internal.EnumGetMethod_): Internal.ForgeConfigSpec$EnumValue<V>;
        defineEnum<V>(arg0: string, arg1: V, arg2: Internal.EnumGetMethod_, arg3: V[]): Internal.ForgeConfigSpec$EnumValue<V>;
        defineEnum<V>(arg0: Internal.List_<string>, arg1: V, arg2: V[]): Internal.ForgeConfigSpec$EnumValue<V>;
        defineEnum<V>(arg0: string, arg1: Internal.Supplier_<V>, arg2: Internal.EnumGetMethod_, arg3: Internal.Predicate_<any>, arg4: Internal.Class_<V>): Internal.ForgeConfigSpec$EnumValue<V>;
        defineEnum<V>(arg0: string, arg1: V): Internal.ForgeConfigSpec$EnumValue<V>;
        defineEnum<V>(arg0: string, arg1: V, arg2: Internal.EnumGetMethod_): Internal.ForgeConfigSpec$EnumValue<V>;
        defineEnum<V>(arg0: Internal.List_<string>, arg1: V): Internal.ForgeConfigSpec$EnumValue<V>;
        defineEnum<V>(arg0: string, arg1: V, arg2: Internal.EnumGetMethod_, arg3: Internal.Predicate_<any>): Internal.ForgeConfigSpec$EnumValue<V>;
        defineEnum<V>(arg0: Internal.List_<string>, arg1: V, arg2: Internal.Predicate_<any>): Internal.ForgeConfigSpec$EnumValue<V>;
        defineEnum<V>(arg0: Internal.List_<string>, arg1: V, arg2: Internal.EnumGetMethod_, arg3: Internal.Predicate_<any>): Internal.ForgeConfigSpec$EnumValue<V>;
        defineEnum<V>(arg0: Internal.List_<string>, arg1: Internal.Supplier_<V>, arg2: Internal.EnumGetMethod_, arg3: Internal.Predicate_<any>, arg4: Internal.Class_<V>): Internal.ForgeConfigSpec$EnumValue<V>;
        defineEnum<V>(arg0: Internal.List_<string>, arg1: Internal.Supplier_<V>, arg2: Internal.Predicate_<any>, arg3: Internal.Class_<V>): Internal.ForgeConfigSpec$EnumValue<V>;
        defineEnum<V>(arg0: string, arg1: Internal.Supplier_<V>, arg2: Internal.Predicate_<any>, arg3: Internal.Class_<V>): Internal.ForgeConfigSpec$EnumValue<V>;
        defineEnum<V>(arg0: Internal.List_<string>, arg1: V, arg2: Internal.EnumGetMethod_, arg3: V[]): Internal.ForgeConfigSpec$EnumValue<V>;
        defineEnum<V>(arg0: string, arg1: V, arg2: Internal.Collection_<V>): Internal.ForgeConfigSpec$EnumValue<V>;
        defineEnum<V>(arg0: string, arg1: V, arg2: Internal.EnumGetMethod_, arg3: Internal.Collection_<V>): Internal.ForgeConfigSpec$EnumValue<V>;
        defineEnum<V>(arg0: Internal.List_<string>, arg1: V, arg2: Internal.Collection_<V>): Internal.ForgeConfigSpec$EnumValue<V>;
        defineEnum<V>(arg0: Internal.List_<string>, arg1: V, arg2: Internal.EnumGetMethod_, arg3: Internal.Collection_<V>): Internal.ForgeConfigSpec$EnumValue<V>;
        defineEnum<V>(arg0: string, arg1: V, arg2: Internal.Predicate_<any>): Internal.ForgeConfigSpec$EnumValue<V>;
        defineList<T>(arg0: Internal.List_<string>, arg1: Internal.List_<T>, arg2: Internal.Predicate_<any>): Internal.ForgeConfigSpec$ConfigValue<Internal.List<T>>;
        defineList<T>(arg0: string, arg1: Internal.Supplier_<Internal.List_<T>>, arg2: Internal.Predicate_<any>): Internal.ForgeConfigSpec$ConfigValue<Internal.List<T>>;
        defineList<T>(arg0: string, arg1: Internal.List_<T>, arg2: Internal.Predicate_<any>): Internal.ForgeConfigSpec$ConfigValue<Internal.List<T>>;
        defineList<T>(arg0: Internal.List_<string>, arg1: Internal.Supplier_<Internal.List_<T>>, arg2: Internal.Predicate_<any>): Internal.ForgeConfigSpec$ConfigValue<Internal.List<T>>;
        configure<T>(arg0: java_.util.function_.Function_<Internal.ForgeConfigSpec$Builder_, T>): org.apache.commons.lang3.tuple.Pair<T, Internal.ForgeConfigSpec>;
        notify(): void;
        push(arg0: Internal.List_<string>): Internal.ForgeConfigSpec$Builder;
        push(arg0: string): Internal.ForgeConfigSpec$Builder;
        defineInList<T>(arg0: Internal.List_<string>, arg1: Internal.Supplier_<T>, arg2: Internal.Collection_<T>): Internal.ForgeConfigSpec$ConfigValue<T>;
        defineInList<T>(arg0: string, arg1: T, arg2: Internal.Collection_<T>): Internal.ForgeConfigSpec$ConfigValue<T>;
        defineInList<T>(arg0: Internal.List_<string>, arg1: T, arg2: Internal.Collection_<T>): Internal.ForgeConfigSpec$ConfigValue<T>;
        defineInList<T>(arg0: string, arg1: Internal.Supplier_<T>, arg2: Internal.Collection_<T>): Internal.ForgeConfigSpec$ConfigValue<T>;
        pop(): Internal.ForgeConfigSpec$Builder;
        pop(arg0: number): Internal.ForgeConfigSpec$Builder;
        defineInRange(arg0: string, arg1: Internal.Supplier_<number>, arg2: number, arg3: number): Internal.ForgeConfigSpec$DoubleValue;
        defineInRange(arg0: Internal.List_<string>, arg1: number, arg2: number, arg3: number): Internal.ForgeConfigSpec$DoubleValue;
        defineInRange(arg0: Internal.List_<string>, arg1: Internal.Supplier_<number>, arg2: number, arg3: number): Internal.ForgeConfigSpec$DoubleValue;
        defineInRange(arg0: string, arg1: number, arg2: number, arg3: number): Internal.ForgeConfigSpec$IntValue;
        defineInRange(arg0: string, arg1: number, arg2: number, arg3: number): Internal.ForgeConfigSpec$DoubleValue;
        defineInRange<V>(arg0: string, arg1: Internal.Supplier_<V>, arg2: V, arg3: V, arg4: Internal.Class_<V>): Internal.ForgeConfigSpec$ConfigValue<V>;
        defineInRange<V>(arg0: Internal.List_<string>, arg1: Internal.Supplier_<V>, arg2: V, arg3: V, arg4: Internal.Class_<V>): Internal.ForgeConfigSpec$ConfigValue<V>;
        defineInRange(arg0: Internal.List_<string>, arg1: number, arg2: number, arg3: number): Internal.ForgeConfigSpec$LongValue;
        defineInRange(arg0: string, arg1: Internal.Supplier_<number>, arg2: number, arg3: number): Internal.ForgeConfigSpec$LongValue;
        defineInRange(arg0: Internal.List_<string>, arg1: Internal.Supplier_<number>, arg2: number, arg3: number): Internal.ForgeConfigSpec$LongValue;
        defineInRange<V>(arg0: Internal.List_<string>, arg1: V, arg2: V, arg3: V, arg4: Internal.Class_<V>): Internal.ForgeConfigSpec$ConfigValue<V>;
        defineInRange<V>(arg0: string, arg1: V, arg2: V, arg3: V, arg4: Internal.Class_<V>): Internal.ForgeConfigSpec$ConfigValue<V>;
        defineInRange(arg0: Internal.List_<string>, arg1: number, arg2: number, arg3: number): Internal.ForgeConfigSpec$IntValue;
        defineInRange(arg0: string, arg1: Internal.Supplier_<number>, arg2: number, arg3: number): Internal.ForgeConfigSpec$IntValue;
        defineInRange(arg0: Internal.List_<string>, arg1: Internal.Supplier_<number>, arg2: number, arg3: number): Internal.ForgeConfigSpec$IntValue;
        defineInRange(arg0: string, arg1: number, arg2: number, arg3: number): Internal.ForgeConfigSpec$LongValue;
        worldRestart(): Internal.ForgeConfigSpec$Builder;
        build(): Internal.ForgeConfigSpec;
        hashCode(): number;
        equals(arg0: any): boolean;
        defineListAllowEmpty<T>(arg0: Internal.List_<string>, arg1: Internal.Supplier_<Internal.List_<T>>, arg2: Internal.Predicate_<any>): Internal.ForgeConfigSpec$ConfigValue<Internal.List<T>>;
        define(arg0: string, arg1: boolean): Internal.ForgeConfigSpec$BooleanValue;
        define(arg0: Internal.List_<string>, arg1: boolean): Internal.ForgeConfigSpec$BooleanValue;
        define(arg0: string, arg1: Internal.Supplier_<boolean>): Internal.ForgeConfigSpec$BooleanValue;
        define(arg0: Internal.List_<string>, arg1: Internal.Supplier_<boolean>): Internal.ForgeConfigSpec$BooleanValue;
        define<T>(arg0: string, arg1: T, arg2: Internal.Predicate_<any>): Internal.ForgeConfigSpec$ConfigValue<T>;
        define<T>(arg0: Internal.List_<string>, arg1: T): Internal.ForgeConfigSpec$ConfigValue<T>;
        define<T>(arg0: Internal.List_<string>, arg1: T, arg2: Internal.Predicate_<any>): Internal.ForgeConfigSpec$ConfigValue<T>;
        define<T>(arg0: string, arg1: Internal.Supplier_<T>, arg2: Internal.Predicate_<any>): Internal.ForgeConfigSpec$ConfigValue<T>;
        define<T>(arg0: string, arg1: T): Internal.ForgeConfigSpec$ConfigValue<T>;
        define<T>(arg0: Internal.List_<string>, arg1: Internal.Supplier_<T>, arg2: Internal.Predicate_<any>): Internal.ForgeConfigSpec$ConfigValue<T>;
        define<T>(arg0: Internal.List_<string>, arg1: Internal.ForgeConfigSpec$ValueSpec_, arg2: Internal.Supplier_<T>): Internal.ForgeConfigSpec$ConfigValue<T>;
        define<T>(arg0: Internal.List_<string>, arg1: Internal.Supplier_<T>, arg2: Internal.Predicate_<any>, arg3: Internal.Class_<any>): Internal.ForgeConfigSpec$ConfigValue<T>;
        translation(arg0: string): Internal.ForgeConfigSpec$Builder;
        toString(): string;
        comment(arg0: string[]): Internal.ForgeConfigSpec$Builder;
        comment(arg0: string): Internal.ForgeConfigSpec$Builder;
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    type ForgeConfigSpec$Builder_ = ForgeConfigSpec$Builder;
    interface MutableComponent extends Internal.Component {
        getString(): string;
    }
    type MutableComponent_ = MutableComponent;
    class ZonedDateTime implements Internal.Temporal, Internal.ChronoZonedDateTime<Internal.LocalDate>, Internal.Serializable {
        getClass(): Internal.Class<any>;
        plusHours(arg0: number): Internal.ZonedDateTime;
        isEqual(arg0: Internal.ChronoZonedDateTime_<any>): boolean;
        toLocalTime(): Internal.LocalTime;
        compareTo(arg0: Internal.ChronoZonedDateTime_<any>): number;
        static ofLocal(arg0: Internal.LocalDateTime_, arg1: Internal.ZoneId_, arg2: Internal.ZoneOffset_): Internal.ZonedDateTime;
        getDayOfWeek(): Internal.DayOfWeek;
        static ofStrict(arg0: Internal.LocalDateTime_, arg1: Internal.ZoneOffset_, arg2: Internal.ZoneId_): Internal.ZonedDateTime;
        plusSeconds(arg0: number): Internal.ZonedDateTime;
        getMinute(): number;
        static from(arg0: Internal.TemporalAccessor_): Internal.ZonedDateTime;
        getMonth(): Internal.Month;
        plusNanos(arg0: number): Internal.ZonedDateTime;
        withHour(arg0: number): Internal.ZonedDateTime;
        plusMonths(arg0: number): Internal.ZonedDateTime;
        plusYears(arg0: number): Internal.ZonedDateTime;
        truncatedTo(arg0: Internal.TemporalUnit_): Internal.ZonedDateTime;
        query<R_>(arg0: Internal.TemporalQuery_<R_>): R_;
        minusNanos(arg0: number): Internal.ZonedDateTime;
        getNano(): number;
        format(arg0: Internal.DateTimeFormatter_): string;
        getZone(): Internal.ZoneId;
        isSupported(arg0: Internal.TemporalUnit_): boolean;
        isSupported(arg0: Internal.TemporalField_): boolean;
        plus(arg0: Internal.TemporalAmount_): Internal.ZonedDateTime;
        plus(arg0: number, arg1: Internal.TemporalUnit_): Internal.ZonedDateTime;
        getYear(): number;
        toEpochSecond(): number;
        toLocalDateTime(): Internal.LocalDateTime;
        withDayOfMonth(arg0: number): Internal.ZonedDateTime;
        isAfter(arg0: Internal.ChronoZonedDateTime_<any>): boolean;
        withMonth(arg0: number): Internal.ZonedDateTime;
        toOffsetDateTime(): Internal.OffsetDateTime;
        static ofInstant(arg0: Internal.LocalDateTime_, arg1: Internal.ZoneOffset_, arg2: Internal.ZoneId_): Internal.ZonedDateTime;
        static ofInstant(arg0: Internal.Instant_, arg1: Internal.ZoneId_): Internal.ZonedDateTime;
        minus(arg0: number, arg1: Internal.TemporalUnit_): Internal.ZonedDateTime;
        minus(arg0: Internal.TemporalAmount_): Internal.ZonedDateTime;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        withFixedOffsetZone(): Internal.ZonedDateTime;
        minusHours(arg0: number): Internal.ZonedDateTime;
        notifyAll(): void;
        getOffset(): Internal.ZoneOffset;
        range(arg0: Internal.TemporalField_): Internal.ValueRange;
        withYear(arg0: number): Internal.ZonedDateTime;
        plusMinutes(arg0: number): Internal.ZonedDateTime;
        notify(): void;
        minusMinutes(arg0: number): Internal.ZonedDateTime;
        plusDays(arg0: number): Internal.ZonedDateTime;
        withLaterOffsetAtOverlap(): Internal.ZonedDateTime;
        hashCode(): number;
        static now(): Internal.ZonedDateTime;
        static now(arg0: Internal.Clock_): Internal.ZonedDateTime;
        static now(arg0: Internal.ZoneId_): Internal.ZonedDateTime;
        static of(arg0: Internal.LocalDate_, arg1: Internal.LocalTime_, arg2: Internal.ZoneId_): Internal.ZonedDateTime;
        static of(arg0: Internal.LocalDateTime_, arg1: Internal.ZoneId_): Internal.ZonedDateTime;
        static of(arg0: number, arg1: number, arg2: number, arg3: number, arg4: number, arg5: number, arg6: number, arg7: Internal.ZoneId_): Internal.ZonedDateTime;
        get(arg0: Internal.TemporalField_): number;
        withZoneSameLocal(arg0: Internal.ZoneId_): Internal.ZonedDateTime;
        withEarlierOffsetAtOverlap(): Internal.ZonedDateTime;
        getDayOfYear(): number;
        plusWeeks(arg0: number): Internal.ZonedDateTime;
        getHour(): number;
        getChronology(): Internal.Chronology;
        withMinute(arg0: number): Internal.ZonedDateTime;
        getMonthValue(): number;
        minusYears(arg0: number): Internal.ZonedDateTime;
        withZoneSameInstant(arg0: Internal.ZoneId_): Internal.ZonedDateTime;
        minusWeeks(arg0: number): Internal.ZonedDateTime;
        withDayOfYear(arg0: number): Internal.ZonedDateTime;
        static parse(arg0: Internal.CharSequence_, arg1: Internal.DateTimeFormatter_): Internal.ZonedDateTime;
        static parse(arg0: Internal.CharSequence_): Internal.ZonedDateTime;
        toInstant(): Internal.Instant;
        isBefore(arg0: Internal.ChronoZonedDateTime_<any>): boolean;
        minusDays(arg0: number): Internal.ZonedDateTime;
        withNano(arg0: number): Internal.ZonedDateTime;
        getLong(arg0: Internal.TemporalField_): number;
        minusMonths(arg0: number): Internal.ZonedDateTime;
        with(arg0: Internal.TemporalField_, arg1: number): Internal.ZonedDateTime;
        with(arg0: Internal.TemporalAdjuster_): Internal.ZonedDateTime;
        toLocalDate(): Internal.LocalDate;
        equals(arg0: any): boolean;
        getSecond(): number;
        until(arg0: Internal.Temporal_, arg1: Internal.TemporalUnit_): number;
        toString(): string;
        getDayOfMonth(): number;
        minusSeconds(arg0: number): Internal.ZonedDateTime;
        withSecond(arg0: number): Internal.ZonedDateTime;
        get offset(): Internal.ZoneOffset;
        get year(): number;
        get dayOfYear(): number;
        get nano(): number;
        get chronology(): Internal.Chronology;
        get minute(): number;
        get second(): number;
        get dayOfWeek(): Internal.DayOfWeek;
        get month(): Internal.Month;
        get hour(): number;
        get zone(): Internal.ZoneId;
        get dayOfMonth(): number;
        get monthValue(): number;
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    type ZonedDateTime_ = ZonedDateTime;
    interface BiomeProperties {
        getSpawnProperties(): Internal.SpawnProperties;
        getGenerationProperties(): Internal.GenerationProperties;
        getEffectsProperties(): Internal.EffectsProperties;
        getClimateProperties(): Internal.ClimateProperties;
        getCategory(): Internal.Biome$BiomeCategory;
    }
    type BiomeProperties_ = BiomeProperties;
    interface BuiltInExceptionProvider {
        readerExpectedInt(): Internal.SimpleCommandExceptionType;
        readerExpectedBool(): Internal.SimpleCommandExceptionType;
        dispatcherUnknownArgument(): Internal.SimpleCommandExceptionType;
        readerExpectedStartOfQuote(): Internal.SimpleCommandExceptionType;
        integerTooLow(): Internal.Dynamic2CommandExceptionType;
        doubleTooHigh(): Internal.Dynamic2CommandExceptionType;
        readerInvalidLong(): Internal.DynamicCommandExceptionType;
        dispatcherUnknownCommand(): Internal.SimpleCommandExceptionType;
        dispatcherParseException(): Internal.DynamicCommandExceptionType;
        longTooLow(): Internal.Dynamic2CommandExceptionType;
        floatTooLow(): Internal.Dynamic2CommandExceptionType;
        readerExpectedDouble(): Internal.SimpleCommandExceptionType;
        readerInvalidInt(): Internal.DynamicCommandExceptionType;
        readerExpectedLong(): Internal.SimpleCommandExceptionType;
        literalIncorrect(): Internal.DynamicCommandExceptionType;
        doubleTooLow(): Internal.Dynamic2CommandExceptionType;
        floatTooHigh(): Internal.Dynamic2CommandExceptionType;
        readerInvalidEscape(): Internal.DynamicCommandExceptionType;
        readerInvalidBool(): Internal.DynamicCommandExceptionType;
        readerInvalidFloat(): Internal.DynamicCommandExceptionType;
        readerExpectedSymbol(): Internal.DynamicCommandExceptionType;
        dispatcherExpectedArgumentSeparator(): Internal.SimpleCommandExceptionType;
        longTooHigh(): Internal.Dynamic2CommandExceptionType;
        readerInvalidDouble(): Internal.DynamicCommandExceptionType;
        integerTooHigh(): Internal.Dynamic2CommandExceptionType;
        readerExpectedEndOfQuote(): Internal.SimpleCommandExceptionType;
        readerExpectedFloat(): Internal.SimpleCommandExceptionType;
    }
    type BuiltInExceptionProvider_ = BuiltInExceptionProvider;
    class IntOpenHashSet extends Internal.AbstractIntSet implements Internal.Serializable, Internal.Cloneable, Internal.Hash {
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        notifyAll(): void;
        intIterator(): Internal.IntIterator;
        intSpliterator(): Internal.IntSpliterator;
        notify(): void;
        remove(arg0: number): boolean;
        remove(arg0: any): boolean;
        intStream(): Internal.IntStream;
        removeAll(arg0: Internal.IntCollection_): boolean;
        removeAll(arg0: Internal.Collection_<any>): boolean;
        iterator(): Internal.IntIterator;
        trim(): boolean;
        trim(arg0: number): boolean;
        stream(): Internal.Stream<number>;
        hashCode(): number;
        toIntArray(arg0: number[]): number[];
        toIntArray(): number[];
        static of(): Internal.IntOpenHashSet;
        static of(arg0: number): Internal.IntOpenHashSet;
        static of(arg0: number, arg1: number): Internal.IntOpenHashSet;
        static of(arg0: number[]): Internal.IntOpenHashSet;
        static of(arg0: number, arg1: number, arg2: number): Internal.IntOpenHashSet;
        toArray(arg0: number[]): number[];
        toArray(): any[];
        toArray<T_>(arg0: T_[]): T_[];
        toArray<T_>(arg0: Internal.IntFunction_<T_[]>): T_[];
        parallelStream(): Internal.Stream<number>;
        rem(arg0: number): boolean;
        add(arg0: number): boolean;
        spliterator(): Internal.IntSpliterator;
        forEach(arg0: java_.util.function_.IntConsumer_): void;
        forEach(arg0: Internal.IntConsumer_): void;
        forEach(arg0: Internal.Consumer_<number>): void;
        containsAll(arg0: Internal.Collection_<any>): boolean;
        containsAll(arg0: Internal.IntCollection_): boolean;
        isEmpty(): boolean;
        clear(): void;
        static toSetWithExpectedSize(arg0: Internal.IntStream_, arg1: number): Internal.IntOpenHashSet;
        removeIf(arg0: Internal.IntPredicate_): boolean;
        removeIf(arg0: Internal.Predicate_<number>): boolean;
        removeIf(arg0: java_.util.function_.IntPredicate_): boolean;
        static toSet(arg0: Internal.IntStream_): Internal.IntOpenHashSet;
        contains(arg0: number): boolean;
        contains(arg0: any): boolean;
        size(): number;
        addAll(arg0: Internal.IntCollection_): boolean;
        addAll(arg0: Internal.Collection_<number>): boolean;
        equals(arg0: any): boolean;
        clone(): Internal.IntOpenHashSet;
        toString(): string;
        intParallelStream(): Internal.IntStream;
        retainAll(arg0: Internal.Collection_<any>): boolean;
        retainAll(arg0: Internal.IntCollection_): boolean;
        static readonly DEFAULT_GROWTH_FACTOR : 16;
        static readonly FAST_LOAD_FACTOR : 0.5;
        static readonly DEFAULT_INITIAL_SIZE : 16;
        static readonly DEFAULT_LOAD_FACTOR : 0.75;
        static readonly OCCUPIED : -1;
        static readonly VERY_FAST_LOAD_FACTOR : 0.25;
        static readonly FREE : 0;
        static readonly PRIMES : number[];
        static readonly REMOVED : 1;
        get class(): Internal.Class<any>;
        get empty(): boolean;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    type IntOpenHashSet_ = IntOpenHashSet;
    interface LootContextUser {
    }
    type LootContextUser_ = LootContextUser;
    abstract class StringValueData <T> {
        getClass(): Internal.Class<any>;
        getValueAsComponent(): Internal.Component;
        getValue(): T;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        setValueFromString(v: string): void;
        hashCode(): number;
        notifyAll(): void;
        equals(arg0: any): boolean;
        setValue(v: T): void;
        toString(): string;
        getValueAsString(): string;
        notify(): void;
        readonly filter : Internal.ItemStack;
        get valueAsComponent(): Internal.Component;
        get valueAsString(): string;
        get class(): Internal.Class<any>;
        get value(): T;
        set valueFromString(v: string);
        set value(v: T);
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    type StringValueData_<T> = StringValueData<T>;
    interface FieldNamingStrategy {
        translateName(arg0: Internal.Field_): string;
    }
    type FieldNamingStrategy_ = FieldNamingStrategy;
    interface ScheduledFuture <V> extends Internal.Delayed, Internal.Future<V> {
        cancel(arg0: boolean): boolean;
        isCancelled(): boolean;
        getDelay(arg0: Internal.TimeUnit_): number;
        get(arg0: number, arg1: Internal.TimeUnit_): V;
        get(): V;
        compareTo(arg0: Internal.Delayed_): number;
        isDone(): boolean;
    }
    type ScheduledFuture_<V> = ScheduledFuture<V>;
    interface NonNullConsumer <T> {
        accept(arg0: T): void;
    }
    type NonNullConsumer_<T> = ((arg0: T) => void) | NonNullConsumer<T>;
    class DropTargetDragEvent extends Internal.DropTargetEvent {
        getDropTargetContext(): Internal.DropTargetContext;
        getDropAction(): number;
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        getLocation(): Internal.Point;
        notifyAll(): void;
        rejectDrag(): void;
        acceptDrag(arg0: number): void;
        notify(): void;
        getSourceActions(): number;
        getTransferable(): Internal.Transferable;
        getCurrentDataFlavorsAsList(): Internal.List<Internal.DataFlavor>;
        isDataFlavorSupported(arg0: Internal.DataFlavor_): boolean;
        hashCode(): number;
        getSource(): any;
        equals(arg0: any): boolean;
        toString(): string;
        getCurrentDataFlavors(): Internal.DataFlavor[];
        get sourceActions(): number;
        get transferable(): Internal.Transferable;
        get location(): Internal.Point;
        get currentDataFlavors(): Internal.DataFlavor[];
        get dropTargetContext(): Internal.DropTargetContext;
        get source(): any;
        get class(): Internal.Class<any>;
        get dropAction(): number;
        get currentDataFlavorsAsList(): Internal.List<Internal.DataFlavor>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    type DropTargetDragEvent_ = DropTargetDragEvent;
    class BlockPlacerItem extends Internal.BlockItem {
        getClass(): Internal.Class<any>;
        canElytraFly(arg0: Internal.ItemStack_, arg1: Internal.LivingEntity_): boolean;
        setBurnTime(i: number): void;
        setDamage(arg0: Internal.ItemStack_, arg1: number): void;
        canPerformAction(arg0: Internal.ItemStack_, arg1: Internal.ToolAction_): boolean;
        damageItem<T_>(arg0: Internal.ItemStack_, arg1: number, arg2: T_, arg3: Internal.Consumer_<T_>): number;
        shouldCauseBlockBreakReset(arg0: Internal.ItemStack_, arg1: Internal.ItemStack_): boolean;
        getItemEnchantability(arg0: Internal.ItemStack_): number;
        getPlacer(): Internal.BlockPlacerItem;
        shouldCauseReequipAnimation(arg0: Internal.ItemStack_, arg1: Internal.ItemStack_, arg2: boolean): boolean;
        getXpRepairRatio(arg0: Internal.ItemStack_): number;
        readShareTag(arg0: Internal.ItemStack_, arg1: Internal.CompoundTag_): void;
        handler$bcn000$overrideOtherStackedOnMe(arg0: Internal.ItemStack_, arg1: Internal.ItemStack_, arg2: Internal.Slot_, arg3: Internal.ClickAction_, arg4: Internal.Player_, arg5: Internal.SlotAccess_, arg6: Internal.CallbackInfoReturnable_<any>): void;
        onEntityItemUpdate(arg0: Internal.ItemStack_, arg1: Internal.ItemEntity_): boolean;
        getDamage(arg0: Internal.ItemStack_): number;
        mimicUseOn(arg0: Internal.UseOnContext_, arg1: Internal.Block_, arg2: Internal.FoodProperties_): Internal.InteractionResult;
        isBookEnchantable(arg0: Internal.ItemStack_, arg1: Internal.ItemStack_): boolean;
        canDisableShield(arg0: Internal.ItemStack_, arg1: Internal.ItemStack_, arg2: Internal.LivingEntity_, arg3: Internal.LivingEntity_): boolean;
        onUsingTick(arg0: Internal.ItemStack_, arg1: Internal.LivingEntity_, arg2: number): void;
        isPiglinCurrency(arg0: Internal.ItemStack_): boolean;
        getCreativeTabs(): Internal.Collection<Internal.CreativeModeTab>;
        createEntity(arg0: Internal.Level_, arg1: Internal.Entity_, arg2: Internal.ItemStack_): Internal.Entity;
        getSweepHitBox(arg0: Internal.ItemStack_, arg1: Internal.Player_, arg2: Internal.Entity_): Internal.AABB;
        isRepairable(arg0: Internal.ItemStack_): boolean;
        mimicPlace(arg0: Internal.BlockPlaceContext_, arg1: Internal.Block_, arg2: Internal.SoundType_): Internal.InteractionResult;
        getPlaceableBlock(): Internal.Block;
        removeFromBlockToItemMap(arg0: Internal.Map_<Internal.Block_, Internal.Item_>, arg1: Internal.Item_): void;
        getShareTag(arg0: Internal.ItemStack_): Internal.CompoundTag;
        getBurnTime(arg0: Internal.ItemStack_, arg1: Internal.RecipeType_<any>): number;
        onDroppedByPlayer(arg0: Internal.ItemStack_, arg1: Internal.Player_): boolean;
        isDamageable(arg0: Internal.ItemStack_): boolean;
        onEntitySwing(arg0: Internal.ItemStack_, arg1: Internal.LivingEntity_): boolean;
        getRegistryType(): Internal.Class<Internal.Item>;
        setItemBuilderKJS(b: Internal.ItemBuilder_): void;
        elytraFlightTick(arg0: Internal.ItemStack_, arg1: Internal.LivingEntity_, arg2: number): boolean;
        getItemBuilderKJS(): Internal.ItemBuilder;
        handler$bcn000$overrideStackedOnOther(arg0: Internal.ItemStack_, arg1: Internal.Slot_, arg2: Internal.ClickAction_, arg3: Internal.Player_, arg4: Internal.CallbackInfoReturnable_<any>): void;
        getAttributeModifiers(arg0: EquipmentSlot_, arg1: Internal.ItemStack_): Internal.Multimap<Internal.Attribute, Internal.AttributeModifier>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        onLeftClickEntity(arg0: Internal.ItemStack_, arg1: Internal.Player_, arg2: Internal.Entity_): boolean;
        canEquip(arg0: Internal.ItemStack_, arg1: EquipmentSlot_, arg2: Internal.Entity_): boolean;
        notifyAll(): void;
        getId(): string;
        static registerPlaceableItem(arg0: Internal.Block_, arg1: Internal.Supplier_<Internal.Item_>, arg2: Internal.ForgeConfigSpec$BooleanValue_): void;
        notify(): void;
        onBlockStartBreak(arg0: Internal.ItemStack_, arg1: BlockPos_, arg2: Internal.Player_): boolean;
        onHorseArmorTick(arg0: Internal.ItemStack_, arg1: Internal.Level_, arg2: Internal.Mob_): void;
        canContinueUsing(arg0: Internal.ItemStack_, arg1: Internal.ItemStack_): boolean;
        getEntityLifespan(arg0: Internal.ItemStack_, arg1: Internal.Level_): number;
        getRenderPropertiesInternal(): any;
        getArmorTexture(arg0: Internal.ItemStack_, arg1: Internal.Entity_, arg2: EquipmentSlot_, arg3: string): string;
        getDefaultTooltipHideFlags(arg0: Internal.ItemStack_): number;
        hashCode(): number;
        hasCustomEntity(arg0: Internal.ItemStack_): boolean;
        getHighlightTip(arg0: Internal.ItemStack_, arg1: Internal.Component_): Internal.Component;
        canWalkOnPowderedSnow(arg0: Internal.ItemStack_, arg1: Internal.LivingEntity_): boolean;
        initializeClient(arg0: Internal.Consumer_<Internal.IItemRenderProperties_>): void;
        getMaxDamage(arg0: Internal.ItemStack_): number;
        getCreatorModId(arg0: Internal.ItemStack_): string;
        isDamaged(arg0: Internal.ItemStack_): boolean;
        mimicGetPlacementState(arg0: Internal.BlockPlaceContext_, arg1: Internal.Block_): Internal.BlockState;
        onArmorTick(arg0: Internal.ItemStack_, arg1: Internal.Level_, arg2: Internal.Player_): void;
        hasContainerItem(arg0: Internal.ItemStack_): boolean;
        getFoodProperties(arg0: Internal.ItemStack_, arg1: Internal.LivingEntity_): Internal.FoodProperties;
        doesSneakBypassUse(arg0: Internal.ItemStack_, arg1: Internal.LevelReader_, arg2: BlockPos_, arg3: Internal.Player_): boolean;
        makePlaceable(arg0: Internal.Block_): void;
        onItemUseFirst(arg0: Internal.ItemStack_, arg1: Internal.UseOnContext_): Internal.InteractionResult;
        getContainerItem(arg0: Internal.ItemStack_): Internal.ItemStack;
        getRegistryName(): ResourceLocation;
        setRegistryName(arg0: ResourceLocation_): Internal.Item;
        setRegistryName(arg0: string): Internal.Item;
        setRegistryName(arg0: string, arg1: string): Internal.Item;
        onDestroyed(arg0: Internal.ItemEntity_, arg1: Internal.DamageSource_): void;
        isCorrectToolForDrops(arg0: Internal.ItemStack_, arg1: Internal.BlockState_): boolean;
        getEquipmentSlot(arg0: Internal.ItemStack_): EquipmentSlot;
        getItemStackLimit(arg0: Internal.ItemStack_): number;
        initCapabilities(arg0: Internal.ItemStack_, arg1: Internal.CompoundTag_): Internal.ICapabilityProvider;
        equals(arg0: any): boolean;
        makesPiglinsNeutral(arg0: Internal.ItemStack_, arg1: Internal.LivingEntity_): boolean;
        getTypeData(): Internal.CompoundTag;
        toString(): string;
        isEnderMask(arg0: Internal.ItemStack_, arg1: Internal.Player_, arg2: Internal.EnderMan_): boolean;
        static getInstance(): Internal.BlockPlacerItem;
        canApplyAtEnchantingTable(arg0: Internal.ItemStack_, arg1: Internal.Enchantment_): boolean;
        readonly delegate : Internal.IRegistryDelegate<Internal.Item>;
        renderProperties : any;
        static readonly PLACEABLE_ITEMS : {};
        get registryType(): Internal.Class<Internal.Item>;
        get instance(): Internal.BlockPlacerItem;
        get itemBuilderKJS(): Internal.ItemBuilder;
        get renderPropertiesInternal(): any;
        get placer(): Internal.BlockPlacerItem;
        get placeableBlock(): Internal.Block;
        get creativeTabs(): Internal.Collection<Internal.CreativeModeTab>;
        get id(): string;
        get registryName(): ResourceLocation;
        get typeData(): Internal.CompoundTag;
        get class(): Internal.Class<any>;
        set itemBuilderKJS(b: Internal.ItemBuilder_);
        set burnTime(i: number);
        set registryName(arg0: ResourceLocation_);
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    type BlockPlacerItem_ = BlockPlacerItem;
    interface RegistrarOption {
    }
    type RegistrarOption_ = RegistrarOption;
    class UpdateRendererEvent extends Internal.EventJS {
        cancel(): void;
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        isCancelled(): boolean;
        getRenderer(): Internal.IMultiblockedRenderer;
        notifyAll(): void;
        notify(): void;
        post(t: Internal.ScriptType_, id: string, sub: string): boolean;
        post(t: Internal.ScriptType_, id: string): boolean;
        hashCode(): number;
        setRenderer(arg0: Internal.IMultiblockedRenderer_): void;
        equals(arg0: any): boolean;
        toString(): string;
        getComponent(): Internal.ComponentTileEntity<any>;
        canCancel(): boolean;
        renderer : Internal.IMultiblockedRenderer;
        static readonly ID : "mbd.update_renderer";
        get component(): Internal.ComponentTileEntity<any>;
        get cancelled(): boolean;
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    type UpdateRendererEvent_ = UpdateRendererEvent;
    interface IForgePackResources {
        isHidden(): boolean;
    }
    type IForgePackResources_ = IForgePackResources;
    class Motive extends Internal.ForgeRegistryEntry<Internal.Motive> {
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        hashCode(): number;
        notifyAll(): void;
        equals(arg0: any): boolean;
        getRegistryType(): Internal.Class<Internal.Motive>;
        getRegistryName(): ResourceLocation;
        toString(): string;
        setRegistryName(arg0: ResourceLocation_): Internal.Motive;
        setRegistryName(arg0: string): Internal.Motive;
        setRegistryName(arg0: string, arg1: string): Internal.Motive;
        notify(): void;
        readonly delegate : Internal.IRegistryDelegate<Internal.Motive>;
        get registryType(): Internal.Class<Internal.Motive>;
        get registryName(): ResourceLocation;
        get class(): Internal.Class<any>;
        set registryName(arg0: ResourceLocation_);
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    type Motive_ = Motive;
    class LootBuilderPool implements Internal.FunctionContainer, Internal.ConditionContainer {
        enchantWithLevels(levels: Internal.NumberProvider_, treasure: boolean): Internal.FunctionContainer;
        damage(damage: Internal.NumberProvider_): Internal.FunctionContainer;
        nbt(tag: Internal.CompoundTag_): Internal.FunctionContainer;
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        survivesExplosion(): Internal.ConditionContainer;
        notifyAll(): void;
        addEmpty(weight: number): Internal.LootTableEntry;
        addConditionalFunction(func: Internal.Consumer_<Internal.ConditionalFunction_>): Internal.FunctionContainer;
        addCondition(o: Internal.JsonObject_): Internal.LootBuilderPool;
        addTag(tag: string, expand: boolean): Internal.LootTableEntry;
        notify(): void;
        addItem(item: Internal.ItemStack_): Internal.LootTableEntry;
        addItem(item: Internal.ItemStack_, weight: number, count: Internal.NumberProvider_): Internal.LootTableEntry;
        addItem(item: Internal.ItemStack_, weight: number): Internal.LootTableEntry;
        lootTable(table: ResourceLocation_, seed: number): Internal.FunctionContainer;
        setBinomialRolls(n: number, p: number): void;
        hashCode(): number;
        killedByPlayer(): Internal.ConditionContainer;
        randomChance(chance: number): Internal.ConditionContainer;
        addFunction(o: Internal.JsonObject_): Internal.LootBuilderPool;
        count(count: Internal.NumberProvider_): Internal.FunctionContainer;
        lootingEnchant(count: Internal.NumberProvider_, limit: number): Internal.FunctionContainer;
        setUniformRolls(min: number, max: number): void;
        toJson(): Internal.JsonObject;
        entityScores(entity: Internal.LootContext$EntityTarget_, scores: Internal.Map_<string, any>): Internal.ConditionContainer;
        copyName(source: Internal.CopyNameFunction$NameSource_): Internal.FunctionContainer;
        addEntry(json: Internal.JsonObject_): Internal.LootTableEntry;
        equals(arg0: any): boolean;
        name(name: Internal.Text_, entity: Internal.LootContext$EntityTarget_): Internal.FunctionContainer;
        name(name: Internal.Text_): Internal.FunctionContainer;
        randomChanceWithLooting(chance: number, multiplier: number): Internal.ConditionContainer;
        furnaceSmelt(): Internal.FunctionContainer;
        addLootTable(table: ResourceLocation_): Internal.LootTableEntry;
        toString(): string;
        enchantRandomly(enchantments: ResourceLocation_[]): Internal.FunctionContainer;
        entityProperties(entity: Internal.LootContext$EntityTarget_, properties: Internal.JsonObject_): Internal.ConditionContainer;
        readonly entries : Internal.JsonArray;
        readonly functions : Internal.JsonArray;
        rolls : Internal.NumberProvider;
        readonly conditions : Internal.JsonArray;
        bonusRolls : Internal.NumberProvider;
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    type LootBuilderPool_ = LootBuilderPool;
    class ScrollBar extends dev.ftb.mods.ftblibrary.ui.Widget {
        static isMouseButtonDown(button: Internal.MouseButton_): boolean;
        closeGui(openPrevScreen: boolean): void;
        closeGui(): void;
        getClass(): Internal.Class<any>;
        setY(v: number): void;
        setCanAlwaysScrollPlane(v: boolean): void;
        collidesWith(x: number, y: number, w: number, h: number): boolean;
        setX(v: number): void;
        shouldDraw(): boolean;
        acceptGhostIngredient(ingredient: any): void;
        isGhostIngredientTarget(ingredient: any): boolean;
        run(): void;
        getGui(): Internal.BaseScreen;
        canMouseScroll(): boolean;
        mousePressed(button: Internal.MouseButton_): boolean;
        setPos(x: number, y: number): void;
        getTitle(): Internal.Component;
        static getClipboardString(): string;
        drawBackground(matrixStack: Internal.PoseStack_, theme: Internal.Theme_, x: number, y: number, w: number, h: number): void;
        static isCtrlKeyDown(): boolean;
        updateMouseOver(mouseX: number, mouseY: number): void;
        getScrollStep(): number;
        getScreen(): Internal.Window;
        getMouseY(): number;
        onClosed(): void;
        isMouseOver(): boolean;
        keyPressed(key: dev.ftb.mods.ftblibrary.ui.input.Key_): boolean;
        getMouseX(): number;
        openGui(): void;
        setPosAndSize(x: number, y: number, w: number, h: number): dev.ftb.mods.ftblibrary.ui.Widget;
        getMappedValue(max: number): number;
        tick(): void;
        setHeight(v: number): void;
        addMouseOverText(list: Internal.TooltipList_): void;
        setMaxValue(max: number): void;
        showValueOnMouseOver(): boolean;
        canMouseScrollPlane(): boolean;
        playClickSound(): void;
        handleClick(click: string): boolean;
        handleClick(scheme: string, path: string): boolean;
        isEnabled(): boolean;
        charTyped(c: string, modifiers: Internal.KeyModifiers_): boolean;
        getScrollBarSize(): number;
        setMinValue(min: number): void;
        mouseDoubleClicked(button: Internal.MouseButton_): boolean;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        mouseScrolled(scroll: number): boolean;
        getMaxValue(): number;
        notifyAll(): void;
        shouldAddMouseOverText(): boolean;
        openAfter(runnable: Internal.Runnable_): Internal.Runnable;
        drawScrollBar(matrixStack: Internal.PoseStack_, theme: Internal.Theme_, x: number, y: number, w: number, h: number): void;
        closeContextMenu(): void;
        notify(): void;
        mouseReleased(button: Internal.MouseButton_): void;
        setSize(w: number, h: number): void;
        hashCode(): number;
        getPartialTicks(): number;
        openGuiLater(): void;
        static isKeyDown(key: number): boolean;
        keyReleased(key: dev.ftb.mods.ftblibrary.ui.input.Key_): void;
        setCanAlwaysScroll(v: boolean): void;
        static setClipboardString(string: string): void;
        static isShiftKeyDown(): boolean;
        getCursor(): Internal.CursorType;
        setScrollStep(s: number): void;
        getWidgetType(): Internal.WidgetType;
        draw(matrixStack: Internal.PoseStack_, theme: Internal.Theme_, x: number, y: number, w: number, h: number): void;
        checkMouseOver(mouseX: number, mouseY: number): boolean;
        setWidth(v: number): void;
        onMoved(): void;
        getValue(): number;
        openContextMenu(panel: Internal.Panel_): void;
        getX(): number;
        getMinValue(): number;
        getY(): number;
        equals(arg0: any): boolean;
        setValue(v: number): void;
        toString(): string;
        getIngredientUnderMouse(): any;
        readonly plane : Internal.ScrollBar$Plane;
        posX : number;
        parent : Internal.Panel;
        posY : number;
        width : number;
        height : number;
        get mouseX(): number;
        get cursor(): Internal.CursorType;
        get ingredientUnderMouse(): any;
        get clipboardString(): string;
        get maxValue(): number;
        get mouseY(): number;
        get shiftKeyDown(): boolean;
        get mouseOver(): boolean;
        get screen(): Internal.Window;
        get scrollStep(): number;
        get title(): Internal.Component;
        get scrollBarSize(): number;
        get enabled(): boolean;
        get widgetType(): Internal.WidgetType;
        get ctrlKeyDown(): boolean;
        get minValue(): number;
        get x(): number;
        get y(): number;
        get gui(): Internal.BaseScreen;
        get class(): Internal.Class<any>;
        get value(): number;
        get partialTicks(): number;
        set canAlwaysScroll(v: boolean);
        set canAlwaysScrollPlane(v: boolean);
        set minValue(min: number);
        set clipboardString(string: string);
        set maxValue(max: number);
        set x(v: number);
        set y(v: number);
        set scrollStep(s: number);
        set value(v: number);
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    type ScrollBar_ = ScrollBar;
    interface AccessorScreen {
        getRenderables(): Internal.List<Internal.Widget>;
        getNarratables(): Internal.List<Internal.NarratableEntry>;
    }
    type AccessorScreen_ = AccessorScreen;
    interface TooltipFlag {
    }
    type TooltipFlag_ = TooltipFlag;
    class Position {
        add(arg0: Internal.Size_): Internal.Position;
        add(arg0: Internal.Position_): Internal.Position;
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        getX(): number;
        getY(): number;
        hashCode(): number;
        notifyAll(): void;
        subtract(arg0: Internal.Position_): Internal.Position;
        equals(arg0: any): boolean;
        toString(): string;
        notify(): void;
        static readonly ORIGIN : Internal.Position;
        readonly x : number;
        readonly y : number;
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    type Position_ = Position;
    class ResourceBundle$Control {
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        static getControl(arg0: Internal.List_<string>): Internal.ResourceBundle$Control;
        toBundleName(arg0: string, arg1: Internal.Locale_): string;
        notifyAll(): void;
        newBundle(arg0: string, arg1: Internal.Locale_, arg2: string, arg3: Internal.ClassLoader_, arg4: boolean): Internal.ResourceBundle;
        getFormats(arg0: string): Internal.List<string>;
        getTimeToLive(arg0: string, arg1: Internal.Locale_): number;
        getFallbackLocale(arg0: string, arg1: Internal.Locale_): Internal.Locale;
        notify(): void;
        getCandidateLocales(arg0: string, arg1: Internal.Locale_): Internal.List<Internal.Locale>;
        static getNoFallbackControl(arg0: Internal.List_<string>): Internal.ResourceBundle$Control;
        hashCode(): number;
        equals(arg0: any): boolean;
        needsReload(arg0: string, arg1: Internal.Locale_, arg2: string, arg3: Internal.ClassLoader_, arg4: Internal.ResourceBundle_, arg5: number): boolean;
        toString(): string;
        toResourceName(arg0: string, arg1: string): string;
        static readonly FORMAT_PROPERTIES : Internal.List<string>;
        static readonly TTL_DONT_CACHE : -1;
        static readonly FORMAT_DEFAULT : Internal.List<string>;
        static readonly TTL_NO_EXPIRATION_CONTROL : -2;
        static readonly FORMAT_CLASS : Internal.List<string>;
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    type ResourceBundle$Control_ = ResourceBundle$Control;
    interface LootItemCondition$Builder {
    }
    type LootItemCondition$Builder_ = LootItemCondition$Builder;
    interface Decoder$Simple <A> {
        decoder(): Internal.Decoder<A>;
        decode<T>(arg0: Internal.Dynamic_<T>): Internal.DataResult<A>;
    }
    type Decoder$Simple_<A> = Decoder$Simple<A>;
    interface Table$Cell <R, C, V> {
        getValue(): V;
        getColumnKey(): C;
        hashCode(): number;
        equals(arg0: any): boolean;
        getRowKey(): R;
    }
    type Table$Cell_<R, C, V> = Table$Cell<R, C, V>;
    abstract class CreativeModeTab {
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        notifyAll(): void;
        getLabelColor(): number;
        setBackgroundImage(arg0: ResourceLocation_): Internal.CreativeModeTab;
        getSearchbarWidth(): number;
        static getGroupCountSafe(): number;
        notify(): void;
        hasSearchBar(): boolean;
        hashCode(): number;
        equals(arg0: any): boolean;
        toString(): string;
        getBackgroundImage(): ResourceLocation;
        getSlotColor(): number;
        getTabsImage(): ResourceLocation;
        getTabPage(): number;
        get tabsImage(): ResourceLocation;
        get slotColor(): number;
        get backgroundImage(): ResourceLocation;
        get tabPage(): number;
        get searchbarWidth(): number;
        get groupCountSafe(): number;
        get class(): Internal.Class<any>;
        get labelColor(): number;
        set backgroundImage(arg0: ResourceLocation_);
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    type CreativeModeTab_ = CreativeModeTab;
    abstract class FileLock implements Internal.AutoCloseable {
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        release(): void;
        notifyAll(): void;
        isValid(): boolean;
        channel(): Internal.FileChannel;
        notify(): void;
        acquiredBy(): Internal.Channel;
        size(): number;
        hashCode(): number;
        equals(arg0: any): boolean;
        overlaps(arg0: number, arg1: number): boolean;
        toString(): string;
        position(): number;
        close(): void;
        isShared(): boolean;
        get valid(): boolean;
        get shared(): boolean;
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    type FileLock_ = FileLock;
    interface AccessorCraftingContainer {
        bookshelf$getMenu(): Internal.AbstractContainerMenu;
    }
    type AccessorCraftingContainer_ = AccessorCraftingContainer;
    class CommandSyntaxException extends Internal.Exception {
        getClass(): Internal.Class<any>;
        getCursor(): number;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        printStackTrace(): void;
        printStackTrace(arg0: Internal.PrintWriter_): void;
        printStackTrace(arg0: Internal.PrintStream_): void;
        getLocalizedMessage(): string;
        notifyAll(): void;
        getRawMessage(): Internal.Message;
        initCause(arg0: Internal.Throwable_): Internal.Throwable;
        getMessage(): string;
        getInput(): string;
        getCause(): Internal.Throwable;
        notify(): void;
        addSuppressed(arg0: Internal.Throwable_): void;
        setStackTrace(arg0: any_[]): void;
        getStackTrace(): any[];
        getType(): Internal.CommandExceptionType;
        hashCode(): number;
        equals(arg0: any): boolean;
        getSuppressed(): Internal.Throwable[];
        toString(): string;
        getContext(): string;
        fillInStackTrace(): Internal.Throwable;
        static BUILT_IN_EXCEPTIONS : Internal.BuiltInExceptionProvider;
        static ENABLE_COMMAND_STACK_TRACES : false;
        static readonly CONTEXT_AMOUNT : 10;
        get cursor(): number;
        get input(): string;
        get localizedMessage(): string;
        get context(): string;
        get cause(): Internal.Throwable;
        get stackTrace(): any[];
        get suppressed(): Internal.Throwable[];
        get message(): string;
        get type(): Internal.CommandExceptionType;
        get class(): Internal.Class<any>;
        get rawMessage(): Internal.Message;
        set stackTrace(arg0: any_[]);
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    type CommandSyntaxException_ = CommandSyntaxException;
    interface IForgeItem {
        canElytraFly(arg0: Internal.ItemStack_, arg1: Internal.LivingEntity_): boolean;
        setDamage(arg0: Internal.ItemStack_, arg1: number): void;
        canPerformAction(arg0: Internal.ItemStack_, arg1: Internal.ToolAction_): boolean;
        damageItem<T>(arg0: Internal.ItemStack_, arg1: number, arg2: T, arg3: Internal.Consumer_<T>): number;
        shouldCauseBlockBreakReset(arg0: Internal.ItemStack_, arg1: Internal.ItemStack_): boolean;
        getItemEnchantability(arg0: Internal.ItemStack_): number;
        shouldCauseReequipAnimation(arg0: Internal.ItemStack_, arg1: Internal.ItemStack_, arg2: boolean): boolean;
        getXpRepairRatio(arg0: Internal.ItemStack_): number;
        readShareTag(arg0: Internal.ItemStack_, arg1: Internal.CompoundTag_): void;
        onEntityItemUpdate(arg0: Internal.ItemStack_, arg1: Internal.ItemEntity_): boolean;
        getDamage(arg0: Internal.ItemStack_): number;
        isBookEnchantable(arg0: Internal.ItemStack_, arg1: Internal.ItemStack_): boolean;
        canDisableShield(arg0: Internal.ItemStack_, arg1: Internal.ItemStack_, arg2: Internal.LivingEntity_, arg3: Internal.LivingEntity_): boolean;
        onUsingTick(arg0: Internal.ItemStack_, arg1: Internal.LivingEntity_, arg2: number): void;
        isPiglinCurrency(arg0: Internal.ItemStack_): boolean;
        getCreativeTabs(): Internal.Collection<Internal.CreativeModeTab>;
        createEntity(arg0: Internal.Level_, arg1: Internal.Entity_, arg2: Internal.ItemStack_): Internal.Entity;
        getSweepHitBox(arg0: Internal.ItemStack_, arg1: Internal.Player_, arg2: Internal.Entity_): Internal.AABB;
        isRepairable(arg0: Internal.ItemStack_): boolean;
        getShareTag(arg0: Internal.ItemStack_): Internal.CompoundTag;
        getBurnTime(arg0: Internal.ItemStack_, arg1: Internal.RecipeType_<any>): number;
        onDroppedByPlayer(arg0: Internal.ItemStack_, arg1: Internal.Player_): boolean;
        isDamageable(arg0: Internal.ItemStack_): boolean;
        onEntitySwing(arg0: Internal.ItemStack_, arg1: Internal.LivingEntity_): boolean;
        elytraFlightTick(arg0: Internal.ItemStack_, arg1: Internal.LivingEntity_, arg2: number): boolean;
        getAttributeModifiers(arg0: EquipmentSlot_, arg1: Internal.ItemStack_): Internal.Multimap<Internal.Attribute, Internal.AttributeModifier>;
        onLeftClickEntity(arg0: Internal.ItemStack_, arg1: Internal.Player_, arg2: Internal.Entity_): boolean;
        canEquip(arg0: Internal.ItemStack_, arg1: EquipmentSlot_, arg2: Internal.Entity_): boolean;
        onBlockStartBreak(arg0: Internal.ItemStack_, arg1: BlockPos_, arg2: Internal.Player_): boolean;
        onHorseArmorTick(arg0: Internal.ItemStack_, arg1: Internal.Level_, arg2: Internal.Mob_): void;
        canContinueUsing(arg0: Internal.ItemStack_, arg1: Internal.ItemStack_): boolean;
        getEntityLifespan(arg0: Internal.ItemStack_, arg1: Internal.Level_): number;
        getArmorTexture(arg0: Internal.ItemStack_, arg1: Internal.Entity_, arg2: EquipmentSlot_, arg3: string): string;
        getDefaultTooltipHideFlags(arg0: Internal.ItemStack_): number;
        hasCustomEntity(arg0: Internal.ItemStack_): boolean;
        getHighlightTip(arg0: Internal.ItemStack_, arg1: Internal.Component_): Internal.Component;
        canWalkOnPowderedSnow(arg0: Internal.ItemStack_, arg1: Internal.LivingEntity_): boolean;
        getMaxDamage(arg0: Internal.ItemStack_): number;
        getCreatorModId(arg0: Internal.ItemStack_): string;
        isDamaged(arg0: Internal.ItemStack_): boolean;
        onArmorTick(arg0: Internal.ItemStack_, arg1: Internal.Level_, arg2: Internal.Player_): void;
        hasContainerItem(arg0: Internal.ItemStack_): boolean;
        getFoodProperties(arg0: Internal.ItemStack_, arg1: Internal.LivingEntity_): Internal.FoodProperties;
        doesSneakBypassUse(arg0: Internal.ItemStack_, arg1: Internal.LevelReader_, arg2: BlockPos_, arg3: Internal.Player_): boolean;
        onItemUseFirst(arg0: Internal.ItemStack_, arg1: Internal.UseOnContext_): Internal.InteractionResult;
        getContainerItem(arg0: Internal.ItemStack_): Internal.ItemStack;
        onDestroyed(arg0: Internal.ItemEntity_, arg1: Internal.DamageSource_): void;
        isCorrectToolForDrops(arg0: Internal.ItemStack_, arg1: Internal.BlockState_): boolean;
        getEquipmentSlot(arg0: Internal.ItemStack_): EquipmentSlot;
        getItemStackLimit(arg0: Internal.ItemStack_): number;
        initCapabilities(arg0: Internal.ItemStack_, arg1: Internal.CompoundTag_): Internal.ICapabilityProvider;
        makesPiglinsNeutral(arg0: Internal.ItemStack_, arg1: Internal.LivingEntity_): boolean;
        isEnderMask(arg0: Internal.ItemStack_, arg1: Internal.Player_, arg2: Internal.EnderMan_): boolean;
        canApplyAtEnchantingTable(arg0: Internal.ItemStack_, arg1: Internal.Enchantment_): boolean;
    }
    type IForgeItem_ = IForgeItem;
    class ForgeConfigSpec$EnumValue <T> extends Internal.ForgeConfigSpec$ConfigValue<T> {
        next(): Internal.ForgeConfigSpec$Builder;
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        set(arg0: T): void;
        hashCode(): number;
        notifyAll(): void;
        equals(arg0: any): boolean;
        get(): T;
        getPath(): Internal.List<string>;
        save(): void;
        toString(): string;
        clearCache(): void;
        notify(): void;
        get path(): Internal.List<string>;
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    type ForgeConfigSpec$EnumValue_<T> = ForgeConfigSpec$EnumValue<T>;
    class Products$P6 <F, T1, T2, T3, T4, T5, T6> {
        t4(): Internal.App<F, T4>;
        getClass(): Internal.Class<any>;
        t5(): Internal.App<F, T5>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        t6(): Internal.App<F, T6>;
        apply<R>(arg0: Internal.Applicative_<F, any>, arg1: Internal.Function6_<T1, T2, T3, T4, T5, T6, R>): Internal.App<F, R>;
        apply<R>(arg0: Internal.Applicative_<F, any>, arg1: Internal.App_<F, Internal.Function6_<T1, T2, T3, T4, T5, T6, R>>): Internal.App<F, R>;
        notifyAll(): void;
        notify(): void;
        hashCode(): number;
        and<T7>(arg0: Internal.App_<F, T7>): Internal.Products$P7<F, T1, T2, T3, T4, T5, T6, T7>;
        and<T7, T8>(arg0: Internal.Products$P2_<F, T7, T8>): Internal.Products$P8<F, T1, T2, T3, T4, T5, T6, T7, T8>;
        equals(arg0: any): boolean;
        toString(): string;
        t1(): Internal.App<F, T1>;
        t2(): Internal.App<F, T2>;
        t3(): Internal.App<F, T3>;
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    type Products$P6_<F, T1, T2, T3, T4, T5, T6> = Products$P6<F, T1, T2, T3, T4, T5, T6>;
    class RecordCodecBuilder$Mu <O> implements Internal.K1 {
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        hashCode(): number;
        notifyAll(): void;
        equals(arg0: any): boolean;
        toString(): string;
        notify(): void;
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    type RecordCodecBuilder$Mu_<O> = RecordCodecBuilder$Mu<O>;
    interface IForgeRecipeSerializer <T> {
        fromJson(arg0: ResourceLocation_, arg1: Internal.JsonObject_, arg2: Internal.ICondition$IContext_): T;
    }
    type IForgeRecipeSerializer_<T> = IForgeRecipeSerializer<T>;
    interface ChannelConfig {
        setMessageSizeEstimator(arg0: Internal.MessageSizeEstimator_): Internal.ChannelConfig;
        setWriteBufferLowWaterMark(arg0: number): Internal.ChannelConfig;
        getWriteBufferLowWaterMark(): number;
        getMessageSizeEstimator(): Internal.MessageSizeEstimator;
        setRecvByteBufAllocator(arg0: Internal.RecvByteBufAllocator_): Internal.ChannelConfig;
        getOption<T>(arg0: Internal.ChannelOption_<T>): T;
        isAutoClose(): boolean;
        getRecvByteBufAllocator<T>(): T;
        getAllocator(): Internal.ByteBufAllocator;
        setAllocator(arg0: Internal.ByteBufAllocator_): Internal.ChannelConfig;
        isAutoRead(): boolean;
        setOptions(arg0: Internal.Map_<Internal.ChannelOption_<any>, any>): boolean;
        setConnectTimeoutMillis(arg0: number): Internal.ChannelConfig;
        setWriteBufferWaterMark(arg0: Internal.WriteBufferWaterMark_): Internal.ChannelConfig;
        setOption<T>(arg0: Internal.ChannelOption_<T>, arg1: T): boolean;
        setWriteSpinCount(arg0: number): Internal.ChannelConfig;
        getConnectTimeoutMillis(): number;
        setWriteBufferHighWaterMark(arg0: number): Internal.ChannelConfig;
        getMaxMessagesPerRead(): number;
        getWriteBufferHighWaterMark(): number;
        setAutoRead(arg0: boolean): Internal.ChannelConfig;
        getWriteSpinCount(): number;
        setMaxMessagesPerRead(arg0: number): Internal.ChannelConfig;
        getOptions(): Internal.Map<Internal.ChannelOption<any>, any>;
        getWriteBufferWaterMark(): Internal.WriteBufferWaterMark;
        setAutoClose(arg0: boolean): Internal.ChannelConfig;
    }
    type ChannelConfig_ = ChannelConfig;
    interface Function8 <T1, T2, T3, T4, T5, T6, T7, T8, R> {
        apply(arg0: T1, arg1: T2, arg2: T3, arg3: T4, arg4: T5, arg5: T6, arg6: T7, arg7: T8): R;
        curry7(): Internal.Function7<T1, T2, T3, T4, T5, T6, T7, java_.util.function_.Function<T8, R>>;
        curry5(): Internal.Function5<T1, T2, T3, T4, T5, Internal.Function3<T6, T7, T8, R>>;
        curry6(): Internal.Function6<T1, T2, T3, T4, T5, T6, Internal.BiFunction<T7, T8, R>>;
        curry3(): Internal.Function3<T1, T2, T3, Internal.Function5<T4, T5, T6, T7, T8, R>>;
        curry4(): Internal.Function4<T1, T2, T3, T4, Internal.Function4<T5, T6, T7, T8, R>>;
        curry2(): Internal.BiFunction<T1, T2, Internal.Function6<T3, T4, T5, T6, T7, T8, R>>;
        curry(): java_.util.function_.Function<T1, Internal.Function7<T2, T3, T4, T5, T6, T7, T8, R>>;
    }
    type Function8_<T1, T2, T3, T4, T5, T6, T7, T8, R> = Function8<T1, T2, T3, T4, T5, T6, T7, T8, R>;
    interface ObjectSpliterator <K> extends Internal.Spliterator<K> {
        trySplit(): Internal.ObjectSpliterator<K>;
        tryAdvance(arg0: Internal.Consumer_<K>): boolean;
        characteristics(): number;
        getComparator(): Internal.Comparator<K>;
        getExactSizeIfKnown(): number;
        estimateSize(): number;
        skip(arg0: number): number;
        hasCharacteristics(arg0: number): boolean;
        forEachRemaining(arg0: Internal.Consumer_<K>): void;
    }
    type ObjectSpliterator_<K> = ObjectSpliterator<K>;
    /**
    * Fired when you need to add, change tags of things.
    *
    * However, due to the type erasure of Java, Probe can not determine what
    * can be used here, please refer to the tag string itself.
    */
    class TagEventJS <T> extends Internal.EventJS {
        cancel(): void;
        add(tag: ResourceLocation_, ids: string[]): Internal.TagEventJS$TagWrapper<>;
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        isCancelled(): boolean;
        notifyAll(): void;
        removeAllTagsFrom(ids: string[]): void;
        setGlobalPriorityList(o: any): void;
        notify(): void;
        remove(tag: ResourceLocation_, ids: string[]): Internal.TagEventJS$TagWrapper<>;
        removeAll(tag: ResourceLocation_): Internal.TagEventJS$TagWrapper<>;
        post(event: string): void;
        post(t: Internal.ScriptType_, id: string, sub: string): boolean;
        post(t: Internal.ScriptType_, id: string): boolean;
        getType(): string;
        hashCode(): number;
        equals(arg0: any): boolean;
        get(id: ResourceLocation_): Internal.TagEventJS$TagWrapper<>;
        toString(): string;
        canCancel(): boolean;
        get cancelled(): boolean;
        get type(): string;
        get class(): Internal.Class<any>;
        set globalPriorityList(o: any);
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    /**
    * Fired when you need to add, change tags of things.
    *
    * However, due to the type erasure of Java, Probe can not determine what
    * can be used here, please refer to the tag string itself.
    */
    type TagEventJS_<T> = TagEventJS<T>;
    class ObjectiveCriteria {
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        hashCode(): number;
        notifyAll(): void;
        equals(arg0: any): boolean;
        toString(): string;
        notify(): void;
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    type ObjectiveCriteria_ = ObjectiveCriteria;
    class ControllerTileEntity extends Internal.ComponentTileEntity<Internal.ControllerDefinition> implements Internal.ICapabilityProxyHolder, Internal.IAsyncThreadUpdate, Internal.IControllerComponent {
        setRendererObject(arg0: any): void;
        getDefinition(): Internal.ControllerDefinition;
        getClass(): Internal.Class<any>;
        getLocation(): ResourceLocation;
        getCapability<K_>(arg0: Internal.Capability_<K_>, arg1: Internal.Direction_): Internal.LazyOptional<K_>;
        getCapability<T_>(arg0: Internal.Capability_<T_>): Internal.LazyOptional<T_>;
        use(arg0: Internal.Player_, arg1: Hand_, arg2: Internal.BlockHitResult_): Internal.InteractionResult;
        getStatus(): string;
        getOwner(): Internal.Player;
        getSubID(): string;
        getUnlocalizedName(): string;
        setOwner(arg0: Internal.UUID_): void;
        setOwner(arg0: Internal.Player_): void;
        getUpdatePacket(): Internal.ClientboundBlockEntityDataPacket;
        createUI(arg0: Internal.Player_): Internal.ModularUI;
        invalidateCaps(): void;
        serializeNBT(): Internal.CompoundTag;
        getLocalizedName(): string;
        receiveCustomData(arg0: number, arg1: Internal.FriendlyByteBuf_): void;
        onChunkUnloaded(): void;
        getRenderBoundingBox(): Internal.AABB;
        onDataPacket(arg0: Internal.Connection_, arg1: Internal.ClientboundBlockEntityDataPacket_): void;
        onNeighborChange(): void;
        requestModelDataUpdate(): void;
        isFormed(): boolean;
        getTileData(): Internal.CompoundTag;
        updateCurrentRenderer(): Internal.IMultiblockedRenderer;
        hasProxies(): boolean;
        areCapsCompatible(arg0: Internal.CapabilityProvider_<Internal.BlockEntity_>): boolean;
        areCapsCompatible(arg0: Internal.CapabilityDispatcher_): boolean;
        isInvalid(): boolean;
        rotateTo(arg0: Internal.Rotation_): void;
        reviveCaps(): void;
        getModelData(): Internal.IModelData;
        notifyBlockUpdate(): void;
        getRendererObject(): any;
        writeTraitData(arg0: Internal.CapabilityTrait_, arg1: number, arg2: Internal.Consumer_<Internal.FriendlyByteBuf_>): void;
        onStructureFormed(): void;
        onDrops(arg0: Internal.NonNullList_<Internal.ItemStack_>, arg1: Internal.Player_): void;
        needAlwaysUpdate(): boolean;
        getTimer(): number;
        writeInitialSyncData(arg0: Internal.FriendlyByteBuf_): void;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        getOwnerUUID(): Internal.UUID;
        writeCustomData(arg0: number, arg1: Internal.Consumer_<Internal.FriendlyByteBuf_>): void;
        asyncThreadLogic(arg0: number): void;
        notifyAll(): void;
        getOffset(): number;
        update(): void;
        getOutputRedstoneSignal(arg0: Internal.Direction_): number;
        getRecipeLogic(): Internal.RecipeLogic;
        notify(): void;
        getFrontFacing(): Internal.Direction;
        checkPattern(): boolean;
        hashCode(): number;
        getInnerCapability<K_>(arg0: Internal.Capability_<K_>, arg1: Internal.Direction_): Internal.LazyOptional<K_>;
        onStructureInvalid(): void;
        hasTrait(arg0: Internal.MultiblockCapability_<any>): boolean;
        markAsDirty(): void;
        handleUpdateTag(arg0: Internal.CompoundTag_): void;
        isValidFrontFacing(arg0: Internal.Direction_): boolean;
        getRenderer(): Internal.IMultiblockedRenderer;
        hasProxy(arg0: Internal.IO_, arg1: Internal.MultiblockCapability_<any>): boolean;
        mergeWith(arg0: Internal.ICapabilityProxyHolder_): Internal.ICapabilityProxyHolder;
        isRemote(): boolean;
        setFrontFacing(arg0: Internal.Direction_): void;
        deserializeNBT(arg0: Internal.CompoundTag_): void;
        getTrait(arg0: Internal.MultiblockCapability_<any>): Internal.CapabilityTrait;
        setStatus(arg0: string): void;
        updateFormed(): void;
        scheduleChunkForRenderUpdate(): void;
        equals(arg0: any): boolean;
        canConnectRedstone(arg0: Internal.Direction_): boolean;
        self(): Internal.BlockEntity;
        onLoad(): void;
        toString(): string;
        getPattern(): Internal.BlockPattern;
        getCapabilitiesProxy(): Internal.Table<Internal.IO, Internal.MultiblockCapability<any>, Internal.Long2ObjectOpenHashMap<Internal.CapabilityProxy<any>>>;
        receiveInitialSyncData(arg0: Internal.FriendlyByteBuf_): void;
        static readonly INFINITE_EXTENT_AABB : Internal.AABB;
        rendererObject : any;
        persistedData : net.minecraft.nbt.Tag;
        state : Internal.MultiblockState;
        static readonly EMPTY : Internal.IUIHolder;
        asyncRecipeSearching : boolean;
        get owner(): Internal.Player;
        get localizedName(): string;
        get renderer(): Internal.IMultiblockedRenderer;
        get ownerUUID(): Internal.UUID;
        get offset(): number;
        get renderBoundingBox(): Internal.AABB;
        get pattern(): Internal.BlockPattern;
        get tileData(): Internal.CompoundTag;
        get recipeLogic(): Internal.RecipeLogic;
        get remote(): boolean;
        get frontFacing(): Internal.Direction;
        get subID(): string;
        get timer(): number;
        get updatePacket(): Internal.ClientboundBlockEntityDataPacket;
        get modelData(): Internal.IModelData;
        get capabilitiesProxy(): Internal.Table<Internal.IO, Internal.MultiblockCapability<any>, Internal.Long2ObjectOpenHashMap<Internal.CapabilityProxy<any>>>;
        get unlocalizedName(): string;
        get invalid(): boolean;
        get definition(): Internal.ControllerDefinition;
        get location(): ResourceLocation;
        get formed(): boolean;
        get class(): Internal.Class<any>;
        get status(): string;
        set owner(arg0: Internal.Player_);
        set status(arg0: string);
        set frontFacing(arg0: Internal.Direction_);
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    type ControllerTileEntity_ = ControllerTileEntity;
    interface BiomeManager$NoiseBiomeSource {
    }
    type BiomeManager$NoiseBiomeSource_ = BiomeManager$NoiseBiomeSource;
    class PlacedFeature extends Internal.Record {
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        hashCode(): number;
        notifyAll(): void;
        equals(arg0: any): boolean;
        toString(): string;
        notify(): void;
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    type PlacedFeature_ = PlacedFeature;
    interface EventLoopGroup extends Internal.EventExecutorGroup {
        scheduleAtFixedRate(arg0: Internal.Runnable_, arg1: number, arg2: number, arg3: Internal.TimeUnit_): io.netty.util.concurrent.ScheduledFuture<any>;
        scheduleAtFixedRate(arg0: Internal.Runnable_, arg1: number, arg2: number, arg3: Internal.TimeUnit_): Internal.ScheduledFuture<any>;
        next(): Internal.EventLoop;
        next(): Internal.EventExecutor;
        terminationFuture(): io.netty.util.concurrent.Future<any>;
        shutdownGracefully(): io.netty.util.concurrent.Future<any>;
        shutdownGracefully(arg0: number, arg1: number, arg2: Internal.TimeUnit_): io.netty.util.concurrent.Future<any>;
        submit<T_>(arg0: Internal.Runnable_, arg1: T_): io.netty.util.concurrent.Future<T_>;
        submit<T_>(arg0: Internal.Runnable_, arg1: T_): Internal.Future<T_>;
        submit<T_>(arg0: java_.util.concurrent.Callable_<T_>): io.netty.util.concurrent.Future<T_>;
        submit<T_>(arg0: java_.util.concurrent.Callable_<T_>): Internal.Future<T_>;
        submit(arg0: Internal.Runnable_): io.netty.util.concurrent.Future<any>;
        submit(arg0: Internal.Runnable_): Internal.Future<any>;
        spliterator(): Internal.Spliterator<Internal.EventExecutor>;
        isTerminated(): boolean;
        forEach(arg0: Internal.Consumer_<Internal.EventExecutor_>): void;
        scheduleWithFixedDelay(arg0: Internal.Runnable_, arg1: number, arg2: number, arg3: Internal.TimeUnit_): io.netty.util.concurrent.ScheduledFuture<any>;
        scheduleWithFixedDelay(arg0: Internal.Runnable_, arg1: number, arg2: number, arg3: Internal.TimeUnit_): Internal.ScheduledFuture<any>;
        invokeAll<T_>(arg0: Internal.Collection_<java_.util.concurrent.Callable_<T_>>): Internal.List<Internal.Future<T_>>;
        invokeAll<T_>(arg0: Internal.Collection_<java_.util.concurrent.Callable_<T_>>, arg1: number, arg2: Internal.TimeUnit_): Internal.List<Internal.Future<T_>>;
        execute(arg0: Internal.Runnable_): void;
        schedule<V_>(arg0: java_.util.concurrent.Callable_<V_>, arg1: number, arg2: Internal.TimeUnit_): io.netty.util.concurrent.ScheduledFuture<V_>;
        schedule<V_>(arg0: java_.util.concurrent.Callable_<V_>, arg1: number, arg2: Internal.TimeUnit_): Internal.ScheduledFuture<V_>;
        schedule(arg0: Internal.Runnable_, arg1: number, arg2: Internal.TimeUnit_): io.netty.util.concurrent.ScheduledFuture<any>;
        schedule(arg0: Internal.Runnable_, arg1: number, arg2: Internal.TimeUnit_): Internal.ScheduledFuture<any>;
        isShuttingDown(): boolean;
        iterator(): Internal.Iterator<Internal.EventExecutor>;
        awaitTermination(arg0: number, arg1: Internal.TimeUnit_): boolean;
        invokeAny<T_>(arg0: Internal.Collection_<java_.util.concurrent.Callable_<T_>>, arg1: number, arg2: Internal.TimeUnit_): T_;
        invokeAny<T_>(arg0: Internal.Collection_<java_.util.concurrent.Callable_<T_>>): T_;
        shutdownNow(): Internal.List<Internal.Runnable>;
        shutdown(): void;
        isShutdown(): boolean;
        register(arg0: io.netty.channel.Channel_, arg1: Internal.ChannelPromise_): Internal.ChannelFuture;
        register(arg0: Internal.ChannelPromise_): Internal.ChannelFuture;
        register(arg0: io.netty.channel.Channel_): Internal.ChannelFuture;
    }
    type EventLoopGroup_ = EventLoopGroup;
    interface ArmedModel {
    }
    type ArmedModel_ = ArmedModel;
    interface IProperShieldUser {
        isActuallyReallyBlocking(): boolean;
    }
    type IProperShieldUser_ = IProperShieldUser;
    abstract class ConfigWithVariants <T> extends Internal.ConfigValue<T> {
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        getName(): string;
        setCanEdit(e: boolean): Internal.ConfigValue<Internal.ConfigValue<Internal.ConfigValue<T>>>;
        notifyAll(): void;
        isEqual(v1: Internal.ConfigValue_<Internal.ConfigValue_<T>>, v2: Internal.ConfigValue_<Internal.ConfigValue_<T>>): boolean;
        compareTo(o: Internal.ConfigValue_<Internal.ConfigValue_<Internal.ConfigValue_<T>>>): number;
        notify(): void;
        getCanEdit(): boolean;
        getTooltip(): string;
        getIteration(arg0: Internal.ConfigValue_<Internal.ConfigValue_<T>>, arg1: boolean): Internal.ConfigValue<Internal.ConfigValue<T>>;
        hashCode(): number;
        getStringForGUI(v: Internal.ConfigValue_<Internal.ConfigValue_<T>>): Internal.Component;
        getPath(): string;
        copy(value: Internal.ConfigValue_<Internal.ConfigValue_<T>>): Internal.ConfigValue<Internal.ConfigValue<T>>;
        static info(key: string, value: any): Internal.Component;
        init(g: Internal.ConfigGroup_, i: string, v: Internal.ConfigValue_<Internal.ConfigValue_<T>>, c: Internal.Consumer_<Internal.ConfigValue_<Internal.ConfigValue_<T>>>, def: Internal.ConfigValue_<Internal.ConfigValue_<T>>): Internal.ConfigValue<Internal.ConfigValue<Internal.ConfigValue<T>>>;
        getColor(v: Internal.ConfigValue_<Internal.ConfigValue_<T>>): Internal.Color4I;
        addInfo(list: Internal.TooltipList_): void;
        getIcon(v: Internal.ConfigValue_<Internal.ConfigValue_<T>>): Internal.Icon;
        setIcon(i: Internal.Icon_): Internal.ConfigValue<Internal.ConfigValue<Internal.ConfigValue<T>>>;
        setOrder(o: number): Internal.ConfigValue<Internal.ConfigValue<Internal.ConfigValue<T>>>;
        getNameKey(): string;
        setNameKey(key: string): Internal.ConfigValue<Internal.ConfigValue<Internal.ConfigValue<T>>>;
        equals(arg0: any): boolean;
        onClicked(button: Internal.MouseButton_, callback: Internal.ConfigCallback_): void;
        toString(): string;
        setCurrentValue(v: Internal.ConfigValue_<Internal.ConfigValue_<T>>): boolean;
        defaultValue : Internal.ConfigValue<Internal.ConfigValue<T>>;
        id : string;
        static readonly NULL_TEXT : Internal.TextComponent;
        setter : ((arg0: Internal.ConfigValue<Internal.ConfigValue<T>>) => void);
        value : Internal.ConfigValue<Internal.ConfigValue<T>>;
        group : Internal.ConfigGroup;
        get path(): string;
        get nameKey(): string;
        get canEdit(): boolean;
        get name(): string;
        get tooltip(): string;
        get class(): Internal.Class<any>;
        set nameKey(key: string);
        set canEdit(e: boolean);
        set icon(i: Internal.Icon_);
        set currentValue(v: Internal.ConfigValue_<Internal.ConfigValue_<T>>);
        set order(o: number);
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    type ConfigWithVariants_<T> = ConfigWithVariants<T>;
    class Products$P13 <F, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13> {
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        apply<R>(arg0: Internal.Applicative_<F, any>, arg1: Internal.Function13_<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, R>): Internal.App<F, R>;
        apply<R>(arg0: Internal.Applicative_<F, any>, arg1: Internal.App_<F, Internal.Function13_<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, R>>): Internal.App<F, R>;
        hashCode(): number;
        notifyAll(): void;
        equals(arg0: any): boolean;
        toString(): string;
        notify(): void;
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    type Products$P13_<F, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13> = Products$P13<F, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13>;
    class Window implements Internal.AutoCloseable {
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        hashCode(): number;
        notifyAll(): void;
        equals(arg0: any): boolean;
        toString(): string;
        close(): void;
        notify(): void;
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    type Window_ = Window;
    interface WeightedEntry {
    }
    type WeightedEntry_ = WeightedEntry;
    abstract class CharsetDecoder {
        averageCharsPerByte(): number;
        getClass(): Internal.Class<any>;
        charset(): Internal.Charset;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        maxCharsPerByte(): number;
        onUnmappableCharacter(arg0: Internal.CodingErrorAction_): Internal.CharsetDecoder;
        notifyAll(): void;
        isCharsetDetected(): boolean;
        decode(arg0: Internal.ByteBuffer_): Internal.CharBuffer;
        decode(arg0: Internal.ByteBuffer_, arg1: Internal.CharBuffer_, arg2: boolean): Internal.CoderResult;
        notify(): void;
        isAutoDetecting(): boolean;
        unmappableCharacterAction(): Internal.CodingErrorAction;
        detectedCharset(): Internal.Charset;
        malformedInputAction(): Internal.CodingErrorAction;
        flush(arg0: Internal.CharBuffer_): Internal.CoderResult;
        hashCode(): number;
        equals(arg0: any): boolean;
        onMalformedInput(arg0: Internal.CodingErrorAction_): Internal.CharsetDecoder;
        reset(): Internal.CharsetDecoder;
        toString(): string;
        replacement(): string;
        replaceWith(arg0: string): Internal.CharsetDecoder;
        get autoDetecting(): boolean;
        get charsetDetected(): boolean;
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    type CharsetDecoder_ = CharsetDecoder;
    class ProgressChange {
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        hashCode(): number;
        notifyAll(): void;
        equals(arg0: any): boolean;
        toString(): string;
        write(buffer: Internal.FriendlyByteBuf_): void;
        notify(): void;
        readonly file : Internal.QuestFile;
        origin : Internal.QuestObjectBase;
        reset : boolean;
        time : Internal.Date;
        notifications : boolean;
        player : Internal.UUID;
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    type ProgressChange_ = ProgressChange;
    class SearchRegistry implements Internal.ResourceManagerReloadListener {
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        hashCode(): number;
        notifyAll(): void;
        equals(arg0: any): boolean;
        toString(): string;
        notify(): void;
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    type SearchRegistry_ = SearchRegistry;
    interface FormattedText {
        getString(): string;
    }
    type FormattedText_ = FormattedText;
    abstract class CapabilityProvider <B> implements Internal.ICapabilityProviderImpl<B> {
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        invalidateCaps(): void;
        getCapability<T_>(arg0: Internal.Capability_<T_>, arg1: Internal.Direction_): Internal.LazyOptional<T_>;
        getCapability<T_>(arg0: Internal.Capability_<T_>): Internal.LazyOptional<T_>;
        hashCode(): number;
        notifyAll(): void;
        equals(arg0: any): boolean;
        areCapsCompatible(arg0: Internal.CapabilityProvider_<B>): boolean;
        areCapsCompatible(arg0: Internal.CapabilityDispatcher_): boolean;
        toString(): string;
        notify(): void;
        reviveCaps(): void;
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    type CapabilityProvider_<B> = CapabilityProvider<B>;
    interface CommandSource {
    }
    type CommandSource_ = CommandSource;
    interface Double2ShortFunction extends Internal.Function<number, number>, Internal.DoubleToIntFunction {
        getOrDefault(arg0: any, arg1: number): number;
        getOrDefault(arg0: number, arg1: number): number;
        andThenShort(arg0: Internal.Short2ShortFunction_): Internal.Double2ShortFunction;
        composeByte(arg0: Internal.Byte2DoubleFunction_): Internal.Byte2ShortFunction;
        andThenInt(arg0: Internal.Short2IntFunction_): Internal.Double2IntFunction;
        composeReference<T_>(arg0: Internal.Reference2DoubleFunction_<T_>): Internal.Reference2ShortFunction<T_>;
        andThen<T_>(arg0: java_.util.function_.Function_<number, T_>): java_.util.function_.Function<number, T_>;
        put(arg0: number, arg1: number): number;
        remove(arg0: number): number;
        remove(arg0: any): number;
        defaultReturnValue(): number;
        defaultReturnValue(arg0: number): void;
        andThenDouble(arg0: Internal.Short2DoubleFunction_): Internal.Double2DoubleFunction;
        andThenObject<T_>(arg0: Internal.Short2ObjectFunction_<T_>): Internal.Double2ObjectFunction<T_>;
        get(arg0: any): number;
        get(arg0: number): number;
        andThenLong(arg0: Internal.Short2LongFunction_): Internal.Double2LongFunction;
        composeLong(arg0: Internal.Long2DoubleFunction_): Internal.Long2ShortFunction;
        andThenByte(arg0: Internal.Short2ByteFunction_): Internal.Double2ByteFunction;
        andThenFloat(arg0: Internal.Short2FloatFunction_): Internal.Double2FloatFunction;
        applyAsInt(arg0: number): number;
        apply(arg0: number): number;
        containsKey(arg0: any): boolean;
        containsKey(arg0: number): boolean;
        composeInt(arg0: Internal.Int2DoubleFunction_): Internal.Int2ShortFunction;
        clear(): void;
        composeFloat(arg0: Internal.Float2DoubleFunction_): Internal.Float2ShortFunction;
        andThenChar(arg0: Internal.Short2CharFunction_): Internal.Double2CharFunction;
        composeObject<T_>(arg0: Internal.Object2DoubleFunction_<T_>): Internal.Object2ShortFunction<T_>;
        size(): number;
        compose<T_>(arg0: java_.util.function_.Function_<T_, number>): java_.util.function_.Function<T_, number>;
        composeShort(arg0: Internal.Short2DoubleFunction_): Internal.Short2ShortFunction;
        andThenReference<T_>(arg0: Internal.Short2ReferenceFunction_<T_>): Internal.Double2ReferenceFunction<T_>;
        composeChar(arg0: Internal.Char2DoubleFunction_): Internal.Char2ShortFunction;
        composeDouble(arg0: Internal.Double2DoubleFunction_): Internal.Double2ShortFunction;
    }
    type Double2ShortFunction_ = ((arg0: number) => number) | Double2ShortFunction;
    interface IScreenWrapper extends Internal.IOpenableScreen {
        closeGui(openPrevScreen: boolean): void;
        closeGui(): void;
        openContextMenu(panel: Internal.Panel_): void;
        openGui(): void;
        openGuiLater(): void;
        run(): void;
        openAfter(runnable: Internal.Runnable_): Internal.Runnable;
        closeContextMenu(): void;
        getGui(): Internal.BaseScreen;
    }
    type IScreenWrapper_ = IScreenWrapper;
    class PixelBuffer {
        getClass(): Internal.Class<any>;
        getSubimage(x: number, y: number, w: number, h: number): Internal.PixelBuffer;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        setPixels(p: number[]): void;
        notifyAll(): void;
        setRGB(x: number, y: number, col: number): void;
        setRGB(startX: number, startY: number, w: number, h: number, rgbArray: number[]): void;
        setRGB(startX: number, startY: number, buffer: Internal.PixelBuffer_): void;
        getWidth(): number;
        fill(startX: number, startY: number, w: number, h: number, col: number): void;
        fill(col: number): void;
        toByteBuffer(alpha: boolean): Internal.ByteBuffer;
        notify(): void;
        getHeight(): number;
        toImage(type: number): Internal.BufferedImage;
        getPixels(): number[];
        hashCode(): number;
        equals(o: any): boolean;
        toString(): string;
        static from(img: Internal.BufferedImage_): Internal.PixelBuffer;
        static from(stream: Internal.InputStream_): Internal.PixelBuffer;
        copy(): Internal.PixelBuffer;
        getRGB(x: number, y: number): number;
        getRGB(startX: number, startY: number, w: number, h: number, p: number[]): number[];
        get pixels(): number[];
        get width(): number;
        get class(): Internal.Class<any>;
        get height(): number;
        set pixels(p: number[]);
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    type PixelBuffer_ = PixelBuffer;
    class DropTargetContext implements Internal.Serializable {
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        hashCode(): number;
        notifyAll(): void;
        equals(arg0: any): boolean;
        toString(): string;
        getComponent(): java_.awt.Component;
        dropComplete(arg0: boolean): void;
        getDropTarget(): Internal.DropTarget;
        notify(): void;
        get component(): java_.awt.Component;
        get dropTarget(): Internal.DropTarget;
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    type DropTargetContext_ = DropTargetContext;
    interface Decoder$Terminal <A> {
        decoder(): Internal.Decoder<A>;
        decode<T>(arg0: Internal.DynamicOps_<T>, arg1: T): Internal.DataResult<A>;
    }
    type Decoder$Terminal_<A> = Decoder$Terminal<A>;
    class CropBlockBuilder extends Internal.BlockBuilder {
        noItem(): Internal.BlockBuilder;
        suffocating(b: boolean): Internal.BlockBuilder;
        getClass(): Internal.Class<any>;
        translationKey(key: string): Internal.BuilderBase<Internal.Block>;
        newID(pre: string, post: string): ResourceLocation;
        type(type: string): Internal.BuilderBase<Internal.Block>;
        unbreakable(): Internal.BlockBuilder;
        model(m: string): Internal.BlockBuilder;
        tag(tag: ResourceLocation_): Internal.BlockBuilder;
        generateDataJsons(generator: Internal.DataJsonGenerator_): void;
        tagBoth(tag: ResourceLocation_): Internal.BlockBuilder;
        defaultCutout(): Internal.BlockBuilder;
        item(i: Internal.Consumer_<Internal.BlockItemBuilder_>): Internal.BlockBuilder;
        resistance(r: number): Internal.BlockBuilder;
        hardness(h: number): Internal.BlockBuilder;
        slipperiness(f: number): Internal.BlockBuilder;
        getRegistryType(): Internal.RegistryObjectBuilderTypes<Internal.Block>;
        dropSeed(dropSeed: boolean): Internal.CropBlockBuilder;
        textureSide(direction: Internal.Direction_, tex: string): Internal.BlockBuilder;
        crop(output: any, chance: number): Internal.CropBlockBuilder;
        crop(output: any): Internal.CropBlockBuilder;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        clientRegistry(minecraft: Internal.Minecraft_): void;
        waterlogged(): Internal.BlockBuilder;
        transformObject(obj: Internal.Block_): Internal.Block;
        color(index: number, c: Internal.Color_): Internal.BlockBuilder;
        textureAll(tex: string): Internal.BlockBuilder;
        displayName(name: string): Internal.BuilderBase<Internal.Block>;
        notifyAll(): void;
        box(x0: number, y0: number, z0: number, x1: number, y1: number, z1: number): Internal.BlockBuilder;
        box(x0: number, y0: number, z0: number, x1: number, y1: number, z1: number, scale16: boolean): Internal.BlockBuilder;
        viewBlocking(b: boolean): Internal.BlockBuilder;
        notify(): void;
        transparent(b: boolean): Internal.BlockBuilder;
        createAdditionalObjects(): void;
        tagBlock(tag: ResourceLocation_): Internal.BlockBuilder;
        fullBlock(f: boolean): Internal.BlockBuilder;
        createProperties(): Internal.BlockBehaviour$Properties;
        notSolid(): Internal.BlockBuilder;
        generateBlockModels(builder: Internal.BlockBuilder_): Internal.Map<ResourceLocation, Internal.JsonObject>;
        hashCode(): number;
        noCollission(): Internal.BlockBuilder;
        get(): Internal.Block;
        requiresTool(f: boolean): Internal.BlockBuilder;
        renderType(l: string): Internal.BlockBuilder;
        jumpFactor(f: number): Internal.BlockBuilder;
        createShape(): Internal.VoxelShape;
        generateAssetJsons(generator: Internal.AssetJsonGenerator_): void;
        noCollision(): Internal.BlockBuilder;
        opaque(o: boolean): Internal.BlockBuilder;
        survive(surviveCallback: Internal.CropBlockBuilder$SurviveCallback_): Internal.CropBlockBuilder;
        randomTick(randomTickCallback: Internal.Consumer_<Internal.RandomTickCallbackJS_>): Internal.BlockBuilder;
        getTranslationKeyGroup(): string;
        texture(id: string, tex: string): Internal.BlockBuilder;
        noDrops(): Internal.BlockBuilder;
        generateLang(lang: Internal.Map_<string, string>): void;
        tagItem(tag: ResourceLocation_): Internal.BlockBuilder;
        speedFactor(f: number): Internal.BlockBuilder;
        noValidSpawns(b: boolean): Internal.BlockBuilder;
        growTick(growSpeedCallback: Internal.ToDoubleFunction_<Internal.RandomTickCallbackJS_>): Internal.CropBlockBuilder;
        createObject(): Internal.Block;
        lightLevel(light: number): Internal.BlockBuilder;
        addResourcePackLocations(path: string, list: Internal.List_<ResourceLocation_>, packType: Internal.PackType_): void;
        defaultTranslucent(): Internal.BlockBuilder;
        material(m: Internal.MaterialJS_): Internal.BlockBuilder;
        equals(arg0: any): boolean;
        bonemeal(bonemealCallback: Internal.ToIntFunction_<Internal.RandomTickCallbackJS_>): Internal.CropBlockBuilder;
        toString(): string;
        redstoneConductor(b: boolean): Internal.BlockBuilder;
        age(age: number): Internal.CropBlockBuilder;
        age(age: number, builder: Internal.Consumer_<Internal.CropBlockBuilder$ShapeBuilder_>): Internal.CropBlockBuilder;
        lootTable : ((arg0: Internal.LootBuilder) => void);
        modelJson : Internal.JsonObject;
        blockstateJson : Internal.JsonObject;
        readonly id : ResourceLocation;
        randomTickCallback : ((arg0: Internal.RandomTickCallbackJS) => void);
        get registryType(): Internal.RegistryObjectBuilderTypes<Internal.Block>;
        get class(): Internal.Class<any>;
        get translationKeyGroup(): string;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    type CropBlockBuilder_ = CropBlockBuilder;
    class ByteOrder {
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        hashCode(): number;
        notifyAll(): void;
        equals(arg0: any): boolean;
        static nativeOrder(): Internal.ByteOrder;
        toString(): string;
        notify(): void;
        static readonly BIG_ENDIAN : Internal.ByteOrder;
        static readonly LITTLE_ENDIAN : Internal.ByteOrder;
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    type ByteOrder_ = ByteOrder;
    interface ClassShutter {
        visibleToScripts(arg0: string, arg1: number): boolean;
    }
    type ClassShutter_ = ClassShutter;
    interface Reference2BooleanFunction <K> extends Internal.Function<K, boolean>, Internal.Predicate<K> {
        getOrDefault(arg0: any, arg1: boolean): boolean;
        andThenShort(arg0: Internal.Boolean2ShortFunction_): Internal.Reference2ShortFunction<K>;
        composeByte(arg0: Internal.Byte2ReferenceFunction_<K>): Internal.Byte2BooleanFunction;
        andThenInt(arg0: Internal.Boolean2IntFunction_): Internal.Reference2IntFunction<K>;
        composeReference<T_>(arg0: Internal.Reference2ReferenceFunction_<T_, K>): Internal.Reference2BooleanFunction<T_>;
        andThen<T_>(arg0: java_.util.function_.Function_<boolean, T_>): java_.util.function_.Function<K, T_>;
        put(arg0: K, arg1: boolean): boolean;
        remove(arg0: any): boolean;
        defaultReturnValue(): boolean;
        defaultReturnValue(arg0: boolean): void;
        andThenDouble(arg0: Internal.Boolean2DoubleFunction_): Internal.Reference2DoubleFunction<K>;
        andThenObject<T_>(arg0: Internal.Boolean2ObjectFunction_<T_>): Internal.Reference2ObjectFunction<K, T_>;
        and(arg0: Internal.Predicate_<K>): Internal.Predicate<K>;
        get(arg0: any): boolean;
        andThenLong(arg0: Internal.Boolean2LongFunction_): Internal.Reference2LongFunction<K>;
        removeBoolean(arg0: any): boolean;
        composeLong(arg0: Internal.Long2ReferenceFunction_<K>): Internal.Long2BooleanFunction;
        getBoolean(arg0: any): boolean;
        andThenByte(arg0: Internal.Boolean2ByteFunction_): Internal.Reference2ByteFunction<K>;
        andThenFloat(arg0: Internal.Boolean2FloatFunction_): Internal.Reference2FloatFunction<K>;
        or(arg0: Internal.Predicate_<K>): Internal.Predicate<K>;
        test(arg0: K): boolean;
        apply(arg0: K): boolean;
        containsKey(arg0: any): boolean;
        composeInt(arg0: Internal.Int2ReferenceFunction_<K>): Internal.Int2BooleanFunction;
        clear(): void;
        composeFloat(arg0: Internal.Float2ReferenceFunction_<K>): Internal.Float2BooleanFunction;
        andThenChar(arg0: Internal.Boolean2CharFunction_): Internal.Reference2CharFunction<K>;
        composeObject<T_>(arg0: Internal.Object2ReferenceFunction_<T_, K>): Internal.Object2BooleanFunction<T_>;
        size(): number;
        compose<V_>(arg0: java_.util.function_.Function_<V_, K>): java_.util.function_.Function<V_, boolean>;
        negate(): Internal.Predicate<K>;
        composeShort(arg0: Internal.Short2ReferenceFunction_<K>): Internal.Short2BooleanFunction;
        andThenReference<T_>(arg0: Internal.Boolean2ReferenceFunction_<T_>): Internal.Reference2ReferenceFunction<K, T_>;
        composeChar(arg0: Internal.Char2ReferenceFunction_<K>): Internal.Char2BooleanFunction;
        composeDouble(arg0: Internal.Double2ReferenceFunction_<K>): Internal.Double2BooleanFunction;
    }
    type Reference2BooleanFunction_<K> = ((arg0: any) => boolean) | Reference2BooleanFunction<K>;
    class ExplosionJS {
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        strength(f: number): Internal.ExplosionJS;
        hashCode(): number;
        exploder(entity: Internal.EntityJS_): Internal.ExplosionJS;
        explode(): void;
        damagesTerrain(b: boolean): Internal.ExplosionJS;
        notifyAll(): void;
        equals(arg0: any): boolean;
        toString(): string;
        causesFire(b: boolean): Internal.ExplosionJS;
        destroysTerrain(b: boolean): Internal.ExplosionJS;
        notify(): void;
        explosionMode : Internal.Explosion$BlockInteraction;
        readonly x : number;
        readonly y : number;
        readonly z : number;
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    type ExplosionJS_ = ExplosionJS;
    interface VertexType <T> {
        createFallbackWriter(arg0: Internal.VertexConsumer_): T;
        asBlittable(): Internal.BlittableVertexType<T>;
    }
    type VertexType_<T> = VertexType<T>;
    abstract class IngredientAction extends Internal.IngredientActionFilter {
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        checkFilter(index: number, stack: Internal.ItemStack_): boolean;
        static getRemaining(container: Internal.CraftingContainer_, index: number, ingredientActions: Internal.List_<Internal.IngredientAction_>): Internal.ItemStack;
        notifyAll(): void;
        static parseList(json: Internal.JsonElement_): Internal.List<Internal.IngredientAction>;
        static filterOf(o: any): Internal.IngredientActionFilter;
        notify(): void;
        copyFrom(filter: Internal.IngredientActionFilter_): void;
        static readList(buf: Internal.FriendlyByteBuf_): Internal.List<Internal.IngredientAction>;
        toJson(json: Internal.JsonObject_): void;
        toJson(): Internal.JsonObject;
        transform(arg0: Internal.ItemStack_, arg1: number, arg2: Internal.CraftingContainer_): Internal.ItemStack;
        static writeList(buf: Internal.FriendlyByteBuf_, list: Internal.List_<Internal.IngredientAction_>): void;
        getType(): string;
        hashCode(): number;
        equals(arg0: any): boolean;
        toString(): string;
        static readonly FACTORY_MAP : {"damage":any,"custom":any,"keep":any,"replace":any};
        filterIndex : number;
        filterIngredient : ((arg0: Internal.ItemStackJS) => boolean);
        get type(): string;
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    type IngredientAction_ = IngredientAction;
    class FocusEvent$Cause extends Internal.Enum<Internal.FocusEvent$Cause> {
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        static valueOf(arg0: string): Internal.FocusEvent$Cause;
        static valueOf<T_>(arg0: Internal.Class_<T_>, arg1: string): T_;
        notifyAll(): void;
        static values(): Internal.FocusEvent$Cause[];
        compareTo(arg0: Internal.FocusEvent$Cause_): number;
        describeConstable(): Internal.Optional<Internal.Enum$EnumDesc<Internal.FocusEvent$Cause>>;
        notify(): void;
        getDeclaringClass(): Internal.Class<Internal.FocusEvent$Cause>;
        hashCode(): number;
        equals(arg0: any): boolean;
        name(): string;
        toString(): string;
        ordinal(): number;
        static readonly UNEXPECTED : Internal.FocusEvent$Cause;
        static readonly CLEAR_GLOBAL_FOCUS_OWNER : Internal.FocusEvent$Cause;
        static readonly ACTIVATION : Internal.FocusEvent$Cause;
        static readonly TRAVERSAL : Internal.FocusEvent$Cause;
        static readonly TRAVERSAL_UP : Internal.FocusEvent$Cause;
        static readonly TRAVERSAL_FORWARD : Internal.FocusEvent$Cause;
        static readonly TRAVERSAL_DOWN : Internal.FocusEvent$Cause;
        static readonly TRAVERSAL_BACKWARD : Internal.FocusEvent$Cause;
        static readonly UNKNOWN : Internal.FocusEvent$Cause;
        static readonly MOUSE_EVENT : Internal.FocusEvent$Cause;
        static readonly ROLLBACK : Internal.FocusEvent$Cause;
        get class(): Internal.Class<any>;
        get declaringClass(): Internal.Class<Internal.FocusEvent$Cause>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    type FocusEvent$Cause_ = "rollback" | "traversal_up" | "traversal_backward" | "unexpected" | "clear_global_focus_owner" | "traversal" | "activation" | "traversal_down" | "mouse_event" | "unknown" | "traversal_forward" | FocusEvent$Cause;
    class DragSourceDragEvent extends Internal.DragSourceEvent {
        getDropAction(): number;
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        getLocation(): Internal.Point;
        getTargetActions(): number;
        notifyAll(): void;
        getGestureModifiersEx(): number;
        notify(): void;
        getX(): number;
        getY(): number;
        hashCode(): number;
        getSource(): any;
        getDragSourceContext(): Internal.DragSourceContext;
        equals(arg0: any): boolean;
        getUserAction(): number;
        getGestureModifiers(): number;
        toString(): string;
        get userAction(): number;
        get gestureModifiers(): number;
        get x(): number;
        get dragSourceContext(): Internal.DragSourceContext;
        get y(): number;
        get location(): Internal.Point;
        get source(): any;
        get class(): Internal.Class<any>;
        get gestureModifiersEx(): number;
        get dropAction(): number;
        get targetActions(): number;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    type DragSourceDragEvent_ = DragSourceDragEvent;
    /**
    */
    class EnchantmentBuilder extends Internal.BuilderBase<Internal.Enchantment> {
        damageBonus(i: Internal.EnchantmentBuilder$DamageBonusFunction_): Internal.EnchantmentBuilder;
        armorFeet(): Internal.EnchantmentBuilder;
        veryRare(): Internal.EnchantmentBuilder;
        getClass(): Internal.Class<any>;
        undiscoverable(): Internal.EnchantmentBuilder;
        translationKey(key: string): Internal.BuilderBase<Internal.Enchantment>;
        crossbow(): Internal.EnchantmentBuilder;
        newID(pre: string, post: string): ResourceLocation;
        armorLegs(): Internal.EnchantmentBuilder;
        type(type: string): Internal.BuilderBase<Internal.Enchantment>;
        canEnchant(i: Internal.Object2BooleanFunction_<Internal.ItemStackJS_>): Internal.EnchantmentBuilder;
        rare(): Internal.EnchantmentBuilder;
        maxCost(i: Internal.Int2IntFunction_): Internal.EnchantmentBuilder;
        tag(tag: ResourceLocation_): Internal.BuilderBase<Internal.Enchantment>;
        generateDataJsons(generator: Internal.DataJsonGenerator_): void;
        treasureOnly(): Internal.EnchantmentBuilder;
        wearable(): Internal.EnchantmentBuilder;
        minLevel(i: number): Internal.EnchantmentBuilder;
        armorHead(): Internal.EnchantmentBuilder;
        slots(s: EquipmentSlot_[]): Internal.EnchantmentBuilder;
        fishingRod(): Internal.EnchantmentBuilder;
        armor(): Internal.EnchantmentBuilder;
        getRegistryType(): Internal.RegistryObjectBuilderTypes<Internal.Enchantment>;
        curse(): Internal.EnchantmentBuilder;
        checkCompatibility(i: Internal.Object2BooleanFunction_<ResourceLocation_>): Internal.EnchantmentBuilder;
        breakable(): Internal.EnchantmentBuilder;
        untradeable(): Internal.EnchantmentBuilder;
        rarity(r: Internal.Enchantment$Rarity_): Internal.EnchantmentBuilder;
        maxLevel(i: number): Internal.EnchantmentBuilder;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        clientRegistry(minecraft: Internal.Minecraft_): void;
        transformObject(obj: Internal.Enchantment_): Internal.Enchantment;
        postAttack(i: Internal.EnchantmentBuilder$PostFunction_): Internal.EnchantmentBuilder;
        displayName(name: string): Internal.BuilderBase<Internal.Enchantment>;
        notifyAll(): void;
        vanishable(): Internal.EnchantmentBuilder;
        bow(): Internal.EnchantmentBuilder;
        notify(): void;
        createAdditionalObjects(): void;
        weapon(): Internal.EnchantmentBuilder;
        uncommon(): Internal.EnchantmentBuilder;
        hashCode(): number;
        postHurt(i: Internal.EnchantmentBuilder$PostFunction_): Internal.EnchantmentBuilder;
        get(): Internal.Enchantment;
        minCost(i: Internal.Int2IntFunction_): Internal.EnchantmentBuilder;
        generateAssetJsons(generator: Internal.AssetJsonGenerator_): void;
        damageProtection(i: Internal.EnchantmentBuilder$DamageProtectionFunction_): Internal.EnchantmentBuilder;
        trident(): Internal.EnchantmentBuilder;
        getTranslationKeyGroup(): string;
        armorChest(): Internal.EnchantmentBuilder;
        generateLang(lang: Internal.Map_<string, string>): void;
        createObject(): Internal.Enchantment;
        addResourcePackLocations(path: string, list: Internal.List_<ResourceLocation_>, packType: Internal.PackType_): void;
        equals(arg0: any): boolean;
        toString(): string;
        category(c: Internal.EnchantmentCategory_): Internal.EnchantmentBuilder;
        readonly id : ResourceLocation;
        get registryType(): Internal.RegistryObjectBuilderTypes<Internal.Enchantment>;
        get class(): Internal.Class<any>;
        get translationKeyGroup(): string;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
        /**
        * Set the callback when the enchanted item hits an entity.
        *
        * WARN: This callback will ALWAYS be called TWICE, for both main hand and off hand.
        * This is an annoying code logic from Vanilla Minecraft. There's no way KubeJS can
        * change this.
        */
        doPostAttack(i: Internal.EnchantmentBuilder$PostFunction_): Internal.EnchantmentBuilder;
    }
    /**
    */
    type EnchantmentBuilder_ = EnchantmentBuilder;
    interface JsonSerializer <T> {
        serialize(arg0: T, arg1: java_.lang.reflect.Type_, arg2: Internal.JsonSerializationContext_): Internal.JsonElement;
    }
    type JsonSerializer_<T> = JsonSerializer<T>;
    interface EnchantmentBuilder$DamageProtectionFunction {
        getDamageProtection(arg0: number, arg1: Internal.DamageSource_): number;
    }
    type EnchantmentBuilder$DamageProtectionFunction_ = ((arg0: number, arg1: Internal.DamageSource) => number) | EnchantmentBuilder$DamageProtectionFunction;
    abstract class UnmodifiableIterator <E> implements Internal.Iterator<E> {
        next(): E;
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        hashCode(): number;
        notifyAll(): void;
        equals(arg0: any): boolean;
        hasNext(): boolean;
        toString(): string;
        forEachRemaining(arg0: Internal.Consumer_<E>): void;
        notify(): void;
        remove(): void;
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    type UnmodifiableIterator_<E> = UnmodifiableIterator<E>;
    class TeamProperties {
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        read(tag: Internal.CompoundTag_): void;
        read(buffer: Internal.FriendlyByteBuf_): void;
        set<T>(key: Internal.TeamProperty_<T>, value: T): void;
        updateFrom(properties: Internal.TeamProperties_): Internal.TeamProperties;
        notifyAll(): void;
        notify(): void;
        hashCode(): number;
        equals(arg0: any): boolean;
        get<T>(key: Internal.TeamProperty_<T>): T;
        toString(): string;
        copy(): Internal.TeamProperties;
        write(buffer: Internal.FriendlyByteBuf_): void;
        write(tag: Internal.CompoundTag_): Internal.CompoundTag;
        collect(): Internal.TeamProperties;
        readonly map : Internal.Map<Internal.TeamProperty, Internal.TeamPropertyValue>;
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    type TeamProperties_ = TeamProperties;
    interface LongIterator extends Internal.PrimitiveIterator$OfLong {
        next(): number;
        hasNext(): boolean;
        skip(arg0: number): number;
        forEachRemaining(arg0: Internal.Consumer_<number>): void;
        forEachRemaining(arg0: Internal.LongConsumer_): void;
        forEachRemaining(arg0: java_.util.function_.LongConsumer_): void;
        nextLong(): number;
        remove(): void;
    }
    type LongIterator_ = LongIterator;
    class RecipeTypeRegistryEventJS extends Internal.EventJS {
        cancel(): void;
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        isCancelled(): boolean;
        registerShaped(id: ResourceLocation_): void;
        notifyAll(): void;
        notify(): void;
        post(t: Internal.ScriptType_, id: string, sub: string): boolean;
        post(t: Internal.ScriptType_, id: string): boolean;
        hashCode(): number;
        registerShapeless(id: ResourceLocation_): void;
        equals(arg0: any): boolean;
        ignore(id: ResourceLocation_): void;
        toString(): string;
        canCancel(): boolean;
        register(id: ResourceLocation_, f: Internal.Supplier_<Internal.RecipeJS_>): void;
        register(type: Internal.RecipeTypeJS_): void;
        get cancelled(): boolean;
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    type RecipeTypeRegistryEventJS_ = RecipeTypeRegistryEventJS;
    class Excluder implements Internal.TypeAdapterFactory, Internal.Cloneable {
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        notifyAll(): void;
        disableInnerClassSerialization(): Internal.Excluder;
        withModifiers(arg0: number[]): Internal.Excluder;
        withVersion(arg0: number): Internal.Excluder;
        excludeField(arg0: Internal.Field_, arg1: boolean): boolean;
        notify(): void;
        hashCode(): number;
        withExclusionStrategy(arg0: Internal.ExclusionStrategy_, arg1: boolean, arg2: boolean): Internal.Excluder;
        equals(arg0: any): boolean;
        create<T_>(arg0: Internal.Gson_, arg1: Internal.TypeToken_<T_>): Internal.TypeAdapter<T_>;
        toString(): string;
        excludeClass(arg0: Internal.Class_<any>, arg1: boolean): boolean;
        excludeFieldsWithoutExposeAnnotation(): Internal.Excluder;
        static readonly DEFAULT : Internal.Excluder;
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    type Excluder_ = Excluder;
    interface EffectsProperties {
        getAmbientMoodSound(): Internal.Optional<Internal.AmbientMoodSettings>;
        getFoliageColorOverride(): Internal.OptionalInt;
        getSkyColor(): number;
        getAmbientParticle(): Internal.Optional<Internal.AmbientParticleSettings>;
        getAmbientLoopSound(): Internal.Optional<Internal.SoundEvent>;
        getGrassColorOverride(): Internal.OptionalInt;
        getFogColor(): number;
        getBackgroundMusic(): Internal.Optional<Internal.Music>;
        getAmbientAdditionsSound(): Internal.Optional<Internal.AmbientAdditionsSettings>;
        getGrassColorModifier(): Internal.BiomeSpecialEffects$GrassColorModifier;
        getWaterFogColor(): number;
        getWaterColor(): number;
    }
    type EffectsProperties_ = EffectsProperties;
    class EntityPredicateBuilderJS implements Internal.ExtendedEntityFlagsPredicate$IBuilder<Internal.EntityPredicate> {
        isBaby(arg0: boolean): Internal.EntityPredicateBuilderJS;
        getClass(): Internal.Class<any>;
        nbt(arg0: Internal.CompoundTag_): Internal.EntityPredicateBuilderJS;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        anyType(arg0: Internal.Resolver_[]): Internal.EntityPredicateBuilderJS;
        isCrouching(arg0: boolean): Internal.EntityPredicateBuilderJS;
        notifyAll(): void;
        isUnderWater(arg0: boolean): Internal.EntityPredicateBuilderJS;
        isSprinting(arg0: boolean): Internal.EntityPredicateBuilderJS;
        matchFluid(arg0: Internal.Resolver_): Internal.EntityPredicateBuilderJS;
        notify(): void;
        hashCode(): number;
        matchBlock(arg0: Internal.Resolver_): Internal.EntityPredicateBuilderJS;
        matchBlock(arg0: Internal.Resolver_, arg1: Internal.Map_<string, string>): Internal.EntityPredicateBuilderJS;
        hasEffect(arg0: Internal.MobEffect_): Internal.EntityPredicateBuilderJS;
        hasEffect(arg0: Internal.MobEffect_, arg1: number): Internal.EntityPredicateBuilderJS;
        isIllegarMob(arg0: boolean): Internal.EntityPredicateBuilderJS;
        isSwimming(arg0: boolean): Internal.EntityPredicateBuilderJS;
        isInWater(arg0: boolean): Internal.EntityPredicateBuilderJS;
        isWaterMob(arg0: boolean): Internal.EntityPredicateBuilderJS;
        catType(arg0: ResourceLocation_): Internal.EntityPredicateBuilderJS;
        isUndeadMob(arg0: boolean): Internal.EntityPredicateBuilderJS;
        isCreature(arg0: boolean): Internal.EntityPredicateBuilderJS;
        build(): Internal.EntityPredicate;
        isMonster(arg0: boolean): Internal.EntityPredicateBuilderJS;
        equals(arg0: any): boolean;
        matchMount(arg0: Internal.Consumer_<Internal.EntityPredicateBuilderJS_>): Internal.EntityPredicateBuilderJS;
        isOnFire(arg0: boolean): Internal.EntityPredicateBuilderJS;
        toString(): string;
        isArthropodMob(arg0: boolean): Internal.EntityPredicateBuilderJS;
        isOnGround(arg0: boolean): Internal.EntityPredicateBuilderJS;
        matchSlot(arg0: EquipmentSlot_, arg1: ItemFilter_): Internal.EntityPredicateBuilderJS;
        matchTargetedEntity(arg0: Internal.Consumer_<Internal.EntityPredicateBuilderJS_>): Internal.EntityPredicateBuilderJS;
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    type EntityPredicateBuilderJS_ = EntityPredicateBuilderJS;
    abstract class TeamProperty <T> {
        getClass(): Internal.Class<any>;
        readValue(buf: Internal.FriendlyByteBuf_): T;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        fromNBT(tag: net.minecraft.nbt.Tag_): Internal.Optional<T>;
        notifyAll(): void;
        notify(): void;
        toNBT(value: T): net.minecraft.nbt.Tag;
        getType(): Internal.TeamPropertyType<T>;
        hashCode(): number;
        equals(o: any): boolean;
        toString(value: T): string;
        toString(): string;
        fromString(arg0: string): Internal.Optional<T>;
        writeValue(buf: Internal.FriendlyByteBuf_, value: T): void;
        config(config: Internal.ConfigGroup_, value: Internal.TeamPropertyValue_<T>): void;
        write(arg0: Internal.FriendlyByteBuf_): void;
        readonly defaultValue : T;
        readonly id : ResourceLocation;
        get type(): Internal.TeamPropertyType<T>;
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    type TeamProperty_<T> = TeamProperty<T>;
    interface ProcessorHandle <Msg> extends Internal.AutoCloseable {
        close(): void;
    }
    type ProcessorHandle_<Msg> = ProcessorHandle<Msg>;
    class EventQueue {
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        static getCurrentEvent(): Internal.AWTEvent;
        createSecondaryLoop(): Internal.SecondaryLoop;
        notifyAll(): void;
        peekEvent(): Internal.AWTEvent;
        peekEvent(arg0: number): Internal.AWTEvent;
        notify(): void;
        static invokeAndWait(arg0: Internal.Runnable_): void;
        static isDispatchThread(): boolean;
        static invokeLater(arg0: Internal.Runnable_): void;
        push(arg0: Internal.EventQueue_): void;
        postEvent(arg0: Internal.AWTEvent_): void;
        hashCode(): number;
        equals(arg0: any): boolean;
        static getMostRecentEventTime(): number;
        toString(): string;
        getNextEvent(): Internal.AWTEvent;
        get dispatchThread(): boolean;
        get currentEvent(): Internal.AWTEvent;
        get mostRecentEventTime(): number;
        get nextEvent(): Internal.AWTEvent;
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    type EventQueue_ = EventQueue;
    abstract class AbstractIntCollection extends Internal.AbstractCollection<number> implements Internal.IntCollection {
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        notifyAll(): void;
        intIterator(): Internal.IntIterator;
        intSpliterator(): Internal.IntSpliterator;
        notify(): void;
        remove(arg0: any): boolean;
        intStream(): Internal.IntStream;
        removeAll(arg0: Internal.IntCollection_): boolean;
        removeAll(arg0: Internal.Collection_<any>): boolean;
        iterator(): Internal.IntIterator;
        stream(): Internal.Stream<number>;
        hashCode(): number;
        toIntArray(arg0: number[]): number[];
        toIntArray(): number[];
        toArray(arg0: number[]): number[];
        toArray(): any[];
        toArray<T_>(arg0: T_[]): T_[];
        toArray<T_>(arg0: Internal.IntFunction_<T_[]>): T_[];
        parallelStream(): Internal.Stream<number>;
        rem(arg0: number): boolean;
        add(arg0: number): boolean;
        spliterator(): Internal.IntSpliterator;
        forEach(arg0: Internal.IntConsumer_): void;
        forEach(arg0: Internal.Consumer_<number>): void;
        forEach(arg0: java_.util.function_.IntConsumer_): void;
        containsAll(arg0: Internal.Collection_<any>): boolean;
        containsAll(arg0: Internal.IntCollection_): boolean;
        isEmpty(): boolean;
        clear(): void;
        removeIf(arg0: Internal.IntPredicate_): boolean;
        removeIf(arg0: Internal.Predicate_<number>): boolean;
        removeIf(arg0: java_.util.function_.IntPredicate_): boolean;
        contains(arg0: number): boolean;
        contains(arg0: any): boolean;
        size(): number;
        addAll(arg0: Internal.IntCollection_): boolean;
        addAll(arg0: Internal.Collection_<number>): boolean;
        equals(arg0: any): boolean;
        toString(): string;
        intParallelStream(): Internal.IntStream;
        retainAll(arg0: Internal.Collection_<any>): boolean;
        retainAll(arg0: Internal.IntCollection_): boolean;
        get class(): Internal.Class<any>;
        get empty(): boolean;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    type AbstractIntCollection_ = AbstractIntCollection;
    class MathContext implements Internal.Serializable {
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        getRoundingMode(): Internal.RoundingMode;
        hashCode(): number;
        notifyAll(): void;
        equals(arg0: any): boolean;
        toString(): string;
        notify(): void;
        getPrecision(): number;
        static readonly DECIMAL128 : Internal.MathContext;
        static readonly DECIMAL64 : Internal.MathContext;
        static readonly DECIMAL32 : Internal.MathContext;
        static readonly UNLIMITED : Internal.MathContext;
        get roundingMode(): Internal.RoundingMode;
        get precision(): number;
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    type MathContext_ = MathContext;
    class VertexFormatElement {
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        getElementCount(): number;
        hashCode(): number;
        notifyAll(): void;
        equals(arg0: any): boolean;
        toString(): string;
        notify(): void;
        get elementCount(): number;
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    type VertexFormatElement_ = VertexFormatElement;
    interface IngredientKJS extends Internal.AsKJS {
        getItemsKJS(): Internal.ItemStack[];
        asKJS(): any;
    }
    type IngredientKJS_ = IngredientKJS;
    class UseOnContext {
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        hashCode(): number;
        notifyAll(): void;
        equals(arg0: any): boolean;
        toString(): string;
        notify(): void;
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    type UseOnContext_ = UseOnContext;
    interface IDrawable {
        getHeight(): number;
        draw(arg0: Internal.PoseStack_, arg1: number, arg2: number): void;
        draw(arg0: Internal.PoseStack_): void;
        getWidth(): number;
    }
    type IDrawable_ = IDrawable;
    class EnderMan extends Internal.Monster implements Internal.NeutralMob {
        getClass(): Internal.Class<any>;
        resetDynamicLight(): void;
        getCapability<T_>(arg0: Internal.Capability_<T_>, arg1: Internal.Direction_): Internal.LazyOptional<T_>;
        getCapability<T_>(arg0: Internal.Capability_<T_>): Internal.LazyOptional<T_>;
        captureDrops(arg0: Internal.Collection_<Internal.ItemEntity_>): Internal.Collection<Internal.ItemEntity>;
        captureDrops(): Internal.Collection<Internal.ItemEntity>;
        canBeRiddenInWater(arg0: Internal.Entity_): boolean;
        setCitadelEntityData(arg0: Internal.CompoundTag_): void;
        isDynamicLightEnabled(): boolean;
        changeDimension(arg0: Internal.ServerLevel_, arg1: Internal.ITeleporter_): Internal.Entity;
        serializeNBT(): Internal.CompoundTag;
        invalidateCaps(): void;
        setDynamicLightEnabled(arg0: boolean): void;
        shouldUpdateDynamicLight(): boolean;
        foodEatenKJS(is: Internal.ItemStack_): void;
        revive(): void;
        setVisualScale(arg0: number): void;
        dynamicLightTick(): void;
        getPersistentDataKJS(): Internal.CompoundTag;
        canUpdate(): boolean;
        canUpdate(arg0: boolean): void;
        getDynamicLightY(): number;
        getDynamicLightZ(): number;
        handler$zbj000$curio$canFreeze(arg0: Internal.CallbackInfoReturnable_<any>): void;
        getDynamicLightX(): number;
        areCapsCompatible(arg0: Internal.CapabilityProvider_<Internal.Entity_>): boolean;
        areCapsCompatible(arg0: Internal.CapabilityDispatcher_): boolean;
        redirect$bie002$elytraOverride(arg0: Internal.ItemStack_, arg1: Internal.LivingEntity_): boolean;
        handler$zbi000$curio$isLookingAtMe(arg0: Internal.Player_, arg1: Internal.CallbackInfoReturnable_<any>): void;
        getEyeHeightAccess(arg0: Internal.Pose_, arg1: Internal.EntityDimensions_): number;
        reviveCaps(): void;
        lambdynlights$updateDynamicLight(arg0: Internal.LevelRenderer_): boolean;
        handler$bih000$removed(arg0: Internal.CallbackInfo_): void;
        canRiderInteract(): boolean;
        lambdynlights$scheduleTrackedChunksRebuild(arg0: Internal.LevelRenderer_): void;
        handler$bih001$onTick(arg0: Internal.CallbackInfo_): void;
        onAddedToWorld(): void;
        canTrample(arg0: Internal.BlockState_, arg1: BlockPos_, arg2: number): boolean;
        getCitadelEntityData(): Internal.CompoundTag;
        getClassification(arg0: boolean): Internal.MobCategory;
        handler$bih000$onRemove(arg0: Internal.CallbackInfo_): void;
        shouldRiderSit(): boolean;
        getPickedResult(arg0: Internal.HitResult_): Internal.ItemStack;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        notifyAll(): void;
        isActuallyReallyBlocking(): boolean;
        getPersistentData(): Internal.CompoundTag;
        notify(): void;
        redirect$bie000$eytraValidOverride(arg0: Internal.ItemStack_, arg1: Internal.LivingEntity_, arg2: number): boolean;
        hashCode(): number;
        setDimension(arg0: Internal.EntityDimensions_): void;
        isAddedToWorld(): boolean;
        getParts(): any[];
        getDynamicLightWorld(): Internal.Level;
        onRemovedFromWorld(): void;
        getLuminance(): number;
        isMultipartEntity(): boolean;
        deserializeNBT(arg0: Internal.CompoundTag_): void;
        curePotionEffects(arg0: Internal.ItemStack_): boolean;
        asKJS(): any;
        shouldRiderFaceForward(arg0: Internal.Player_): boolean;
        equals(arg0: any): boolean;
        toString(): string;
        getVisualScale(): number;
        get luminance(): number;
        get dynamicLightEnabled(): boolean;
        get citadelEntityData(): Internal.CompoundTag;
        get persistentData(): Internal.CompoundTag;
        get multipartEntity(): boolean;
        get addedToWorld(): boolean;
        get dynamicLightY(): number;
        get dynamicLightZ(): number;
        get dynamicLightX(): number;
        get visualScale(): number;
        get persistentDataKJS(): Internal.CompoundTag;
        get actuallyReallyBlocking(): boolean;
        get parts(): any[];
        get class(): Internal.Class<any>;
        get dynamicLightWorld(): Internal.Level;
        set dynamicLightEnabled(arg0: boolean);
        set visualScale(arg0: number);
        set citadelEntityData(arg0: Internal.CompoundTag_);
        set dimension(arg0: Internal.EntityDimensions_);
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    type EnderMan_ = EnderMan;
    interface LongToDoubleFunction {
        applyAsDouble(arg0: number): number;
    }
    type LongToDoubleFunction_ = ((arg0: number) => number) | LongToDoubleFunction;
    interface WindowStateListener extends Internal.EventListener {
        windowStateChanged(arg0: Internal.WindowEvent_): void;
    }
    type WindowStateListener_ = WindowStateListener;
    class ClientTeam extends Internal.TeamBase {
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        getName(): Internal.Component;
        notifyAll(): void;
        getHighestRank(playerId: Internal.UUID_): Internal.TeamRank;
        save(): void;
        getId(): Internal.UUID;
        isMember(uuid: Internal.UUID_): boolean;
        isOfficer(profile: Internal.UUID_): boolean;
        getDescription(): string;
        notify(): void;
        getColoredName(): Internal.Component;
        hashCode(): number;
        write(buffer: Internal.FriendlyByteBuf_, now: number): void;
        isAlly(profile: Internal.UUID_): boolean;
        getProperty<T_>(property: Internal.TeamProperty_<T_>): T_;
        isValid(): boolean;
        getExtraData(): Internal.CompoundTag;
        getColor(): number;
        getRanked(rank: Internal.TeamRank_): Internal.Map<Internal.UUID, Internal.TeamRank>;
        isFreeToJoin(): boolean;
        isInvited(profile: Internal.UUID_): boolean;
        getStringID(): string;
        getDisplayName(): string;
        getType(): Internal.TeamType;
        setProperty<T_>(property: Internal.TeamProperty_<T_>, value: T_): void;
        equals(o: any): boolean;
        toString(): string;
        isSelf(): boolean;
        getMembers(): Internal.Set<Internal.UUID>;
        static readonly FREE_TO_JOIN : Internal.BooleanProperty;
        readonly manager : Internal.ClientTeamManager;
        static readonly DESCRIPTION : Internal.StringProperty;
        static readonly COLOR : Internal.ColorProperty;
        invalid : boolean;
        readonly messageHistory : Internal.List<Internal.TeamMessage>;
        static readonly DISPLAY_NAME : Internal.StringProperty;
        readonly properties : Internal.TeamProperties;
        get color(): number;
        get extraData(): Internal.CompoundTag;
        get displayName(): string;
        get description(): string;
        get type(): Internal.TeamType;
        get freeToJoin(): boolean;
        get valid(): boolean;
        get stringID(): string;
        get members(): Internal.Set<Internal.UUID>;
        get name(): Internal.Component;
        get self(): boolean;
        get id(): Internal.UUID;
        get class(): Internal.Class<any>;
        get coloredName(): Internal.Component;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    type ClientTeam_ = ClientTeam;
    interface Reference2ShortFunction <K> extends Internal.Function<K, number>, Internal.ToIntFunction<K> {
        getOrDefault(arg0: any, arg1: number): number;
        andThenShort(arg0: Internal.Short2ShortFunction_): Internal.Reference2ShortFunction<K>;
        composeByte(arg0: Internal.Byte2ReferenceFunction_<K>): Internal.Byte2ShortFunction;
        removeShort(arg0: any): number;
        andThenInt(arg0: Internal.Short2IntFunction_): Internal.Reference2IntFunction<K>;
        composeReference<T_>(arg0: Internal.Reference2ReferenceFunction_<T_, K>): Internal.Reference2ShortFunction<T_>;
        andThen<T_>(arg0: java_.util.function_.Function_<number, T_>): java_.util.function_.Function<K, T_>;
        put(arg0: K, arg1: number): number;
        remove(arg0: any): number;
        defaultReturnValue(): number;
        defaultReturnValue(arg0: number): void;
        andThenDouble(arg0: Internal.Short2DoubleFunction_): Internal.Reference2DoubleFunction<K>;
        andThenObject<T_>(arg0: Internal.Short2ObjectFunction_<T_>): Internal.Reference2ObjectFunction<K, T_>;
        get(arg0: any): number;
        andThenLong(arg0: Internal.Short2LongFunction_): Internal.Reference2LongFunction<K>;
        composeLong(arg0: Internal.Long2ReferenceFunction_<K>): Internal.Long2ShortFunction;
        andThenByte(arg0: Internal.Short2ByteFunction_): Internal.Reference2ByteFunction<K>;
        andThenFloat(arg0: Internal.Short2FloatFunction_): Internal.Reference2FloatFunction<K>;
        applyAsInt(arg0: K): number;
        apply(arg0: K): number;
        getShort(arg0: any): number;
        containsKey(arg0: any): boolean;
        composeInt(arg0: Internal.Int2ReferenceFunction_<K>): Internal.Int2ShortFunction;
        clear(): void;
        composeFloat(arg0: Internal.Float2ReferenceFunction_<K>): Internal.Float2ShortFunction;
        andThenChar(arg0: Internal.Short2CharFunction_): Internal.Reference2CharFunction<K>;
        composeObject<T_>(arg0: Internal.Object2ReferenceFunction_<T_, K>): Internal.Object2ShortFunction<T_>;
        size(): number;
        compose<V_>(arg0: java_.util.function_.Function_<V_, K>): java_.util.function_.Function<V_, number>;
        composeShort(arg0: Internal.Short2ReferenceFunction_<K>): Internal.Short2ShortFunction;
        andThenReference<T_>(arg0: Internal.Short2ReferenceFunction_<T_>): Internal.Reference2ReferenceFunction<K, T_>;
        composeChar(arg0: Internal.Char2ReferenceFunction_<K>): Internal.Char2ShortFunction;
        composeDouble(arg0: Internal.Double2ReferenceFunction_<K>): Internal.Double2ShortFunction;
    }
    type Reference2ShortFunction_<K> = ((arg0: any) => number) | Reference2ShortFunction<K>;
    abstract class ModuleReference {
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        hashCode(): number;
        notifyAll(): void;
        equals(arg0: any): boolean;
        toString(): string;
        location(): Internal.Optional<Internal.URI>;
        descriptor(): Internal.ModuleDescriptor;
        notify(): void;
        open(): Internal.ModuleReader;
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    type ModuleReference_ = ModuleReference;
    class MultiblockRecipeJS extends Internal.RecipeJS {
        parseResultItemList(o: any): Internal.List<Internal.ItemStackJS>;
        getClass(): Internal.Class<any>;
        ingredientAction(filter: Internal.IngredientActionFilter_, action: Internal.IngredientAction_): Internal.RecipeJS;
        data(arg0: Internal.CompoundTag_): Internal.MultiblockRecipeJS;
        convertReplacedInput(index: number, oldIngredient: Internal.IngredientJS_, newIngredient: Internal.IngredientJS_): Internal.IngredientJS;
        thunder(arg0: number): Internal.MultiblockRecipeJS;
        thunder(arg0: number, arg1: boolean): Internal.MultiblockRecipeJS;
        inputMana(arg0: number): Internal.MultiblockRecipeJS;
        inputMana(arg0: number, arg1: string): Internal.MultiblockRecipeJS;
        inputFE(arg0: number, arg1: string): Internal.MultiblockRecipeJS;
        inputFE(arg0: number): Internal.MultiblockRecipeJS;
        outputAura(arg0: number, arg1: string): Internal.MultiblockRecipeJS;
        outputAura(arg0: number): Internal.MultiblockRecipeJS;
        outputInfusion(arg0: Internal.MapJS_, arg1: string): Internal.MultiblockRecipeJS;
        outputInfusion(arg0: Internal.MapJS_): Internal.MultiblockRecipeJS;
        getUniqueId(): string;
        output<T_>(arg0: Internal.MultiblockCapability_<T_>, arg1: T_, arg2: string): Internal.MultiblockRecipeJS;
        replaceOutput(i: Internal.IngredientJS_, with_: Internal.ItemStackJS_, exact: boolean): boolean;
        replaceOutput(i: Internal.IngredientJS_, with_: Internal.ItemStackJS_, exact: boolean, func: Internal.BiFunction_<Internal.ItemStackJS_, Internal.ItemStackJS_, Internal.ItemStackJS_>): boolean;
        setChance(arg0: number): Internal.MultiblockRecipeJS;
        outputSlurry(arg0: Internal.MapJS_, arg1: string): Internal.MultiblockRecipeJS;
        outputSlurry(arg0: Internal.MapJS_): Internal.MultiblockRecipeJS;
        parseIngredientItemList(o: any): Internal.List<Internal.IngredientJS>;
        merge(data: any): Internal.RecipeJS;
        getPath(): string;
        outputItems(arg0: Internal.IngredientJS_[]): Internal.MultiblockRecipeJS;
        create(arg0: Internal.ListJS_): void;
        parseIngredientItemStackList(o: any): Internal.List<Internal.IngredientStackJS>;
        id(_id: ResourceLocation_): Internal.RecipeJS;
        text(arg0: string): Internal.MultiblockRecipeJS;
        parseIngredientItem(o: any, key: string): Internal.IngredientJS;
        parseIngredientItem(o: any): Internal.IngredientJS;
        outputHeat(arg0: number): Internal.MultiblockRecipeJS;
        outputHeat(arg0: number, arg1: string): Internal.MultiblockRecipeJS;
        group(g: string): Internal.RecipeJS;
        inputEMC(arg0: number): Internal.MultiblockRecipeJS;
        inputEMC(arg0: number, arg1: string): Internal.MultiblockRecipeJS;
        inputGas(arg0: Internal.MapJS_, arg1: string): Internal.MultiblockRecipeJS;
        inputGas(arg0: Internal.MapJS_): Internal.MultiblockRecipeJS;
        getOriginalRecipeResult(): Internal.ItemStackJS;
        outputPigment(arg0: Internal.MapJS_): Internal.MultiblockRecipeJS;
        outputPigment(arg0: Internal.MapJS_, arg1: string): Internal.MultiblockRecipeJS;
        getOriginalRecipeIngredients(): Internal.List<Internal.IngredientJS>;
        outputFE(arg0: number, arg1: string): Internal.MultiblockRecipeJS;
        outputFE(arg0: number): Internal.MultiblockRecipeJS;
        outputStress(arg0: number): Internal.MultiblockRecipeJS;
        outputStress(arg0: number, arg1: string): Internal.MultiblockRecipeJS;
        getInputIndex(ingredient: Internal.IngredientJS_, exact: boolean): number;
        setGroup(g: string): void;
        serialize(): void;
        outputFluid(arg0: Internal.FluidStackJS_): Internal.MultiblockRecipeJS;
        outputFluid(arg0: Internal.FluidStackJS_, arg1: string): Internal.MultiblockRecipeJS;
        input<T_>(arg0: Internal.MultiblockCapability_<T_>, arg1: T_, arg2: string): Internal.MultiblockRecipeJS;
        inputSlurry(arg0: Internal.MapJS_): Internal.MultiblockRecipeJS;
        inputSlurry(arg0: Internal.MapJS_, arg1: string): Internal.MultiblockRecipeJS;
        replaceInput(i: Internal.IngredientJS_, with_: Internal.IngredientJS_, exact: boolean, func: Internal.BiFunction_<Internal.IngredientJS_, Internal.IngredientJS_, Internal.IngredientJS_>): boolean;
        replaceInput(i: Internal.IngredientJS_, with_: Internal.IngredientJS_, exact: boolean): boolean;
        getType(): string;
        outputGas(arg0: Internal.MapJS_, arg1: string): Internal.MultiblockRecipeJS;
        outputGas(arg0: Internal.MapJS_): Internal.MultiblockRecipeJS;
        biome(arg0: ResourceLocation_, arg1: boolean): Internal.MultiblockRecipeJS;
        biome(arg0: ResourceLocation_): Internal.MultiblockRecipeJS;
        getGroup(): string;
        outputItem(arg0: Internal.IngredientJS_, arg1: string): Internal.MultiblockRecipeJS;
        outputItem(arg0: Internal.IngredientJS_): Internal.MultiblockRecipeJS;
        hasOutput(ingredient: Internal.IngredientJS_, exact: boolean): boolean;
        keepIngredient(filter: Internal.IngredientActionFilter_): Internal.RecipeJS;
        customIngredientAction(filter: Internal.IngredientActionFilter_, id: string): Internal.RecipeJS;
        modifyResult(callback: Internal.ModifyRecipeResultCallback_): Internal.RecipeJS;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        getMod(): string;
        inputItem(arg0: Internal.IngredientJS_, arg1: string): Internal.MultiblockRecipeJS;
        inputItem(arg0: Internal.IngredientJS_): Internal.MultiblockRecipeJS;
        notifyAll(): void;
        convertReplacedOutput(index: number, oldStack: Internal.ItemStackJS_, newStack: Internal.ItemStackJS_): Internal.ItemStackJS;
        save(): void;
        raining(arg0: number): Internal.MultiblockRecipeJS;
        raining(arg0: number, arg1: boolean): Internal.MultiblockRecipeJS;
        damageIngredient(filter: Internal.IngredientActionFilter_): Internal.RecipeJS;
        damageIngredient(filter: Internal.IngredientActionFilter_, damage: number): Internal.RecipeJS;
        getId(): string;
        dontAdd(): void;
        notify(): void;
        serializeJson(): void;
        requiresBlock(arg0: Internal.BlockState_, arg1: number): Internal.MultiblockRecipeJS;
        requiresBlock(arg0: Internal.BlockState_, arg1: number, arg2: boolean): Internal.MultiblockRecipeJS;
        duration(arg0: number): Internal.MultiblockRecipeJS;
        createRecipe(): Internal.Recipe<any>;
        getFromToString(): string;
        yLevel(arg0: number, arg1: number): Internal.MultiblockRecipeJS;
        yLevel(arg0: number, arg1: number, arg2: boolean): Internal.MultiblockRecipeJS;
        inputPigment(arg0: Internal.MapJS_, arg1: string): Internal.MultiblockRecipeJS;
        inputPigment(arg0: Internal.MapJS_): Internal.MultiblockRecipeJS;
        hashCode(): number;
        outputFluids(arg0: Internal.FluidStackJS_[]): Internal.MultiblockRecipeJS;
        outputEMC(arg0: number, arg1: string): Internal.MultiblockRecipeJS;
        outputEMC(arg0: number): Internal.MultiblockRecipeJS;
        setPerTick(arg0: boolean): Internal.MultiblockRecipeJS;
        deserializeJson(): void;
        getOrCreateId(): ResourceLocation;
        dimension(arg0: ResourceLocation_): Internal.MultiblockRecipeJS;
        dimension(arg0: ResourceLocation_, arg1: boolean): Internal.MultiblockRecipeJS;
        inputStress(arg0: number): Internal.MultiblockRecipeJS;
        inputStress(arg0: number, arg1: string): Internal.MultiblockRecipeJS;
        deserialize(): void;
        inputInfusion(arg0: Internal.MapJS_): Internal.MultiblockRecipeJS;
        inputInfusion(arg0: Internal.MapJS_, arg1: string): Internal.MultiblockRecipeJS;
        serializeNBTAsJson(): boolean;
        getOutputIndex(ingredient: Internal.IngredientJS_, exact: boolean): number;
        inputHeat(arg0: number, arg1: string): Internal.MultiblockRecipeJS;
        inputHeat(arg0: number): Internal.MultiblockRecipeJS;
        inputFluid(arg0: Internal.FluidStackJS_, arg1: string): Internal.MultiblockRecipeJS;
        inputFluid(arg0: Internal.FluidStackJS_): Internal.MultiblockRecipeJS;
        inputItems(arg0: Internal.IngredientJS_[]): Internal.MultiblockRecipeJS;
        outputMana(arg0: number): Internal.MultiblockRecipeJS;
        outputMana(arg0: number, arg1: string): Internal.MultiblockRecipeJS;
        resultFromRecipeJson(json: Internal.JsonObject_): Internal.ItemStackJS;
        stage(s: string): Internal.RecipeJS;
        serializeIngredientStack(arg0: Internal.IngredientStackJS_): Internal.JsonElement;
        equals(arg0: any): boolean;
        inputFluids(arg0: Internal.FluidStackJS_[]): Internal.MultiblockRecipeJS;
        serializeItemStack(stack: Internal.ItemStackJS_): Internal.JsonElement;
        inputAura(arg0: number): Internal.MultiblockRecipeJS;
        inputAura(arg0: number, arg1: string): Internal.MultiblockRecipeJS;
        toString(): string;
        hasInput(ingredient: Internal.IngredientJS_, exact: boolean): boolean;
        parseResultItem(o: any): Internal.ItemStackJS;
        replaceIngredient(filter: Internal.IngredientActionFilter_, item: Internal.ItemStackJS_): Internal.RecipeJS;
        static currentRecipe : Internal.RecipeJS;
        originalJson : Internal.JsonObject;
        serializeOutputs : boolean;
        originalRecipe : Internal.Recipe<any>;
        static itemErrors : false;
        json : Internal.JsonObject;
        type : Internal.RecipeTypeJS;
        serializeInputs : boolean;
        get path(): string;
        get originalRecipeIngredients(): Internal.List<Internal.IngredientJS>;
        get mod(): string;
        get originalRecipeResult(): Internal.ItemStackJS;
        get orCreateId(): ResourceLocation;
        get class(): Internal.Class<any>;
        get fromToString(): string;
        get uniqueId(): string;
        set chance(arg0: number);
        set perTick(arg0: boolean);
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    type MultiblockRecipeJS_ = MultiblockRecipeJS;
    interface Float2ReferenceFunction <V> extends Internal.Function<number, V>, Internal.DoubleFunction<V> {
        getOrDefault(arg0: number, arg1: V): V;
        getOrDefault(arg0: any, arg1: V): V;
        andThenShort(arg0: Internal.Reference2ShortFunction_<V>): Internal.Float2ShortFunction;
        composeByte(arg0: Internal.Byte2FloatFunction_): Internal.Byte2ReferenceFunction<V>;
        andThenInt(arg0: Internal.Reference2IntFunction_<V>): Internal.Float2IntFunction;
        andThen<V_>(arg0: java_.util.function_.Function_<V, V_>): java_.util.function_.Function<number, V_>;
        composeReference<T_>(arg0: Internal.Reference2FloatFunction_<T_>): Internal.Reference2ReferenceFunction<T_, V>;
        put(arg0: number, arg1: V): V;
        remove(arg0: any): V;
        remove(arg0: number): V;
        defaultReturnValue(arg0: V): void;
        defaultReturnValue(): V;
        andThenDouble(arg0: Internal.Reference2DoubleFunction_<V>): Internal.Float2DoubleFunction;
        andThenObject<T_>(arg0: Internal.Reference2ObjectFunction_<V, T_>): Internal.Float2ObjectFunction<T_>;
        get(arg0: any): V;
        get(arg0: number): V;
        andThenLong(arg0: Internal.Reference2LongFunction_<V>): Internal.Float2LongFunction;
        composeLong(arg0: Internal.Long2FloatFunction_): Internal.Long2ReferenceFunction<V>;
        andThenByte(arg0: Internal.Reference2ByteFunction_<V>): Internal.Float2ByteFunction;
        andThenFloat(arg0: Internal.Reference2FloatFunction_<V>): Internal.Float2FloatFunction;
        apply(arg0: number): V;
        containsKey(arg0: any): boolean;
        containsKey(arg0: number): boolean;
        composeInt(arg0: Internal.Int2FloatFunction_): Internal.Int2ReferenceFunction<V>;
        clear(): void;
        composeFloat(arg0: Internal.Float2FloatFunction_): Internal.Float2ReferenceFunction<V>;
        andThenChar(arg0: Internal.Reference2CharFunction_<V>): Internal.Float2CharFunction;
        composeObject<T_>(arg0: Internal.Object2FloatFunction_<T_>): Internal.Object2ReferenceFunction<T_, V>;
        size(): number;
        compose<T_>(arg0: java_.util.function_.Function_<T_, number>): java_.util.function_.Function<T_, V>;
        composeShort(arg0: Internal.Short2FloatFunction_): Internal.Short2ReferenceFunction<V>;
        andThenReference<T_>(arg0: Internal.Reference2ReferenceFunction_<V, T_>): Internal.Float2ReferenceFunction<T_>;
        composeChar(arg0: Internal.Char2FloatFunction_): Internal.Char2ReferenceFunction<V>;
        composeDouble(arg0: Internal.Double2FloatFunction_): Internal.Double2ReferenceFunction<V>;
    }
    type Float2ReferenceFunction_<V> = ((arg0: number) => V) | Float2ReferenceFunction<V>;
    interface AsynchronousChannel extends Internal.Channel {
        isOpen(): boolean;
        close(): void;
    }
    type AsynchronousChannel_ = AsynchronousChannel;
    class CustomStatBuilder extends Internal.BuilderBase<ResourceLocation> {
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        clientRegistry(minecraft: Internal.Minecraft_): void;
        generateAssetJsons(generator: Internal.AssetJsonGenerator_): void;
        transformObject(obj: ResourceLocation_): ResourceLocation;
        translationKey(key: string): Internal.BuilderBase<ResourceLocation>;
        getTranslationKeyGroup(): string;
        newID(pre: string, post: string): ResourceLocation;
        displayName(name: string): Internal.BuilderBase<ResourceLocation>;
        notifyAll(): void;
        generateLang(lang: Internal.Map_<string, string>): void;
        type(type: string): Internal.BuilderBase<ResourceLocation>;
        notify(): void;
        createAdditionalObjects(): void;
        createObject(): ResourceLocation;
        addResourcePackLocations(path: string, list: Internal.List_<ResourceLocation_>, packType: Internal.PackType_): void;
        hashCode(): number;
        equals(arg0: any): boolean;
        get(): ResourceLocation;
        getRegistryType(): Internal.RegistryObjectBuilderTypes<ResourceLocation>;
        toString(): string;
        tag(tag: ResourceLocation_): Internal.BuilderBase<ResourceLocation>;
        generateDataJsons(generator: Internal.DataJsonGenerator_): void;
        readonly id : ResourceLocation;
        get registryType(): Internal.RegistryObjectBuilderTypes<ResourceLocation>;
        get class(): Internal.Class<any>;
        get translationKeyGroup(): string;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    type CustomStatBuilder_ = CustomStatBuilder;
    abstract class ForgeRegistryEntry$UncheckedRegistryEntry <V> extends Internal.ForgeRegistryEntry<V> {
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        hashCode(): number;
        notifyAll(): void;
        equals(arg0: any): boolean;
        getRegistryType(): Internal.Class<V>;
        getRegistryName(): ResourceLocation;
        toString(): string;
        setRegistryName(arg0: ResourceLocation_): V;
        setRegistryName(arg0: string): V;
        setRegistryName(arg0: string, arg1: string): V;
        notify(): void;
        readonly delegate : Internal.IRegistryDelegate<V>;
        get registryType(): Internal.Class<V>;
        get registryName(): ResourceLocation;
        get class(): Internal.Class<any>;
        set registryName(arg0: ResourceLocation_);
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    type ForgeRegistryEntry$UncheckedRegistryEntry_<V> = ForgeRegistryEntry$UncheckedRegistryEntry<V>;
    class Products$P3 <F, T1, T2, T3> {
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        apply<R>(arg0: Internal.Applicative_<F, any>, arg1: Internal.Function3_<T1, T2, T3, R>): Internal.App<F, R>;
        apply<R>(arg0: Internal.Applicative_<F, any>, arg1: Internal.App_<F, Internal.Function3_<T1, T2, T3, R>>): Internal.App<F, R>;
        hashCode(): number;
        and<T4, T5, T6, T7>(arg0: Internal.Products$P4_<F, T4, T5, T6, T7>): Internal.Products$P7<F, T1, T2, T3, T4, T5, T6, T7>;
        and<T4, T5, T6, T7, T8>(arg0: Internal.Products$P5_<F, T4, T5, T6, T7, T8>): Internal.Products$P8<F, T1, T2, T3, T4, T5, T6, T7, T8>;
        and<T4>(arg0: Internal.App_<F, T4>): Internal.Products$P4<F, T1, T2, T3, T4>;
        and<T4, T5>(arg0: Internal.Products$P2_<F, T4, T5>): Internal.Products$P5<F, T1, T2, T3, T4, T5>;
        and<T4, T5, T6>(arg0: Internal.Products$P3_<F, T4, T5, T6>): Internal.Products$P6<F, T1, T2, T3, T4, T5, T6>;
        notifyAll(): void;
        equals(arg0: any): boolean;
        toString(): string;
        t1(): Internal.App<F, T1>;
        notify(): void;
        t2(): Internal.App<F, T2>;
        t3(): Internal.App<F, T3>;
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    type Products$P3_<F, T1, T2, T3> = Products$P3<F, T1, T2, T3>;
    abstract class AbstractReferenceCountedByteBuf extends Internal.AbstractByteBuf {
        asReadOnly(): Internal.ByteBuf;
        markReaderIndex(): Internal.ByteBuf;
        getByte(arg0: number): number;
        release(): boolean;
        release(arg0: number): boolean;
        readDoubleLE(): number;
        writeZero(arg0: number): Internal.ByteBuf;
        resetReaderIndex(): Internal.ByteBuf;
        writeFloat(arg0: number): Internal.ByteBuf;
        setLongLE(arg0: number, arg1: number): Internal.ByteBuf;
        readRetainedSlice(arg0: number): Internal.ByteBuf;
        slice(): Internal.ByteBuf;
        slice(arg0: number, arg1: number): Internal.ByteBuf;
        setDoubleLE(arg0: number, arg1: number): Internal.ByteBuf;
        getMediumLE(arg0: number): number;
        readUnsignedIntLE(): number;
        writeFloatLE(arg0: number): Internal.ByteBuf;
        readInt(): number;
        order(arg0: Internal.ByteOrder_): Internal.ByteBuf;
        order(): Internal.ByteOrder;
        writeMedium(arg0: number): Internal.ByteBuf;
        resetWriterIndex(): Internal.ByteBuf;
        writableBytes(): number;
        maxCapacity(): number;
        getUnsignedShort(arg0: number): number;
        nioBufferCount(): number;
        bytesBefore(arg0: number): number;
        bytesBefore(arg0: number, arg1: number, arg2: number): number;
        bytesBefore(arg0: number, arg1: number): number;
        setInt(arg0: number, arg1: number): Internal.ByteBuf;
        getInt(arg0: number): number;
        markWriterIndex(): Internal.ByteBuf;
        isReadable(arg0: number): boolean;
        isReadable(): boolean;
        writeBoolean(arg0: boolean): Internal.ByteBuf;
        setIntLE(arg0: number, arg1: number): Internal.ByteBuf;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        writeLongLE(arg0: number): Internal.ByteBuf;
        setShortLE(arg0: number, arg1: number): Internal.ByteBuf;
        retain(arg0: number): Internal.ByteBuf;
        retain(): Internal.ByteBuf;
        isWritable(): boolean;
        isWritable(arg0: number): boolean;
        notify(): void;
        readChar(): string;
        hasMemoryAddress(): boolean;
        capacity(): number;
        capacity(arg0: number): Internal.ByteBuf;
        readCharSequence(arg0: number, arg1: Internal.Charset_): Internal.CharSequence;
        isReadOnly(): boolean;
        readUnsignedShortLE(): number;
        readDouble(): number;
        readFloat(): number;
        getLongLE(arg0: number): number;
        getBoolean(arg0: number): boolean;
        copy(): Internal.ByteBuf;
        copy(arg0: number, arg1: number): Internal.ByteBuf;
        readShortLE(): number;
        readUnsignedMedium(): number;
        ensureWritable(arg0: number): Internal.ByteBuf;
        ensureWritable(arg0: number, arg1: boolean): number;
        writeInt(arg0: number): Internal.ByteBuf;
        readFloatLE(): number;
        getDoubleLE(arg0: number): number;
        hasArray(): boolean;
        memoryAddress(): number;
        maxFastWritableBytes(): number;
        readableBytes(): number;
        readSlice(arg0: number): Internal.ByteBuf;
        getIntLE(arg0: number): number;
        nioBuffers(): Internal.ByteBuffer[];
        nioBuffers(arg0: number, arg1: number): Internal.ByteBuffer[];
        forEachByteDesc(arg0: Internal.ByteProcessor_): number;
        forEachByteDesc(arg0: number, arg1: number, arg2: Internal.ByteProcessor_): number;
        skipBytes(arg0: number): Internal.ByteBuf;
        getLong(arg0: number): number;
        readLong(): number;
        readShort(): number;
        equals(arg0: any): boolean;
        setZero(arg0: number, arg1: number): Internal.ByteBuf;
        getUnsignedMedium(arg0: number): number;
        readBytes(arg0: number[]): Internal.ByteBuf;
        readBytes(arg0: Internal.ByteBuf_): Internal.ByteBuf;
        readBytes(arg0: number): Internal.ByteBuf;
        readBytes(arg0: Internal.GatheringByteChannel_, arg1: number): number;
        readBytes(arg0: Internal.FileChannel_, arg1: number, arg2: number): number;
        readBytes(arg0: Internal.OutputStream_, arg1: number): Internal.ByteBuf;
        readBytes(arg0: number[], arg1: number, arg2: number): Internal.ByteBuf;
        readBytes(arg0: Internal.ByteBuf_, arg1: number): Internal.ByteBuf;
        readBytes(arg0: Internal.ByteBuf_, arg1: number, arg2: number): Internal.ByteBuf;
        readBytes(arg0: Internal.ByteBuffer_): Internal.ByteBuf;
        readBoolean(): boolean;
        toString(): string;
        toString(arg0: number, arg1: number, arg2: Internal.Charset_): string;
        toString(arg0: Internal.Charset_): string;
        retainedSlice(arg0: number, arg1: number): Internal.ByteBuf;
        retainedSlice(): Internal.ByteBuf;
        readMediumLE(): number;
        isDirect(): boolean;
        setMedium(arg0: number, arg1: number): Internal.ByteBuf;
        setBoolean(arg0: number, arg1: boolean): Internal.ByteBuf;
        getClass(): Internal.Class<any>;
        getFloatLE(arg0: number): number;
        readerIndex(): number;
        readerIndex(arg0: number): Internal.ByteBuf;
        getCharSequence(arg0: number, arg1: number, arg2: Internal.Charset_): Internal.CharSequence;
        setShort(arg0: number, arg1: number): Internal.ByteBuf;
        compareTo(arg0: Internal.ByteBuf_): number;
        getBytes(arg0: number, arg1: Internal.ByteBuf_, arg2: number): Internal.ByteBuf;
        getBytes(arg0: number, arg1: Internal.ByteBuf_): Internal.ByteBuf;
        getBytes(arg0: number, arg1: number[]): Internal.ByteBuf;
        getBytes(arg0: number, arg1: Internal.ByteBuf_, arg2: number, arg3: number): Internal.ByteBuf;
        getBytes(arg0: number, arg1: Internal.FileChannel_, arg2: number, arg3: number): number;
        getBytes(arg0: number, arg1: Internal.GatheringByteChannel_, arg2: number): number;
        getBytes(arg0: number, arg1: Internal.OutputStream_, arg2: number): Internal.ByteBuf;
        getBytes(arg0: number, arg1: number[], arg2: number, arg3: number): Internal.ByteBuf;
        getBytes(arg0: number, arg1: Internal.ByteBuffer_): Internal.ByteBuf;
        unwrap(): Internal.ByteBuf;
        setDouble(arg0: number, arg1: number): Internal.ByteBuf;
        setChar(arg0: number, arg1: number): Internal.ByteBuf;
        refCnt(): number;
        getUnsignedIntLE(arg0: number): number;
        setFloatLE(arg0: number, arg1: number): Internal.ByteBuf;
        getUnsignedInt(arg0: number): number;
        indexOf(arg0: number, arg1: number, arg2: number): number;
        writeByte(arg0: number): Internal.ByteBuf;
        nioBuffer(): Internal.ByteBuffer;
        nioBuffer(arg0: number, arg1: number): Internal.ByteBuffer;
        discardSomeReadBytes(): Internal.ByteBuf;
        touch(arg0: any): Internal.ByteBuf;
        touch(): Internal.ByteBuf;
        duplicate(): Internal.ByteBuf;
        writerIndex(arg0: number): Internal.ByteBuf;
        writerIndex(): number;
        writeCharSequence(arg0: Internal.CharSequence_, arg1: Internal.Charset_): number;
        readUnsignedInt(): number;
        getUnsignedShortLE(arg0: number): number;
        retainedDuplicate(): Internal.ByteBuf;
        getChar(arg0: number): string;
        setLong(arg0: number, arg1: number): Internal.ByteBuf;
        readMedium(): number;
        writeBytes(arg0: Internal.ScatteringByteChannel_, arg1: number): number;
        writeBytes(arg0: Internal.InputStream_, arg1: number): number;
        writeBytes(arg0: Internal.ByteBuffer_): Internal.ByteBuf;
        writeBytes(arg0: number[], arg1: number, arg2: number): Internal.ByteBuf;
        writeBytes(arg0: number[]): Internal.ByteBuf;
        writeBytes(arg0: Internal.ByteBuf_): Internal.ByteBuf;
        writeBytes(arg0: Internal.FileChannel_, arg1: number, arg2: number): number;
        writeBytes(arg0: Internal.ByteBuf_, arg1: number, arg2: number): Internal.ByteBuf;
        writeBytes(arg0: Internal.ByteBuf_, arg1: number): Internal.ByteBuf;
        forEachByte(arg0: Internal.ByteProcessor_): number;
        forEachByte(arg0: number, arg1: number, arg2: Internal.ByteProcessor_): number;
        setIndex(arg0: number, arg1: number): Internal.ByteBuf;
        writeShort(arg0: number): Internal.ByteBuf;
        alloc(): Internal.ByteBufAllocator;
        getShortLE(arg0: number): number;
        getMedium(arg0: number): number;
        readUnsignedShort(): number;
        setByte(arg0: number, arg1: number): Internal.ByteBuf;
        writeShortLE(arg0: number): Internal.ByteBuf;
        maxWritableBytes(): number;
        notifyAll(): void;
        getDouble(arg0: number): number;
        getFloat(arg0: number): number;
        writeLong(arg0: number): Internal.ByteBuf;
        writeIntLE(arg0: number): Internal.ByteBuf;
        array(): number[];
        setCharSequence(arg0: number, arg1: Internal.CharSequence_, arg2: Internal.Charset_): number;
        hashCode(): number;
        internalNioBuffer(arg0: number, arg1: number): Internal.ByteBuffer;
        arrayOffset(): number;
        readIntLE(): number;
        setMediumLE(arg0: number, arg1: number): Internal.ByteBuf;
        readUnsignedByte(): number;
        readUnsignedMediumLE(): number;
        readLongLE(): number;
        writeDouble(arg0: number): Internal.ByteBuf;
        setBytes(arg0: number, arg1: Internal.ByteBuf_): Internal.ByteBuf;
        setBytes(arg0: number, arg1: number[]): Internal.ByteBuf;
        setBytes(arg0: number, arg1: Internal.ByteBuf_, arg2: number): Internal.ByteBuf;
        setBytes(arg0: number, arg1: Internal.ByteBuf_, arg2: number, arg3: number): Internal.ByteBuf;
        setBytes(arg0: number, arg1: Internal.FileChannel_, arg2: number, arg3: number): number;
        setBytes(arg0: number, arg1: Internal.InputStream_, arg2: number): number;
        setBytes(arg0: number, arg1: Internal.ScatteringByteChannel_, arg2: number): number;
        setBytes(arg0: number, arg1: number[], arg2: number, arg3: number): Internal.ByteBuf;
        setBytes(arg0: number, arg1: Internal.ByteBuffer_): Internal.ByteBuf;
        setFloat(arg0: number, arg1: number): Internal.ByteBuf;
        getShort(arg0: number): number;
        writeMediumLE(arg0: number): Internal.ByteBuf;
        clear(): Internal.ByteBuf;
        getUnsignedByte(arg0: number): number;
        discardReadBytes(): Internal.ByteBuf;
        writeChar(arg0: number): Internal.ByteBuf;
        isContiguous(): boolean;
        writeDoubleLE(arg0: number): Internal.ByteBuf;
        getUnsignedMediumLE(arg0: number): number;
        readByte(): number;
        get readable(): boolean;
        get direct(): boolean;
        get readOnly(): boolean;
        get class(): Internal.Class<any>;
        get contiguous(): boolean;
        get writable(): boolean;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    type AbstractReferenceCountedByteBuf_ = AbstractReferenceCountedByteBuf;
    class RewardAutoClaim extends Internal.Enum<Internal.RewardAutoClaim> {
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        static valueOf(name: string): Internal.RewardAutoClaim;
        static valueOf<T_>(arg0: Internal.Class_<T_>, arg1: string): T_;
        notifyAll(): void;
        static values(): Internal.RewardAutoClaim[];
        compareTo(arg0: Internal.RewardAutoClaim_): number;
        describeConstable(): Internal.Optional<Internal.Enum$EnumDesc<Internal.RewardAutoClaim>>;
        notify(): void;
        getDeclaringClass(): Internal.Class<Internal.RewardAutoClaim>;
        hashCode(): number;
        equals(arg0: any): boolean;
        name(): string;
        toString(): string;
        ordinal(): number;
        static readonly DISABLED : Internal.RewardAutoClaim;
        static readonly NO_TOAST : Internal.RewardAutoClaim;
        static readonly INVISIBLE : Internal.RewardAutoClaim;
        static readonly NAME_MAP : Internal.NameMap<Internal.RewardAutoClaim>;
        static readonly NAME_MAP_NO_DEFAULT : Internal.NameMap<Internal.RewardAutoClaim>;
        static readonly ENABLED : Internal.RewardAutoClaim;
        id : string;
        static readonly DEFAULT : Internal.RewardAutoClaim;
        get class(): Internal.Class<any>;
        get declaringClass(): Internal.Class<Internal.RewardAutoClaim>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    type RewardAutoClaim_ = "default" | "invisible" | "disabled" | "enabled" | "no_toast" | RewardAutoClaim;
    interface IForgeMobEffectInstance {
        writeCurativeItems(arg0: Internal.CompoundTag_): void;
        addCurativeItem(arg0: Internal.ItemStack_): void;
        setCurativeItems(arg0: Internal.List_<Internal.ItemStack_>): void;
        isCurativeItem(arg0: Internal.ItemStack_): boolean;
        getCurativeItems(): Internal.List<Internal.ItemStack>;
    }
    type IForgeMobEffectInstance_ = IForgeMobEffectInstance;
    interface IPlaceableItem {
        getPlaceableBlock(): Internal.Block;
        getPlacer(): Internal.BlockPlacerItem;
        makePlaceable(arg0: Internal.Block_): void;
    }
    type IPlaceableItem_ = IPlaceableItem;
    class EntityArrayList extends Internal.ArrayList<Internal.EntityJS> implements Internal.MessageSender {
        getClass(): Internal.Class<any>;
        sendData(channel: string, data: Internal.CompoundTag_): void;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        getWorld(): Internal.LevelJS;
        getName(): Internal.Text;
        notifyAll(): void;
        tell(message: Internal.Component_): void;
        replaceAll(arg0: Internal.UnaryOperator_<Internal.EntityJS_>): void;
        notify(): void;
        remove(arg0: any): boolean;
        remove(arg0: number): Internal.EntityJS;
        runCommandSilent(command: string): number;
        removeAll(arg0: Internal.Collection_<any>): boolean;
        iterator(): Internal.Iterator<Internal.EntityJS>;
        stream(): Internal.Stream<Internal.EntityJS>;
        hashCode(): number;
        getFirst(): Internal.EntityJS;
        get(arg0: number): Internal.EntityJS;
        playSound(id: Internal.SoundEvent_, volume: number, pitch: number): void;
        playSound(id: Internal.SoundEvent_): void;
        toArray(): any[];
        toArray<T_>(arg0: T_[]): T_[];
        toArray<T_>(arg0: Internal.IntFunction_<T_[]>): T_[];
        parallelStream(): Internal.Stream<Internal.EntityJS>;
        runCommand(command: string): number;
        indexOf(arg0: any): number;
        add(arg0: Internal.EntityJS_): boolean;
        add(arg0: number, arg1: Internal.EntityJS_): void;
        subList(arg0: number, arg1: number): Internal.List<Internal.EntityJS>;
        setStatusMessage(message: Internal.Component_): void;
        trimToSize(): void;
        set(arg0: number, arg1: Internal.EntityJS_): Internal.EntityJS;
        spliterator(): Internal.Spliterator<Internal.EntityJS>;
        forEach(arg0: Internal.Consumer_<Internal.EntityJS_>): void;
        containsAll(arg0: Internal.Collection_<any>): boolean;
        isEmpty(): boolean;
        clear(): void;
        sort(arg0: Internal.Comparator_<Internal.EntityJS_>): void;
        kill(): void;
        removeIf(arg0: Internal.Predicate_<Internal.EntityJS_>): boolean;
        filter(filter: Internal.Predicate_<Internal.EntityJS_>): Internal.EntityArrayList;
        lastIndexOf(arg0: any): number;
        getLevel(): Internal.LevelJS;
        contains(arg0: any): boolean;
        size(): number;
        addAll(arg0: number, arg1: Internal.Collection_<Internal.EntityJS_>): boolean;
        addAll(arg0: Internal.Collection_<Internal.EntityJS_>): boolean;
        getDisplayName(): Internal.Text;
        equals(arg0: any): boolean;
        clone(): any;
        listIterator(): Internal.ListIterator<Internal.EntityJS>;
        listIterator(arg0: number): Internal.ListIterator<Internal.EntityJS>;
        toString(): string;
        ensureCapacity(arg0: number): void;
        retainAll(arg0: Internal.Collection_<any>): boolean;
        get world(): Internal.LevelJS;
        get level(): Internal.LevelJS;
        get displayName(): Internal.Text;
        get name(): Internal.Text;
        get class(): Internal.Class<any>;
        get first(): Internal.EntityJS;
        get empty(): boolean;
        set statusMessage(message: Internal.Component_);
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    type EntityArrayList_ = EntityArrayList;
    abstract class QuestObject extends Internal.QuestObjectBase {
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        deleteChildren(): void;
        readNetData(buffer: Internal.FriendlyByteBuf_): void;
        notifyAll(): void;
        getMutableTitle(): Internal.MutableComponent;
        getTags(): Internal.Set<string>;
        static getCodeString(object: Internal.QuestObjectBase_): string;
        getCodeString(): string;
        static getCodeString(id: number): string;
        writeData(nbt: Internal.CompoundTag_): void;
        createSubGroup(group: Internal.ConfigGroup_): Internal.ConfigGroup;
        editedFromGUIOnServer(): void;
        notify(): void;
        forceProgress(teamData: Internal.TeamData_, progressChange: Internal.ProgressChange_): void;
        isCompletedRaw(data: Internal.TeamData_): boolean;
        getTitle(): Internal.Component;
        getRelativeProgressFromChildren(arg0: Internal.TeamData_): number;
        static getRelativeProgressFromChildren(progressSum: number, count: number): number;
        getAltIcon(): Internal.Icon;
        hashCode(): number;
        getObjectType(): Internal.QuestObjectType;
        getPath(): string;
        hasUnclaimedRewardsRaw(teamData: Internal.TeamData_, player: Internal.UUID_): boolean;
        clearCachedData(): void;
        getParentID(): number;
        getProgressColor(data: Internal.TeamData_, dim: boolean): Internal.Color4I;
        getProgressColor(data: Internal.TeamData_): Internal.Color4I;
        editedFromGUI(): void;
        refreshJEI(): number;
        static parseCodeString(id: string): number;
        readData(nbt: Internal.CompoundTag_): void;
        hasTag(tag: string): boolean;
        getQuestChapter(): Internal.Chapter;
        onCompleted(data: Internal.QuestProgressEventData_<any>): void;
        getQuestFile(): Internal.QuestFile;
        static getID(object: Internal.QuestObjectBase_): number;
        isVisible(data: Internal.TeamData_): boolean;
        onEditButtonClicked(gui: Internal.Runnable_): void;
        writeNetData(buffer: Internal.FriendlyByteBuf_): void;
        getConfig(config: Internal.ConfigGroup_): void;
        getIcon(): Internal.Icon;
        getChildren(): Internal.Collection<Internal.QuestObject>;
        forceProgressRaw(teamData: Internal.TeamData_, progressChange: Internal.ProgressChange_): void;
        onStarted(data: Internal.QuestProgressEventData_<any>): void;
        getAltTitle(): Internal.Component;
        static isNull(object: Internal.QuestObjectBase_): boolean;
        equals(object: any): boolean;
        toString(): string;
        deleteSelf(): void;
        onCreated(): void;
        static titleToID(s: string): Internal.Optional<string>;
        cacheProgress(): boolean;
        disableToast : boolean;
        invalid : boolean;
        icon : Internal.ItemStack;
        static sendNotifications : Internal.Tristate;
        id : number;
        title : string;
        get path(): string;
        get children(): Internal.Collection<Internal.QuestObject>;
        get codeString(): string;
        get altTitle(): Internal.Component;
        get questFile(): Internal.QuestFile;
        get class(): Internal.Class<any>;
        get parentID(): number;
        get mutableTitle(): Internal.MutableComponent;
        get tags(): Internal.Set<string>;
        get altIcon(): Internal.Icon;
        get objectType(): Internal.QuestObjectType;
        get questChapter(): Internal.Chapter;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    type QuestObject_ = QuestObject;
    class VillagerType implements Internal.VillagerTypeAccess {
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        hashCode(): number;
        notifyAll(): void;
        equals(arg0: any): boolean;
        toString(): string;
        notify(): void;
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    type VillagerType_ = VillagerType;
    class Color4I extends Internal.Icon {
        redf(): number;
        getClass(): Internal.Class<any>;
        rgba(): number;
        static rgba(col: number): Internal.Color4I;
        static rgba(r: number, g: number, b: number, a: number): Internal.Color4I;
        addBrightness(percent: number): Internal.Color4I;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        withAlpha(a: number): Internal.Color4I;
        static getChatFormattingColor(id: number): Internal.Color4I;
        static getChatFormattingColor(formatting: Internal.ChatFormatting_): Internal.Color4I;
        lerp(col: Internal.Color4I_, m: number): Internal.Color4I;
        notifyAll(): void;
        static rgb(r: number, g: number, b: number): Internal.Color4I;
        rgb(): number;
        static rgb(col: number): Internal.Color4I;
        static rgb(color: Vec3_): Internal.Color4I;
        withTint(col: Internal.Color4I_): Internal.Color4I;
        redi(): number;
        notify(): void;
        createPixelBuffer(): Internal.PixelBuffer;
        hashCode(): number;
        bluei(): number;
        mutable(): Internal.MutableColor4I;
        bluef(): number;
        copy(): Internal.Color4I;
        hasPixelBuffer(): boolean;
        combineWith(icon: Internal.Icon_): Internal.Icon;
        combineWith(icons: Internal.Icon_[]): Internal.Icon;
        getJson(): Internal.JsonElement;
        drawStatic(matrixStack: Internal.PoseStack_, x: number, y: number, w: number, h: number): void;
        withBorder(color: Internal.Color4I_, roundEdges: boolean): Internal.Icon;
        alphaf(): number;
        alphai(): number;
        withColor(color: Internal.Color4I_): Internal.Icon;
        isEmpty(): boolean;
        withUV(x: number, y: number, w: number, h: number, tw: number, th: number): Internal.Icon;
        withUV(u0: number, v0: number, u1: number, v1: number): Internal.Icon;
        draw(matrixStack: Internal.PoseStack_, x: number, y: number, w: number, h: number): void;
        draw3D(matrixStack: Internal.PoseStack_): void;
        whiteIfEmpty(): Internal.Color4I;
        static getIcon(json: Internal.JsonElement_): Internal.Icon;
        static getIcon(id: ResourceLocation_): Internal.Icon;
        static getIcon(id: string): Internal.Icon;
        toStyle(): Internal.Style;
        isMutable(): boolean;
        getIngredient(): any;
        static hsb(h: number, s: number, b: number): Internal.Color4I;
        equals(o: any): boolean;
        withPadding(padding: number): Internal.Icon;
        withAlphaf(alpha: number): Internal.Color4I;
        static fromJson(element: Internal.JsonElement_): Internal.Color4I;
        greenf(): number;
        static get256(id: number): Internal.Color4I;
        toString(): string;
        static fromString(s: string): Internal.Color4I;
        greeni(): number;
        static readonly RED : Internal.Color4I;
        static readonly GRAY : Internal.Color4I;
        static readonly WHITE : Internal.Color4I;
        static readonly LIGHT_RED : Internal.Color4I;
        static readonly BLUE : Internal.Color4I;
        static readonly LIGHT_BLUE : Internal.Color4I;
        static readonly LIGHT_GREEN : Internal.Color4I;
        static readonly BLACK : Internal.Color4I;
        static readonly DARK_GRAY : Internal.Color4I;
        static readonly GREEN : Internal.Color4I;
        static readonly EMPTY : Internal.Color4I;
        get ingredient(): any;
        get json(): Internal.JsonElement;
        get class(): Internal.Class<any>;
        get empty(): boolean;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    type Color4I_ = Color4I;
    class DropTargetDropEvent extends Internal.DropTargetEvent {
        getDropTargetContext(): Internal.DropTargetContext;
        getDropAction(): number;
        getClass(): Internal.Class<any>;
        acceptDrop(arg0: number): void;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        getLocation(): Internal.Point;
        notifyAll(): void;
        dropComplete(arg0: boolean): void;
        notify(): void;
        getSourceActions(): number;
        isLocalTransfer(): boolean;
        getTransferable(): Internal.Transferable;
        getCurrentDataFlavorsAsList(): Internal.List<Internal.DataFlavor>;
        isDataFlavorSupported(arg0: Internal.DataFlavor_): boolean;
        hashCode(): number;
        getSource(): any;
        equals(arg0: any): boolean;
        rejectDrop(): void;
        toString(): string;
        getCurrentDataFlavors(): Internal.DataFlavor[];
        get sourceActions(): number;
        get localTransfer(): boolean;
        get transferable(): Internal.Transferable;
        get location(): Internal.Point;
        get currentDataFlavors(): Internal.DataFlavor[];
        get dropTargetContext(): Internal.DropTargetContext;
        get source(): any;
        get class(): Internal.Class<any>;
        get dropAction(): number;
        get currentDataFlavorsAsList(): Internal.List<Internal.DataFlavor>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    type DropTargetDropEvent_ = DropTargetDropEvent;
    class PlayerStatsJS {
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        getPlayTime(): number;
        getPlayer(): Internal.PlayerJS<any>;
        getWalkDistance(): number;
        getCrouchDistance(): number;
        getDamageAbsorbed(): number;
        notifyAll(): void;
        getDamageDealt_absorbed(): number;
        getItemsPickedUp(item: Internal.Item_): number;
        getFishCaught(): number;
        getDeaths(): number;
        notify(): void;
        getSwimDistance(): number;
        getItemsCrafted(item: Internal.Item_): number;
        getBlocksMined(block: Internal.Block_): number;
        getDamageDealt_resisted(): number;
        getPlayerKills(): number;
        hashCode(): number;
        get(id: ResourceLocation_): number;
        getTimeSinceDeath(): number;
        getDamageBlocked_by_shield(): number;
        getTimeCrouchTime(): number;
        getKilled(entity: Internal.EntityType_<any>): number;
        getDamageTaken(): number;
        add(id: ResourceLocation_, value: number): void;
        getItemsDropped(item: Internal.Item_): number;
        set(id: ResourceLocation_, value: number): void;
        getJumps(): number;
        getDamageResisted(): number;
        getAnimalsBred(): number;
        getItemsBroken(item: Internal.Item_): number;
        getMobKills(): number;
        equals(arg0: any): boolean;
        getSprintDistance(): number;
        getTimeSinceRest(): number;
        getKilledBy(entity: Internal.EntityType_<any>): number;
        toString(): string;
        getDamageDealt(): number;
        getItemsUsed(item: Internal.Item_): number;
        get playerKills(): number;
        get animalsBred(): number;
        get walkDistance(): number;
        get damageDealt_resisted(): number;
        get crouchDistance(): number;
        get damageAbsorbed(): number;
        get damageResisted(): number;
        get jumps(): number;
        get damageDealt_absorbed(): number;
        get timeSinceDeath(): number;
        get timeCrouchTime(): number;
        get damageBlocked_by_shield(): number;
        get fishCaught(): number;
        get mobKills(): number;
        get sprintDistance(): number;
        get timeSinceRest(): number;
        get swimDistance(): number;
        get playTime(): number;
        get class(): Internal.Class<any>;
        get deaths(): number;
        get damageDealt(): number;
        get player(): Internal.PlayerJS<any>;
        get damageTaken(): number;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    type PlayerStatsJS_ = PlayerStatsJS;
    class ImageIcon extends Internal.Icon {
        drawStatic(matrixStack: Internal.PoseStack_, x: number, y: number, w: number, h: number): void;
        getClass(): Internal.Class<any>;
        bindTexture(): void;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        withBorder(color: Internal.Color4I_, roundEdges: boolean): Internal.Icon;
        notifyAll(): void;
        withColor(color: Internal.Color4I_): Internal.ImageIcon;
        isEmpty(): boolean;
        withUV(u0: number, v0: number, u1: number, v1: number): Internal.ImageIcon;
        withUV(x: number, y: number, w: number, h: number, tw: number, th: number): Internal.Icon;
        draw(matrixStack: Internal.PoseStack_, x: number, y: number, w: number, h: number): void;
        withTint(c: Internal.Color4I_): Internal.ImageIcon;
        draw3D(matrixStack: Internal.PoseStack_): void;
        notify(): void;
        static getIcon(json: Internal.JsonElement_): Internal.Icon;
        static getIcon(id: ResourceLocation_): Internal.Icon;
        static getIcon(id: string): Internal.Icon;
        createPixelBuffer(): Internal.PixelBuffer;
        getIngredient(): any;
        hashCode(): number;
        equals(o: any): boolean;
        withPadding(padding: number): Internal.Icon;
        toString(): string;
        copy(): Internal.ImageIcon;
        hasPixelBuffer(): boolean;
        combineWith(icon: Internal.Icon_): Internal.Icon;
        combineWith(icons: Internal.Icon_[]): Internal.Icon;
        getJson(): Internal.JsonElement;
        minU : number;
        maxV : number;
        maxU : number;
        color : Internal.Color4I;
        readonly texture : ResourceLocation;
        static readonly MISSING_IMAGE : ResourceLocation;
        minV : number;
        tileSize : number;
        static readonly EMPTY : Internal.Color4I;
        get ingredient(): any;
        get json(): Internal.JsonElement;
        get class(): Internal.Class<any>;
        get empty(): boolean;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    type ImageIcon_ = ImageIcon;
    class EnumConfig <E> extends Internal.ConfigWithVariants<E> {
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        getName(): string;
        setCanEdit(e: boolean): Internal.ConfigValue<E>;
        notifyAll(): void;
        isEqual(v1: E, v2: E): boolean;
        compareTo(o: Internal.ConfigValue_<E>): number;
        notify(): void;
        getCanEdit(): boolean;
        getTooltip(): string;
        getIteration(v: E, next: boolean): E;
        hashCode(): number;
        getStringForGUI(v: E): Internal.Component;
        getPath(): string;
        copy(value: E): E;
        static info(key: string, value: any): Internal.Component;
        init(g: Internal.ConfigGroup_, i: string, v: E, c: Internal.Consumer_<E>, def: E): Internal.ConfigValue<E>;
        getColor(v: E): Internal.Color4I;
        addInfo(list: Internal.TooltipList_): void;
        getIcon(v: E): Internal.Icon;
        setIcon(i: Internal.Icon_): Internal.ConfigValue<E>;
        setOrder(o: number): Internal.ConfigValue<E>;
        getNameKey(): string;
        setNameKey(key: string): Internal.ConfigValue<E>;
        equals(arg0: any): boolean;
        onClicked(button: Internal.MouseButton_, callback: Internal.ConfigCallback_): void;
        toString(): string;
        setCurrentValue(v: E): boolean;
        readonly nameMap : Internal.NameMap<E>;
        defaultValue : E;
        id : string;
        static readonly NULL_TEXT : Internal.TextComponent;
        setter : ((arg0: E) => void);
        value : E;
        group : Internal.ConfigGroup;
        get path(): string;
        get nameKey(): string;
        get canEdit(): boolean;
        get name(): string;
        get tooltip(): string;
        get class(): Internal.Class<any>;
        set nameKey(key: string);
        set canEdit(e: boolean);
        set icon(i: Internal.Icon_);
        set currentValue(v: E);
        set order(o: number);
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    type EnumConfig_<E> = EnumConfig<E>;
    class StageChangeEvent {
        getStage(): string;
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        getPlayer(): Internal.Player;
        hashCode(): number;
        notifyAll(): void;
        equals(arg0: any): boolean;
        toString(): string;
        notify(): void;
        getPlayerStages(): Internal.Stages;
        get stage(): string;
        get playerStages(): Internal.Stages;
        get class(): Internal.Class<any>;
        get player(): Internal.Player;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    type StageChangeEvent_ = StageChangeEvent;
    interface IGuiTexture {
        updateTick(): void;
        draw(arg0: Internal.PoseStack_, arg1: number, arg2: number, arg3: number, arg4: number, arg5: number, arg6: number): void;
        draw(arg0: Internal.PoseStack_, arg1: number, arg2: number, arg3: number, arg4: number): void;
        drawSubArea(arg0: Internal.PoseStack_, arg1: number, arg2: number, arg3: number, arg4: number, arg5: number, arg6: number, arg7: number, arg8: number): void;
    }
    type IGuiTexture_ = IGuiTexture;
    interface FilterInfo {
        pop(): void;
        add(arg0: Internal.Component_): void;
        push(): void;
    }
    type FilterInfo_ = FilterInfo;
    interface BiFunction <T, U, R> {
        apply(arg0: T, arg1: U): R;
        andThen<V>(arg0: java_.util.function_.Function_<R, V>): Internal.BiFunction<T, U, V>;
    }
    type BiFunction_<T, U, R> = ((arg0: T, arg1: U) => R) | BiFunction<T, U, R>;
    interface FeatureAccess {
    }
    type FeatureAccess_ = FeatureAccess;
    class NetworkInterface {
        getClass(): Internal.Class<any>;
        getInterfaceAddresses(): Internal.List<Internal.InterfaceAddress>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        getName(): string;
        getIndex(): number;
        supportsMulticast(): boolean;
        getSubInterfaces(): Internal.Enumeration<Internal.NetworkInterface>;
        notifyAll(): void;
        inetAddresses(): Internal.Stream<Internal.InetAddress>;
        notify(): void;
        isPointToPoint(): boolean;
        isUp(): boolean;
        hashCode(): number;
        static getByName(arg0: string): Internal.NetworkInterface;
        isLoopback(): boolean;
        subInterfaces(): Internal.Stream<Internal.NetworkInterface>;
        getParent(): Internal.NetworkInterface;
        static getByIndex(arg0: number): Internal.NetworkInterface;
        static getByInetAddress(arg0: Internal.InetAddress_): Internal.NetworkInterface;
        getMTU(): number;
        static networkInterfaces(): Internal.Stream<Internal.NetworkInterface>;
        getDisplayName(): string;
        equals(arg0: any): boolean;
        getHardwareAddress(): number[];
        toString(): string;
        isVirtual(): boolean;
        static getNetworkInterfaces(): Internal.Enumeration<Internal.NetworkInterface>;
        getInetAddresses(): Internal.Enumeration<Internal.InetAddress>;
        get parent(): Internal.NetworkInterface;
        get hardwareAddress(): number[];
        get virtual(): boolean;
        get displayName(): string;
        get pointToPoint(): boolean;
        get interfaceAddresses(): Internal.List<Internal.InterfaceAddress>;
        get name(): string;
        get index(): number;
        get up(): boolean;
        get class(): Internal.Class<any>;
        get loopback(): boolean;
        get mTU(): number;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    type NetworkInterface_ = NetworkInterface;
    abstract class Resolver {
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        hashCode(): number;
        notifyAll(): void;
        equals(arg0: any): boolean;
        static of(arg0: string): Internal.Resolver;
        toString(): string;
        notify(): void;
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    type Resolver_ = Resolver;
    interface Holder <T> extends Internal.IReverseTag<T> {
        getTagKeys(): Internal.Stream<Internal.TagKey<T>>;
        containsTag(arg0: Internal.TagKey_<T>): boolean;
        containsTag(arg0: Internal.ITag_<T>): boolean;
    }
    type Holder_<T> = Holder<T>;
    interface EventExecutor extends Internal.EventExecutorGroup {
        scheduleAtFixedRate(arg0: Internal.Runnable_, arg1: number, arg2: number, arg3: Internal.TimeUnit_): io.netty.util.concurrent.ScheduledFuture<any>;
        scheduleAtFixedRate(arg0: Internal.Runnable_, arg1: number, arg2: number, arg3: Internal.TimeUnit_): Internal.ScheduledFuture<any>;
        next(): Internal.EventExecutor;
        terminationFuture(): io.netty.util.concurrent.Future<any>;
        parent(): Internal.EventExecutorGroup;
        newProgressivePromise<V_>(): Internal.ProgressivePromise<V_>;
        shutdownGracefully(): io.netty.util.concurrent.Future<any>;
        shutdownGracefully(arg0: number, arg1: number, arg2: Internal.TimeUnit_): io.netty.util.concurrent.Future<any>;
        submit<T_>(arg0: Internal.Runnable_, arg1: T_): io.netty.util.concurrent.Future<T_>;
        submit<T_>(arg0: Internal.Runnable_, arg1: T_): Internal.Future<T_>;
        submit<T_>(arg0: java_.util.concurrent.Callable_<T_>): io.netty.util.concurrent.Future<T_>;
        submit<T_>(arg0: java_.util.concurrent.Callable_<T_>): Internal.Future<T_>;
        submit(arg0: Internal.Runnable_): io.netty.util.concurrent.Future<any>;
        submit(arg0: Internal.Runnable_): Internal.Future<any>;
        spliterator(): Internal.Spliterator<Internal.EventExecutor>;
        isTerminated(): boolean;
        forEach(arg0: Internal.Consumer_<Internal.EventExecutor_>): void;
        scheduleWithFixedDelay(arg0: Internal.Runnable_, arg1: number, arg2: number, arg3: Internal.TimeUnit_): io.netty.util.concurrent.ScheduledFuture<any>;
        scheduleWithFixedDelay(arg0: Internal.Runnable_, arg1: number, arg2: number, arg3: Internal.TimeUnit_): Internal.ScheduledFuture<any>;
        invokeAll<T_>(arg0: Internal.Collection_<java_.util.concurrent.Callable_<T_>>): Internal.List<Internal.Future<T_>>;
        invokeAll<T_>(arg0: Internal.Collection_<java_.util.concurrent.Callable_<T_>>, arg1: number, arg2: Internal.TimeUnit_): Internal.List<Internal.Future<T_>>;
        newFailedFuture<V_>(arg0: Internal.Throwable_): io.netty.util.concurrent.Future<V_>;
        execute(arg0: Internal.Runnable_): void;
        inEventLoop(): boolean;
        inEventLoop(arg0: Internal.Thread_): boolean;
        schedule<V_>(arg0: java_.util.concurrent.Callable_<V_>, arg1: number, arg2: Internal.TimeUnit_): io.netty.util.concurrent.ScheduledFuture<V_>;
        schedule<V_>(arg0: java_.util.concurrent.Callable_<V_>, arg1: number, arg2: Internal.TimeUnit_): Internal.ScheduledFuture<V_>;
        schedule(arg0: Internal.Runnable_, arg1: number, arg2: Internal.TimeUnit_): io.netty.util.concurrent.ScheduledFuture<any>;
        schedule(arg0: Internal.Runnable_, arg1: number, arg2: Internal.TimeUnit_): Internal.ScheduledFuture<any>;
        isShuttingDown(): boolean;
        iterator(): Internal.Iterator<Internal.EventExecutor>;
        newSucceededFuture<V_>(arg0: V_): io.netty.util.concurrent.Future<V_>;
        awaitTermination(arg0: number, arg1: Internal.TimeUnit_): boolean;
        invokeAny<T_>(arg0: Internal.Collection_<java_.util.concurrent.Callable_<T_>>, arg1: number, arg2: Internal.TimeUnit_): T_;
        invokeAny<T_>(arg0: Internal.Collection_<java_.util.concurrent.Callable_<T_>>): T_;
        shutdownNow(): Internal.List<Internal.Runnable>;
        shutdown(): void;
        isShutdown(): boolean;
        newPromise<V_>(): Internal.Promise<V_>;
    }
    type EventExecutor_ = EventExecutor;
    class AttributeModifier$Operation extends Internal.Enum<Internal.AttributeModifier$Operation> {
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        static valueOf(arg0: string): Internal.AttributeModifier$Operation;
        static valueOf<T_>(arg0: Internal.Class_<T_>, arg1: string): T_;
        notifyAll(): void;
        static values(): Internal.AttributeModifier$Operation[];
        compareTo(arg0: Internal.AttributeModifier$Operation_): number;
        describeConstable(): Internal.Optional<Internal.Enum$EnumDesc<Internal.AttributeModifier$Operation>>;
        notify(): void;
        getDeclaringClass(): Internal.Class<Internal.AttributeModifier$Operation>;
        hashCode(): number;
        equals(arg0: any): boolean;
        name(): string;
        toString(): string;
        ordinal(): number;
        static readonly ADDITION : Internal.AttributeModifier$Operation;
        static readonly MULTIPLY_BASE : Internal.AttributeModifier$Operation;
        static readonly MULTIPLY_TOTAL : Internal.AttributeModifier$Operation;
        get class(): Internal.Class<any>;
        get declaringClass(): Internal.Class<Internal.AttributeModifier$Operation>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    type AttributeModifier$Operation_ = "multiply_base" | "multiply_total" | "addition" | AttributeModifier$Operation;
    abstract class ComponentTileEntity <T> extends Internal.BlockEntity implements Internal.IInnerCapabilityProvider, Internal.IUIHolder, Internal.IComponent {
        setRendererObject(arg0: any): void;
        getDefinition(): Internal.CompoundTag;
        getClass(): Internal.Class<any>;
        getLocation(): ResourceLocation;
        getCapability<K_>(arg0: Internal.Capability_<K_>, arg1: Internal.Direction_): Internal.LazyOptional<K_>;
        getCapability<T_>(arg0: Internal.Capability_<T_>): Internal.LazyOptional<T_>;
        use(arg0: Internal.Player_, arg1: Hand_, arg2: Internal.BlockHitResult_): Internal.InteractionResult;
        getStatus(): string;
        getOwner(): Internal.Player;
        getSubID(): string;
        getUnlocalizedName(): string;
        setOwner(arg0: Internal.UUID_): void;
        setOwner(arg0: Internal.Player_): void;
        createUI(arg0: Internal.Player_): Internal.ModularUI;
        getUpdatePacket(): Internal.ClientboundBlockEntityDataPacket;
        invalidateCaps(): void;
        serializeNBT(): Internal.CompoundTag;
        receiveCustomData(arg0: number, arg1: Internal.FriendlyByteBuf_): void;
        getLocalizedName(): string;
        onChunkUnloaded(): void;
        getRenderBoundingBox(): Internal.AABB;
        onDataPacket(arg0: Internal.Connection_, arg1: Internal.ClientboundBlockEntityDataPacket_): void;
        onNeighborChange(): void;
        requestModelDataUpdate(): void;
        isFormed(): boolean;
        getTileData(): Internal.CompoundTag;
        updateCurrentRenderer(): Internal.IMultiblockedRenderer;
        areCapsCompatible(arg0: Internal.CapabilityProvider_<Internal.BlockEntity_>): boolean;
        areCapsCompatible(arg0: Internal.CapabilityDispatcher_): boolean;
        isInvalid(): boolean;
        rotateTo(arg0: Internal.Rotation_): void;
        reviveCaps(): void;
        getModelData(): Internal.IModelData;
        notifyBlockUpdate(): void;
        getRendererObject(): any;
        writeTraitData(arg0: Internal.CapabilityTrait_, arg1: number, arg2: Internal.Consumer_<Internal.FriendlyByteBuf_>): void;
        onDrops(arg0: Internal.NonNullList_<Internal.ItemStack_>, arg1: Internal.Player_): void;
        needAlwaysUpdate(): boolean;
        getTimer(): number;
        writeInitialSyncData(arg0: Internal.FriendlyByteBuf_): void;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        getOwnerUUID(): Internal.UUID;
        writeCustomData(arg0: number, arg1: Internal.Consumer_<Internal.FriendlyByteBuf_>): void;
        notifyAll(): void;
        getOffset(): number;
        update(): void;
        getOutputRedstoneSignal(arg0: Internal.Direction_): number;
        notify(): void;
        getFrontFacing(): Internal.Direction;
        hashCode(): number;
        getInnerCapability<K_>(arg0: Internal.Capability_<K_>, arg1: Internal.Direction_): Internal.LazyOptional<K_>;
        hasTrait(arg0: Internal.MultiblockCapability_<any>): boolean;
        markAsDirty(): void;
        handleUpdateTag(arg0: Internal.CompoundTag_): void;
        isValidFrontFacing(arg0: Internal.Direction_): boolean;
        getRenderer(): Internal.IMultiblockedRenderer;
        isRemote(): boolean;
        setFrontFacing(arg0: Internal.Direction_): void;
        deserializeNBT(arg0: Internal.CompoundTag_): void;
        getTrait(arg0: Internal.MultiblockCapability_<any>): Internal.CapabilityTrait;
        setStatus(arg0: string): void;
        scheduleChunkForRenderUpdate(): void;
        equals(arg0: any): boolean;
        canConnectRedstone(arg0: Internal.Direction_): boolean;
        self(): Internal.BlockEntity;
        onLoad(): void;
        toString(): string;
        receiveInitialSyncData(arg0: Internal.FriendlyByteBuf_): void;
        static readonly INFINITE_EXTENT_AABB : Internal.AABB;
        rendererObject : any;
        persistedData : net.minecraft.nbt.Tag;
        static readonly EMPTY : Internal.IUIHolder;
        get owner(): Internal.Player;
        get localizedName(): string;
        get renderer(): Internal.IMultiblockedRenderer;
        get ownerUUID(): Internal.UUID;
        get offset(): number;
        get renderBoundingBox(): Internal.AABB;
        get tileData(): Internal.CompoundTag;
        get remote(): boolean;
        get frontFacing(): Internal.Direction;
        get subID(): string;
        get timer(): number;
        get updatePacket(): Internal.ClientboundBlockEntityDataPacket;
        get modelData(): Internal.IModelData;
        get unlocalizedName(): string;
        get invalid(): boolean;
        get definition(): Internal.CompoundTag;
        get location(): ResourceLocation;
        get formed(): boolean;
        get class(): Internal.Class<any>;
        get status(): string;
        set owner(arg0: Internal.Player_);
        set status(arg0: string);
        set frontFacing(arg0: Internal.Direction_);
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    type ComponentTileEntity_<T> = ComponentTileEntity<T>;
    interface IdMap <T> extends Internal.Iterable<T> {
        iterator(): Internal.Iterator<T>;
        spliterator(): Internal.Spliterator<T>;
        forEach(arg0: Internal.Consumer_<T>): void;
    }
    type IdMap_<T> = IdMap<T>;
    interface ImageObserver {
        imageUpdate(arg0: Internal.Image_, arg1: number, arg2: number, arg3: number, arg4: number, arg5: number): boolean;
    }
    type ImageObserver_ = ImageObserver;
    interface TriPredicate <T, U, V> {
        or(arg0: Internal.TriPredicate_<T, U, V>): Internal.TriPredicate<T, U, V>;
        test(arg0: T, arg1: U, arg2: V): boolean;
        and(arg0: Internal.TriPredicate_<T, U, V>): Internal.TriPredicate<T, U, V>;
        negate(): Internal.TriPredicate<T, U, V>;
    }
    type TriPredicate_<T, U, V> = ((arg0: T, arg1: U, arg2: V) => boolean) | TriPredicate<T, U, V>;
    class MutableUnit extends dev.latvian.mods.rhino.util.unit.Unit {
        getClass(): Internal.Class<any>;
        mod(with_: dev.latvian.mods.rhino.util.unit.Unit_): dev.latvian.mods.rhino.util.unit.Unit;
        log1p(): dev.latvian.mods.rhino.util.unit.Unit;
        cos(): dev.latvian.mods.rhino.util.unit.Unit;
        deg(): dev.latvian.mods.rhino.util.unit.Unit;
        lt(with_: dev.latvian.mods.rhino.util.unit.Unit_): dev.latvian.mods.rhino.util.unit.Unit;
        atan(): dev.latvian.mods.rhino.util.unit.Unit;
        getAsInt(): number;
        div(with_: dev.latvian.mods.rhino.util.unit.Unit_): dev.latvian.mods.rhino.util.unit.Unit;
        neg(): dev.latvian.mods.rhino.util.unit.Unit;
        shiftLeft(with_: dev.latvian.mods.rhino.util.unit.Unit_): dev.latvian.mods.rhino.util.unit.Unit;
        rad(): dev.latvian.mods.rhino.util.unit.Unit;
        sqrt(): dev.latvian.mods.rhino.util.unit.Unit;
        gte(with_: dev.latvian.mods.rhino.util.unit.Unit_): dev.latvian.mods.rhino.util.unit.Unit;
        neq(with_: dev.latvian.mods.rhino.util.unit.Unit_): dev.latvian.mods.rhino.util.unit.Unit;
        atan2(with_: dev.latvian.mods.rhino.util.unit.Unit_): dev.latvian.mods.rhino.util.unit.Unit;
        tan(): dev.latvian.mods.rhino.util.unit.Unit;
        add(with_: dev.latvian.mods.rhino.util.unit.Unit_): dev.latvian.mods.rhino.util.unit.Unit;
        toBool(): dev.latvian.mods.rhino.util.unit.Unit;
        ceil(): dev.latvian.mods.rhino.util.unit.Unit;
        eq(with_: dev.latvian.mods.rhino.util.unit.Unit_): dev.latvian.mods.rhino.util.unit.Unit;
        shiftRight(with_: dev.latvian.mods.rhino.util.unit.Unit_): dev.latvian.mods.rhino.util.unit.Unit;
        sub(with_: dev.latvian.mods.rhino.util.unit.Unit_): dev.latvian.mods.rhino.util.unit.Unit;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        mul(with_: dev.latvian.mods.rhino.util.unit.Unit_): dev.latvian.mods.rhino.util.unit.Unit;
        log(): dev.latvian.mods.rhino.util.unit.Unit;
        log10(): dev.latvian.mods.rhino.util.unit.Unit;
        notifyAll(): void;
        notify(): void;
        not(): dev.latvian.mods.rhino.util.unit.Unit;
        min(with_: dev.latvian.mods.rhino.util.unit.Unit_): dev.latvian.mods.rhino.util.unit.Unit;
        hashCode(): number;
        and(with_: dev.latvian.mods.rhino.util.unit.Unit_): dev.latvian.mods.rhino.util.unit.Unit;
        get(): number;
        pow(with_: dev.latvian.mods.rhino.util.unit.Unit_): dev.latvian.mods.rhino.util.unit.Unit;
        sin(): dev.latvian.mods.rhino.util.unit.Unit;
        xor(with_: dev.latvian.mods.rhino.util.unit.Unit_): dev.latvian.mods.rhino.util.unit.Unit;
        lte(with_: dev.latvian.mods.rhino.util.unit.Unit_): dev.latvian.mods.rhino.util.unit.Unit;
        floor(): dev.latvian.mods.rhino.util.unit.Unit;
        isFixed(): boolean;
        sq(): dev.latvian.mods.rhino.util.unit.Unit;
        or(with_: dev.latvian.mods.rhino.util.unit.Unit_): dev.latvian.mods.rhino.util.unit.Unit;
        set(v: number): void;
        max(with_: dev.latvian.mods.rhino.util.unit.Unit_): dev.latvian.mods.rhino.util.unit.Unit;
        gt(with_: dev.latvian.mods.rhino.util.unit.Unit_): dev.latvian.mods.rhino.util.unit.Unit;
        abs(): dev.latvian.mods.rhino.util.unit.Unit;
        getAsBoolean(): boolean;
        equals(arg0: any): boolean;
        toString(): string;
        append(sb: Internal.StringBuilder_): void;
        get asInt(): number;
        get fixed(): boolean;
        get class(): Internal.Class<any>;
        get asBoolean(): boolean;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    type MutableUnit_ = MutableUnit;
    class AccessibleRole extends Internal.AccessibleBundle {
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        toDisplayString(): string;
        toDisplayString(arg0: Internal.Locale_): string;
        hashCode(): number;
        notifyAll(): void;
        equals(arg0: any): boolean;
        toString(): string;
        notify(): void;
        static readonly DATE_EDITOR : Internal.AccessibleRole;
        static readonly PARAGRAPH : Internal.AccessibleRole;
        static readonly TEXT : Internal.AccessibleRole;
        static readonly ALERT : Internal.AccessibleRole;
        static readonly FONT_CHOOSER : Internal.AccessibleRole;
        static readonly GROUP_BOX : Internal.AccessibleRole;
        static readonly ROOT_PANE : Internal.AccessibleRole;
        static readonly TABLE : Internal.AccessibleRole;
        static readonly COMBO_BOX : Internal.AccessibleRole;
        static readonly SLIDER : Internal.AccessibleRole;
        static readonly PROGRESS_MONITOR : Internal.AccessibleRole;
        static readonly HYPERLINK : Internal.AccessibleRole;
        static readonly LABEL : Internal.AccessibleRole;
        static readonly PROGRESS_BAR : Internal.AccessibleRole;
        static readonly DESKTOP_ICON : Internal.AccessibleRole;
        static readonly SEPARATOR : Internal.AccessibleRole;
        static readonly MENU_ITEM : Internal.AccessibleRole;
        static readonly SCROLL_PANE : Internal.AccessibleRole;
        static readonly AWT_COMPONENT : Internal.AccessibleRole;
        static readonly MENU_BAR : Internal.AccessibleRole;
        static readonly PUSH_BUTTON : Internal.AccessibleRole;
        static readonly PAGE_TAB : Internal.AccessibleRole;
        static readonly CHECK_BOX : Internal.AccessibleRole;
        static readonly TREE : Internal.AccessibleRole;
        static readonly PASSWORD_TEXT : Internal.AccessibleRole;
        static readonly LIST : Internal.AccessibleRole;
        static readonly HTML_CONTAINER : Internal.AccessibleRole;
        static readonly OPTION_PANE : Internal.AccessibleRole;
        static readonly DESKTOP_PANE : Internal.AccessibleRole;
        static readonly HEADER : Internal.AccessibleRole;
        static readonly FRAME : Internal.AccessibleRole;
        static readonly TOOL_TIP : Internal.AccessibleRole;
        static readonly ROW_HEADER : Internal.AccessibleRole;
        static readonly SPIN_BOX : Internal.AccessibleRole;
        static readonly CANVAS : Internal.AccessibleRole;
        static readonly TOOL_BAR : Internal.AccessibleRole;
        static readonly INTERNAL_FRAME : Internal.AccessibleRole;
        static readonly LAYERED_PANE : Internal.AccessibleRole;
        static readonly PAGE_TAB_LIST : Internal.AccessibleRole;
        static readonly COLUMN_HEADER : Internal.AccessibleRole;
        static readonly ICON : Internal.AccessibleRole;
        static readonly COLOR_CHOOSER : Internal.AccessibleRole;
        static readonly VIEWPORT : Internal.AccessibleRole;
        static readonly PANEL : Internal.AccessibleRole;
        static readonly DIRECTORY_PANE : Internal.AccessibleRole;
        static readonly STATUS_BAR : Internal.AccessibleRole;
        static readonly DIALOG : Internal.AccessibleRole;
        static readonly SPLIT_PANE : Internal.AccessibleRole;
        static readonly GLASS_PANE : Internal.AccessibleRole;
        static readonly SWING_COMPONENT : Internal.AccessibleRole;
        static readonly FOOTER : Internal.AccessibleRole;
        static readonly EDITBAR : Internal.AccessibleRole;
        static readonly FILLER : Internal.AccessibleRole;
        static readonly WINDOW : Internal.AccessibleRole;
        static readonly FILE_CHOOSER : Internal.AccessibleRole;
        static readonly POPUP_MENU : Internal.AccessibleRole;
        static readonly SCROLL_BAR : Internal.AccessibleRole;
        static readonly LIST_ITEM : Internal.AccessibleRole;
        static readonly RADIO_BUTTON : Internal.AccessibleRole;
        static readonly MENU : Internal.AccessibleRole;
        static readonly UNKNOWN : Internal.AccessibleRole;
        static readonly RULER : Internal.AccessibleRole;
        static readonly TOGGLE_BUTTON : Internal.AccessibleRole;
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    type AccessibleRole_ = AccessibleRole;
    class Byte2DoubleOpenHashMap extends Internal.AbstractByte2DoubleMap implements Internal.Serializable, Internal.Cloneable, Internal.Hash {
        getClass(): Internal.Class<any>;
        getOrDefault(arg0: number, arg1: number): number;
        getOrDefault(arg0: any, arg1: number): number;
        applyAsDouble(arg0: number): number;
        replace(arg0: number, arg1: number, arg2: number): boolean;
        replace(arg0: number, arg1: number): number;
        composeByte(arg0: Internal.Byte2ByteFunction_): Internal.Byte2DoubleFunction;
        composeReference<T_>(arg0: Internal.Reference2ByteFunction_<T_>): Internal.Reference2DoubleFunction<T_>;
        andThen<T_>(arg0: java_.util.function_.Function_<number, T_>): java_.util.function_.Function<number, T_>;
        containsValue(arg0: number): boolean;
        containsValue(arg0: any): boolean;
        put(arg0: number, arg1: number): number;
        compute(arg0: number, arg1: Internal.BiFunction_<number, number, number>): number;
        defaultReturnValue(arg0: number): void;
        defaultReturnValue(): number;
        andThenObject<T_>(arg0: Internal.Double2ObjectFunction_<T_>): Internal.Byte2ObjectFunction<T_>;
        trim(): boolean;
        trim(arg0: number): boolean;
        merge(arg0: number, arg1: number, arg2: Internal.BiFunction_<number, number, number>): number;
        composeLong(arg0: Internal.Long2ByteFunction_): Internal.Long2DoubleFunction;
        entrySet(): Internal.ObjectSet<Internal.Map$Entry<number, number>>;
        containsKey(arg0: number): boolean;
        containsKey(arg0: any): boolean;
        composeObject<T_>(arg0: Internal.Object2ByteFunction_<T_>): Internal.Object2DoubleFunction<T_>;
        size(): number;
        compose<T_>(arg0: java_.util.function_.Function_<T_, number>): java_.util.function_.Function<T_, number>;
        composeShort(arg0: Internal.Short2ByteFunction_): Internal.Short2DoubleFunction;
        mergeDouble(arg0: number, arg1: number, arg2: it.unimi.dsi.fastutil.doubles.DoubleBinaryOperator_): number;
        mergeDouble(arg0: number, arg1: number, arg2: Internal.DoubleBinaryOperator_): number;
        composeChar(arg0: Internal.Char2ByteFunction_): Internal.Char2DoubleFunction;
        composeDouble(arg0: Internal.Double2ByteFunction_): Internal.Double2DoubleFunction;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        byte2DoubleEntrySet(): Internal.Byte2DoubleMap$FastEntrySet;
        notifyAll(): void;
        computeIfAbsent(arg0: number, arg1: Internal.IntToDoubleFunction_): number;
        computeIfAbsent(arg0: number, arg1: Internal.Byte2DoubleFunction_): number;
        computeIfAbsent(arg0: number, arg1: java_.util.function_.Function_<number, number>): number;
        values(): Internal.DoubleCollection;
        andThenShort(arg0: Internal.Double2ShortFunction_): Internal.Byte2ShortFunction;
        computeIfAbsentPartial(arg0: number, arg1: Internal.Byte2DoubleFunction_): number;
        replaceAll(arg0: Internal.BiFunction_<number, number, number>): void;
        andThenInt(arg0: Internal.Double2IntFunction_): Internal.Byte2IntFunction;
        notify(): void;
        remove(arg0: number, arg1: number): boolean;
        remove(arg0: number): number;
        remove(arg0: any): number;
        remove(arg0: any, arg1: any): boolean;
        andThenDouble(arg0: Internal.Double2DoubleFunction_): Internal.Byte2DoubleFunction;
        hashCode(): number;
        putAll(arg0: Internal.Map_<number, number>): void;
        get(arg0: number): number;
        get(arg0: any): number;
        andThenLong(arg0: Internal.Double2LongFunction_): Internal.Byte2LongFunction;
        keySet(): Internal.ByteSet;
        andThenByte(arg0: Internal.Double2ByteFunction_): Internal.Byte2ByteFunction;
        andThenFloat(arg0: Internal.Double2FloatFunction_): Internal.Byte2FloatFunction;
        apply(arg0: number): number;
        computeIfAbsentNullable(arg0: number, arg1: Internal.IntFunction_<number>): number;
        forEach(arg0: Internal.BiConsumer_<number, number>): void;
        composeInt(arg0: Internal.Int2ByteFunction_): Internal.Int2DoubleFunction;
        isEmpty(): boolean;
        clear(): void;
        composeFloat(arg0: Internal.Float2ByteFunction_): Internal.Float2DoubleFunction;
        andThenChar(arg0: Internal.Double2CharFunction_): Internal.Byte2CharFunction;
        computeIfPresent(arg0: number, arg1: Internal.BiFunction_<number, number, number>): number;
        equals(arg0: any): boolean;
        andThenReference<T_>(arg0: Internal.Double2ReferenceFunction_<T_>): Internal.Byte2ReferenceFunction<T_>;
        clone(): Internal.Byte2DoubleOpenHashMap;
        addTo(arg0: number, arg1: number): number;
        toString(): string;
        putIfAbsent(arg0: number, arg1: number): number;
        static readonly DEFAULT_GROWTH_FACTOR : 16;
        static readonly FAST_LOAD_FACTOR : 0.5;
        static readonly DEFAULT_INITIAL_SIZE : 16;
        static readonly DEFAULT_LOAD_FACTOR : 0.75;
        static readonly OCCUPIED : -1;
        static readonly VERY_FAST_LOAD_FACTOR : 0.25;
        static readonly FREE : 0;
        static readonly PRIMES : number[];
        static readonly REMOVED : 1;
        get class(): Internal.Class<any>;
        get empty(): boolean;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    type Byte2DoubleOpenHashMap_ = Byte2DoubleOpenHashMap;
    class ClientboundBlockEntityDataPacket implements Internal.Packet<any> {
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        hashCode(): number;
        notifyAll(): void;
        equals(arg0: any): boolean;
        toString(): string;
        notify(): void;
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    type ClientboundBlockEntityDataPacket_ = ClientboundBlockEntityDataPacket;
    class MouseEvent extends Internal.InputEvent {
        getClass(): Internal.Class<any>;
        setSource(arg0: any): void;
        translatePoint(arg0: number, arg1: number): void;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        getLocationOnScreen(): Internal.Point;
        notifyAll(): void;
        isMetaDown(): boolean;
        consume(): void;
        getModifiersEx(): number;
        notify(): void;
        isPopupTrigger(): boolean;
        isShiftDown(): boolean;
        getButton(): number;
        paramString(): string;
        isConsumed(): boolean;
        static getModifiersExText(arg0: number): string;
        hashCode(): number;
        isAltGraphDown(): boolean;
        static getMaskForButton(arg0: number): number;
        getModifiers(): number;
        isAltDown(): boolean;
        getPoint(): Internal.Point;
        static getMouseModifiersText(arg0: number): string;
        isControlDown(): boolean;
        getID(): number;
        getX(): number;
        getY(): number;
        getYOnScreen(): number;
        getSource(): any;
        equals(arg0: any): boolean;
        getWhen(): number;
        getClickCount(): number;
        toString(): string;
        getComponent(): java_.awt.Component;
        getXOnScreen(): number;
        static readonly ADJUSTMENT_EVENT_MASK : 256;
        static readonly MOUSE_FIRST : 500;
        static readonly BUTTON1_MASK : 16;
        static readonly MOUSE_PRESSED : 501;
        static readonly FOCUS_EVENT_MASK : 4;
        static readonly INVOCATION_EVENT_MASK : 16384;
        static readonly RESERVED_ID_MAX : 1999;
        static readonly BUTTON1 : 1;
        static readonly BUTTON2_MASK : 8;
        static readonly CONTAINER_EVENT_MASK : 2;
        static readonly MOUSE_WHEEL_EVENT_MASK : 131072;
        static readonly ALT_DOWN_MASK : 512;
        static readonly MOUSE_MOTION_EVENT_MASK : 32;
        static readonly BUTTON1_DOWN_MASK : 1024;
        static readonly COMPONENT_SHOWN : 102;
        static readonly MOUSE_LAST : 507;
        static readonly META_DOWN_MASK : 256;
        static readonly BUTTON3_DOWN_MASK : 4096;
        static readonly TEXT_EVENT_MASK : 1024;
        static readonly NOBUTTON : 0;
        static readonly COMPONENT_RESIZED : 101;
        static readonly MOUSE_EVENT_MASK : 16;
        static readonly MOUSE_WHEEL : 507;
        static readonly COMPONENT_EVENT_MASK : 1;
        static readonly PAINT_EVENT_MASK : 8192;
        static readonly SHIFT_MASK : 1;
        static readonly COMPONENT_HIDDEN : 103;
        static readonly INPUT_METHOD_EVENT_MASK : 2048;
        static readonly HIERARCHY_BOUNDS_EVENT_MASK : 65536;
        static readonly COMPONENT_LAST : 103;
        static readonly ALT_GRAPH_MASK : 32;
        static readonly KEY_EVENT_MASK : 8;
        static readonly WINDOW_EVENT_MASK : 64;
        static readonly MOUSE_EXITED : 505;
        static readonly CTRL_MASK : 2;
        static readonly ALT_MASK : 8;
        static readonly MOUSE_CLICKED : 500;
        static readonly COMPONENT_FIRST : 100;
        static readonly WINDOW_FOCUS_EVENT_MASK : 524288;
        static readonly MOUSE_MOVED : 503;
        static readonly COMPONENT_MOVED : 100;
        static readonly SHIFT_DOWN_MASK : 64;
        static readonly CTRL_DOWN_MASK : 128;
        static readonly BUTTON2 : 2;
        static readonly BUTTON3 : 3;
        static readonly BUTTON2_DOWN_MASK : 2048;
        static readonly ALT_GRAPH_DOWN_MASK : 8192;
        static readonly ACTION_EVENT_MASK : 128;
        static readonly ITEM_EVENT_MASK : 512;
        static readonly MOUSE_RELEASED : 502;
        static readonly BUTTON3_MASK : 4;
        static readonly HIERARCHY_EVENT_MASK : 32768;
        static readonly WINDOW_STATE_EVENT_MASK : 262144;
        static readonly META_MASK : 4;
        static readonly MOUSE_ENTERED : 504;
        static readonly MOUSE_DRAGGED : 506;
        get consumed(): boolean;
        get altDown(): boolean;
        get controlDown(): boolean;
        get clickCount(): number;
        get yOnScreen(): number;
        get xOnScreen(): number;
        get source(): any;
        get modifiers(): number;
        get when(): number;
        get point(): Internal.Point;
        get altGraphDown(): boolean;
        get button(): number;
        get component(): java_.awt.Component;
        get modifiersEx(): number;
        get shiftDown(): boolean;
        get popupTrigger(): boolean;
        get locationOnScreen(): Internal.Point;
        get metaDown(): boolean;
        get x(): number;
        get y(): number;
        get iD(): number;
        get class(): Internal.Class<any>;
        set source(arg0: any);
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    type MouseEvent_ = MouseEvent;
    class BlockPlaceContext extends Internal.UseOnContext {
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        hashCode(): number;
        notifyAll(): void;
        equals(arg0: any): boolean;
        toString(): string;
        notify(): void;
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    type BlockPlaceContext_ = BlockPlaceContext;
    class JobAttributes$SidesType extends Internal.AttributeValue {
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        notifyAll(): void;
        equals(arg0: any): boolean;
        notify(): void;
        static readonly TWO_SIDED_SHORT_EDGE : Internal.JobAttributes$SidesType;
        static readonly TWO_SIDED_LONG_EDGE : Internal.JobAttributes$SidesType;
        static readonly ONE_SIDED : Internal.JobAttributes$SidesType;
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    type JobAttributes$SidesType_ = JobAttributes$SidesType;
    interface ForgeAccessorRegistry {
    }
    type ForgeAccessorRegistry_ = ForgeAccessorRegistry;
    class ClientPlayerJS extends Internal.PlayerJS<Internal.Player> {
        getXpLevel(): number;
        getLastAttackedEntity(): Internal.LivingEntityJS;
        setY(y: number): void;
        setX(x: number): void;
        isOnScoreboardTeam(teamID: string): boolean;
        isLiving(): boolean;
        isSprinting(): boolean;
        getItem(): Internal.ItemStackJS;
        paint(tag: Internal.CompoundTag_): void;
        getOffHandItem(): Internal.ItemStackJS;
        setGlowing(glowing: boolean): void;
        setZ(z: number): void;
        setXpLevel(l: number): void;
        getHasCustomName(): boolean;
        runCommandSilent(command: string): number;
        setSelectedSlot(index: number): void;
        getDistanceSq(pos: BlockPos_): number;
        getDistanceSq(x: number, y: number, z: number): number;
        isBoss(): boolean;
        setMovementSpeedAddition(speed: number): void;
        isGlowing(): boolean;
        getHorizontalFacing(): Internal.Direction;
        setLegsArmorItem(item: Internal.ItemStackJS_): void;
        setMotion(x: number, y: number, z: number): void;
        getProfile(): Internal.GameProfile;
        setRotation(yaw: number, pitch: number): void;
        isMiningBlock(): boolean;
        setAbsorptionAmount(amount: number): void;
        isOnSameTeam(e: Internal.EntityJS_): boolean;
        isAnimal(): boolean;
        getType(): string;
        setCustomNameAlwaysVisible(b: boolean): void;
        addMotion(x: number, y: number, z: number): void;
        isFake(): boolean;
        isSelf(): boolean;
        getFallDistance(): number;
        damageHeldItem(hand: Hand_, amount: number): void;
        damageHeldItem(hand: Hand_, amount: number, onBroken: Internal.Consumer_<Internal.ItemStackJS_>): void;
        damageHeldItem(): void;
        setOnFire(seconds: number): void;
        attack(source: string, hp: number): void;
        attack(hp: number): void;
        isUndead(): boolean;
        getInventory(): Internal.InventoryJS;
        getDistance(x: number, y: number, z: number): number;
        getDistance(pos: BlockPos_): number;
        getReachDistance(): number;
        getCustomName(): Internal.Text;
        getStepHeight(): number;
        getDefaultMovementSpeed(): number;
        getRidingEntity(): Internal.EntityJS;
        setPositionAndRotation(x: number, y: number, z: number, yaw: number, pitch: number): void;
        getLastAttackedEntityTime(): number;
        isMonster(): boolean;
        addItemCooldown(item: Internal.Item_, ticks: number): void;
        setPitch(pitch: number): void;
        getFacing(): Internal.Direction;
        isOnGround(): boolean;
        toString(): string;
        isSilent(): boolean;
        setXp(xp: number): void;
        getMaxAirSupply(): number;
        getName(): Internal.Text;
        getFeetArmorItem(): Internal.ItemStackJS;
        setStepHeight(stepHeight: number): void;
        isWaterCreature(): boolean;
        setPosition(x: number, y: number, z: number): void;
        setPosition(block: Internal.BlockContainerJS_): void;
        closeInventory(): void;
        extinguish(): void;
        setInvulnerable(invulnerable: boolean): void;
        setMovementSpeed(speed: number): void;
        isChild(): boolean;
        setDefaultMovementSpeed(speed: number): void;
        setEquipment(slot: EquipmentSlot_, item: Internal.ItemStackJS_): void;
        giveInHand(item: Internal.ItemStackJS_): void;
        getLegsArmorItem(): Internal.ItemStackJS;
        isCreativeMode(): boolean;
        getFullNBT(): Internal.CompoundTag;
        getNoClip(): boolean;
        setYaw(yaw: number): void;
        getYaw(): number;
        getTotalMovementSpeed(): number;
        setNoGravity(noGravity: boolean): void;
        setHeldItem(hand: Hand_, item: Internal.ItemStackJS_): void;
        getRevengeTimer(): number;
        notifyAll(): void;
        getId(): Internal.UUID;
        addXPLevels(l: number): void;
        getOpenInventory(): Internal.AbstractContainerMenu;
        hashCode(): number;
        getChestArmorItem(): Internal.ItemStackJS;
        isFrame(): boolean;
        startRiding(e: Internal.EntityJS_, force: boolean): boolean;
        runCommand(command: string): number;
        setChestArmorItem(item: Internal.ItemStackJS_): void;
        getCustomNameAlwaysVisible(): boolean;
        removeAttribute(attribute: Internal.Attribute_, identifier: string): void;
        addXP(xp: number): void;
        getMainHandItem(): Internal.ItemStackJS;
        setHealth(hp: number): void;
        getBlock(): Internal.BlockContainerJS;
        isElytraFlying(): boolean;
        isInWater(): boolean;
        dismountRidingEntity(): void;
        isSleeping(): boolean;
        swingArm(hand: Hand_): void;
        getPotionEffects(): Internal.EntityPotionEffectsJS;
        isInvulnerable(): boolean;
        setHeadArmorItem(item: Internal.ItemStackJS_): void;
        isPeacefulCreature(): boolean;
        getMouseItem(): Internal.ItemStackJS;
        getMotionZ(): number;
        getMotionX(): number;
        getMotionY(): number;
        sendData(channel: string, data: Internal.CompoundTag_): void;
        getRevengeTarget(): Internal.LivingEntityJS;
        getTags(): Internal.Set<string>;
        setInvisible(invisible: boolean): void;
        getIdleTime(): number;
        getMovementSpeed(): number;
        setDefaultMovementSpeedMultiplier(speed: number): void;
        addFood(f: number, m: number): void;
        getHealth(): number;
        getServer(): Internal.ServerJS;
        setFeetArmorItem(item: Internal.ItemStackJS_): void;
        getAttributeBaseValue(attribute: Internal.Attribute_): number;
        give(item: Internal.ItemStackJS_): void;
        setMaxHealth(hp: number): void;
        isSpectator(): boolean;
        getDisplayName(): Internal.Text;
        getXp(): number;
        addExhaustion(exhaustion: number): void;
        setOffHandItem(item: Internal.ItemStackJS_): void;
        getFoodLevel(): number;
        isInvisible(): boolean;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        getMaxHealth(): number;
        isUnderWater(): boolean;
        getHeldItem(hand: Hand_): Internal.ItemStackJS;
        getEyeHeight(): number;
        getEquipment(slot: EquipmentSlot_): Internal.ItemStackJS;
        notify(): void;
        setAirSupply(air: number): void;
        setTotalMovementSpeedMultiplier(speed: number): void;
        removePassengers(): void;
        isOnLadder(): boolean;
        playSound(id: Internal.SoundEvent_, volume: number, pitch: number): void;
        playSound(id: Internal.SoundEvent_): void;
        boostElytraFlight(): void;
        getData(): Internal.AttachedData;
        getLastDamageSource(): Internal.DamageSource;
        setStatusMessage(message: Internal.Component_): void;
        isSwimming(): boolean;
        mergeFullNBT(tag: Internal.CompoundTag_): Internal.EntityJS;
        kill(): void;
        getLevel(): Internal.LevelJS;
        getPitch(): number;
        getPassengers(): Internal.EntityArrayList;
        equals(arg0: any): boolean;
        isPassenger(e: Internal.EntityJS_): boolean;
        getClass(): Internal.Class<any>;
        getRecursivePassengers(): Internal.EntityArrayList;
        getNbt(): Internal.CompoundTag;
        setFallDistance(fallDistance: number): void;
        sendInventoryUpdate(): void;
        setCustomName(name: Internal.Component_): void;
        setMainHandItem(item: Internal.ItemStackJS_): void;
        tell(message: Internal.Component_): void;
        getTeamId(): string;
        setNoClip(noClip: boolean): void;
        getAttributeTotalValue(attribute: Internal.Attribute_): number;
        setRevengeTarget(target: Internal.LivingEntityJS_): void;
        getAirSupply(): number;
        setFullNBT(nbt: Internal.CompoundTag_): void;
        getAttackingEntity(): Internal.LivingEntityJS;
        isHoldingInAnyHand(ingredient: any): boolean;
        damageEquipment(slot: EquipmentSlot_): void;
        damageEquipment(slot: EquipmentSlot_, amount: number, onBroken: Internal.Consumer_<Internal.ItemStackJS_>): void;
        damageEquipment(slot: EquipmentSlot_, amount: number): void;
        isAlive(): boolean;
        modifyAttribute(attribute: Internal.Attribute_, identifier: string, d: number, operation: Internal.AttributeModifier$Operation_): void;
        getHeadArmorItem(): Internal.ItemStackJS;
        setMouseItem(item: Internal.ItemStackJS_): void;
        setAttributeBaseValue(attribute: Internal.Attribute_, value: number): void;
        isPlayer(): boolean;
        getStats(): Internal.PlayerStatsJS;
        getAbsorptionAmount(): number;
        isCrouching(): boolean;
        getTicksExisted(): number;
        getStages(): Internal.Stages;
        setSilent(isSilent: boolean): void;
        heal(hp: number): void;
        setMotionZ(z: number): void;
        setMotionY(y: number): void;
        setMotionX(x: number): void;
        isAmbientCreature(): boolean;
        rayTrace(distance: number): Internal.RayTraceResultJS;
        rayTrace(): Internal.RayTraceResultJS;
        getSelectedSlot(): number;
        canEntityBeSeen(entity: Internal.LivingEntityJS_): boolean;
        getX(): number;
        getY(): number;
        spawn(): void;
        getZ(): number;
        setFoodLevel(foodLevel: number): void;
        getNoGravity(): boolean;
        static readonly PLAYER_CUSTOM_SPEED : Internal.UUID;
        static readonly PLAYER_CUSTOM_SPEED_NAME : "kubejs.player.speed.modifier";
        readonly persistentData : Internal.CompoundTag;
        readonly minecraftPlayer : Internal.Player;
        readonly minecraftEntity : Internal.Entity;
        readonly minecraftLivingEntity : Internal.LivingEntity;
        get xpLevel(): number;
        get invisible(): boolean;
        get creativeMode(): boolean;
        get customNameAlwaysVisible(): boolean;
        get type(): string;
        get defaultMovementSpeed(): number;
        get movementSpeed(): number;
        get stats(): Internal.PlayerStatsJS;
        get revengeTarget(): Internal.LivingEntityJS;
        get hasCustomName(): boolean;
        get block(): Internal.BlockContainerJS;
        get maxHealth(): number;
        get id(): Internal.UUID;
        get pitch(): number;
        get item(): Internal.ItemStackJS;
        get passengers(): Internal.EntityArrayList;
        get profile(): Internal.GameProfile;
        get onLadder(): boolean;
        get offHandItem(): Internal.ItemStackJS;
        get customName(): Internal.Text;
        get lastAttackedEntityTime(): number;
        get tags(): Internal.Set<string>;
        get crouching(): boolean;
        get animal(): boolean;
        get lastDamageSource(): Internal.DamageSource;
        get stepHeight(): number;
        get noClip(): boolean;
        get server(): Internal.ServerJS;
        get nbt(): Internal.CompoundTag;
        get boss(): boolean;
        get alive(): boolean;
        get revengeTimer(): number;
        get displayName(): Internal.Text;
        get mainHandItem(): Internal.ItemStackJS;
        get facing(): Internal.Direction;
        get ambientCreature(): boolean;
        get swimming(): boolean;
        get selectedSlot(): number;
        get eyeHeight(): number;
        get underWater(): boolean;
        get openInventory(): Internal.AbstractContainerMenu;
        get motionZ(): number;
        get silent(): boolean;
        get motionY(): number;
        get motionX(): number;
        get health(): number;
        get chestArmorItem(): Internal.ItemStackJS;
        get yaw(): number;
        get monster(): boolean;
        get glowing(): boolean;
        get onGround(): boolean;
        get spectator(): boolean;
        get x(): number;
        get self(): boolean;
        get y(): number;
        get fake(): boolean;
        get z(): number;
        get foodLevel(): number;
        get data(): Internal.AttachedData;
        get idleTime(): number;
        get legsArmorItem(): Internal.ItemStackJS;
        get maxAirSupply(): number;
        get undead(): boolean;
        get lastAttackedEntity(): Internal.LivingEntityJS;
        get potionEffects(): Internal.EntityPotionEffectsJS;
        get level(): Internal.LevelJS;
        get feetArmorItem(): Internal.ItemStackJS;
        get horizontalFacing(): Internal.Direction;
        get sprinting(): boolean;
        get mouseItem(): Internal.ItemStackJS;
        get noGravity(): boolean;
        get fullNBT(): Internal.CompoundTag;
        get name(): Internal.Text;
        get peacefulCreature(): boolean;
        get child(): boolean;
        get frame(): boolean;
        get ticksExisted(): number;
        get fallDistance(): number;
        get elytraFlying(): boolean;
        get inventory(): Internal.InventoryJS;
        get sleeping(): boolean;
        get airSupply(): number;
        get waterCreature(): boolean;
        get invulnerable(): boolean;
        get miningBlock(): boolean;
        get headArmorItem(): Internal.ItemStackJS;
        get class(): Internal.Class<any>;
        get reachDistance(): number;
        get player(): boolean;
        get absorptionAmount(): number;
        get living(): boolean;
        get ridingEntity(): Internal.EntityJS;
        get inWater(): boolean;
        get recursivePassengers(): Internal.EntityArrayList;
        get attackingEntity(): Internal.LivingEntityJS;
        get totalMovementSpeed(): number;
        get teamId(): string;
        get xp(): number;
        get stages(): Internal.Stages;
        set noClip(noClip: boolean);
        set xpLevel(l: number);
        set fallDistance(fallDistance: number);
        set mainHandItem(item: Internal.ItemStackJS_);
        set invisible(invisible: boolean);
        set customNameAlwaysVisible(b: boolean);
        set defaultMovementSpeed(speed: number);
        set movementSpeed(speed: number);
        set airSupply(air: number);
        set invulnerable(invulnerable: boolean);
        set legsArmorItem(item: Internal.ItemStackJS_);
        set totalMovementSpeedMultiplier(speed: number);
        set selectedSlot(index: number);
        set revengeTarget(target: Internal.LivingEntityJS_);
        set maxHealth(hp: number);
        set headArmorItem(item: Internal.ItemStackJS_);
        set pitch(pitch: number);
        set movementSpeedAddition(speed: number);
        set motionZ(z: number);
        set absorptionAmount(amount: number);
        set silent(isSilent: boolean);
        set motionY(y: number);
        set motionX(x: number);
        set feetArmorItem(item: Internal.ItemStackJS_);
        set health(hp: number);
        set offHandItem(item: Internal.ItemStackJS_);
        set chestArmorItem(item: Internal.ItemStackJS_);
        set defaultMovementSpeedMultiplier(speed: number);
        set onFire(seconds: number);
        set statusMessage(message: Internal.Component_);
        set yaw(yaw: number);
        set glowing(glowing: boolean);
        set mouseItem(item: Internal.ItemStackJS_);
        set noGravity(noGravity: boolean);
        set fullNBT(nbt: Internal.CompoundTag_);
        set xp(xp: number);
        set x(x: number);
        set y(y: number);
        set z(z: number);
        set foodLevel(foodLevel: number);
        set position(block: Internal.BlockContainerJS_);
        set stepHeight(stepHeight: number);
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    type ClientPlayerJS_ = ClientPlayerJS;
    interface Byte2ReferenceFunction <V> extends Internal.Function<number, V>, Internal.IntFunction<V> {
        getOrDefault(arg0: number, arg1: V): V;
        getOrDefault(arg0: any, arg1: V): V;
        andThenShort(arg0: Internal.Reference2ShortFunction_<V>): Internal.Byte2ShortFunction;
        composeByte(arg0: Internal.Byte2ByteFunction_): Internal.Byte2ReferenceFunction<V>;
        andThenInt(arg0: Internal.Reference2IntFunction_<V>): Internal.Byte2IntFunction;
        andThen<V_>(arg0: java_.util.function_.Function_<V, V_>): java_.util.function_.Function<number, V_>;
        composeReference<T_>(arg0: Internal.Reference2ByteFunction_<T_>): Internal.Reference2ReferenceFunction<T_, V>;
        put(arg0: number, arg1: V): V;
        remove(arg0: any): V;
        remove(arg0: number): V;
        defaultReturnValue(arg0: V): void;
        defaultReturnValue(): V;
        andThenDouble(arg0: Internal.Reference2DoubleFunction_<V>): Internal.Byte2DoubleFunction;
        andThenObject<T_>(arg0: Internal.Reference2ObjectFunction_<V, T_>): Internal.Byte2ObjectFunction<T_>;
        get(arg0: any): V;
        get(arg0: number): V;
        andThenLong(arg0: Internal.Reference2LongFunction_<V>): Internal.Byte2LongFunction;
        composeLong(arg0: Internal.Long2ByteFunction_): Internal.Long2ReferenceFunction<V>;
        andThenByte(arg0: Internal.Reference2ByteFunction_<V>): Internal.Byte2ByteFunction;
        andThenFloat(arg0: Internal.Reference2FloatFunction_<V>): Internal.Byte2FloatFunction;
        apply(arg0: number): V;
        containsKey(arg0: any): boolean;
        containsKey(arg0: number): boolean;
        composeInt(arg0: Internal.Int2ByteFunction_): Internal.Int2ReferenceFunction<V>;
        clear(): void;
        composeFloat(arg0: Internal.Float2ByteFunction_): Internal.Float2ReferenceFunction<V>;
        andThenChar(arg0: Internal.Reference2CharFunction_<V>): Internal.Byte2CharFunction;
        composeObject<T_>(arg0: Internal.Object2ByteFunction_<T_>): Internal.Object2ReferenceFunction<T_, V>;
        size(): number;
        compose<T_>(arg0: java_.util.function_.Function_<T_, number>): java_.util.function_.Function<T_, V>;
        composeShort(arg0: Internal.Short2ByteFunction_): Internal.Short2ReferenceFunction<V>;
        andThenReference<T_>(arg0: Internal.Reference2ReferenceFunction_<V, T_>): Internal.Byte2ReferenceFunction<T_>;
        composeChar(arg0: Internal.Char2ByteFunction_): Internal.Char2ReferenceFunction<V>;
        composeDouble(arg0: Internal.Double2ByteFunction_): Internal.Double2ReferenceFunction<V>;
    }
    type Byte2ReferenceFunction_<V> = ((arg0: number) => V) | Byte2ReferenceFunction<V>;
    abstract class Number implements Internal.Serializable {
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        hashCode(): number;
        intValue(): number;
        notifyAll(): void;
        equals(arg0: any): boolean;
        floatValue(): number;
        toString(): string;
        shortValue(): number;
        doubleValue(): number;
        notify(): void;
        longValue(): number;
        byteValue(): number;
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    type Number_ = Number;
    abstract class JsonElement {
        getAsFloat(): number;
        getClass(): Internal.Class<any>;
        getAsByte(): number;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        getAsBigDecimal(): Internal.BigDecimal;
        notifyAll(): void;
        getAsNumber(): Internal.Number;
        getAsCharacter(): string;
        getAsString(): string;
        isJsonArray(): boolean;
        notify(): void;
        getAsInt(): number;
        isJsonPrimitive(): boolean;
        getAsLong(): number;
        hashCode(): number;
        isJsonObject(): boolean;
        getAsBigInteger(): Internal.BigInteger;
        getAsJsonObject(): Internal.JsonObject;
        getAsJsonNull(): Internal.JsonNull;
        isJsonNull(): boolean;
        getAsDouble(): number;
        deepCopy(): Internal.JsonElement;
        getAsJsonArray(): Internal.JsonArray;
        getAsJsonPrimitive(): Internal.JsonPrimitive;
        getAsBoolean(): boolean;
        equals(arg0: any): boolean;
        toString(): string;
        getAsShort(): number;
        get asByte(): number;
        get asBigInteger(): Internal.BigInteger;
        get asJsonObject(): Internal.JsonObject;
        get asCharacter(): string;
        get jsonPrimitive(): boolean;
        get asNumber(): Internal.Number;
        get asBigDecimal(): Internal.BigDecimal;
        get jsonNull(): boolean;
        get asFloat(): number;
        get asLong(): number;
        get asInt(): number;
        get asJsonPrimitive(): Internal.JsonPrimitive;
        get asJsonNull(): Internal.JsonNull;
        get asShort(): number;
        get asDouble(): number;
        get asJsonArray(): Internal.JsonArray;
        get asString(): string;
        get jsonObject(): boolean;
        get class(): Internal.Class<any>;
        get jsonArray(): boolean;
        get asBoolean(): boolean;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    type JsonElement_ = JsonElement;
    class ControllerDefinition extends Internal.ComponentDefinition {
        getBlockProperties(): Internal.BlockBehaviour$Properties;
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        getRenderer(): Internal.IRenderer;
        needUpdateTick(): boolean;
        getDesigns(): Internal.List<Internal.MultiblockShapeInfo>;
        notifyAll(): void;
        getID(): string;
        getTileType(): Internal.BlockEntityType<Internal.BlockEntity>;
        getDescription(): string;
        notify(): void;
        registerTileEntity(arg0: Internal.Block_, arg1: Internal.IForgeRegistry_<Internal.BlockEntityType_<any>>): void;
        getStackForm(): Internal.ItemStack;
        getRecipeMap(): MbdRecipeMap;
        getBasePattern(): Internal.BlockPattern;
        hashCode(): number;
        createNewTileEntity(arg0: BlockPos_, arg1: Internal.BlockState_): Internal.BlockEntity;
        equals(arg0: any): boolean;
        getItemProperties(): Internal.Item$Properties;
        toString(): string;
        traits : Internal.JsonObject;
        catalyst : Internal.ItemStack;
        consumeCatalyst : boolean;
        baseRenderer : Internal.IMultiblockedRenderer;
        workingRenderer : Internal.IMultiblockedRenderer;
        showInJei : boolean;
        readonly location : ResourceLocation;
        formedRenderer : Internal.IMultiblockedRenderer;
        allowRotate : boolean;
        properties : Internal.CustomProperties;
        get tileType(): Internal.BlockEntityType<Internal.BlockEntity>;
        get recipeMap(): MbdRecipeMap;
        get renderer(): Internal.IRenderer;
        get blockProperties(): Internal.BlockBehaviour$Properties;
        get description(): string;
        get basePattern(): Internal.BlockPattern;
        get itemProperties(): Internal.Item$Properties;
        get designs(): Internal.List<Internal.MultiblockShapeInfo>;
        get iD(): string;
        get stackForm(): Internal.ItemStack;
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    type ControllerDefinition_ = ControllerDefinition;
    class SuggestionContext <S> {
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        hashCode(): number;
        notifyAll(): void;
        equals(arg0: any): boolean;
        toString(): string;
        notify(): void;
        readonly parent : Internal.CommandNode<S>;
        readonly startPos : number;
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    type SuggestionContext_<S> = SuggestionContext<S>;
    class SelectableWidgetGroup extends Internal.WidgetGroup implements Internal.DraggableScrollableWidgetGroup$ISelected {
        getClass(): Internal.Class<any>;
        mouseWheelMove(arg0: number, arg1: number, arg2: number): boolean;
        mouseDragged(arg0: number, arg1: number, arg2: number, arg3: number, arg4: number): boolean;
        drawInForeground(arg0: Internal.PoseStack_, arg1: number, arg2: number, arg3: number): void;
        readUpdateInfo(arg0: number, arg1: Internal.FriendlyByteBuf_): void;
        toRectangleBox(): Internal.Rect2i;
        isActive(): boolean;
        getGui(): Internal.ModularUI;
        updateScreen(): void;
        clearAllWidgets(): void;
        setOnSelected(arg0: Internal.Consumer_<Internal.SelectableWidgetGroup_>): Internal.SelectableWidgetGroup;
        mouseMoved(arg0: number, arg1: number): void;
        isChild(arg0: com.lowdragmc.lowdraglib.gui.widget.Widget_): boolean;
        allowSelected(arg0: number, arg1: number, arg2: number): boolean;
        setVisible(arg0: boolean): void;
        static isMouseOver(arg0: number, arg1: number, arg2: number, arg3: number, arg4: number, arg5: number): boolean;
        addSelfPosition(arg0: number, arg1: number): Internal.Position;
        isParent(arg0: Internal.WidgetGroup_): boolean;
        keyPressed(arg0: number, arg1: number, arg2: number): boolean;
        setOnUnSelected(arg0: Internal.Consumer_<Internal.SelectableWidgetGroup_>): Internal.SelectableWidgetGroup;
        setHoverTexture(arg0: Internal.IGuiTexture_[]): com.lowdragmc.lowdraglib.gui.widget.Widget;
        isMouseOverElement(arg0: number, arg1: number): boolean;
        isVisible(): boolean;
        getSelfPosition(): Internal.Position;
        setClientSideWidget(): Internal.WidgetGroup;
        handleClientAction(arg0: number, arg1: Internal.FriendlyByteBuf_): void;
        setSelectedTexture(arg0: Internal.IGuiTexture_): Internal.SelectableWidgetGroup;
        setSelectedTexture(arg0: number, arg1: number): Internal.SelectableWidgetGroup;
        mouseClicked(arg0: number, arg1: number, arg2: number): boolean;
        charTyped(arg0: string, arg1: number): boolean;
        onSelected(): void;
        removeWidget(arg0: com.lowdragmc.lowdraglib.gui.widget.Widget_): void;
        readInitialData(arg0: Internal.FriendlyByteBuf_): void;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        notifyAll(): void;
        isInitialized(): boolean;
        setBackground(arg0: Internal.IGuiTexture_[]): com.lowdragmc.lowdraglib.gui.widget.Widget;
        notify(): void;
        mouseReleased(arg0: number, arg1: number, arg2: number): boolean;
        setSize(arg0: Internal.Size_): void;
        initWidget(): void;
        hashCode(): number;
        getNativeWidgets(): Internal.List<Internal.SlotWidget>;
        isSelected(): boolean;
        keyReleased(arg0: number, arg1: number, arg2: number): boolean;
        waitToRemoved(arg0: com.lowdragmc.lowdraglib.gui.widget.Widget_): void;
        detectAndSendChanges(): void;
        getPhantomTargets(arg0: any): Internal.List<Internal.Target>;
        getParent(): Internal.WidgetGroup;
        onUnSelected(): void;
        setSelfPosition(arg0: Internal.Position_): void;
        isRemote(): boolean;
        setFocus(arg0: boolean): void;
        setUiAccess(arg0: Internal.WidgetUIAccess_): void;
        drawInBackground(arg0: Internal.PoseStack_, arg1: number, arg2: number, arg3: number): void;
        getParentPosition(): Internal.Position;
        getSize(): Internal.Size;
        setActive(arg0: boolean): void;
        getPosition(): Internal.Position;
        getIngredientOverMouse(arg0: number, arg1: number): any;
        isFocus(): boolean;
        equals(arg0: any): boolean;
        onFocusChanged(arg0: com.lowdragmc.lowdraglib.gui.widget.Widget_, arg1: com.lowdragmc.lowdraglib.gui.widget.Widget_): void;
        setHoverTooltips(arg0: Internal.List_<Internal.Component_>): com.lowdragmc.lowdraglib.gui.widget.Widget;
        setHoverTooltips(arg0: string[]): com.lowdragmc.lowdraglib.gui.widget.Widget;
        setHoverTooltips(arg0: Internal.Component_[]): com.lowdragmc.lowdraglib.gui.widget.Widget;
        writeInitialData(arg0: Internal.FriendlyByteBuf_): void;
        toString(): string;
        setParentPosition(arg0: Internal.Position_): void;
        addWidget(arg0: com.lowdragmc.lowdraglib.gui.widget.Widget_): Internal.WidgetGroup;
        addWidget(arg0: number, arg1: com.lowdragmc.lowdraglib.gui.widget.Widget_): Internal.WidgetGroup;
        setGui(arg0: Internal.ModularUI_): void;
        getContainedWidgets(arg0: boolean): Internal.List<com.lowdragmc.lowdraglib.gui.widget.Widget>;
        readonly widgets : Internal.List<com.lowdragmc.lowdraglib.gui.widget.Widget>;
        get selfPosition(): Internal.Position;
        get parent(): Internal.WidgetGroup;
        get visible(): boolean;
        get nativeWidgets(): Internal.List<Internal.SlotWidget>;
        get active(): boolean;
        get focus(): boolean;
        get remote(): boolean;
        get parentPosition(): Internal.Position;
        get size(): Internal.Size;
        get initialized(): boolean;
        get gui(): Internal.ModularUI;
        get position(): Internal.Position;
        get class(): Internal.Class<any>;
        get selected(): boolean;
        set selfPosition(arg0: Internal.Position_);
        set parentPosition(arg0: Internal.Position_);
        set selectedTexture(arg0: Internal.IGuiTexture_);
        set visible(arg0: boolean);
        set size(arg0: Internal.Size_);
        set hoverTexture(arg0: Internal.IGuiTexture_[]);
        set background(arg0: Internal.IGuiTexture_[]);
        set active(arg0: boolean);
        set focus(arg0: boolean);
        set gui(arg0: Internal.ModularUI_);
        set hoverTooltips(arg0: Internal.List_<Internal.Component_>);
        set uiAccess(arg0: Internal.WidgetUIAccess_);
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    type SelectableWidgetGroup_ = SelectableWidgetGroup;
    interface LongUnaryOperator {
        applyAsLong(arg0: number): number;
        compose(arg0: Internal.LongUnaryOperator_): Internal.LongUnaryOperator;
        andThen(arg0: Internal.LongUnaryOperator_): Internal.LongUnaryOperator;
    }
    type LongUnaryOperator_ = ((arg0: number) => number) | LongUnaryOperator;
    interface IBlockRenderProperties {
        getFogColor(arg0: Internal.BlockState_, arg1: Internal.LevelReader_, arg2: BlockPos_, arg3: Internal.Entity_, arg4: Internal.Vector3d_, arg5: number): Internal.Vector3d;
        addDestroyEffects(arg0: Internal.BlockState_, arg1: Internal.Level_, arg2: BlockPos_, arg3: Internal.ParticleEngine_): boolean;
        addHitEffects(arg0: Internal.BlockState_, arg1: Internal.Level_, arg2: Internal.HitResult_, arg3: Internal.ParticleEngine_): boolean;
    }
    type IBlockRenderProperties_ = IBlockRenderProperties;
    interface ScreenAccessor {
        balm_getChildren(): Internal.List<Internal.GuiEventListener>;
        balm_getRenderables(): Internal.List<Internal.Widget>;
        balm_getNarratables(): Internal.List<Internal.NarratableEntry>;
    }
    type ScreenAccessor_ = ScreenAccessor;
    interface RecordBuilder <T> {
        withErrorsFrom(arg0: Internal.DataResult_<any>): Internal.RecordBuilder<T>;
        add(arg0: string, arg1: T): Internal.RecordBuilder<T>;
        add(arg0: string, arg1: Internal.DataResult_<T>): Internal.RecordBuilder<T>;
        add(arg0: Internal.DataResult_<T>, arg1: Internal.DataResult_<T>): Internal.RecordBuilder<T>;
        add<E>(arg0: string, arg1: E, arg2: Internal.Encoder_<E>): Internal.RecordBuilder<T>;
        add(arg0: T, arg1: T): Internal.RecordBuilder<T>;
        add(arg0: T, arg1: Internal.DataResult_<T>): Internal.RecordBuilder<T>;
        mapError(arg0: Internal.UnaryOperator_<string>): Internal.RecordBuilder<T>;
        ops(): Internal.DynamicOps<T>;
        setLifecycle(arg0: Internal.Lifecycle_): Internal.RecordBuilder<T>;
        build(arg0: Internal.DataResult_<T>): Internal.DataResult<T>;
        build(arg0: T): Internal.DataResult<T>;
    }
    type RecordBuilder_<T> = RecordBuilder<T>;
    class Int2ObjectOpenHashMap <V> extends Internal.AbstractInt2ObjectMap<V> implements Internal.Serializable, Internal.Cloneable, Internal.Hash {
        getClass(): Internal.Class<any>;
        getOrDefault(arg0: number, arg1: V): V;
        getOrDefault(arg0: any, arg1: V): V;
        replace(arg0: number, arg1: V, arg2: V): boolean;
        replace(arg0: number, arg1: V): V;
        composeByte(arg0: Internal.Byte2IntFunction_): Internal.Byte2ObjectFunction<V>;
        andThen<V_>(arg0: java_.util.function_.Function_<V, V_>): java_.util.function_.Function<number, V_>;
        composeReference<T_>(arg0: Internal.Reference2IntFunction_<T_>): Internal.Reference2ObjectFunction<T_, V>;
        containsValue(arg0: any): boolean;
        put(arg0: number, arg1: V): V;
        compute(arg0: number, arg1: Internal.BiFunction_<number, V, V>): V;
        defaultReturnValue(arg0: V): void;
        defaultReturnValue(): V;
        andThenObject<T_>(arg0: Internal.Object2ObjectFunction_<V, T_>): Internal.Int2ObjectFunction<T_>;
        trim(arg0: number): boolean;
        trim(): boolean;
        merge(arg0: number, arg1: V, arg2: Internal.BiFunction_<V, V, V>): V;
        composeLong(arg0: Internal.Long2IntFunction_): Internal.Long2ObjectFunction<V>;
        entrySet(): Internal.ObjectSet<Internal.Map$Entry<number, V>>;
        containsKey(arg0: number): boolean;
        containsKey(arg0: any): boolean;
        composeObject<T_>(arg0: Internal.Object2IntFunction_<T_>): Internal.Object2ObjectFunction<T_, V>;
        size(): number;
        compose<T_>(arg0: java_.util.function_.Function_<T_, number>): java_.util.function_.Function<T_, V>;
        composeShort(arg0: Internal.Short2IntFunction_): Internal.Short2ObjectFunction<V>;
        composeChar(arg0: Internal.Char2IntFunction_): Internal.Char2ObjectFunction<V>;
        composeDouble(arg0: Internal.Double2IntFunction_): Internal.Double2ObjectFunction<V>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        notifyAll(): void;
        computeIfAbsent(arg0: number, arg1: Internal.IntFunction_<V>): V;
        computeIfAbsent(arg0: number, arg1: Internal.Int2ObjectFunction_<V>): V;
        computeIfAbsent(arg0: number, arg1: java_.util.function_.Function_<number, V>): V;
        values(): Internal.ObjectCollection<V>;
        andThenShort(arg0: Internal.Object2ShortFunction_<V>): Internal.Int2ShortFunction;
        computeIfAbsentPartial(arg0: number, arg1: Internal.Int2ObjectFunction_<V>): V;
        replaceAll(arg0: Internal.BiFunction_<number, V, V>): void;
        andThenInt(arg0: Internal.Object2IntFunction_<V>): Internal.Int2IntFunction;
        notify(): void;
        remove(arg0: number, arg1: any): boolean;
        remove(arg0: number): V;
        remove(arg0: any): V;
        remove(arg0: any, arg1: any): boolean;
        andThenDouble(arg0: Internal.Object2DoubleFunction_<V>): Internal.Int2DoubleFunction;
        int2ObjectEntrySet(): Internal.Int2ObjectMap$FastEntrySet<V>;
        hashCode(): number;
        putAll(arg0: Internal.Map_<number, V>): void;
        get(arg0: number): V;
        get(arg0: any): V;
        andThenLong(arg0: Internal.Object2LongFunction_<V>): Internal.Int2LongFunction;
        keySet(): Internal.IntSet;
        andThenByte(arg0: Internal.Object2ByteFunction_<V>): Internal.Int2ByteFunction;
        andThenFloat(arg0: Internal.Object2FloatFunction_<V>): Internal.Int2FloatFunction;
        apply(arg0: number): V;
        forEach(arg0: Internal.BiConsumer_<number, V>): void;
        composeInt(arg0: Internal.Int2IntFunction_): Internal.Int2ObjectFunction<V>;
        isEmpty(): boolean;
        clear(): void;
        composeFloat(arg0: Internal.Float2IntFunction_): Internal.Float2ObjectFunction<V>;
        andThenChar(arg0: Internal.Object2CharFunction_<V>): Internal.Int2CharFunction;
        computeIfPresent(arg0: number, arg1: Internal.BiFunction_<number, V, V>): V;
        equals(arg0: any): boolean;
        andThenReference<T_>(arg0: Internal.Object2ReferenceFunction_<V, T_>): Internal.Int2ReferenceFunction<T_>;
        clone(): Internal.Int2ObjectOpenHashMap<V>;
        toString(): string;
        putIfAbsent(arg0: number, arg1: V): V;
        static readonly DEFAULT_GROWTH_FACTOR : 16;
        static readonly FAST_LOAD_FACTOR : 0.5;
        static readonly DEFAULT_INITIAL_SIZE : 16;
        static readonly DEFAULT_LOAD_FACTOR : 0.75;
        static readonly OCCUPIED : -1;
        static readonly VERY_FAST_LOAD_FACTOR : 0.25;
        static readonly FREE : 0;
        static readonly PRIMES : number[];
        static readonly REMOVED : 1;
        get class(): Internal.Class<any>;
        get empty(): boolean;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    type Int2ObjectOpenHashMap_<V> = Int2ObjectOpenHashMap<V>;
    class RewardClaimType extends Internal.Enum<Internal.RewardClaimType> {
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        canClaim(): boolean;
        static valueOf(name: string): Internal.RewardClaimType;
        static valueOf<T_>(arg0: Internal.Class_<T_>, arg1: string): T_;
        notifyAll(): void;
        static values(): Internal.RewardClaimType[];
        compareTo(arg0: Internal.RewardClaimType_): number;
        describeConstable(): Internal.Optional<Internal.Enum$EnumDesc<Internal.RewardClaimType>>;
        notify(): void;
        getDeclaringClass(): Internal.Class<Internal.RewardClaimType>;
        cantClaim(): boolean;
        hashCode(): number;
        equals(arg0: any): boolean;
        name(): string;
        toString(): string;
        isClaimed(): boolean;
        ordinal(): number;
        static readonly CLAIMED : Internal.RewardClaimType;
        static readonly CAN_CLAIM : Internal.RewardClaimType;
        static readonly CANT_CLAIM : Internal.RewardClaimType;
        get claimed(): boolean;
        get class(): Internal.Class<any>;
        get declaringClass(): Internal.Class<Internal.RewardClaimType>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    type RewardClaimType_ = "can_claim" | "claimed" | "cant_claim" | RewardClaimType;
    class ParsePosition {
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        getIndex(): number;
        setIndex(arg0: number): void;
        hashCode(): number;
        notifyAll(): void;
        equals(arg0: any): boolean;
        toString(): string;
        notify(): void;
        setErrorIndex(arg0: number): void;
        getErrorIndex(): number;
        get errorIndex(): number;
        get index(): number;
        get class(): Internal.Class<any>;
        set errorIndex(arg0: number);
        set index(arg0: number);
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    type ParsePosition_ = ParsePosition;
    interface ITagManager <V> extends Internal.Iterable<Internal.ITag<V>> {
        iterator(): Internal.Iterator<Internal.ITag<V>>;
        isKnownTagName(arg0: Internal.TagKey_<V>): boolean;
        spliterator(): Internal.Spliterator<Internal.ITag<V>>;
        stream(): Internal.Stream<Internal.ITag<V>>;
        forEach(arg0: Internal.Consumer_<Internal.ITag_<V>>): void;
        createOptionalTagKey(arg0: ResourceLocation_, arg1: Internal.Set_<Internal.Supplier_<V>>): Internal.TagKey<V>;
        createTagKey(arg0: ResourceLocation_): Internal.TagKey<V>;
        getTag(arg0: Internal.TagKey_<V>): Internal.ITag<V>;
        addOptionalTagDefaults(arg0: Internal.TagKey_<V>, arg1: Internal.Set_<Internal.Supplier_<V>>): void;
        getReverseTag(arg0: V): Internal.Optional<Internal.IReverseTag<V>>;
        getTagNames(): Internal.Stream<Internal.TagKey<V>>;
    }
    type ITagManager_<V> = ITagManager<V>;
    abstract class BaseImmutableMultimap <K, V> extends Internal.AbstractMultimap<K, V> {
        getClass(): Internal.Class<any>;
        containsEntry(arg0: any, arg1: any): boolean;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        containsKey(arg0: any): boolean;
        forEach(arg0: Internal.BiConsumer_<K, V>): void;
        asMap(): Internal.Map<K, Internal.Collection<V>>;
        keys(): Internal.Multiset<K>;
        notifyAll(): void;
        values(): Internal.Collection<V>;
        clear(): void;
        isEmpty(): boolean;
        replaceValues(arg0: K, arg1: Internal.Iterable_<V>): Internal.Collection<V>;
        notify(): void;
        containsValue(arg0: any): boolean;
        put(arg0: K, arg1: V): boolean;
        remove(arg0: any, arg1: any): boolean;
        removeAll(arg0: any): Internal.Collection<V>;
        entries(): Internal.Collection<Internal.Map$Entry<K, V>>;
        size(): number;
        hashCode(): number;
        get(arg0: K): Internal.Collection<V>;
        putAll(arg0: K, arg1: Internal.Iterable_<V>): boolean;
        putAll(arg0: Internal.Multimap_<K, V>): boolean;
        equals(arg0: any): boolean;
        toString(): string;
        keySet(): Internal.Set<K>;
        get class(): Internal.Class<any>;
        get empty(): boolean;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    type BaseImmutableMultimap_<K, V> = BaseImmutableMultimap<K, V>;
    interface Reference2IntFunction <K> extends Internal.Function<K, number>, Internal.ToIntFunction<K> {
        getOrDefault(arg0: any, arg1: number): number;
        andThenShort(arg0: Internal.Int2ShortFunction_): Internal.Reference2ShortFunction<K>;
        composeByte(arg0: Internal.Byte2ReferenceFunction_<K>): Internal.Byte2IntFunction;
        andThenInt(arg0: Internal.Int2IntFunction_): Internal.Reference2IntFunction<K>;
        composeReference<T_>(arg0: Internal.Reference2ReferenceFunction_<T_, K>): Internal.Reference2IntFunction<T_>;
        andThen<T_>(arg0: java_.util.function_.Function_<number, T_>): java_.util.function_.Function<K, T_>;
        put(arg0: K, arg1: number): number;
        remove(arg0: any): number;
        defaultReturnValue(): number;
        defaultReturnValue(arg0: number): void;
        andThenDouble(arg0: Internal.Int2DoubleFunction_): Internal.Reference2DoubleFunction<K>;
        andThenObject<T_>(arg0: Internal.Int2ObjectFunction_<T_>): Internal.Reference2ObjectFunction<K, T_>;
        get(arg0: any): number;
        andThenLong(arg0: Internal.Int2LongFunction_): Internal.Reference2LongFunction<K>;
        composeLong(arg0: Internal.Long2ReferenceFunction_<K>): Internal.Long2IntFunction;
        andThenByte(arg0: Internal.Int2ByteFunction_): Internal.Reference2ByteFunction<K>;
        andThenFloat(arg0: Internal.Int2FloatFunction_): Internal.Reference2FloatFunction<K>;
        applyAsInt(arg0: K): number;
        removeInt(arg0: any): number;
        apply(arg0: K): number;
        containsKey(arg0: any): boolean;
        composeInt(arg0: Internal.Int2ReferenceFunction_<K>): Internal.Int2IntFunction;
        clear(): void;
        composeFloat(arg0: Internal.Float2ReferenceFunction_<K>): Internal.Float2IntFunction;
        andThenChar(arg0: Internal.Int2CharFunction_): Internal.Reference2CharFunction<K>;
        getInt(arg0: any): number;
        composeObject<T_>(arg0: Internal.Object2ReferenceFunction_<T_, K>): Internal.Object2IntFunction<T_>;
        size(): number;
        compose<V_>(arg0: java_.util.function_.Function_<V_, K>): java_.util.function_.Function<V_, number>;
        composeShort(arg0: Internal.Short2ReferenceFunction_<K>): Internal.Short2IntFunction;
        andThenReference<T_>(arg0: Internal.Int2ReferenceFunction_<T_>): Internal.Reference2ReferenceFunction<K, T_>;
        composeChar(arg0: Internal.Char2ReferenceFunction_<K>): Internal.Char2IntFunction;
        composeDouble(arg0: Internal.Double2ReferenceFunction_<K>): Internal.Double2IntFunction;
    }
    type Reference2IntFunction_<K> = ((arg0: any) => number) | Reference2IntFunction<K>;
    /**
    */
    class IngredientActionFilter {
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        checkFilter(index: number, stack: Internal.ItemStack_): boolean;
        hashCode(): number;
        notifyAll(): void;
        equals(arg0: any): boolean;
        toString(): string;
        static filterOf(o: any): Internal.IngredientActionFilter;
        notify(): void;
        copyFrom(filter: Internal.IngredientActionFilter_): void;
        filterIndex : number;
        filterIngredient : ((arg0: Internal.ItemStackJS) => boolean);
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    /**
    */
    type IngredientActionFilter_ = number | Internal.IngredientJS_ | string | {item: Internal.IngredientJS_, index?: number} | IngredientActionFilter;
    interface Object2FloatMap <K> extends Internal.Object2FloatFunction<K>, Internal.Map<K, number> {
        computeFloatIfAbsent(arg0: K, arg1: Internal.ToDoubleFunction_<K>): number;
        getOrDefault(arg0: any, arg1: number): number;
        applyAsDouble(arg0: K): number;
        replace(arg0: K, arg1: number, arg2: number): boolean;
        replace(arg0: K, arg1: number): number;
        composeByte(arg0: Internal.Byte2ObjectFunction_<K>): Internal.Byte2FloatFunction;
        composeReference<T_>(arg0: Internal.Reference2ObjectFunction_<T_, K>): Internal.Reference2FloatFunction<T_>;
        andThen<T_>(arg0: java_.util.function_.Function_<number, T_>): java_.util.function_.Function<K, T_>;
        containsValue(arg0: any): boolean;
        containsValue(arg0: number): boolean;
        put(arg0: K, arg1: number): number;
        compute(arg0: K, arg1: Internal.BiFunction_<K, number, number>): number;
        defaultReturnValue(arg0: number): void;
        defaultReturnValue(): number;
        andThenObject<T_>(arg0: Internal.Float2ObjectFunction_<T_>): Internal.Object2ObjectFunction<K, T_>;
        mergeFloat(arg0: K, arg1: number, arg2: Internal.DoubleBinaryOperator_): number;
        mergeFloat(arg0: K, arg1: number, arg2: Internal.BiFunction_<number, number, number>): number;
        mergeFloat(arg0: K, arg1: number, arg2: Internal.FloatBinaryOperator_): number;
        merge(arg0: K, arg1: number, arg2: Internal.BiFunction_<number, number, number>): number;
        composeLong(arg0: Internal.Long2ObjectFunction_<K>): Internal.Long2FloatFunction;
        computeFloatIfPresent(arg0: K, arg1: Internal.BiFunction_<K, number, number>): number;
        removeFloat(arg0: any): number;
        entrySet(): Internal.ObjectSet<Internal.Map$Entry<K, number>>;
        containsKey(arg0: any): boolean;
        composeObject<T_>(arg0: Internal.Object2ObjectFunction_<T_, K>): Internal.Object2FloatFunction<T_>;
        size(): number;
        compose<V_>(arg0: java_.util.function_.Function_<V_, K>): java_.util.function_.Function<V_, number>;
        object2FloatEntrySet(): Internal.ObjectSet<Internal.Object2FloatMap$Entry<K>>;
        composeShort(arg0: Internal.Short2ObjectFunction_<K>): Internal.Short2FloatFunction;
        composeChar(arg0: Internal.Char2ObjectFunction_<K>): Internal.Char2FloatFunction;
        composeDouble(arg0: Internal.Double2ObjectFunction_<K>): Internal.Double2FloatFunction;
        computeIfAbsent(arg0: K, arg1: Internal.ToDoubleFunction_<K>): number;
        computeIfAbsent(arg0: K, arg1: Internal.Object2FloatFunction_<K>): number;
        computeIfAbsent(arg0: K, arg1: java_.util.function_.Function_<K, number>): number;
        values(): Internal.FloatCollection;
        andThenShort(arg0: Internal.Float2ShortFunction_): Internal.Object2ShortFunction<K>;
        getFloat(arg0: any): number;
        replaceAll(arg0: Internal.BiFunction_<K, number, number>): void;
        andThenInt(arg0: Internal.Float2IntFunction_): Internal.Object2IntFunction<K>;
        remove(arg0: any, arg1: any): boolean;
        remove(arg0: any): number;
        remove(arg0: any, arg1: number): boolean;
        computeFloat(arg0: K, arg1: Internal.BiFunction_<K, number, number>): number;
        andThenDouble(arg0: Internal.Float2DoubleFunction_): Internal.Object2DoubleFunction<K>;
        hashCode(): number;
        putAll(arg0: Internal.Map_<K, number>): void;
        get(arg0: any): number;
        andThenLong(arg0: Internal.Float2LongFunction_): Internal.Object2LongFunction<K>;
        keySet(): Internal.ObjectSet<K>;
        andThenByte(arg0: Internal.Float2ByteFunction_): Internal.Object2ByteFunction<K>;
        computeFloatIfAbsentPartial(arg0: K, arg1: Internal.Object2FloatFunction_<K>): number;
        andThenFloat(arg0: Internal.Float2FloatFunction_): Internal.Object2FloatFunction<K>;
        apply(arg0: K): number;
        forEach(arg0: Internal.BiConsumer_<K, number>): void;
        composeInt(arg0: Internal.Int2ObjectFunction_<K>): Internal.Int2FloatFunction;
        isEmpty(): boolean;
        clear(): void;
        composeFloat(arg0: Internal.Float2ObjectFunction_<K>): Internal.Float2FloatFunction;
        andThenChar(arg0: Internal.Float2CharFunction_): Internal.Object2CharFunction<K>;
        computeIfPresent(arg0: K, arg1: Internal.BiFunction_<K, number, number>): number;
        equals(arg0: any): boolean;
        andThenReference<T_>(arg0: Internal.Float2ReferenceFunction_<T_>): Internal.Object2ReferenceFunction<K, T_>;
        putIfAbsent(arg0: K, arg1: number): number;
    }
    type Object2FloatMap_<K> = Object2FloatMap<K>;
    interface Byte2ShortFunction extends Internal.Function<number, number>, Internal.IntUnaryOperator {
        getOrDefault(arg0: any, arg1: number): number;
        getOrDefault(arg0: number, arg1: number): number;
        andThenShort(arg0: Internal.Short2ShortFunction_): Internal.Byte2ShortFunction;
        composeByte(arg0: Internal.Byte2ByteFunction_): Internal.Byte2ShortFunction;
        andThenInt(arg0: Internal.Short2IntFunction_): Internal.Byte2IntFunction;
        composeReference<T_>(arg0: Internal.Reference2ByteFunction_<T_>): Internal.Reference2ShortFunction<T_>;
        andThen<T_>(arg0: java_.util.function_.Function_<number, T_>): java_.util.function_.Function<number, T_>;
        andThen(arg0: Internal.IntUnaryOperator_): Internal.IntUnaryOperator;
        put(arg0: number, arg1: number): number;
        remove(arg0: number): number;
        remove(arg0: any): number;
        defaultReturnValue(): number;
        defaultReturnValue(arg0: number): void;
        andThenDouble(arg0: Internal.Short2DoubleFunction_): Internal.Byte2DoubleFunction;
        andThenObject<T_>(arg0: Internal.Short2ObjectFunction_<T_>): Internal.Byte2ObjectFunction<T_>;
        get(arg0: any): number;
        get(arg0: number): number;
        andThenLong(arg0: Internal.Short2LongFunction_): Internal.Byte2LongFunction;
        composeLong(arg0: Internal.Long2ByteFunction_): Internal.Long2ShortFunction;
        andThenByte(arg0: Internal.Short2ByteFunction_): Internal.Byte2ByteFunction;
        andThenFloat(arg0: Internal.Short2FloatFunction_): Internal.Byte2FloatFunction;
        applyAsInt(arg0: number): number;
        apply(arg0: number): number;
        containsKey(arg0: any): boolean;
        containsKey(arg0: number): boolean;
        composeInt(arg0: Internal.Int2ByteFunction_): Internal.Int2ShortFunction;
        clear(): void;
        composeFloat(arg0: Internal.Float2ByteFunction_): Internal.Float2ShortFunction;
        andThenChar(arg0: Internal.Short2CharFunction_): Internal.Byte2CharFunction;
        composeObject<T_>(arg0: Internal.Object2ByteFunction_<T_>): Internal.Object2ShortFunction<T_>;
        size(): number;
        compose<T_>(arg0: java_.util.function_.Function_<T_, number>): java_.util.function_.Function<T_, number>;
        compose(arg0: Internal.IntUnaryOperator_): Internal.IntUnaryOperator;
        composeShort(arg0: Internal.Short2ByteFunction_): Internal.Short2ShortFunction;
        andThenReference<T_>(arg0: Internal.Short2ReferenceFunction_<T_>): Internal.Byte2ReferenceFunction<T_>;
        composeChar(arg0: Internal.Char2ByteFunction_): Internal.Char2ShortFunction;
        composeDouble(arg0: Internal.Double2ByteFunction_): Internal.Double2ShortFunction;
    }
    type Byte2ShortFunction_ = ((arg0: number) => number) | Byte2ShortFunction;
    /**
    * Fired by different tag when the level:
    * - loads
    * - ticks
    * - unloads
    */
    class SimpleLevelEventJS extends Internal.LevelEventJS {
        cancel(): void;
        getServer(): Internal.ServerJS;
        getClass(): Internal.Class<any>;
        getLevel(): Internal.LevelJS;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        isCancelled(): boolean;
        post(id: string): boolean;
        post(id: string, sub: string): boolean;
        post(t: Internal.ScriptType_, id: string, sub: string): boolean;
        post(t: Internal.ScriptType_, id: string): boolean;
        hashCode(): number;
        notifyAll(): void;
        equals(arg0: any): boolean;
        toString(): string;
        notify(): void;
        canCancel(): boolean;
        get server(): Internal.ServerJS;
        get level(): Internal.LevelJS;
        get cancelled(): boolean;
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    /**
    * Fired by different tag when the level:
    * - loads
    * - ticks
    * - unloads
    */
    type SimpleLevelEventJS_ = SimpleLevelEventJS;
    class AABB {
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        hashCode(): number;
        notifyAll(): void;
        equals(arg0: any): boolean;
        toString(): string;
        notify(): void;
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    type AABB_ = AABB;
    interface IntToLongFunction {
        applyAsLong(arg0: number): number;
    }
    type IntToLongFunction_ = ((arg0: number) => number) | IntToLongFunction;
    abstract class ReentrantBlockableEventLoop <R> extends Internal.BlockableEventLoop<R> {
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        hashCode(): number;
        notifyAll(): void;
        equals(arg0: any): boolean;
        toString(): string;
        close(): void;
        execute(arg0: Internal.Runnable_): void;
        notify(): void;
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    type ReentrantBlockableEventLoop_<R> = ReentrantBlockableEventLoop<R>;
    class Vector3f {
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        setY(arg0: number): void;
        setX(arg0: number): void;
        set(arg0: number[]): void;
        hashCode(): number;
        notifyAll(): void;
        equals(arg0: any): boolean;
        toString(): string;
        setZ(arg0: number): void;
        notify(): void;
        get class(): Internal.Class<any>;
        set x(arg0: number);
        set y(arg0: number);
        set z(arg0: number);
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    type Vector3f_ = Vector3f;
    class DyeColor extends Internal.Enum<Internal.DyeColor> implements Internal.StringRepresentable, Internal.Color {
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        getRgbKJS(): number;
        static valueOf(arg0: string): Internal.DyeColor;
        static valueOf<T_>(arg0: Internal.Class_<T_>, arg1: string): T_;
        notifyAll(): void;
        static values(): Internal.DyeColor[];
        static getColor(arg0: Internal.ItemStack_): Internal.DyeColor;
        compareTo(arg0: Internal.DyeColor_): number;
        getSerializeKJS(): string;
        getTag(): Internal.TagKey<Internal.Item>;
        describeConstable(): Internal.Optional<Internal.Enum$EnumDesc<Internal.DyeColor>>;
        notify(): void;
        getDeclaringClass(): Internal.Class<Internal.DyeColor>;
        hashCode(): number;
        equals(arg0: any): boolean;
        name(): string;
        createTextColorKJS(): Internal.TextColor;
        getHexKJS(): string;
        getArgbKJS(): number;
        toString(): string;
        getFireworkColorKJS(): number;
        specialEquals(o: any, shallow: boolean): boolean;
        ordinal(): number;
        static readonly WHITE : Internal.DyeColor;
        static readonly GRAY : Internal.DyeColor;
        static readonly BLUE : Internal.DyeColor;
        static readonly PURPLE : Internal.DyeColor;
        static readonly GREEN : Internal.DyeColor;
        static readonly RED : Internal.DyeColor;
        static readonly PINK : Internal.DyeColor;
        static readonly LIGHT_GRAY : Internal.DyeColor;
        static readonly LIGHT_BLUE : Internal.DyeColor;
        static readonly LIME : Internal.DyeColor;
        static readonly MAGENTA : Internal.DyeColor;
        static readonly BLACK : Internal.DyeColor;
        static readonly YELLOW : Internal.DyeColor;
        static readonly CYAN : Internal.DyeColor;
        static readonly BROWN : Internal.DyeColor;
        static readonly ORANGE : Internal.DyeColor;
        get fireworkColorKJS(): number;
        get rgbKJS(): number;
        get argbKJS(): number;
        get serializeKJS(): string;
        get hexKJS(): string;
        get tag(): Internal.TagKey<Internal.Item>;
        get class(): Internal.Class<any>;
        get declaringClass(): Internal.Class<Internal.DyeColor>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    type DyeColor_ = "magenta" | "pink" | "green" | "lime" | "light_gray" | "yellow" | "black" | "light_blue" | "brown" | "cyan" | "orange" | "red" | "gray" | "white" | "blue" | "purple" | DyeColor;
    class LootModificationEventJS extends Internal.EventJS {
        cancel(): void;
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        isCancelled(): boolean;
        addBlockLootModifier(arg0: BlockStatePredicate_): Internal.LootActionsBuilderJS;
        notifyAll(): void;
        removeGlobalModifier(arg0: string[]): void;
        notify(): void;
        disableLootModification(arg0: any_[]): void;
        addLootTableModifier(arg0: any_[]): Internal.LootActionsBuilderJS;
        getGlobalModifiers(): Internal.List<string>;
        post(t: Internal.ScriptType_, id: string, sub: string): boolean;
        post(t: Internal.ScriptType_, id: string): boolean;
        addLootTypeModifier(arg0: LootType_[]): Internal.LootActionsBuilderJS;
        hashCode(): number;
        equals(arg0: any): boolean;
        addEntityLootModifier(arg0: Internal.EntityType_<any>[]): Internal.LootActionsBuilderJS;
        toString(): string;
        enableLogging(): void;
        canCancel(): boolean;
        get globalModifiers(): Internal.List<string>;
        get cancelled(): boolean;
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    type LootModificationEventJS_ = LootModificationEventJS;
    class ParsedArgument <S, T> {
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        getRange(): Internal.StringRange;
        hashCode(): number;
        notifyAll(): void;
        getResult(): T;
        equals(arg0: any): boolean;
        toString(): string;
        notify(): void;
        get result(): T;
        get range(): Internal.StringRange;
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    type ParsedArgument_<S, T> = ParsedArgument<S, T>;
    class DoubleConfig extends Internal.NumberConfig<number> {
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        getName(): string;
        setCanEdit(e: boolean): Internal.ConfigValue<number>;
        notifyAll(): void;
        isEqual(v1: number, v2: number): boolean;
        compareTo(o: Internal.ConfigValue_<number>): number;
        notify(): void;
        getCanEdit(): boolean;
        getStringFromValue(v: number): string;
        getTooltip(): string;
        hashCode(): number;
        getStringForGUI(v: number): Internal.Component;
        getPath(): string;
        copy(value: number): number;
        static info(key: string, value: any): Internal.Component;
        init(g: Internal.ConfigGroup_, i: string, v: number, c: Internal.Consumer_<number>, def: number): Internal.ConfigValue<number>;
        getColor(v: number): Internal.Color4I;
        addInfo(list: Internal.TooltipList_): void;
        parse(callback: Internal.Consumer_<number>, string: string): boolean;
        getIcon(v: number): Internal.Icon;
        setIcon(i: Internal.Icon_): Internal.ConfigValue<number>;
        setOrder(o: number): Internal.ConfigValue<number>;
        getNameKey(): string;
        setNameKey(key: string): Internal.ConfigValue<number>;
        equals(arg0: any): boolean;
        onClicked(button: Internal.MouseButton_, callback: Internal.ConfigCallback_): void;
        toString(): string;
        setCurrentValue(v: number): boolean;
        fader(v: boolean): Internal.NumberConfig<number>;
        readonly min : number;
        readonly max : number;
        static readonly COLOR : Internal.Color4I;
        defaultValue : number;
        id : string;
        static readonly NULL_TEXT : Internal.TextComponent;
        setter : ((arg0: number) => void);
        value : number;
        group : Internal.ConfigGroup;
        get path(): string;
        get nameKey(): string;
        get canEdit(): boolean;
        get name(): string;
        get tooltip(): string;
        get class(): Internal.Class<any>;
        set nameKey(key: string);
        set canEdit(e: boolean);
        set icon(i: Internal.Icon_);
        set currentValue(v: number);
        set order(o: number);
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    type DoubleConfig_ = DoubleConfig;
    interface Function15 <T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, R> {
        curry12(): Internal.Function12<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, Internal.Function3<T13, T14, T15, R>>;
        curry9(): Internal.Function9<T1, T2, T3, T4, T5, T6, T7, T8, T9, Internal.Function6<T10, T11, T12, T13, T14, T15, R>>;
        curry13(): Internal.Function13<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, Internal.BiFunction<T14, T15, R>>;
        apply(arg0: T1, arg1: T2, arg2: T3, arg3: T4, arg4: T5, arg5: T6, arg6: T7, arg7: T8, arg8: T9, arg9: T10, arg10: T11, arg11: T12, arg12: T13, arg13: T14, arg14: T15): R;
        curry7(): Internal.Function7<T1, T2, T3, T4, T5, T6, T7, Internal.Function8<T8, T9, T10, T11, T12, T13, T14, T15, R>>;
        curry14(): Internal.Function14<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, java_.util.function_.Function<T15, R>>;
        curry8(): Internal.Function8<T1, T2, T3, T4, T5, T6, T7, T8, Internal.Function7<T9, T10, T11, T12, T13, T14, T15, R>>;
        curry10(): Internal.Function10<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, Internal.Function5<T11, T12, T13, T14, T15, R>>;
        curry11(): Internal.Function11<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, Internal.Function4<T12, T13, T14, T15, R>>;
        curry(): java_.util.function_.Function<T1, Internal.Function14<T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, R>>;
        curry5(): Internal.Function5<T1, T2, T3, T4, T5, Internal.Function10<T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, R>>;
        curry6(): Internal.Function6<T1, T2, T3, T4, T5, T6, Internal.Function9<T7, T8, T9, T10, T11, T12, T13, T14, T15, R>>;
        curry3(): Internal.Function3<T1, T2, T3, Internal.Function12<T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, R>>;
        curry4(): Internal.Function4<T1, T2, T3, T4, Internal.Function11<T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, R>>;
        curry2(): Internal.BiFunction<T1, T2, Internal.Function13<T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, R>>;
    }
    type Function15_<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, R> = Function15<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, R>;
    class Dimension extends Internal.Dimension2D implements Internal.Serializable {
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        getHeight(): number;
        getSize(): Internal.Dimension;
        setSize(arg0: Internal.Dimension_): void;
        setSize(arg0: number, arg1: number): void;
        setSize(arg0: Internal.Dimension2D_): void;
        hashCode(): number;
        notifyAll(): void;
        equals(arg0: any): boolean;
        clone(): any;
        toString(): string;
        getWidth(): number;
        notify(): void;
        width : number;
        height : number;
        get size(): Internal.Dimension;
        get class(): Internal.Class<any>;
        set size(arg0: Internal.Dimension_);
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    type Dimension_ = Dimension;
    interface Char2FloatFunction extends Internal.Function<string, number>, Internal.IntToDoubleFunction {
        getOrDefault(arg0: any, arg1: number): number;
        getOrDefault(arg0: string, arg1: number): number;
        applyAsDouble(arg0: number): number;
        andThenShort(arg0: Internal.Float2ShortFunction_): Internal.Char2ShortFunction;
        composeByte(arg0: Internal.Byte2CharFunction_): Internal.Byte2FloatFunction;
        andThenInt(arg0: Internal.Float2IntFunction_): Internal.Char2IntFunction;
        composeReference<T_>(arg0: Internal.Reference2CharFunction_<T_>): Internal.Reference2FloatFunction<T_>;
        andThen<T_>(arg0: java_.util.function_.Function_<number, T_>): java_.util.function_.Function<string, T_>;
        put(arg0: string, arg1: number): number;
        remove(arg0: string): number;
        remove(arg0: any): number;
        defaultReturnValue(): number;
        defaultReturnValue(arg0: number): void;
        andThenDouble(arg0: Internal.Float2DoubleFunction_): Internal.Char2DoubleFunction;
        andThenObject<T_>(arg0: Internal.Float2ObjectFunction_<T_>): Internal.Char2ObjectFunction<T_>;
        get(arg0: any): number;
        get(arg0: string): number;
        andThenLong(arg0: Internal.Float2LongFunction_): Internal.Char2LongFunction;
        composeLong(arg0: Internal.Long2CharFunction_): Internal.Long2FloatFunction;
        andThenByte(arg0: Internal.Float2ByteFunction_): Internal.Char2ByteFunction;
        andThenFloat(arg0: Internal.Float2FloatFunction_): Internal.Char2FloatFunction;
        apply(arg0: string): number;
        containsKey(arg0: any): boolean;
        containsKey(arg0: string): boolean;
        composeInt(arg0: Internal.Int2CharFunction_): Internal.Int2FloatFunction;
        clear(): void;
        composeFloat(arg0: Internal.Float2CharFunction_): Internal.Float2FloatFunction;
        andThenChar(arg0: Internal.Float2CharFunction_): Internal.Char2CharFunction;
        composeObject<T_>(arg0: Internal.Object2CharFunction_<T_>): Internal.Object2FloatFunction<T_>;
        size(): number;
        compose<T_>(arg0: java_.util.function_.Function_<T_, string>): java_.util.function_.Function<T_, number>;
        composeShort(arg0: Internal.Short2CharFunction_): Internal.Short2FloatFunction;
        andThenReference<T_>(arg0: Internal.Float2ReferenceFunction_<T_>): Internal.Char2ReferenceFunction<T_>;
        composeChar(arg0: Internal.Char2CharFunction_): Internal.Char2FloatFunction;
        composeDouble(arg0: Internal.Double2CharFunction_): Internal.Double2FloatFunction;
    }
    type Char2FloatFunction_ = ((arg0: string) => number) | Char2FloatFunction;
    class MenuShortcut implements Internal.Serializable {
        getClass(): Internal.Class<any>;
        getKey(): number;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        usesShiftModifier(): boolean;
        hashCode(): number;
        notifyAll(): void;
        equals(arg0: Internal.MenuShortcut_): boolean;
        equals(arg0: any): boolean;
        toString(): string;
        notify(): void;
        get class(): Internal.Class<any>;
        get key(): number;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    type MenuShortcut_ = MenuShortcut;
    interface Transferable {
        isDataFlavorSupported(arg0: Internal.DataFlavor_): boolean;
        getTransferData(arg0: Internal.DataFlavor_): any;
        getTransferDataFlavors(): Internal.DataFlavor[];
    }
    type Transferable_ = Transferable;
    interface Chronology extends Internal.Comparable<Internal.Chronology> {
        localDateTime(arg0: Internal.TemporalAccessor_): Internal.ChronoLocalDateTime<Internal.ChronoLocalDate>;
        date(arg0: number, arg1: number, arg2: number): Internal.ChronoLocalDate;
        date(arg0: Internal.TemporalAccessor_): Internal.ChronoLocalDate;
        date(arg0: Internal.Era_, arg1: number, arg2: number, arg3: number): Internal.ChronoLocalDate;
        period(arg0: number, arg1: number, arg2: number): Internal.ChronoPeriod;
        dateYearDay(arg0: Internal.Era_, arg1: number, arg2: number): Internal.ChronoLocalDate;
        dateYearDay(arg0: number, arg1: number): Internal.ChronoLocalDate;
        getCalendarType(): string;
        resolveDate(arg0: Internal.Map_<Internal.TemporalField_, number>, arg1: Internal.ResolverStyle_): Internal.ChronoLocalDate;
        isLeapYear(arg0: number): boolean;
        range(arg0: Internal.ChronoField_): Internal.ValueRange;
        dateEpochDay(arg0: number): Internal.ChronoLocalDate;
        getId(): string;
        compareTo(arg0: Internal.Chronology_): number;
        dateNow(): Internal.ChronoLocalDate;
        dateNow(arg0: Internal.ZoneId_): Internal.ChronoLocalDate;
        dateNow(arg0: Internal.Clock_): Internal.ChronoLocalDate;
        eraOf(arg0: number): Internal.Era;
        eras(): Internal.List<Internal.Era>;
        prolepticYear(arg0: Internal.Era_, arg1: number): number;
        zonedDateTime(arg0: Internal.TemporalAccessor_): Internal.ChronoZonedDateTime<Internal.ChronoLocalDate>;
        zonedDateTime(arg0: Internal.Instant_, arg1: Internal.ZoneId_): Internal.ChronoZonedDateTime<Internal.ChronoLocalDate>;
        getDisplayName(arg0: Internal.TextStyle_, arg1: Internal.Locale_): string;
        hashCode(): number;
        equals(arg0: any): boolean;
        epochSecond(arg0: number, arg1: number, arg2: number, arg3: number, arg4: number, arg5: number, arg6: Internal.ZoneOffset_): number;
        epochSecond(arg0: Internal.Era_, arg1: number, arg2: number, arg3: number, arg4: number, arg5: number, arg6: number, arg7: Internal.ZoneOffset_): number;
        toString(): string;
    }
    type Chronology_ = Chronology;
    abstract class LevelJS implements Internal.WithAttachedData {
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        getPlayer(entity: Internal.Entity_): Internal.PlayerJS<any>;
        getEntitiesWithin(aabb: Internal.AABB_): Internal.EntityArrayList;
        getPlayerData(arg0: Internal.Player_): Internal.PlayerDataJS<any, any>;
        spawnFireworks(x: number, y: number, z: number, f: Internal.FireworksJS_): void;
        getTime(): number;
        notifyAll(): void;
        getSide(): Internal.ScriptType;
        getGameRules(): Internal.GameRulesJS;
        notify(): void;
        setRainStrength(strength: number): void;
        hashCode(): number;
        getDimension(): string;
        isDaytime(): boolean;
        createEntityList(entities: Internal.Collection_<Internal.Entity_>): Internal.EntityArrayList;
        getPlayers(): Internal.EntityArrayList;
        getData(): Internal.AttachedData;
        getMinecraftLevel(): Internal.Level;
        getServer(): Internal.ServerJS;
        getLivingEntity(entity: Internal.Entity_): Internal.LivingEntityJS;
        getBlock(x: number, y: number, z: number): Internal.BlockContainerJS;
        getBlock(pos: BlockPos_): Internal.BlockContainerJS;
        getBlock(blockEntity: Internal.BlockEntity_): Internal.BlockContainerJS;
        isOverworld(): boolean;
        createExplosion(x: number, y: number, z: number): Internal.ExplosionJS;
        getEntity(e: Internal.Entity_): Internal.EntityJS;
        createEntity(id: ResourceLocation_): Internal.EntityJS;
        spawnLightning(x: number, y: number, z: number, effectOnly: boolean, player: Internal.EntityJS_): void;
        spawnLightning(x: number, y: number, z: number, effectOnly: boolean): void;
        getLocalTime(): number;
        equals(arg0: any): boolean;
        isThundering(): boolean;
        getEntities(): Internal.EntityArrayList;
        toString(): string;
        isRaining(): boolean;
        readonly minecraftLevel : Internal.Level;
        get server(): Internal.ServerJS;
        get side(): Internal.ScriptType;
        get data(): Internal.AttachedData;
        get players(): Internal.EntityArrayList;
        get raining(): boolean;
        get thundering(): boolean;
        get overworld(): boolean;
        get gameRules(): Internal.GameRulesJS;
        get localTime(): number;
        get entities(): Internal.EntityArrayList;
        get time(): number;
        get class(): Internal.Class<any>;
        get dimension(): string;
        get daytime(): boolean;
        set rainStrength(strength: number);
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    type LevelJS_ = LevelJS;
    class DataFlavor implements Internal.Externalizable, Internal.Cloneable {
        isFlavorJavaFileListType(): boolean;
        getClass(): Internal.Class<any>;
        static getTextPlainUnicodeFlavor(): Internal.DataFlavor;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        getDefaultRepresentationClass(): Internal.Class<any>;
        getPrimaryType(): string;
        notifyAll(): void;
        getSubType(): string;
        isMimeTypeEqual(arg0: string): boolean;
        isMimeTypeEqual(arg0: Internal.DataFlavor_): boolean;
        notify(): void;
        hashCode(): number;
        isRepresentationClassSerializable(): boolean;
        getDefaultRepresentationClassAsString(): string;
        isRepresentationClassCharBuffer(): boolean;
        isRepresentationClassByteBuffer(): boolean;
        getParameter(arg0: string): string;
        static selectBestTextFlavor(arg0: Internal.DataFlavor_[]): Internal.DataFlavor;
        writeExternal(arg0: Internal.ObjectOutput_): void;
        setHumanPresentableName(arg0: string): void;
        isMimeTypeSerializedObject(): boolean;
        getMimeType(): string;
        getReaderForText(arg0: Internal.Transferable_): Internal.Reader;
        match(arg0: Internal.DataFlavor_): boolean;
        isFlavorTextType(): boolean;
        isFlavorSerializedObjectType(): boolean;
        getHumanPresentableName(): string;
        getRepresentationClass(): Internal.Class<any>;
        isRepresentationClassInputStream(): boolean;
        isFlavorRemoteObjectType(): boolean;
        isRepresentationClassReader(): boolean;
        equals(arg0: any): boolean;
        equals(arg0: string): boolean;
        equals(arg0: Internal.DataFlavor_): boolean;
        readExternal(arg0: Internal.ObjectInput_): void;
        clone(): any;
        toString(): string;
        isRepresentationClassRemote(): boolean;
        static readonly javaJVMLocalObjectMimeType : "application/x-java-jvm-local-objectref";
        static readonly stringFlavor : Internal.DataFlavor;
        static readonly javaFileListFlavor : Internal.DataFlavor;
        static readonly javaSerializedObjectMimeType : "application/x-java-serialized-object";
        static readonly plainTextFlavor : Internal.DataFlavor;
        static readonly javaRemoteObjectMimeType : "application/x-java-remote-object";
        static readonly imageFlavor : Internal.DataFlavor;
        static readonly selectionHtmlFlavor : Internal.DataFlavor;
        static readonly allHtmlFlavor : Internal.DataFlavor;
        static readonly fragmentHtmlFlavor : Internal.DataFlavor;
        get representationClass(): Internal.Class<any>;
        get flavorRemoteObjectType(): boolean;
        get representationClassSerializable(): boolean;
        get mimeTypeSerializedObject(): boolean;
        get humanPresentableName(): string;
        get mimeType(): string;
        get representationClassInputStream(): boolean;
        get defaultRepresentationClassAsString(): string;
        get flavorSerializedObjectType(): boolean;
        get representationClassReader(): boolean;
        get representationClassRemote(): boolean;
        get representationClassByteBuffer(): boolean;
        get primaryType(): string;
        get textPlainUnicodeFlavor(): Internal.DataFlavor;
        get subType(): string;
        get defaultRepresentationClass(): Internal.Class<any>;
        get class(): Internal.Class<any>;
        get flavorTextType(): boolean;
        get flavorJavaFileListType(): boolean;
        get representationClassCharBuffer(): boolean;
        set humanPresentableName(arg0: string);
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    type DataFlavor_ = DataFlavor;
    interface BiomeFilter extends Internal.Predicate<Internal.BiomeModifications$BiomeContext> {
        or(arg0: Internal.Predicate_<Internal.BiomeModifications$BiomeContext_>): Internal.Predicate<Internal.BiomeModifications$BiomeContext>;
        test(arg0: Internal.BiomeModifications$BiomeContext_): boolean;
        and(arg0: Internal.Predicate_<Internal.BiomeModifications$BiomeContext_>): Internal.Predicate<Internal.BiomeModifications$BiomeContext>;
        negate(): Internal.Predicate<Internal.BiomeModifications$BiomeContext>;
    }
    type BiomeFilter_ = ((arg0: Internal.BiomeModifications$BiomeContext) => boolean) | BiomeFilter;
    interface AccessScreen {
        controlling$getRenderables(): Internal.List<Internal.Widget>;
    }
    type AccessScreen_ = AccessScreen;
    class RecipeFunction extends Internal.BaseFunction implements Internal.WrappedJS {
        getClass(): Internal.Class<any>;
        isSealed(): boolean;
        setParentScope(m: Internal.Scriptable_): void;
        static redefineProperty(obj: Internal.Scriptable_, name: string, isConst: boolean): void;
        putConst(name: string, start: Internal.Scriptable_, value: any): void;
        static getTypedProperty<T_>(s: Internal.Scriptable_, name: string, type: Internal.Class_<T_>): T_;
        static getTypedProperty<T_>(s: Internal.Scriptable_, index: number, type: Internal.Class_<T_>): T_;
        getIds(): any[];
        static getArrayPrototype(scope: Internal.Scriptable_): Internal.Scriptable;
        construct(cx: Internal.Context_, scope: Internal.Scriptable_, args: any[]): Internal.Scriptable;
        getAllIds(): any[];
        put(key: Internal.Symbol_, start: Internal.Scriptable_, value: any): void;
        put(name: string, start: Internal.Scriptable_, value: any): void;
        put(index: number, start: Internal.Scriptable_, value: any): void;
        getArity(): number;
        static getDefaultValue(object: Internal.Scriptable_, typeHint: Internal.Class_<any>): any;
        getDefaultValue(typeHint: Internal.Class_<any>): any;
        defineOwnProperties(cx: Internal.Context_, props: Internal.ScriptableObject_): void;
        defineProperty(key: Internal.Symbol_, value: any, attributes: number): void;
        defineProperty(propertyName: string, clazz: Internal.Class_<any>, attributes: number): void;
        defineProperty(propertyName: string, delegateTo: any, getter: Internal.Method_, setter: Internal.Method_, attributes: number): void;
        defineProperty(propertyName: string, value: any, attributes: number): void;
        static defineProperty(destination: Internal.Scriptable_, propertyName: string, value: any, attributes: number): void;
        hasPrototypeMap(): boolean;
        setGetterOrSetter(name: string, index: number, getterOrSetter: Internal.Callable_, isSetter: boolean): void;
        avoidObjectDetection(): boolean;
        has(key: Internal.Symbol_, start: Internal.Scriptable_): boolean;
        has(name: string, start: Internal.Scriptable_): boolean;
        has(index: number, start: Internal.Scriptable_): boolean;
        getFunctionName(): string;
        getExternalArrayLength(): any;
        getAttributes(name: string): number;
        getAttributes(key: Internal.Symbol_): number;
        getAttributes(index: number): number;
        setImmunePrototypeProperty(value: any): void;
        hasInstance(instance: Internal.Scriptable_): boolean;
        getAssociatedValue(key: any): any;
        execIdCall(f: Internal.IdFunctionObject_, cx: Internal.Context_, scope: Internal.Scriptable_, thisObj: Internal.Scriptable_, args: any[]): any;
        static getPropertyIds(obj: Internal.Scriptable_): any[];
        static hasProperty(obj: Internal.Scriptable_, name: string): boolean;
        static hasProperty(obj: Internal.Scriptable_, key: Internal.Symbol_): boolean;
        static hasProperty(obj: Internal.Scriptable_, index: number): boolean;
        getExternalArrayData(): Internal.ExternalArrayData;
        size(): number;
        initPrototypeMethod(tag: any, id: number, propertyName: string, functionName: string, arity: number): Internal.IdFunctionObject;
        initPrototypeMethod(tag: any, id: number, key: Internal.Symbol_, functionName: string, arity: number): Internal.IdFunctionObject;
        initPrototypeMethod(tag: any, id: number, name: string, arity: number): Internal.IdFunctionObject;
        defineOwnProperty(cx: Internal.Context_, key: any, desc: Internal.ScriptableObject_): void;
        initPrototypeValue(id: number, name: string, value: any, attributes: number): void;
        initPrototypeValue(id: number, key: Internal.Symbol_, value: any, attributes: number): void;
        static getFunctionPrototype(scope: Internal.Scriptable_): Internal.Scriptable;
        getClassName(): string;
        getParentScope(): Internal.Scriptable;
        preventExtensions(): void;
        setExternalArrayData(array: Internal.ExternalArrayData_): void;
        static callMethod(cx: Internal.Context_, obj: Internal.Scriptable_, methodName: string, args: any[]): any;
        static callMethod(obj: Internal.Scriptable_, methodName: string, args: any[]): any;
        enumerationIteratorNext(cx: Internal.Context_, currentId: Internal.Consumer_<any>): boolean;
        getTypeOf(): string;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        static getTopScopeValue(scope: Internal.Scriptable_, key: any): any;
        initPrototypeConstructor(f: Internal.IdFunctionObject_): void;
        notifyAll(): void;
        sealObject(): void;
        setAttributes(name: string, attributes: number): void;
        setAttributes(key: Internal.Symbol_, attributes: number): void;
        setAttributes(index: number, attributes: number): void;
        static putProperty(obj: Internal.Scriptable_, name: string, value: any): void;
        static putProperty(obj: Internal.Scriptable_, index: number, value: any): void;
        static putProperty(obj: Internal.Scriptable_, key: Internal.Symbol_, value: any): void;
        delete(key: Internal.Symbol_): void;
        delete(name: string): void;
        delete(index: number): void;
        notify(): void;
        associateValue(key: any, value: any): any;
        static deleteProperty(obj: Internal.Scriptable_, name: string): boolean;
        static deleteProperty(obj: Internal.Scriptable_, index: number): boolean;
        getPrototype(): Internal.Scriptable;
        static getObjectPrototype(scope: Internal.Scriptable_): Internal.Scriptable;
        createRecipe(args0: any[]): Internal.RecipeJS;
        isExtensible(): boolean;
        hashCode(): number;
        isConst(name: string): boolean;
        get(name: string, start: Internal.Scriptable_): any;
        get(key: Internal.Symbol_, start: Internal.Scriptable_): any;
        get(index: number, start: Internal.Scriptable_): any;
        get(key: any): any;
        static putConstProperty(obj: Internal.Scriptable_, name: string, value: any): void;
        getGetterOrSetter(name: string, index: number, isSetter: boolean): any;
        static getTopLevelScope(obj: Internal.Scriptable_): Internal.Scriptable;
        static getProperty(obj: Internal.Scriptable_, name: string): any;
        static getProperty(obj: Internal.Scriptable_, key: Internal.Symbol_): any;
        static getProperty(obj: Internal.Scriptable_, index: number): any;
        static defineClass<T_>(scope: Internal.Scriptable_, clazz: Internal.Class_<T_>, sealed: boolean): void;
        static defineClass<T_>(scope: Internal.Scriptable_, clazz: Internal.Class_<T_>): void;
        static defineClass<T_>(scope: Internal.Scriptable_, clazz: Internal.Class_<T_>, sealed: boolean, mapInheritance: boolean): string;
        activatePrototypeMap(maxPrototypeId: number): void;
        isEmpty(): boolean;
        defineFunctionProperties(names: string[], clazz: Internal.Class_<any>, attributes: number): void;
        static getClassPrototype(scope: Internal.Scriptable_, className: string): Internal.Scriptable;
        createObject(cx: Internal.Context_, scope: Internal.Scriptable_): Internal.Scriptable;
        setPrototype(m: Internal.Scriptable_): void;
        exportAsJSClass(maxPrototypeId: number, scope: Internal.Scriptable_, sealed: boolean): Internal.IdFunctionObject;
        call(cx: Internal.Context_, scope: Internal.Scriptable_, thisObj: Internal.Scriptable_, args0: any[]): Internal.RecipeJS;
        defineConst(name: string, start: Internal.Scriptable_): void;
        equals(arg0: any): boolean;
        static defineConstProperty(destination: Internal.Scriptable_, propertyName: string): void;
        getLength(): number;
        toString(): string;
        enumerationIteratorHasNext(cx: Internal.Context_, currentId: Internal.Consumer_<any>): boolean;
        static getGeneratorFunctionPrototype(scope: Internal.Scriptable_): Internal.Scriptable;
        static readonly DONTENUM : 2;
        static readonly CONST : 13;
        static readonly NOT_FOUND : any;
        static readonly UNINITIALIZED_CONST : 8;
        readonly typeID : ResourceLocation;
        readonly type : Internal.RecipeTypeJS;
        static readonly EMPTY : 0;
        static readonly READONLY : 1;
        static readonly PERMANENT : 4;
        get functionName(): string;
        get sealed(): boolean;
        get externalArrayData(): Internal.ExternalArrayData;
        get length(): number;
        get className(): string;
        get prototype(): Internal.Scriptable;
        get empty(): boolean;
        get arity(): number;
        get parentScope(): Internal.Scriptable;
        get ids(): any[];
        get externalArrayLength(): any;
        get class(): Internal.Class<any>;
        get allIds(): any[];
        get extensible(): boolean;
        get typeOf(): string;
        set immunePrototypeProperty(value: any);
        set externalArrayData(array: Internal.ExternalArrayData_);
        set parentScope(m: Internal.Scriptable_);
        set prototype(m: Internal.Scriptable_);
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    type RecipeFunction_ = RecipeFunction;
    class JsonWriter implements Internal.Closeable, Internal.Flushable {
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        setSerializeNulls(arg0: boolean): void;
        setHtmlSafe(arg0: boolean): void;
        jsonValue(arg0: string): Internal.JsonWriter;
        isLenient(): boolean;
        notifyAll(): void;
        endArray(): Internal.JsonWriter;
        nullValue(): Internal.JsonWriter;
        setLenient(arg0: boolean): void;
        notify(): void;
        endObject(): Internal.JsonWriter;
        beginArray(): Internal.JsonWriter;
        flush(): void;
        beginObject(): Internal.JsonWriter;
        hashCode(): number;
        equals(arg0: any): boolean;
        getSerializeNulls(): boolean;
        setIndent(arg0: string): void;
        name(arg0: string): Internal.JsonWriter;
        toString(): string;
        isHtmlSafe(): boolean;
        close(): void;
        value(arg0: boolean): Internal.JsonWriter;
        value(arg0: number): Internal.JsonWriter;
        value(arg0: string): Internal.JsonWriter;
        value(arg0: Internal.Number_): Internal.JsonWriter;
        get serializeNulls(): boolean;
        get class(): Internal.Class<any>;
        get lenient(): boolean;
        get htmlSafe(): boolean;
        set serializeNulls(arg0: boolean);
        set indent(arg0: string);
        set lenient(arg0: boolean);
        set htmlSafe(arg0: boolean);
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    type JsonWriter_ = JsonWriter;
    interface VertexSink {
        flush(): void;
        ensureCapacity(arg0: number): void;
        getVertexCount(): number;
    }
    type VertexSink_ = VertexSink;
    interface ChronoLocalDateTime <D> extends Internal.Temporal, Internal.TemporalAdjuster, Internal.Comparable<Internal.ChronoLocalDateTime<any>> {
        minus(arg0: Internal.TemporalAmount_): Internal.ChronoLocalDateTime<D>;
        minus(arg0: number, arg1: Internal.TemporalUnit_): Internal.ChronoLocalDateTime<D>;
        isEqual(arg0: Internal.ChronoLocalDateTime_<any>): boolean;
        toLocalTime(): Internal.LocalTime;
        adjustInto(arg0: Internal.Temporal_): Internal.Temporal;
        range(arg0: Internal.TemporalField_): Internal.ValueRange;
        compareTo(arg0: Internal.ChronoLocalDateTime_<any>): number;
        hashCode(): number;
        get(arg0: Internal.TemporalField_): number;
        getChronology(): Internal.Chronology;
        query<R_>(arg0: Internal.TemporalQuery_<R_>): R_;
        format(arg0: Internal.DateTimeFormatter_): string;
        isSupported(arg0: Internal.TemporalUnit_): boolean;
        isSupported(arg0: Internal.TemporalField_): boolean;
        atZone(arg0: Internal.ZoneId_): Internal.ChronoZonedDateTime<D>;
        toInstant(arg0: Internal.ZoneOffset_): Internal.Instant;
        isBefore(arg0: Internal.ChronoLocalDateTime_<any>): boolean;
        plus(arg0: number, arg1: Internal.TemporalUnit_): Internal.ChronoLocalDateTime<D>;
        plus(arg0: Internal.TemporalAmount_): Internal.ChronoLocalDateTime<D>;
        getLong(arg0: Internal.TemporalField_): number;
        with(arg0: Internal.TemporalField_, arg1: number): Internal.ChronoLocalDateTime<D>;
        with(arg0: Internal.TemporalAdjuster_): Internal.ChronoLocalDateTime<D>;
        toLocalDate(): D;
        toEpochSecond(arg0: Internal.ZoneOffset_): number;
        equals(arg0: any): boolean;
        until(arg0: Internal.Temporal_, arg1: Internal.TemporalUnit_): number;
        toString(): string;
        isAfter(arg0: Internal.ChronoLocalDateTime_<any>): boolean;
    }
    type ChronoLocalDateTime_<D> = ChronoLocalDateTime<D>;
    /**
    */
    class SwordItemBuilder extends Internal.HandheldItemBuilder {
        barWidth(barWidth: Internal.ToIntFunction_<Internal.ItemStackJS_>): Internal.ItemBuilder;
        getClass(): Internal.Class<any>;
        maxStackSize(v: number): Internal.ItemBuilder;
        translationKey(key: string): Internal.BuilderBase<Internal.Item>;
        newID(pre: string, post: string): ResourceLocation;
        use(use: Internal.ItemBuilder$UseCallback_): Internal.ItemBuilder;
        maxDamage(v: number): Internal.ItemBuilder;
        textureJson(json: Internal.JsonObject_): Internal.ItemBuilder;
        tooltip(text: Internal.Component_): Internal.ItemBuilder;
        modifyTier(callback: Internal.Consumer_<Internal.MutableToolTier_>): Internal.HandheldItemBuilder;
        type(type: string): Internal.BuilderBase<Internal.Item>;
        containerItem(id: string): Internal.ItemBuilder;
        subtypes(fn: java_.util.function_.Function_<Internal.ItemStackJS_, Internal.Collection_<Internal.ItemStackJS_>>): Internal.ItemBuilder;
        modelJson(json: Internal.JsonObject_): Internal.ItemBuilder;
        burnTime(v: number): Internal.ItemBuilder;
        useDuration(useDuration: Internal.ToIntFunction_<Internal.ItemStackJS_>): Internal.ItemBuilder;
        tag(tag: ResourceLocation_): Internal.BuilderBase<Internal.Item>;
        parentModel(m: string): Internal.ItemBuilder;
        generateDataJsons(generator: Internal.DataJsonGenerator_): void;
        group(g: string): Internal.ItemBuilder;
        static ofArmorMaterial(o: any): Internal.ArmorMaterial;
        /**
        */
        modifyAttribute(attribute: net.minecraft.world.entity.ai.attributes.Attribute_, identifier: string, d: number, operation: Internal.AttributeModifier$Operation_): Internal.ItemBuilder;
        getRegistryType(): Internal.RegistryObjectBuilderTypes<Internal.Item>;
        attackDamageBonus(f: number): Internal.HandheldItemBuilder;
        glow(v: boolean): Internal.ItemBuilder;
        useAnimation(animation: Internal.UseAnim_): Internal.ItemBuilder;
        rarity(v: Rarity_): Internal.ItemBuilder;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        clientRegistry(minecraft: Internal.Minecraft_): void;
        transformObject(obj: Internal.Item_): Internal.Item;
        color(callback: Internal.ItemBuilder$ItemColorJS_): Internal.ItemBuilder;
        color(index: number, c: Internal.Color_): Internal.ItemBuilder;
        displayName(name: string): Internal.BuilderBase<Internal.Item>;
        notifyAll(): void;
        barColor(barColor: java_.util.function_.Function_<Internal.ItemStackJS_, Internal.Color_>): Internal.ItemBuilder;
        notify(): void;
        createAdditionalObjects(): void;
        speed(f: number): Internal.HandheldItemBuilder;
        tier(t: Internal.Tier_): Internal.HandheldItemBuilder;
        hashCode(): number;
        get(): Internal.Item;
        speedBaseline(f: number): Internal.HandheldItemBuilder;
        generateAssetJsons(generator: Internal.AssetJsonGenerator_): void;
        getTranslationKeyGroup(): string;
        texture(key: string, tex: string): Internal.ItemBuilder;
        texture(tex: string): Internal.ItemBuilder;
        generateLang(lang: Internal.Map_<string, string>): void;
        food(b: Internal.Consumer_<Internal.FoodBuilder_>): Internal.ItemBuilder;
        createObject(): Internal.Item;
        releaseUsing(releaseUsing: Internal.ItemBuilder$ReleaseUsingCallback_): Internal.ItemBuilder;
        attackDamageBaseline(f: number): Internal.HandheldItemBuilder;
        unstackable(): Internal.ItemBuilder;
        addResourcePackLocations(path: string, list: Internal.List_<ResourceLocation_>, packType: Internal.PackType_): void;
        equals(arg0: any): boolean;
        toString(): string;
        finishUsing(finishUsing: Internal.ItemBuilder$FinishUsingCallback_): Internal.ItemBuilder;
        createItemProperties(): Internal.Item$Properties;
        static readonly TOOL_TIERS : {"gold":any,"diamond":any,"iron":any,"wood":any,"stone":any,"netherite":any};
        static readonly ARMOR_TIERS : {"gold":any,"chain":any,"diamond":any,"turtle":any,"iron":any,"leather":any,"netherite":any};
        readonly id : ResourceLocation;
        get registryType(): Internal.RegistryObjectBuilderTypes<Internal.Item>;
        get class(): Internal.Class<any>;
        get translationKeyGroup(): string;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    /**
    */
    type SwordItemBuilder_ = SwordItemBuilder;
    interface ConfigParser <C> {
        getFormat(): Internal.ConfigFormat<C>;
        parse(arg0: Internal.Path_, arg1: Internal.FileNotFoundAction_): C;
        parse(arg0: Internal.File_, arg1: Internal.Config_, arg2: Internal.ParsingMode_, arg3: Internal.FileNotFoundAction_, arg4: Internal.Charset_): void;
        parse(arg0: Internal.File_, arg1: Internal.Config_, arg2: Internal.ParsingMode_, arg3: Internal.FileNotFoundAction_): void;
        parse(arg0: Internal.File_, arg1: Internal.FileNotFoundAction_, arg2: Internal.Charset_): C;
        parse(arg0: Internal.URL_, arg1: Internal.Config_, arg2: Internal.ParsingMode_): void;
        parse(arg0: Internal.URL_): C;
        parse(arg0: Internal.Path_, arg1: Internal.Config_, arg2: Internal.ParsingMode_, arg3: Internal.FileNotFoundAction_, arg4: Internal.Charset_): void;
        parse(arg0: Internal.Path_, arg1: Internal.Config_, arg2: Internal.ParsingMode_, arg3: Internal.FileNotFoundAction_): void;
        parse(arg0: Internal.Path_, arg1: Internal.FileNotFoundAction_, arg2: Internal.Charset_): C;
        parse(arg0: string, arg1: Internal.Config_, arg2: Internal.ParsingMode_): void;
        parse(arg0: string): C;
        parse(arg0: Internal.Reader_, arg1: Internal.Config_, arg2: Internal.ParsingMode_): void;
        parse(arg0: Internal.Reader_): C;
        parse(arg0: Internal.File_, arg1: Internal.FileNotFoundAction_): C;
        parse(arg0: Internal.InputStream_, arg1: Internal.Config_, arg2: Internal.ParsingMode_, arg3: Internal.Charset_): void;
        parse(arg0: Internal.InputStream_, arg1: Internal.Config_, arg2: Internal.ParsingMode_): void;
        parse(arg0: Internal.InputStream_, arg1: Internal.Charset_): C;
        parse(arg0: Internal.InputStream_): C;
    }
    type ConfigParser_<C> = ConfigParser<C>;
    class MultiblockState {
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        getWorld(): Internal.Level;
        getMatchContext(): Internal.PatternMatchContext;
        onChunkLoad(): void;
        notifyAll(): void;
        onChunkUnload(): void;
        update(arg0: BlockPos_, arg1: Internal.TraceabilityPredicate_): boolean;
        onBlockStateChanged(arg0: BlockPos_): void;
        notify(): void;
        hashCode(): number;
        getPos(): BlockPos;
        getTileEntity(): Internal.BlockEntity;
        deserialize(arg0: Internal.FriendlyByteBuf_): void;
        isFormed(): boolean;
        isPosInCache(arg0: BlockPos_): boolean;
        clean(): void;
        getController(): Internal.ControllerTileEntity;
        addPosCache(arg0: BlockPos_): void;
        serialize(arg0: Internal.FriendlyByteBuf_): void;
        getCache(): Internal.Collection<BlockPos>;
        getOffsetState(arg0: Internal.Direction_): Internal.BlockState;
        setError(arg0: Internal.PatternError_): void;
        equals(arg0: any): boolean;
        toString(): string;
        getBlockState(): Internal.BlockState;
        cache : Internal.LongOpenHashSet;
        tileEntityInitialized : boolean;
        io : Internal.IO;
        globalCount : Internal.Map<Internal.SimplePredicate, number>;
        lastController : Internal.ControllerTileEntity;
        error : Internal.PatternError;
        static readonly UNLOAD_ERROR : Internal.PatternError;
        predicate : Internal.TraceabilityPredicate;
        readonly controllerPos : BlockPos;
        readonly world : Internal.Level;
        pos : BlockPos;
        static readonly UNINIT_ERROR : Internal.PatternError;
        matchContext : Internal.PatternMatchContext;
        state : Internal.BlockState;
        tileEntity : Internal.BlockEntity;
        get blockState(): Internal.BlockState;
        get controller(): Internal.ControllerTileEntity;
        get formed(): boolean;
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    type MultiblockState_ = MultiblockState;
    class BufferBuilder extends Internal.DefaultedVertexConsumer implements Internal.BufferVertexConsumer, Internal.VertexDrain, Internal.VertexBufferView, Internal.MemoryTrackingBuffer, Internal.BufferBuilderExt, Internal.BlockSensitiveBufferBuilder {
        getClass(): Internal.Class<any>;
        ensureBufferCapacity(bytes: number): boolean;
        applyBakedLighting(arg0: number, arg1: Internal.ByteBuffer_): number;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        setupBufferSlice(arg0: Internal.ByteBuffer_, arg1: Internal.BufferBuilder$DrawState_): void;
        putInt(arg0: number, arg1: number): void;
        getUsedSize(): number;
        notifyAll(): void;
        beginBlock(arg0: number, arg1: number): void;
        splitStrip(): void;
        notify(): void;
        endBlock(): void;
        createSink(factory: Internal.VertexType_<any>): Internal.VertexSink;
        flush(vertexCount: number, format: Internal.BufferVertexFormat_): void;
        getWriterPosition(): number;
        hashCode(): number;
        equals(arg0: any): boolean;
        redirect$zhd000$debugGetNextBuffer(buffer: Internal.ByteBuffer_, newLimit: number): Internal.ByteBuffer;
        teardownBufferSlice(): void;
        toString(): string;
        getAllocatedSize(): number;
        putBulkData(arg0: Internal.ByteBuffer_): void;
        putBulkData(arg0: Internal.PoseStack$Pose_, arg1: Internal.BakedQuad_, arg2: number[], arg3: number, arg4: number, arg5: number, arg6: number, arg7: number[], arg8: number, arg9: boolean): void;
        putBulkData(arg0: Internal.PoseStack$Pose_, arg1: Internal.BakedQuad_, arg2: number, arg3: number, arg4: number, arg5: number, arg6: number, arg7: number, arg8: boolean): void;
        putBulkData(arg0: Internal.PoseStack$Pose_, arg1: Internal.BakedQuad_, arg2: number, arg3: number, arg4: number, arg5: number, arg6: number, arg7: number): void;
        putBulkData(arg0: Internal.PoseStack$Pose_, arg1: Internal.BakedQuad_, arg2: number, arg3: number, arg4: number, arg5: number, arg6: number, arg7: boolean): void;
        getVertexFormat(): Internal.BufferVertexFormat;
        getVertexFormat(): Internal.VertexFormat;
        applyBakedNormals(arg0: Internal.Vector3f_, arg1: Internal.ByteBuffer_, arg2: Internal.Matrix3f_): void;
        getDirectBuffer(): Internal.ByteBuffer;
        get allocatedSize(): number;
        get vertexFormat(): Internal.VertexFormat;
        get writerPosition(): number;
        get directBuffer(): Internal.ByteBuffer;
        get usedSize(): number;
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    type BufferBuilder_ = BufferBuilder;
    class ContextFactory {
        enterContext(cx: Internal.Context_): Internal.Context;
        enterContext(): Internal.Context;
        getClass(): Internal.Class<any>;
        isSealed(): boolean;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        notifyAll(): void;
        seal(): void;
        getApplicationClassLoader(): Internal.ClassLoader;
        removeListener(listener: Internal.ContextFactory$Listener_): void;
        notify(): void;
        call<T>(action: Internal.ContextAction_<T>): T;
        hashCode(): number;
        equals(arg0: any): boolean;
        static getGlobal(): Internal.ContextFactory;
        toString(): string;
        addListener(listener: Internal.ContextFactory$Listener_): void;
        get sealed(): boolean;
        get applicationClassLoader(): Internal.ClassLoader;
        get global(): Internal.ContextFactory;
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    type ContextFactory_ = ContextFactory;
    class VillagerTypeBuilder extends Internal.BuilderBase<Internal.VillagerType> {
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        clientRegistry(minecraft: Internal.Minecraft_): void;
        generateAssetJsons(generator: Internal.AssetJsonGenerator_): void;
        transformObject(obj: Internal.VillagerType_): Internal.VillagerType;
        translationKey(key: string): Internal.BuilderBase<Internal.VillagerType>;
        getTranslationKeyGroup(): string;
        newID(pre: string, post: string): ResourceLocation;
        displayName(name: string): Internal.BuilderBase<Internal.VillagerType>;
        notifyAll(): void;
        generateLang(lang: Internal.Map_<string, string>): void;
        type(type: string): Internal.BuilderBase<Internal.VillagerType>;
        notify(): void;
        createAdditionalObjects(): void;
        createObject(): Internal.VillagerType;
        addResourcePackLocations(path: string, list: Internal.List_<ResourceLocation_>, packType: Internal.PackType_): void;
        hashCode(): number;
        equals(arg0: any): boolean;
        get(): Internal.VillagerType;
        getRegistryType(): Internal.RegistryObjectBuilderTypes<Internal.VillagerType>;
        toString(): string;
        tag(tag: ResourceLocation_): Internal.BuilderBase<Internal.VillagerType>;
        generateDataJsons(generator: Internal.DataJsonGenerator_): void;
        readonly id : ResourceLocation;
        get registryType(): Internal.RegistryObjectBuilderTypes<Internal.VillagerType>;
        get class(): Internal.Class<any>;
        get translationKeyGroup(): string;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    type VillagerTypeBuilder_ = VillagerTypeBuilder;
    class IntervalJS {
        matchesSqr(arg0: number): boolean;
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        max(arg0: number): Internal.IntervalJS;
        notifyAll(): void;
        getVanillaInt(): Internal.MinMaxBounds$Ints;
        getVanillaDoubles(): Internal.MinMaxBounds$Doubles;
        matches(arg0: number): boolean;
        notify(): void;
        static ofInt(arg0: any): Internal.MinMaxBounds$Ints;
        min(arg0: number): Internal.IntervalJS;
        hashCode(): number;
        equals(arg0: any): boolean;
        toString(): string;
        between(arg0: number, arg1: number): Internal.IntervalJS;
        static ofDoubles(arg0: any): Internal.MinMaxBounds$Doubles;
        get vanillaInt(): Internal.MinMaxBounds$Ints;
        get vanillaDoubles(): Internal.MinMaxBounds$Doubles;
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    type IntervalJS_ = IntervalJS;
    class LocalDateTime implements Internal.Temporal, Internal.TemporalAdjuster, Internal.ChronoLocalDateTime<Internal.LocalDate>, Internal.Serializable {
        static ofEpochSecond(arg0: number, arg1: number, arg2: Internal.ZoneOffset_): Internal.LocalDateTime;
        getClass(): Internal.Class<any>;
        plusHours(arg0: number): Internal.LocalDateTime;
        isEqual(arg0: Internal.ChronoLocalDateTime_<any>): boolean;
        toLocalTime(): Internal.LocalTime;
        compareTo(arg0: Internal.ChronoLocalDateTime_<any>): number;
        getDayOfWeek(): Internal.DayOfWeek;
        plusSeconds(arg0: number): Internal.LocalDateTime;
        getMinute(): number;
        static from(arg0: Internal.TemporalAccessor_): Internal.LocalDateTime;
        getMonth(): Internal.Month;
        plusNanos(arg0: number): Internal.LocalDateTime;
        withHour(arg0: number): Internal.LocalDateTime;
        plusMonths(arg0: number): Internal.LocalDateTime;
        plusYears(arg0: number): Internal.LocalDateTime;
        truncatedTo(arg0: Internal.TemporalUnit_): Internal.LocalDateTime;
        query<R_>(arg0: Internal.TemporalQuery_<R_>): R_;
        minusNanos(arg0: number): Internal.LocalDateTime;
        getNano(): number;
        format(arg0: Internal.DateTimeFormatter_): string;
        isSupported(arg0: Internal.TemporalUnit_): boolean;
        isSupported(arg0: Internal.TemporalField_): boolean;
        plus(arg0: number, arg1: Internal.TemporalUnit_): Internal.LocalDateTime;
        plus(arg0: Internal.TemporalAmount_): Internal.LocalDateTime;
        getYear(): number;
        toEpochSecond(arg0: Internal.ZoneOffset_): number;
        withDayOfMonth(arg0: number): Internal.LocalDateTime;
        withMonth(arg0: number): Internal.LocalDateTime;
        isAfter(arg0: Internal.ChronoLocalDateTime_<any>): boolean;
        static ofInstant(arg0: Internal.Instant_, arg1: Internal.ZoneId_): Internal.LocalDateTime;
        minus(arg0: number, arg1: Internal.TemporalUnit_): Internal.LocalDateTime;
        minus(arg0: Internal.TemporalAmount_): Internal.LocalDateTime;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        minusHours(arg0: number): Internal.LocalDateTime;
        notifyAll(): void;
        adjustInto(arg0: Internal.Temporal_): Internal.Temporal;
        range(arg0: Internal.TemporalField_): Internal.ValueRange;
        withYear(arg0: number): Internal.LocalDateTime;
        plusMinutes(arg0: number): Internal.LocalDateTime;
        notify(): void;
        minusMinutes(arg0: number): Internal.LocalDateTime;
        plusDays(arg0: number): Internal.LocalDateTime;
        hashCode(): number;
        static now(): Internal.LocalDateTime;
        static now(arg0: Internal.Clock_): Internal.LocalDateTime;
        static now(arg0: Internal.ZoneId_): Internal.LocalDateTime;
        static of(arg0: number, arg1: Internal.Month_, arg2: number, arg3: number, arg4: number, arg5: number, arg6: number): Internal.LocalDateTime;
        static of(arg0: number, arg1: Internal.Month_, arg2: number, arg3: number, arg4: number, arg5: number): Internal.LocalDateTime;
        static of(arg0: number, arg1: Internal.Month_, arg2: number, arg3: number, arg4: number): Internal.LocalDateTime;
        static of(arg0: number, arg1: number, arg2: number, arg3: number, arg4: number, arg5: number, arg6: number): Internal.LocalDateTime;
        static of(arg0: number, arg1: number, arg2: number, arg3: number, arg4: number, arg5: number): Internal.LocalDateTime;
        static of(arg0: number, arg1: number, arg2: number, arg3: number, arg4: number): Internal.LocalDateTime;
        static of(arg0: Internal.LocalDate_, arg1: Internal.LocalTime_): Internal.LocalDateTime;
        get(arg0: Internal.TemporalField_): number;
        getDayOfYear(): number;
        plusWeeks(arg0: number): Internal.LocalDateTime;
        getHour(): number;
        getChronology(): Internal.Chronology;
        withMinute(arg0: number): Internal.LocalDateTime;
        getMonthValue(): number;
        minusYears(arg0: number): Internal.LocalDateTime;
        atOffset(arg0: Internal.ZoneOffset_): Internal.OffsetDateTime;
        minusWeeks(arg0: number): Internal.LocalDateTime;
        withDayOfYear(arg0: number): Internal.LocalDateTime;
        static parse(arg0: Internal.CharSequence_, arg1: Internal.DateTimeFormatter_): Internal.LocalDateTime;
        static parse(arg0: Internal.CharSequence_): Internal.LocalDateTime;
        atZone(arg0: Internal.ZoneId_): Internal.ZonedDateTime;
        toInstant(arg0: Internal.ZoneOffset_): Internal.Instant;
        isBefore(arg0: Internal.ChronoLocalDateTime_<any>): boolean;
        minusDays(arg0: number): Internal.LocalDateTime;
        withNano(arg0: number): Internal.LocalDateTime;
        getLong(arg0: Internal.TemporalField_): number;
        minusMonths(arg0: number): Internal.LocalDateTime;
        with(arg0: Internal.TemporalAdjuster_): Internal.LocalDateTime;
        with(arg0: Internal.TemporalField_, arg1: number): Internal.LocalDateTime;
        toLocalDate(): Internal.LocalDate;
        equals(arg0: any): boolean;
        getSecond(): number;
        until(arg0: Internal.Temporal_, arg1: Internal.TemporalUnit_): number;
        toString(): string;
        getDayOfMonth(): number;
        minusSeconds(arg0: number): Internal.LocalDateTime;
        withSecond(arg0: number): Internal.LocalDateTime;
        static readonly MIN : Internal.LocalDateTime;
        static readonly MAX : Internal.LocalDateTime;
        get dayOfWeek(): Internal.DayOfWeek;
        get month(): Internal.Month;
        get hour(): number;
        get year(): number;
        get dayOfYear(): number;
        get dayOfMonth(): number;
        get monthValue(): number;
        get nano(): number;
        get chronology(): Internal.Chronology;
        get class(): Internal.Class<any>;
        get minute(): number;
        get second(): number;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    type LocalDateTime_ = LocalDateTime;
    class RenderBuffers implements Internal.DrawCallTrackingRenderBuffers, Internal.RenderBuffersExt, Internal.MemoryTrackingRenderBuffers, Internal.AccessorRenderBuffers {
        getClass(): Internal.Class<any>;
        getMiscBufferAllocatedSize(): number;
        endLevelRendering(): void;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        getDrawCalls(): number;
        notifyAll(): void;
        beginLevelRendering(): void;
        getEntityBufferAllocatedSize(): number;
        notify(): void;
        resetDrawCounts(): void;
        hashCode(): number;
        getMaxBegins(): number;
        equals(arg0: any): boolean;
        getRenderTypes(): number;
        toString(): string;
        get renderTypes(): number;
        get entityBufferAllocatedSize(): number;
        get miscBufferAllocatedSize(): number;
        get class(): Internal.Class<any>;
        get drawCalls(): number;
        get maxBegins(): number;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    type RenderBuffers_ = RenderBuffers;
    class ZoneOffsetTransitionRule implements Internal.Serializable {
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        notifyAll(): void;
        getOffsetAfter(): Internal.ZoneOffset;
        getOffsetBefore(): Internal.ZoneOffset;
        notify(): void;
        isMidnightEndOfDay(): boolean;
        getDayOfWeek(): Internal.DayOfWeek;
        getLocalTime(): Internal.LocalTime;
        hashCode(): number;
        static of(arg0: Internal.Month_, arg1: number, arg2: Internal.DayOfWeek_, arg3: Internal.LocalTime_, arg4: boolean, arg5: Internal.ZoneOffsetTransitionRule$TimeDefinition_, arg6: Internal.ZoneOffset_, arg7: Internal.ZoneOffset_, arg8: Internal.ZoneOffset_): Internal.ZoneOffsetTransitionRule;
        equals(arg0: any): boolean;
        getStandardOffset(): Internal.ZoneOffset;
        toString(): string;
        createTransition(arg0: number): Internal.ZoneOffsetTransition;
        getTimeDefinition(): Internal.ZoneOffsetTransitionRule$TimeDefinition;
        getMonth(): Internal.Month;
        getDayOfMonthIndicator(): number;
        get localTime(): Internal.LocalTime;
        get dayOfWeek(): Internal.DayOfWeek;
        get dayOfMonthIndicator(): number;
        get midnightEndOfDay(): boolean;
        get standardOffset(): Internal.ZoneOffset;
        get month(): Internal.Month;
        get timeDefinition(): Internal.ZoneOffsetTransitionRule$TimeDefinition;
        get offsetAfter(): Internal.ZoneOffset;
        get class(): Internal.Class<any>;
        get offsetBefore(): Internal.ZoneOffset;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    type ZoneOffsetTransitionRule_ = ZoneOffsetTransitionRule;
    abstract class PermissionCollection implements Internal.Serializable {
        add(arg0: Internal.Permission_): void;
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        elementsAsStream(): Internal.Stream<Internal.Permission>;
        isReadOnly(): boolean;
        hashCode(): number;
        notifyAll(): void;
        equals(arg0: any): boolean;
        elements(): Internal.Enumeration<Internal.Permission>;
        toString(): string;
        implies(arg0: Internal.Permission_): boolean;
        notify(): void;
        setReadOnly(): void;
        get readOnly(): boolean;
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    type PermissionCollection_ = PermissionCollection;
    interface DraggableScrollableWidgetGroup$ISelected {
        onUnSelected(): void;
        onSelected(): void;
        allowSelected(arg0: number, arg1: number, arg2: number): boolean;
    }
    type DraggableScrollableWidgetGroup$ISelected_ = DraggableScrollableWidgetGroup$ISelected;
    interface ClimateProperties {
        getDownfall(): number;
        getTemperatureModifier(): Internal.Biome$TemperatureModifier;
        getTemperature(): number;
        getPrecipitation(): Internal.Biome$Precipitation;
    }
    type ClimateProperties_ = ClimateProperties;
    class RewardType extends Internal.RegistryEntry<Internal.RewardType> {
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        setExcludeFromListRewards(v: boolean): Internal.RewardType;
        notifyAll(): void;
        getRegistryName(): ResourceLocation;
        setRegistryName(name: ResourceLocation_): Internal.RewardType;
        setGuiProvider(p: Internal.RewardType$GuiProvider_): Internal.RewardType;
        setDisplayName(name: Internal.Component_): Internal.RewardType;
        getGuiProvider(): Internal.RewardType$GuiProvider;
        notify(): void;
        static createReward(quest: Internal.Quest_, id: string): Internal.Reward;
        getIcon(): Internal.Icon;
        getDisplayName(): Internal.Component;
        hashCode(): number;
        equals(arg0: any): boolean;
        getRegistryType(): Internal.Class<Internal.RewardType>;
        toString(): string;
        getTypeForNBT(): string;
        getExcludeFromListRewards(): boolean;
        intId : number;
        readonly provider : ((arg0: Internal.Quest) => Internal.Reward);
        readonly id : ResourceLocation;
        get registryType(): Internal.Class<Internal.RewardType>;
        get displayName(): Internal.Component;
        get excludeFromListRewards(): boolean;
        get guiProvider(): Internal.RewardType$GuiProvider;
        get icon(): Internal.Icon;
        get registryName(): ResourceLocation;
        get typeForNBT(): string;
        get class(): Internal.Class<any>;
        set displayName(name: Internal.Component_);
        set excludeFromListRewards(v: boolean);
        set guiProvider(p: Internal.RewardType$GuiProvider_);
        set registryName(name: ResourceLocation_);
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    type RewardType_ = RewardType;
    interface RenderStateShardAccessor {
    }
    type RenderStateShardAccessor_ = RenderStateShardAccessor;
    interface Symbol {
    }
    type Symbol_ = Symbol;
    class WritableRaster extends Internal.Raster {
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        setPixel(arg0: number, arg1: number, arg2: number[]): void;
        createChild(arg0: number, arg1: number, arg2: number, arg3: number, arg4: number, arg5: number, arg6: number[]): Internal.Raster;
        createWritableChild(arg0: number, arg1: number, arg2: number, arg3: number, arg4: number, arg5: number, arg6: number[]): Internal.WritableRaster;
        setPixels(arg0: number, arg1: number, arg2: number, arg3: number, arg4: number[]): void;
        notifyAll(): void;
        getSampleFloat(arg0: number, arg1: number, arg2: number): number;
        createTranslatedChild(arg0: number, arg1: number): Internal.Raster;
        getNumDataElements(): number;
        getNumBands(): number;
        getWidth(): number;
        static createWritableRaster(arg0: Internal.SampleModel_, arg1: Internal.DataBuffer_, arg2: Internal.Point_): Internal.WritableRaster;
        static createWritableRaster(arg0: Internal.SampleModel_, arg1: Internal.Point_): Internal.WritableRaster;
        notify(): void;
        getBounds(): Internal.Rectangle;
        getSampleModel(): Internal.SampleModel;
        getWritableParent(): Internal.WritableRaster;
        getHeight(): number;
        static createRaster(arg0: Internal.SampleModel_, arg1: Internal.DataBuffer_, arg2: Internal.Point_): Internal.Raster;
        getTransferType(): number;
        hashCode(): number;
        getPixels(arg0: number, arg1: number, arg2: number, arg3: number, arg4: number[]): number[];
        setDataElements(arg0: number, arg1: number, arg2: number, arg3: number, arg4: any): void;
        setDataElements(arg0: number, arg1: number, arg2: any): void;
        setDataElements(arg0: number, arg1: number, arg2: Internal.Raster_): void;
        getSampleDouble(arg0: number, arg1: number, arg2: number): number;
        getParent(): Internal.Raster;
        setSamples(arg0: number, arg1: number, arg2: number, arg3: number, arg4: number, arg5: number[]): void;
        static createBandedRaster(arg0: number, arg1: number, arg2: number, arg3: number, arg4: Internal.Point_): Internal.WritableRaster;
        static createBandedRaster(arg0: number, arg1: number, arg2: number, arg3: number, arg4: number[], arg5: number[], arg6: Internal.Point_): Internal.WritableRaster;
        static createBandedRaster(arg0: Internal.DataBuffer_, arg1: number, arg2: number, arg3: number, arg4: number[], arg5: number[], arg6: Internal.Point_): Internal.WritableRaster;
        getDataBuffer(): Internal.DataBuffer;
        getSamples(arg0: number, arg1: number, arg2: number, arg3: number, arg4: number, arg5: number[]): number[];
        createWritableTranslatedChild(arg0: number, arg1: number): Internal.WritableRaster;
        getPixel(arg0: number, arg1: number, arg2: number[]): number[];
        setRect(arg0: Internal.Raster_): void;
        setRect(arg0: number, arg1: number, arg2: Internal.Raster_): void;
        static createPackedRaster(arg0: number, arg1: number, arg2: number, arg3: number, arg4: number, arg5: Internal.Point_): Internal.WritableRaster;
        static createPackedRaster(arg0: Internal.DataBuffer_, arg1: number, arg2: number, arg3: number, arg4: Internal.Point_): Internal.WritableRaster;
        static createPackedRaster(arg0: number, arg1: number, arg2: number, arg3: number[], arg4: Internal.Point_): Internal.WritableRaster;
        static createPackedRaster(arg0: Internal.DataBuffer_, arg1: number, arg2: number, arg3: number, arg4: number[], arg5: Internal.Point_): Internal.WritableRaster;
        createCompatibleWritableRaster(): Internal.WritableRaster;
        createCompatibleWritableRaster(arg0: number, arg1: number): Internal.WritableRaster;
        createCompatibleWritableRaster(arg0: Internal.Rectangle_): Internal.WritableRaster;
        createCompatibleWritableRaster(arg0: number, arg1: number, arg2: number, arg3: number): Internal.WritableRaster;
        getSampleModelTranslateX(): number;
        getSampleModelTranslateY(): number;
        equals(arg0: any): boolean;
        getDataElements(arg0: number, arg1: number, arg2: any): any;
        getDataElements(arg0: number, arg1: number, arg2: number, arg3: number, arg4: any): any;
        toString(): string;
        static createInterleavedRaster(arg0: number, arg1: number, arg2: number, arg3: number, arg4: Internal.Point_): Internal.WritableRaster;
        static createInterleavedRaster(arg0: number, arg1: number, arg2: number, arg3: number, arg4: number, arg5: number[], arg6: Internal.Point_): Internal.WritableRaster;
        static createInterleavedRaster(arg0: Internal.DataBuffer_, arg1: number, arg2: number, arg3: number, arg4: number, arg5: number[], arg6: Internal.Point_): Internal.WritableRaster;
        getSample(arg0: number, arg1: number, arg2: number): number;
        getMinX(): number;
        getMinY(): number;
        setSample(arg0: number, arg1: number, arg2: number, arg3: number): void;
        get parent(): Internal.Raster;
        get dataBuffer(): Internal.DataBuffer;
        get writableParent(): Internal.WritableRaster;
        get numDataElements(): number;
        get numBands(): number;
        get minY(): number;
        get minX(): number;
        get width(): number;
        get bounds(): Internal.Rectangle;
        get transferType(): number;
        get sampleModelTranslateX(): number;
        get class(): Internal.Class<any>;
        get sampleModel(): Internal.SampleModel;
        get height(): number;
        get sampleModelTranslateY(): number;
        set rect(arg0: Internal.Raster_);
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    type WritableRaster_ = WritableRaster;
    class StringReader implements Internal.ImmutableStringReader {
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        readStringUntil(arg0: string): string;
        static isAllowedInUnquotedString(arg0: string): boolean;
        canRead(): boolean;
        canRead(arg0: number): boolean;
        getRemaining(): string;
        notifyAll(): void;
        getRead(): string;
        skip(): void;
        notify(): void;
        hashCode(): number;
        readDouble(): number;
        readUnquotedString(): string;
        readFloat(): number;
        readQuotedString(): string;
        readInt(): number;
        getCursor(): number;
        getTotalLength(): number;
        read(): string;
        readString(): string;
        getString(): string;
        peek(): string;
        peek(arg0: number): string;
        expect(arg0: string): void;
        getRemainingLength(): number;
        readLong(): number;
        equals(arg0: any): boolean;
        static isQuotedStringStart(arg0: string): boolean;
        toString(): string;
        setCursor(arg0: number): void;
        static isAllowedNumber(arg0: string): boolean;
        readBoolean(): boolean;
        skipWhitespace(): void;
        get cursor(): number;
        get string(): string;
        get totalLength(): number;
        get class(): Internal.Class<any>;
        get remaining(): string;
        get remainingLength(): number;
        set cursor(arg0: number);
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    type StringReader_ = StringReader;
    class ListConfig <E, CV> extends Internal.ConfigValue<Internal.List<E>> {
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        getName(): string;
        setCanEdit(e: boolean): Internal.ConfigValue<Internal.List<E>>;
        notifyAll(): void;
        isEqual(v1: Internal.List_<E>, v2: Internal.List_<E>): boolean;
        compareTo(o: Internal.ConfigValue_<Internal.List_<E>>): number;
        notify(): void;
        getCanEdit(): boolean;
        getTooltip(): string;
        hashCode(): number;
        getStringForGUI(v: Internal.List_<E>): Internal.Component;
        getPath(): string;
        copy(v: Internal.List_<E>): Internal.List<E>;
        static info(key: string, value: any): Internal.Component;
        init(g: Internal.ConfigGroup_, i: string, v: Internal.List_<E>, c: Internal.Consumer_<Internal.List_<E>>, def: Internal.List_<E>): Internal.ConfigValue<Internal.List<E>>;
        getColor(v: Internal.List_<E>): Internal.Color4I;
        addInfo(l: Internal.TooltipList_): void;
        getIcon(v: Internal.List_<E>): Internal.Icon;
        setIcon(i: Internal.Icon_): Internal.ConfigValue<Internal.List<E>>;
        setOrder(o: number): Internal.ConfigValue<Internal.List<E>>;
        getNameKey(): string;
        setNameKey(key: string): Internal.ConfigValue<Internal.List<E>>;
        equals(arg0: any): boolean;
        onClicked(button: Internal.MouseButton_, callback: Internal.ConfigCallback_): void;
        toString(): string;
        setCurrentValue(v: Internal.List_<E>): boolean;
        static readonly COLOR : Internal.Color4I;
        defaultValue : Internal.List<E>;
        static readonly EMPTY_LIST : Internal.TextComponent;
        static readonly NON_EMPTY_LIST : Internal.TextComponent;
        id : string;
        readonly type : CV;
        static readonly NULL_TEXT : Internal.TextComponent;
        setter : ((arg0: Internal.List<E>) => void);
        value : Internal.List<E>;
        group : Internal.ConfigGroup;
        get path(): string;
        get nameKey(): string;
        get canEdit(): boolean;
        get name(): string;
        get tooltip(): string;
        get class(): Internal.Class<any>;
        set nameKey(key: string);
        set canEdit(e: boolean);
        set icon(i: Internal.Icon_);
        set currentValue(v: Internal.List_<E>);
        set order(o: number);
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    type ListConfig_<E, CV> = ListConfig<E, CV>;
    class SuggestionsBuilder {
        add(arg0: Internal.SuggestionsBuilder_): Internal.SuggestionsBuilder;
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        createOffset(arg0: number): Internal.SuggestionsBuilder;
        getStart(): number;
        restart(): Internal.SuggestionsBuilder;
        buildFuture(): Internal.CompletableFuture<Internal.Suggestions>;
        getRemaining(): string;
        notifyAll(): void;
        suggest(arg0: string, arg1: Internal.Message_): Internal.SuggestionsBuilder;
        suggest(arg0: string): Internal.SuggestionsBuilder;
        suggest(arg0: number): Internal.SuggestionsBuilder;
        suggest(arg0: number, arg1: Internal.Message_): Internal.SuggestionsBuilder;
        getInput(): string;
        notify(): void;
        getRemainingLowerCase(): string;
        build(): Internal.Suggestions;
        hashCode(): number;
        equals(arg0: any): boolean;
        toString(): string;
        get input(): string;
        get start(): number;
        get class(): Internal.Class<any>;
        get remaining(): string;
        get remainingLowerCase(): string;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    type SuggestionsBuilder_ = SuggestionsBuilder;
    interface RecipeManagerAccessor {
        getContext(): Internal.ICondition$IContext;
    }
    type RecipeManagerAccessor_ = RecipeManagerAccessor;
    class RecipeLogic {
        readFromNBT(arg0: Internal.CompoundTag_): void;
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        handleTickRecipe(arg0: com.lowdragmc.multiblocked.api.recipe.Recipe_): void;
        markDirty(): void;
        notifyAll(): void;
        update(): void;
        getStatus(): Internal.RecipeLogic$Status;
        setupRecipe(arg0: com.lowdragmc.multiblocked.api.recipe.Recipe_): void;
        notify(): void;
        setStatus(arg0: Internal.RecipeLogic$Status_): void;
        handleRecipeWorking(): void;
        hashCode(): number;
        equals(arg0: any): boolean;
        onRecipeFinish(): void;
        toString(): string;
        inValid(): void;
        isIdle(): boolean;
        asyncChanged(): boolean;
        findAndHandleRecipe(): void;
        isWorking(): boolean;
        writeToNBT(arg0: Internal.CompoundTag_): Internal.CompoundTag;
        isSuspend(): boolean;
        duration : number;
        timer : number;
        readonly controller : Internal.ControllerTileEntity;
        lastFaildMattches : Internal.List<com.lowdragmc.multiblocked.api.recipe.Recipe>;
        progress : number;
        lastRecipe : com.lowdragmc.multiblocked.api.recipe.Recipe;
        get suspend(): boolean;
        get idle(): boolean;
        get working(): boolean;
        get class(): Internal.Class<any>;
        get status(): Internal.RecipeLogic$Status;
        set upRecipe(arg0: com.lowdragmc.multiblocked.api.recipe.Recipe_);
        set status(arg0: Internal.RecipeLogic$Status_);
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    type RecipeLogic_ = RecipeLogic;
    interface Char2ObjectFunction <V> extends Internal.Function<string, V>, Internal.IntFunction<V> {
        getOrDefault(arg0: string, arg1: V): V;
        getOrDefault(arg0: any, arg1: V): V;
        andThenShort(arg0: Internal.Object2ShortFunction_<V>): Internal.Char2ShortFunction;
        composeByte(arg0: Internal.Byte2CharFunction_): Internal.Byte2ObjectFunction<V>;
        andThenInt(arg0: Internal.Object2IntFunction_<V>): Internal.Char2IntFunction;
        andThen<V_>(arg0: java_.util.function_.Function_<V, V_>): java_.util.function_.Function<string, V_>;
        composeReference<T_>(arg0: Internal.Reference2CharFunction_<T_>): Internal.Reference2ObjectFunction<T_, V>;
        put(arg0: string, arg1: V): V;
        remove(arg0: any): V;
        remove(arg0: string): V;
        defaultReturnValue(arg0: V): void;
        defaultReturnValue(): V;
        andThenDouble(arg0: Internal.Object2DoubleFunction_<V>): Internal.Char2DoubleFunction;
        andThenObject<T_>(arg0: Internal.Object2ObjectFunction_<V, T_>): Internal.Char2ObjectFunction<T_>;
        get(arg0: any): V;
        get(arg0: string): V;
        andThenLong(arg0: Internal.Object2LongFunction_<V>): Internal.Char2LongFunction;
        composeLong(arg0: Internal.Long2CharFunction_): Internal.Long2ObjectFunction<V>;
        andThenByte(arg0: Internal.Object2ByteFunction_<V>): Internal.Char2ByteFunction;
        andThenFloat(arg0: Internal.Object2FloatFunction_<V>): Internal.Char2FloatFunction;
        apply(arg0: number): V;
        apply(arg0: string): V;
        containsKey(arg0: any): boolean;
        containsKey(arg0: string): boolean;
        composeInt(arg0: Internal.Int2CharFunction_): Internal.Int2ObjectFunction<V>;
        clear(): void;
        composeFloat(arg0: Internal.Float2CharFunction_): Internal.Float2ObjectFunction<V>;
        andThenChar(arg0: Internal.Object2CharFunction_<V>): Internal.Char2CharFunction;
        composeObject<T_>(arg0: Internal.Object2CharFunction_<T_>): Internal.Object2ObjectFunction<T_, V>;
        size(): number;
        compose<T_>(arg0: java_.util.function_.Function_<T_, string>): java_.util.function_.Function<T_, V>;
        composeShort(arg0: Internal.Short2CharFunction_): Internal.Short2ObjectFunction<V>;
        andThenReference<T_>(arg0: Internal.Object2ReferenceFunction_<V, T_>): Internal.Char2ReferenceFunction<T_>;
        composeChar(arg0: Internal.Char2CharFunction_): Internal.Char2ObjectFunction<V>;
        composeDouble(arg0: Internal.Double2CharFunction_): Internal.Double2ObjectFunction<V>;
    }
    type Char2ObjectFunction_<V> = ((arg0: string) => V) | Char2ObjectFunction<V>;
    interface NonNullSupplier <T> {
        get(): T;
    }
    type NonNullSupplier_<T> = (() => T) | NonNullSupplier<T>;
    class ForgeConfigSpec$ValueSpec {
        getClass(): Internal.Class<any>;
        getClazz(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        correct(arg0: any): any;
        test(arg0: any): boolean;
        getTranslationKey(): string;
        notifyAll(): void;
        getDefault(): any;
        notify(): void;
        needsWorldRestart(): boolean;
        hashCode(): number;
        getRange<V>(): Internal.ForgeConfigSpec$Range<V>;
        equals(arg0: any): boolean;
        toString(): string;
        getComment(): string;
        get default(): any;
        get translationKey(): string;
        get range(): Internal.ForgeConfigSpec$Range<V>;
        get comment(): string;
        get class(): Internal.Class<any>;
        get clazz(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    type ForgeConfigSpec$ValueSpec_ = ForgeConfigSpec$ValueSpec;
    class AssetJsonGenerator extends Internal.JsonGenerator {
        multipartState(id: ResourceLocation_, consumer: Internal.Consumer_<Internal.MultipartBlockStateGenerator_>): void;
        getClass(): Internal.Class<any>;
        getAllJsons(): Internal.Map<ResourceLocation, Internal.JsonElement>;
        blockState(id: ResourceLocation_, consumer: Internal.Consumer_<Internal.VariantBlockStateGenerator_>): void;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        notifyAll(): void;
        notify(): void;
        static asItemModelLocation(id: ResourceLocation_): ResourceLocation;
        blockModel(id: ResourceLocation_, consumer: Internal.Consumer_<Internal.ModelGenerator_>): void;
        hashCode(): number;
        itemModel(id: ResourceLocation_, consumer: Internal.Consumer_<Internal.ModelGenerator_>): void;
        equals(arg0: any): boolean;
        json(id: ResourceLocation_, json: Internal.JsonElement_): void;
        toString(): string;
        get class(): Internal.Class<any>;
        get allJsons(): Internal.Map<ResourceLocation, Internal.JsonElement>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    type AssetJsonGenerator_ = AssetJsonGenerator;
    interface AccessorItemEntity {
        getPickupDelay(): number;
        setAge(arg0: number): void;
    }
    type AccessorItemEntity_ = AccessorItemEntity;
    class File implements Internal.Serializable, Internal.Comparable<Internal.File> {
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        getUsableSpace(): number;
        static listRoots(): Internal.File[];
        renameTo(arg0: Internal.File_): boolean;
        getName(): string;
        setExecutable(arg0: boolean): boolean;
        setExecutable(arg0: boolean, arg1: boolean): boolean;
        canRead(): boolean;
        notifyAll(): void;
        getCanonicalFile(): Internal.File;
        compareTo(arg0: Internal.File_): number;
        delete(): boolean;
        notify(): void;
        setReadable(arg0: boolean): boolean;
        setReadable(arg0: boolean, arg1: boolean): boolean;
        getTotalSpace(): number;
        hashCode(): number;
        getParentFile(): Internal.File;
        getPath(): string;
        getAbsoluteFile(): Internal.File;
        listFiles(arg0: Internal.FileFilter_): Internal.File[];
        listFiles(arg0: Internal.FilenameFilter_): Internal.File[];
        listFiles(): Internal.File[];
        mkdir(): boolean;
        deleteOnExit(): void;
        canExecute(): boolean;
        getCanonicalPath(): string;
        toURL(): Internal.URL;
        getParent(): string;
        setWritable(arg0: boolean): boolean;
        setWritable(arg0: boolean, arg1: boolean): boolean;
        isFile(): boolean;
        getAbsolutePath(): string;
        toURI(): Internal.URI;
        getFreeSpace(): number;
        length(): number;
        canWrite(): boolean;
        static createTempFile(arg0: string, arg1: string): Internal.File;
        static createTempFile(arg0: string, arg1: string, arg2: Internal.File_): Internal.File;
        list(): string[];
        list(arg0: Internal.FilenameFilter_): string[];
        isHidden(): boolean;
        toPath(): Internal.Path;
        mkdirs(): boolean;
        equals(arg0: any): boolean;
        exists(): boolean;
        isAbsolute(): boolean;
        toString(): string;
        lastModified(): number;
        createNewFile(): boolean;
        setLastModified(arg0: number): boolean;
        isDirectory(): boolean;
        setReadOnly(): boolean;
        static readonly pathSeparator : ";";
        static readonly pathSeparatorChar : ";";
        static readonly separatorChar : "\\";
        static readonly separator : "\\";
        get parent(): string;
        get parentFile(): Internal.File;
        get hidden(): boolean;
        get freeSpace(): number;
        get usableSpace(): number;
        get totalSpace(): number;
        get canonicalFile(): Internal.File;
        get directory(): boolean;
        get path(): string;
        get absoluteFile(): Internal.File;
        get file(): boolean;
        get absolute(): boolean;
        get name(): string;
        get canonicalPath(): string;
        get absolutePath(): string;
        get class(): Internal.Class<any>;
        set readable(arg0: boolean);
        set executable(arg0: boolean);
        set writable(arg0: boolean);
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    type File_ = File;
    abstract class AbstractInterruptibleChannel implements Internal.Channel, Internal.InterruptibleChannel {
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        isOpen(): boolean;
        hashCode(): number;
        notifyAll(): void;
        equals(arg0: any): boolean;
        toString(): string;
        close(): void;
        notify(): void;
        get class(): Internal.Class<any>;
        get open(): boolean;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    type AbstractInterruptibleChannel_ = AbstractInterruptibleChannel;
    class SimpleMapCodec <K, V> extends Internal.MapCodec<Internal.Map<K, V>> implements Internal.BaseMapCodec<K, V> {
        encode<T_>(arg0: Internal.Map_<K, V>, arg1: Internal.DynamicOps_<T_>, arg2: Internal.RecordBuilder_<T_>): Internal.RecordBuilder<T_>;
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        setPartial(arg0: Internal.Supplier_<Internal.Map_<K, V>>): Internal.MapCodec<Internal.Map<K, V>>;
        keys<T_>(arg0: Internal.DynamicOps_<T_>): Internal.Stream<T_>;
        notifyAll(): void;
        deprecated(arg0: number): Internal.MapCodec<Internal.Map<K, V>>;
        decode<T_>(arg0: Internal.DynamicOps_<T_>, arg1: Internal.MapLike_<T_>): Internal.DataResult<Internal.Map<K, V>>;
        notify(): void;
        flatXmap<S_>(arg0: java_.util.function_.Function_<Internal.Map_<K, V>, Internal.DataResult_<S_>>, arg1: java_.util.function_.Function_<S_, Internal.DataResult_<Internal.Map_<K, V>>>): Internal.MapCodec<S_>;
        hashCode(): number;
        comap<B_>(arg0: java_.util.function_.Function_<B_, Internal.Map_<K, V>>): Internal.MapEncoder<B_>;
        static of<A_>(arg0: Internal.MapEncoder_<A_>, arg1: Internal.MapDecoder_<A_>, arg2: Internal.Supplier_<string>): Internal.MapCodec<A_>;
        static of<A_>(arg0: Internal.MapEncoder_<A_>, arg1: Internal.MapDecoder_<A_>): Internal.MapCodec<A_>;
        fieldOf(arg0: string): Internal.MapCodec<Internal.Map<K, V>>;
        xmap<S_>(arg0: java_.util.function_.Function_<Internal.Map_<K, V>, S_>, arg1: java_.util.function_.Function_<S_, Internal.Map_<K, V>>): Internal.MapCodec<S_>;
        map<B_>(arg0: java_.util.function_.Function_<Internal.Map_<K, V>, B_>): Internal.MapDecoder<B_>;
        dependent<E_>(arg0: Internal.MapCodec_<E_>, arg1: java_.util.function_.Function_<Internal.Map_<K, V>, Internal.Pair_<E_, Internal.MapCodec_<E_>>>, arg2: Internal.BiFunction_<Internal.Map_<K, V>, E_, Internal.Map_<K, V>>): Internal.MapCodec<Internal.Map<K, V>>;
        flatComap<B_>(arg0: java_.util.function_.Function_<B_, Internal.DataResult_<Internal.Map_<K, V>>>): Internal.MapEncoder<B_>;
        compressedDecode<T_>(arg0: Internal.DynamicOps_<T_>, arg1: T_): Internal.DataResult<Internal.Map<K, V>>;
        compressedBuilder<T_>(arg0: Internal.DynamicOps_<T_>): Internal.RecordBuilder<T_>;
        keyCodec(): Internal.Codec<K>;
        decoder(): Internal.Decoder<Internal.Map<K, V>>;
        withLifecycle(arg0: Internal.Lifecycle_): Internal.MapCodec<Internal.Map<K, V>>;
        encoder(): Internal.Encoder<Internal.Map<K, V>>;
        orElse(arg0: Internal.Map_<K, V>): Internal.MapCodec<Internal.Map<K, V>>;
        orElse(arg0: Internal.Consumer_<string>, arg1: Internal.Map_<K, V>): Internal.MapCodec<Internal.Map<K, V>>;
        orElse(arg0: Internal.UnaryOperator_<string>, arg1: Internal.Map_<K, V>): Internal.MapCodec<Internal.Map<K, V>>;
        forGetter<O_>(arg0: java_.util.function_.Function_<O_, Internal.Map_<K, V>>): Internal.RecordCodecBuilder<O_, Internal.Map<K, V>>;
        ap<E_>(arg0: Internal.MapDecoder_<java_.util.function_.Function_<Internal.Map_<K, V>, E_>>): Internal.MapDecoder<E_>;
        flatMap<B_>(arg0: java_.util.function_.Function_<Internal.Map_<K, V>, Internal.DataResult_<B_>>): Internal.MapDecoder<B_>;
        codec(): Internal.Codec<Internal.Map<K, V>>;
        static unit<A_>(arg0: Internal.Supplier_<A_>): Internal.MapCodec<A_>;
        static unit<A_>(arg0: A_): Internal.MapCodec<A_>;
        elementCodec(): Internal.Codec<V>;
        orElseGet(arg0: Internal.UnaryOperator_<string>, arg1: Internal.Supplier_<Internal.Map_<K, V>>): Internal.MapCodec<Internal.Map<K, V>>;
        orElseGet(arg0: Internal.Consumer_<string>, arg1: Internal.Supplier_<Internal.Map_<K, V>>): Internal.MapCodec<Internal.Map<K, V>>;
        orElseGet(arg0: Internal.Supplier_<Internal.Map_<K, V>>): Internal.MapCodec<Internal.Map<K, V>>;
        stable(): Internal.MapCodec<Internal.Map<K, V>>;
        equals(arg0: any): boolean;
        mapResult(arg0: Internal.MapCodec$ResultFunction_<Internal.Map_<K, V>>): Internal.MapCodec<Internal.Map<K, V>>;
        toString(): string;
        compressor<T_>(arg0: Internal.DynamicOps_<T_>): Internal.KeyCompressor<T_>;
        get class(): Internal.Class<any>;
        set partial(arg0: Internal.Supplier_<Internal.Map_<K, V>>);
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    type SimpleMapCodec_<K, V> = SimpleMapCodec<K, V>;
    interface FileNotFoundAction {
        run(arg0: Internal.Path_, arg1: Internal.ConfigFormat_<any>): boolean;
    }
    type FileNotFoundAction_ = ((arg0: Internal.Path, arg1: Internal.ConfigFormat<any>) => boolean) | FileNotFoundAction;
    interface IForgeBlockEntity extends Internal.ICapabilitySerializable<Internal.CompoundTag> {
        requestModelDataUpdate(): void;
        getModelData(): Internal.IModelData;
        serializeNBT(): Internal.CompoundTag;
        getCapability<T_>(arg0: Internal.Capability_<T_>, arg1: Internal.Direction_): Internal.LazyOptional<T_>;
        getCapability<T_>(arg0: Internal.Capability_<T_>): Internal.LazyOptional<T_>;
        getTileData(): Internal.CompoundTag;
        onChunkUnloaded(): void;
        getRenderBoundingBox(): Internal.AABB;
        onDataPacket(arg0: Internal.Connection_, arg1: Internal.ClientboundBlockEntityDataPacket_): void;
        onLoad(): void;
        deserializeNBT(arg0: Internal.CompoundTag_): void;
        handleUpdateTag(arg0: Internal.CompoundTag_): void;
    }
    type IForgeBlockEntity_ = IForgeBlockEntity;
    class DamageSource implements Internal.DamageSourceAccessor, Internal.AccessorDamageSource {
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        getPlayer(): Internal.PlayerJS<any>;
        getActual(): Internal.EntityJS;
        getType(): string;
        hashCode(): number;
        notifyAll(): void;
        equals(arg0: any): boolean;
        getImmediate(): Internal.EntityJS;
        toString(): string;
        notify(): void;
        get actual(): Internal.EntityJS;
        get immediate(): Internal.EntityJS;
        get type(): string;
        get class(): Internal.Class<any>;
        get player(): Internal.PlayerJS<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    type DamageSource_ = inFire | lightningBolt | onFire | lava | hotFloor | inWall | cramming | drown | starve | cactus | fall | flyIntoWall | outOfWorld | generic | magic | wither | anvil | fallingBlock | dragonBreath | dryout | sweetBerryBush | freeze | fallingStalactite | stalagmite | DamageSource;
    interface ICitadelDataEntity {
        setCitadelEntityData(arg0: Internal.CompoundTag_): void;
        getCitadelEntityData(): Internal.CompoundTag;
    }
    type ICitadelDataEntity_ = ICitadelDataEntity;
    class LevelRenderer implements Internal.ResourceManagerReloadListener, Internal.AutoCloseable, Internal.WorldRendererExtended, Internal.LevelRendererAccessor, Internal.CullingDataCache {
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        restoreState(): void;
        saveState(): void;
        notifyAll(): void;
        handler$bel000$playStreamingMusic(arg0: Internal.SoundEvent_, arg1: BlockPos_, arg2: Internal.RecordItem_, arg3: Internal.CallbackInfo_): void;
        notify(): void;
        hashCode(): number;
        equals(arg0: any): boolean;
        toString(): string;
        localvar$zfk000$modifyPoseStack(arg0: Internal.PoseStack_): Internal.PoseStack;
        playStreamingMusic(arg0: Internal.SoundEvent_, arg1: BlockPos_, arg2: Internal.RecordItem_): void;
        close(): void;
        getSodiumWorldRenderer(): Internal.SodiumWorldRenderer;
        localvar$zfk000$modifyPartialTicks(arg0: number): number;
        handler$zfk000$renderLevel(arg0: Internal.CallbackInfo_): void;
        get sodiumWorldRenderer(): Internal.SodiumWorldRenderer;
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    type LevelRenderer_ = LevelRenderer;
    class DragSourceDropEvent extends Internal.DragSourceEvent {
        getDropAction(): number;
        getDropSuccess(): boolean;
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        getLocation(): Internal.Point;
        notifyAll(): void;
        notify(): void;
        getX(): number;
        getY(): number;
        hashCode(): number;
        getSource(): any;
        getDragSourceContext(): Internal.DragSourceContext;
        equals(arg0: any): boolean;
        toString(): string;
        get dropSuccess(): boolean;
        get x(): number;
        get dragSourceContext(): Internal.DragSourceContext;
        get y(): number;
        get location(): Internal.Point;
        get source(): any;
        get class(): Internal.Class<any>;
        get dropAction(): number;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    type DragSourceDropEvent_ = DragSourceDropEvent;
    interface CompositeContext {
        compose(arg0: Internal.Raster_, arg1: Internal.Raster_, arg2: Internal.WritableRaster_): void;
        dispose(): void;
    }
    type CompositeContext_ = CompositeContext;
    class IFocus$Mode extends Internal.Enum<Internal.IFocus$Mode> {
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        toRole(): Internal.RecipeIngredientRole;
        static valueOf(arg0: string): Internal.IFocus$Mode;
        static valueOf<T_>(arg0: Internal.Class_<T_>, arg1: string): T_;
        notifyAll(): void;
        static values(): Internal.IFocus$Mode[];
        compareTo(arg0: Internal.IFocus$Mode_): number;
        describeConstable(): Internal.Optional<Internal.Enum$EnumDesc<Internal.IFocus$Mode>>;
        notify(): void;
        getDeclaringClass(): Internal.Class<Internal.IFocus$Mode>;
        hashCode(): number;
        equals(arg0: any): boolean;
        name(): string;
        toString(): string;
        ordinal(): number;
        static readonly INPUT : Internal.IFocus$Mode;
        static readonly OUTPUT : Internal.IFocus$Mode;
        get class(): Internal.Class<any>;
        get declaringClass(): Internal.Class<Internal.IFocus$Mode>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    type IFocus$Mode_ = "output" | "input" | IFocus$Mode;
    class CursorType extends Internal.Enum<Internal.CursorType> {
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        static set(type: Internal.CursorType_): void;
        static valueOf(name: string): Internal.CursorType;
        static valueOf<T_>(arg0: Internal.Class_<T_>, arg1: string): T_;
        notifyAll(): void;
        static values(): Internal.CursorType[];
        compareTo(arg0: Internal.CursorType_): number;
        describeConstable(): Internal.Optional<Internal.Enum$EnumDesc<Internal.CursorType>>;
        notify(): void;
        getDeclaringClass(): Internal.Class<Internal.CursorType>;
        hashCode(): number;
        equals(arg0: any): boolean;
        name(): string;
        toString(): string;
        ordinal(): number;
        static readonly VRESIZE : Internal.CursorType;
        static readonly ARROW : Internal.CursorType;
        static readonly CROSSHAIR : Internal.CursorType;
        static readonly IBEAM : Internal.CursorType;
        static readonly HRESIZE : Internal.CursorType;
        static readonly HAND : Internal.CursorType;
        get class(): Internal.Class<any>;
        get declaringClass(): Internal.Class<Internal.CursorType>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    type CursorType_ = "crosshair" | "arrow" | "vresize" | "hresize" | "ibeam" | "hand" | CursorType;
    interface ResourceManagerReloadListener extends Internal.PreparableReloadListener {
    }
    type ResourceManagerReloadListener_ = ResourceManagerReloadListener;
    class BlockInfo {
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        apply(arg0: Internal.Level_, arg1: BlockPos_): void;
        getItemStackForm(): Internal.ItemStack;
        getBlockEntity(arg0: BlockPos_): Internal.BlockEntity;
        getBlockEntity(arg0: Internal.Level_, arg1: BlockPos_): Internal.BlockEntity;
        notifyAll(): void;
        hasBlockEntity(): boolean;
        setBlockState(arg0: Internal.BlockState_): void;
        notify(): void;
        static fromBlock(arg0: Internal.Block_): Internal.BlockInfo;
        setHasBlockEntity(arg0: boolean): void;
        hashCode(): number;
        equals(arg0: any): boolean;
        toString(): string;
        static fromBlockState(arg0: Internal.BlockState_): Internal.BlockInfo;
        getBlockState(): Internal.BlockState;
        static readonly EMPTY : Internal.BlockInfo;
        get blockState(): Internal.BlockState;
        get class(): Internal.Class<any>;
        get itemStackForm(): Internal.ItemStack;
        set blockState(arg0: Internal.BlockState_);
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    type BlockInfo_ = BlockInfo;
    class Products$P14 <F, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14> {
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        apply<R>(arg0: Internal.Applicative_<F, any>, arg1: Internal.Function14_<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, R>): Internal.App<F, R>;
        apply<R>(arg0: Internal.Applicative_<F, any>, arg1: Internal.App_<F, Internal.Function14_<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, R>>): Internal.App<F, R>;
        hashCode(): number;
        notifyAll(): void;
        equals(arg0: any): boolean;
        toString(): string;
        notify(): void;
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    type Products$P14_<F, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14> = Products$P14<F, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14>;
    interface ProgressivePromise <V> extends Internal.Promise<V>, Internal.ProgressiveFuture<V> {
        cancel(arg0: boolean): boolean;
        isCancelled(): boolean;
        removeListeners(arg0: Internal.GenericFutureListener_<io.netty.util.concurrent.Future_<V>>[]): Internal.ProgressivePromise<V>;
        removeListeners(arg0: Internal.GenericFutureListener_<io.netty.util.concurrent.Future_<V>>[]): Internal.Promise<V>;
        removeListeners(arg0: Internal.GenericFutureListener_<io.netty.util.concurrent.Future_<V>>[]): io.netty.util.concurrent.Future<V>;
        removeListeners(arg0: Internal.GenericFutureListener_<io.netty.util.concurrent.Future_<V>>[]): Internal.ProgressiveFuture<V>;
        getNow(): V;
        setProgress(arg0: number, arg1: number): Internal.ProgressivePromise<V>;
        cause(): Internal.Throwable;
        awaitUninterruptibly(): Internal.ProgressivePromise<V>;
        awaitUninterruptibly(): Internal.Promise<V>;
        awaitUninterruptibly(): io.netty.util.concurrent.Future<V>;
        awaitUninterruptibly(): Internal.ProgressiveFuture<V>;
        awaitUninterruptibly(arg0: number, arg1: Internal.TimeUnit_): boolean;
        awaitUninterruptibly(arg0: number): boolean;
        removeListener(arg0: Internal.GenericFutureListener_<io.netty.util.concurrent.Future_<V>>): Internal.ProgressivePromise<V>;
        removeListener(arg0: Internal.GenericFutureListener_<io.netty.util.concurrent.Future_<V>>): Internal.Promise<V>;
        removeListener(arg0: Internal.GenericFutureListener_<io.netty.util.concurrent.Future_<V>>): io.netty.util.concurrent.Future<V>;
        removeListener(arg0: Internal.GenericFutureListener_<io.netty.util.concurrent.Future_<V>>): Internal.ProgressiveFuture<V>;
        tryFailure(arg0: Internal.Throwable_): boolean;
        isDone(): boolean;
        sync(): Internal.ProgressivePromise<V>;
        sync(): Internal.Promise<V>;
        sync(): io.netty.util.concurrent.Future<V>;
        sync(): Internal.ProgressiveFuture<V>;
        setSuccess(arg0: V): Internal.ProgressivePromise<V>;
        setSuccess(arg0: V): Internal.Promise<V>;
        setFailure(arg0: Internal.Throwable_): Internal.ProgressivePromise<V>;
        setFailure(arg0: Internal.Throwable_): Internal.Promise<V>;
        trySuccess(arg0: V): boolean;
        tryProgress(arg0: number, arg1: number): boolean;
        syncUninterruptibly(): Internal.ProgressivePromise<V>;
        syncUninterruptibly(): Internal.Promise<V>;
        syncUninterruptibly(): io.netty.util.concurrent.Future<V>;
        syncUninterruptibly(): Internal.ProgressiveFuture<V>;
        get(arg0: number, arg1: Internal.TimeUnit_): V;
        get(): V;
        isCancellable(): boolean;
        await(): Internal.ProgressivePromise<V>;
        await(): Internal.Promise<V>;
        await(): io.netty.util.concurrent.Future<V>;
        await(): Internal.ProgressiveFuture<V>;
        await(arg0: number, arg1: Internal.TimeUnit_): boolean;
        await(arg0: number): boolean;
        addListeners(arg0: Internal.GenericFutureListener_<io.netty.util.concurrent.Future_<V>>[]): Internal.ProgressivePromise<V>;
        addListeners(arg0: Internal.GenericFutureListener_<io.netty.util.concurrent.Future_<V>>[]): Internal.Promise<V>;
        addListeners(arg0: Internal.GenericFutureListener_<io.netty.util.concurrent.Future_<V>>[]): io.netty.util.concurrent.Future<V>;
        addListeners(arg0: Internal.GenericFutureListener_<io.netty.util.concurrent.Future_<V>>[]): Internal.ProgressiveFuture<V>;
        isSuccess(): boolean;
        setUncancellable(): boolean;
        addListener(arg0: Internal.GenericFutureListener_<io.netty.util.concurrent.Future_<V>>): Internal.ProgressivePromise<V>;
        addListener(arg0: Internal.GenericFutureListener_<io.netty.util.concurrent.Future_<V>>): Internal.Promise<V>;
        addListener(arg0: Internal.GenericFutureListener_<io.netty.util.concurrent.Future_<V>>): io.netty.util.concurrent.Future<V>;
        addListener(arg0: Internal.GenericFutureListener_<io.netty.util.concurrent.Future_<V>>): Internal.ProgressiveFuture<V>;
    }
    type ProgressivePromise_<V> = ProgressivePromise<V>;
    abstract class FileSystem implements Internal.Closeable {
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        supportedFileAttributeViews(): Internal.Set<string>;
        getFileStores(): Internal.Iterable<Internal.FileStore>;
        notifyAll(): void;
        newWatchService(): Internal.WatchService;
        notify(): void;
        isReadOnly(): boolean;
        isOpen(): boolean;
        provider(): Internal.FileSystemProvider;
        hashCode(): number;
        equals(arg0: any): boolean;
        getRootDirectories(): Internal.Iterable<Internal.Path>;
        getPath(arg0: string, arg1: string[]): Internal.Path;
        getSeparator(): string;
        toString(): string;
        getPathMatcher(arg0: string): Internal.PathMatcher;
        close(): void;
        getUserPrincipalLookupService(): Internal.UserPrincipalLookupService;
        get rootDirectories(): Internal.Iterable<Internal.Path>;
        get readOnly(): boolean;
        get userPrincipalLookupService(): Internal.UserPrincipalLookupService;
        get class(): Internal.Class<any>;
        get separator(): string;
        get open(): boolean;
        get fileStores(): Internal.Iterable<Internal.FileStore>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    type FileSystem_ = FileSystem;
    class LongOpenHashSet extends Internal.AbstractLongSet implements Internal.Serializable, Internal.Cloneable, Internal.Hash {
        getClass(): Internal.Class<any>;
        longIterator(): Internal.LongIterator;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        notifyAll(): void;
        notify(): void;
        remove(arg0: number): boolean;
        remove(arg0: any): boolean;
        removeAll(arg0: Internal.LongCollection_): boolean;
        removeAll(arg0: Internal.Collection_<any>): boolean;
        iterator(): Internal.LongIterator;
        trim(): boolean;
        trim(arg0: number): boolean;
        stream(): Internal.Stream<number>;
        hashCode(): number;
        static of(): Internal.LongOpenHashSet;
        static of(arg0: number): Internal.LongOpenHashSet;
        static of(arg0: number, arg1: number): Internal.LongOpenHashSet;
        static of(arg0: number[]): Internal.LongOpenHashSet;
        static of(arg0: number, arg1: number, arg2: number): Internal.LongOpenHashSet;
        toArray(arg0: number[]): number[];
        toArray(): any[];
        toArray<T_>(arg0: T_[]): T_[];
        toArray<T_>(arg0: Internal.IntFunction_<T_[]>): T_[];
        longStream(): Internal.LongStream;
        parallelStream(): Internal.Stream<number>;
        rem(arg0: number): boolean;
        add(arg0: number): boolean;
        longSpliterator(): Internal.LongSpliterator;
        toLongArray(arg0: number[]): number[];
        toLongArray(): number[];
        spliterator(): Internal.LongSpliterator;
        forEach(arg0: java_.util.function_.LongConsumer_): void;
        forEach(arg0: Internal.LongConsumer_): void;
        forEach(arg0: Internal.Consumer_<number>): void;
        containsAll(arg0: Internal.Collection_<any>): boolean;
        containsAll(arg0: Internal.LongCollection_): boolean;
        isEmpty(): boolean;
        clear(): void;
        static toSetWithExpectedSize(arg0: Internal.LongStream_, arg1: number): Internal.LongOpenHashSet;
        longParallelStream(): Internal.LongStream;
        removeIf(arg0: it.unimi.dsi.fastutil.longs.LongPredicate_): boolean;
        removeIf(arg0: Internal.Predicate_<number>): boolean;
        removeIf(arg0: Internal.LongPredicate_): boolean;
        static toSet(arg0: Internal.LongStream_): Internal.LongOpenHashSet;
        contains(arg0: number): boolean;
        contains(arg0: any): boolean;
        size(): number;
        addAll(arg0: Internal.LongCollection_): boolean;
        addAll(arg0: Internal.Collection_<number>): boolean;
        equals(arg0: any): boolean;
        clone(): Internal.LongOpenHashSet;
        toString(): string;
        retainAll(arg0: Internal.Collection_<any>): boolean;
        retainAll(arg0: Internal.LongCollection_): boolean;
        static readonly DEFAULT_GROWTH_FACTOR : 16;
        static readonly FAST_LOAD_FACTOR : 0.5;
        static readonly DEFAULT_INITIAL_SIZE : 16;
        static readonly DEFAULT_LOAD_FACTOR : 0.75;
        static readonly OCCUPIED : -1;
        static readonly VERY_FAST_LOAD_FACTOR : 0.25;
        static readonly FREE : 0;
        static readonly PRIMES : number[];
        static readonly REMOVED : 1;
        get class(): Internal.Class<any>;
        get empty(): boolean;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    type LongOpenHashSet_ = LongOpenHashSet;
    interface IFocusGroup {
        getAllFocuses(): Internal.List<Internal.IFocus<any>>;
        isEmpty(): boolean;
        getFocuses<T>(arg0: Internal.IIngredientType_<T>): Internal.Stream<Internal.IFocus<T>>;
        getFocuses<T>(arg0: Internal.IIngredientType_<T>, arg1: Internal.RecipeIngredientRole_): Internal.Stream<Internal.IFocus<T>>;
        getFocuses(arg0: Internal.RecipeIngredientRole_): Internal.Stream<Internal.IFocus<any>>;
    }
    type IFocusGroup_ = IFocusGroup;
    interface RenderBuffersExt {
        endLevelRendering(): void;
        beginLevelRendering(): void;
    }
    type RenderBuffersExt_ = RenderBuffersExt;
    interface Char2IntFunction extends Internal.Function<string, number>, Internal.IntUnaryOperator {
        getOrDefault(arg0: any, arg1: number): number;
        getOrDefault(arg0: string, arg1: number): number;
        andThenShort(arg0: Internal.Int2ShortFunction_): Internal.Char2ShortFunction;
        composeByte(arg0: Internal.Byte2CharFunction_): Internal.Byte2IntFunction;
        andThenInt(arg0: Internal.Int2IntFunction_): Internal.Char2IntFunction;
        composeReference<T_>(arg0: Internal.Reference2CharFunction_<T_>): Internal.Reference2IntFunction<T_>;
        andThen<T_>(arg0: java_.util.function_.Function_<number, T_>): java_.util.function_.Function<string, T_>;
        andThen(arg0: Internal.IntUnaryOperator_): Internal.IntUnaryOperator;
        put(arg0: string, arg1: number): number;
        remove(arg0: string): number;
        remove(arg0: any): number;
        defaultReturnValue(): number;
        defaultReturnValue(arg0: number): void;
        andThenDouble(arg0: Internal.Int2DoubleFunction_): Internal.Char2DoubleFunction;
        andThenObject<T_>(arg0: Internal.Int2ObjectFunction_<T_>): Internal.Char2ObjectFunction<T_>;
        get(arg0: any): number;
        get(arg0: string): number;
        andThenLong(arg0: Internal.Int2LongFunction_): Internal.Char2LongFunction;
        composeLong(arg0: Internal.Long2CharFunction_): Internal.Long2IntFunction;
        andThenByte(arg0: Internal.Int2ByteFunction_): Internal.Char2ByteFunction;
        andThenFloat(arg0: Internal.Int2FloatFunction_): Internal.Char2FloatFunction;
        applyAsInt(arg0: number): number;
        apply(arg0: string): number;
        containsKey(arg0: any): boolean;
        containsKey(arg0: string): boolean;
        composeInt(arg0: Internal.Int2CharFunction_): Internal.Int2IntFunction;
        clear(): void;
        composeFloat(arg0: Internal.Float2CharFunction_): Internal.Float2IntFunction;
        andThenChar(arg0: Internal.Int2CharFunction_): Internal.Char2CharFunction;
        composeObject<T_>(arg0: Internal.Object2CharFunction_<T_>): Internal.Object2IntFunction<T_>;
        size(): number;
        compose<T_>(arg0: java_.util.function_.Function_<T_, string>): java_.util.function_.Function<T_, number>;
        compose(arg0: Internal.IntUnaryOperator_): Internal.IntUnaryOperator;
        composeShort(arg0: Internal.Short2CharFunction_): Internal.Short2IntFunction;
        andThenReference<T_>(arg0: Internal.Int2ReferenceFunction_<T_>): Internal.Char2ReferenceFunction<T_>;
        composeChar(arg0: Internal.Char2CharFunction_): Internal.Char2IntFunction;
        composeDouble(arg0: Internal.Double2CharFunction_): Internal.Double2IntFunction;
    }
    type Char2IntFunction_ = ((arg0: string) => number) | Char2IntFunction;
    interface IntCollection extends Internal.Collection<number>, Internal.IntIterable {
        intIterator(): Internal.IntIterator;
        intSpliterator(): Internal.IntSpliterator;
        remove(arg0: any): boolean;
        intStream(): Internal.IntStream;
        removeAll(arg0: Internal.IntCollection_): boolean;
        removeAll(arg0: Internal.Collection_<any>): boolean;
        iterator(): Internal.IntIterator;
        stream(): Internal.Stream<number>;
        hashCode(): number;
        toIntArray(arg0: number[]): number[];
        toIntArray(): number[];
        toArray(arg0: number[]): number[];
        toArray<T_>(arg0: T_[]): T_[];
        toArray<T_>(arg0: Internal.IntFunction_<T_[]>): T_[];
        toArray(): any[];
        parallelStream(): Internal.Stream<number>;
        rem(arg0: number): boolean;
        add(arg0: number): boolean;
        spliterator(): Internal.IntSpliterator;
        forEach(arg0: Internal.Consumer_<number>): void;
        forEach(arg0: java_.util.function_.IntConsumer_): void;
        forEach(arg0: Internal.IntConsumer_): void;
        containsAll(arg0: Internal.IntCollection_): boolean;
        containsAll(arg0: Internal.Collection_<any>): boolean;
        isEmpty(): boolean;
        clear(): void;
        removeIf(arg0: Internal.Predicate_<number>): boolean;
        removeIf(arg0: java_.util.function_.IntPredicate_): boolean;
        removeIf(arg0: Internal.IntPredicate_): boolean;
        contains(arg0: any): boolean;
        contains(arg0: number): boolean;
        size(): number;
        addAll(arg0: Internal.IntCollection_): boolean;
        addAll(arg0: Internal.Collection_<number>): boolean;
        equals(arg0: any): boolean;
        intParallelStream(): Internal.IntStream;
        retainAll(arg0: Internal.IntCollection_): boolean;
        retainAll(arg0: Internal.Collection_<any>): boolean;
    }
    type IntCollection_ = IntCollection;
    interface CustomProperty {
        get(): any;
    }
    type CustomProperty_ = CustomProperty;
    interface IReverseTag <V> {
        getTagKeys(): Internal.Stream<Internal.TagKey<V>>;
        containsTag(arg0: Internal.TagKey_<V>): boolean;
        containsTag(arg0: Internal.ITag_<V>): boolean;
    }
    type IReverseTag_<V> = IReverseTag<V>;
    class ParticleEngine implements Internal.PreparableReloadListener, Internal.PhasedParticleEngine {
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        hashCode(): number;
        notifyAll(): void;
        equals(arg0: any): boolean;
        addBlockHitEffects(arg0: BlockPos_, arg1: Internal.BlockHitResult_): void;
        toString(): string;
        setParticleRenderingPhase(arg0: Internal.ParticleRenderingPhase_): void;
        render(arg0: Internal.PoseStack_, arg1: Internal.MultiBufferSource$BufferSource_, arg2: Internal.LightTexture_, arg3: Internal.Camera_, arg4: number, arg5: net.minecraft.client.renderer.culling.Frustum_): void;
        notify(): void;
        get class(): Internal.Class<any>;
        set particleRenderingPhase(arg0: Internal.ParticleRenderingPhase_);
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    type ParticleEngine_ = ParticleEngine;
    /**
    * Represents an Ingredient, which can match one or multiple ItemStacks.
    *
    * Can be casted from several object, which has different usages.
    *
    * If you want to specify nbt to check in ItemStack, use either Item.of() or {type: "forge:nbt"}.
    *
    * Using {item: ItemStackJS} will NOT preserve NBT in any form.
    */
    interface IngredientJS extends Internal.JsonSerializable, Internal.WrappedJS, Internal.Copyable {
        anyStackMatches(ingredient: Internal.IngredientJS_): boolean;
        getItemIds(): Internal.Set<string>;
        testVanillaItem(item: Internal.Item_): boolean;
        test(arg0: Internal.ItemStackJS_): boolean;
        getStacks(): Internal.Set<Internal.ItemStackJS>;
        getVanillaItems(): Internal.Set<Internal.Item>;
        isEmpty(): boolean;
        asIngredientStack(): Internal.IngredientStackJS;
        isInvalidRecipeIngredient(): boolean;
        getVanillaPredicate(): Internal.Predicate<Internal.ItemStack>;
        filter(filter: Internal.IngredientJS_): Internal.IngredientJS;
        createVanillaIngredient(): Internal.Ingredient;
        toJson(): Internal.JsonElement;
        not(): Internal.IngredientJS;
        withCount(count: number): Internal.IngredientJS;
        unwrapStackIngredient(): Internal.List<Internal.IngredientJS>;
        getFirst(): Internal.ItemStackJS;
        testVanilla(stack: Internal.ItemStack_): boolean;
        x(c: number): Internal.IngredientJS;
        copy(): Internal.IngredientJS;
        getCount(): number;
    }
    /**
    * Represents an Ingredient, which can match one or multiple ItemStacks.
    *
    * Can be casted from several object, which has different usages.
    *
    * If you want to specify nbt to check in ItemStack, use either Item.of() or {type: "forge:nbt"}.
    *
    * Using {item: ItemStackJS} will NOT preserve NBT in any form.
    */
    type IngredientJS_ = `#${string}` | Internal.ItemStackJS_ | Internal.FluidStackJS_ | "*" | `@${string}` | `%${string}` | RegExp | Internal.Ingredient_ | Internal.IngredientJS_[] | {type: "forge:nbt", item: `${string}:${string}` | {item: string, count?: number}, nbt: object} | {item: Internal.ItemStackJS_, count?: number} | {fluid: Internal.FluidStackJS_} | {value: object} | {ingredient: object} | ((arg0: Internal.ItemStackJS) => boolean) | IngredientJS;
    interface Function11 <T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, R> {
        curry9(): Internal.Function9<T1, T2, T3, T4, T5, T6, T7, T8, T9, Internal.BiFunction<T10, T11, R>>;
        apply(arg0: T1, arg1: T2, arg2: T3, arg3: T4, arg4: T5, arg5: T6, arg6: T7, arg7: T8, arg8: T9, arg9: T10, arg10: T11): R;
        curry7(): Internal.Function7<T1, T2, T3, T4, T5, T6, T7, Internal.Function4<T8, T9, T10, T11, R>>;
        curry8(): Internal.Function8<T1, T2, T3, T4, T5, T6, T7, T8, Internal.Function3<T9, T10, T11, R>>;
        curry5(): Internal.Function5<T1, T2, T3, T4, T5, Internal.Function6<T6, T7, T8, T9, T10, T11, R>>;
        curry6(): Internal.Function6<T1, T2, T3, T4, T5, T6, Internal.Function5<T7, T8, T9, T10, T11, R>>;
        curry3(): Internal.Function3<T1, T2, T3, Internal.Function8<T4, T5, T6, T7, T8, T9, T10, T11, R>>;
        curry10(): Internal.Function10<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, java_.util.function_.Function<T11, R>>;
        curry4(): Internal.Function4<T1, T2, T3, T4, Internal.Function7<T5, T6, T7, T8, T9, T10, T11, R>>;
        curry2(): Internal.BiFunction<T1, T2, Internal.Function9<T3, T4, T5, T6, T7, T8, T9, T10, T11, R>>;
        curry(): java_.util.function_.Function<T1, Internal.Function10<T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, R>>;
    }
    type Function11_<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, R> = Function11<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, R>;
    interface VertexConsumer extends Internal.IForgeVertexConsumer, Internal.VertexDrain {
        applyBakedLighting(arg0: number, arg1: Internal.ByteBuffer_): number;
        createSink(factory: Internal.VertexType_<any>): Internal.VertexSink;
        putBulkData(arg0: Internal.PoseStack$Pose_, arg1: Internal.BakedQuad_, arg2: number[], arg3: number, arg4: number, arg5: number, arg6: number, arg7: number[], arg8: number, arg9: boolean): void;
        putBulkData(arg0: Internal.PoseStack$Pose_, arg1: Internal.BakedQuad_, arg2: number, arg3: number, arg4: number, arg5: number, arg6: number, arg7: number, arg8: boolean): void;
        putBulkData(arg0: Internal.PoseStack$Pose_, arg1: Internal.BakedQuad_, arg2: number, arg3: number, arg4: number, arg5: number, arg6: number, arg7: number): void;
        putBulkData(arg0: Internal.PoseStack$Pose_, arg1: Internal.BakedQuad_, arg2: number, arg3: number, arg4: number, arg5: number, arg6: number, arg7: boolean): void;
        applyBakedNormals(arg0: Internal.Vector3f_, arg1: Internal.ByteBuffer_, arg2: Internal.Matrix3f_): void;
    }
    type VertexConsumer_ = VertexConsumer;
    interface Context$ClassShutterSetter {
        setClassShutter(arg0: Internal.ClassShutter_): void;
        getClassShutter(): Internal.ClassShutter;
    }
    type Context$ClassShutterSetter_ = Context$ClassShutterSetter;
    interface IControllerComponent extends Internal.IComponent {
        isValidFrontFacing(arg0: Internal.Direction_): boolean;
        setRendererObject(arg0: any): void;
        getDefinition(): Internal.ComponentDefinition;
        isFormed(): boolean;
        getRenderer(): Internal.IRenderer;
        use(arg0: Internal.Player_, arg1: Hand_, arg2: Internal.BlockHitResult_): Internal.InteractionResult;
        setFrontFacing(arg0: Internal.Direction_): void;
        getStatus(): string;
        setStatus(arg0: string): void;
        rotateTo(arg0: Internal.Rotation_): void;
        setOwner(arg0: Internal.UUID_): void;
        getFrontFacing(): Internal.Direction;
        getRendererObject(): any;
        canConnectRedstone(arg0: Internal.Direction_): boolean;
        onNeighborChange(): void;
        onDrops(arg0: Internal.NonNullList_<Internal.ItemStack_>, arg1: Internal.Player_): void;
        self(): Internal.BlockEntity;
    }
    type IControllerComponent_ = IControllerComponent;
    interface GeneratedClassLoader {
        defineClass(arg0: string, arg1: number[]): Internal.Class<any>;
        linkClass(arg0: Internal.Class_<any>): void;
    }
    type GeneratedClassLoader_ = GeneratedClassLoader;
    interface Boolean2ShortFunction extends Internal.Function<boolean, number> {
        getOrDefault(arg0: any, arg1: number): number;
        getOrDefault(arg0: boolean, arg1: number): number;
        andThenShort(arg0: Internal.Short2ShortFunction_): Internal.Boolean2ShortFunction;
        composeByte(arg0: Internal.Byte2BooleanFunction_): Internal.Byte2ShortFunction;
        andThenInt(arg0: Internal.Short2IntFunction_): Internal.Boolean2IntFunction;
        composeReference<T_>(arg0: Internal.Reference2BooleanFunction_<T_>): Internal.Reference2ShortFunction<T_>;
        andThen<T_>(arg0: java_.util.function_.Function_<number, T_>): java_.util.function_.Function<boolean, T_>;
        put(arg0: boolean, arg1: number): number;
        remove(arg0: any): number;
        remove(arg0: boolean): number;
        defaultReturnValue(): number;
        defaultReturnValue(arg0: number): void;
        andThenDouble(arg0: Internal.Short2DoubleFunction_): Internal.Boolean2DoubleFunction;
        andThenObject<T_>(arg0: Internal.Short2ObjectFunction_<T_>): Internal.Boolean2ObjectFunction<T_>;
        get(arg0: any): number;
        get(arg0: boolean): number;
        andThenLong(arg0: Internal.Short2LongFunction_): Internal.Boolean2LongFunction;
        composeLong(arg0: Internal.Long2BooleanFunction_): Internal.Long2ShortFunction;
        andThenByte(arg0: Internal.Short2ByteFunction_): Internal.Boolean2ByteFunction;
        andThenFloat(arg0: Internal.Short2FloatFunction_): Internal.Boolean2FloatFunction;
        apply(arg0: boolean): number;
        containsKey(arg0: boolean): boolean;
        containsKey(arg0: any): boolean;
        composeInt(arg0: Internal.Int2BooleanFunction_): Internal.Int2ShortFunction;
        clear(): void;
        composeFloat(arg0: Internal.Float2BooleanFunction_): Internal.Float2ShortFunction;
        andThenChar(arg0: Internal.Short2CharFunction_): Internal.Boolean2CharFunction;
        composeObject<T_>(arg0: Internal.Object2BooleanFunction_<T_>): Internal.Object2ShortFunction<T_>;
        size(): number;
        compose<T_>(arg0: java_.util.function_.Function_<T_, boolean>): java_.util.function_.Function<T_, number>;
        composeShort(arg0: Internal.Short2BooleanFunction_): Internal.Short2ShortFunction;
        andThenReference<T_>(arg0: Internal.Short2ReferenceFunction_<T_>): Internal.Boolean2ReferenceFunction<T_>;
        composeChar(arg0: Internal.Char2BooleanFunction_): Internal.Char2ShortFunction;
        composeDouble(arg0: Internal.Double2BooleanFunction_): Internal.Double2ShortFunction;
    }
    type Boolean2ShortFunction_ = ((arg0: boolean) => number) | Boolean2ShortFunction;
    class FontSet implements Internal.AutoCloseable {
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        hashCode(): number;
        notifyAll(): void;
        equals(arg0: any): boolean;
        toString(): string;
        close(): void;
        notify(): void;
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    type FontSet_ = FontSet;
    class Locale implements Internal.Cloneable, Internal.Serializable {
        stripExtensions(): Internal.Locale;
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        static forLanguageTag(arg0: string): Internal.Locale;
        getUnicodeLocaleAttributes(): Internal.Set<string>;
        getCountry(): string;
        notifyAll(): void;
        getUnicodeLocaleKeys(): Internal.Set<string>;
        notify(): void;
        getISO3Country(): string;
        static lookupTag(arg0: Internal.List_<Internal.Locale$LanguageRange_>, arg1: Internal.Collection_<string>): string;
        getDisplayCountry(): string;
        getDisplayCountry(arg0: Internal.Locale_): string;
        getISO3Language(): string;
        static getISOCountries(arg0: Internal.Locale$IsoCountryCode_): Internal.Set<string>;
        static getISOCountries(): string[];
        hashCode(): number;
        getExtensionKeys(): Internal.Set<string>;
        getDisplayVariant(): string;
        getDisplayVariant(arg0: Internal.Locale_): string;
        static filterTags(arg0: Internal.List_<Internal.Locale$LanguageRange_>, arg1: Internal.Collection_<string>): Internal.List<string>;
        static filterTags(arg0: Internal.List_<Internal.Locale$LanguageRange_>, arg1: Internal.Collection_<string>, arg2: Internal.Locale$FilteringMode_): Internal.List<string>;
        static getISOLanguages(): string[];
        toLanguageTag(): string;
        static getAvailableLocales(): Internal.Locale[];
        getDisplayScript(arg0: Internal.Locale_): string;
        getDisplayScript(): string;
        static lookup(arg0: Internal.List_<Internal.Locale$LanguageRange_>, arg1: Internal.Collection_<Internal.Locale_>): Internal.Locale;
        getLanguage(): string;
        getExtension(arg0: string): string;
        getVariant(): string;
        static getDefault(arg0: Internal.Locale$Category_): Internal.Locale;
        static getDefault(): Internal.Locale;
        static setDefault(arg0: Internal.Locale$Category_, arg1: Internal.Locale_): void;
        static setDefault(arg0: Internal.Locale_): void;
        hasExtensions(): boolean;
        static filter(arg0: Internal.List_<Internal.Locale$LanguageRange_>, arg1: Internal.Collection_<Internal.Locale_>): Internal.List<Internal.Locale>;
        static filter(arg0: Internal.List_<Internal.Locale$LanguageRange_>, arg1: Internal.Collection_<Internal.Locale_>, arg2: Internal.Locale$FilteringMode_): Internal.List<Internal.Locale>;
        getDisplayName(): string;
        getDisplayName(arg0: Internal.Locale_): string;
        equals(arg0: any): boolean;
        clone(): any;
        toString(): string;
        getDisplayLanguage(): string;
        getDisplayLanguage(arg0: Internal.Locale_): string;
        getScript(): string;
        getUnicodeLocaleType(arg0: string): string;
        static readonly PRC : Internal.Locale;
        static readonly CANADA : Internal.Locale;
        static readonly ENGLISH : Internal.Locale;
        static readonly ROOT : Internal.Locale;
        static readonly TAIWAN : Internal.Locale;
        static readonly CHINA : Internal.Locale;
        static readonly ITALY : Internal.Locale;
        static readonly CHINESE : Internal.Locale;
        static readonly KOREA : Internal.Locale;
        static readonly FRENCH : Internal.Locale;
        static readonly FRANCE : Internal.Locale;
        static readonly TRADITIONAL_CHINESE : Internal.Locale;
        static readonly CANADA_FRENCH : Internal.Locale;
        static readonly GERMANY : Internal.Locale;
        static readonly ITALIAN : Internal.Locale;
        static readonly PRIVATE_USE_EXTENSION : "x";
        static readonly UK : Internal.Locale;
        static readonly JAPAN : Internal.Locale;
        static readonly JAPANESE : Internal.Locale;
        static readonly UNICODE_LOCALE_EXTENSION : "u";
        static readonly SIMPLIFIED_CHINESE : Internal.Locale;
        static readonly GERMAN : Internal.Locale;
        static readonly US : Internal.Locale;
        static readonly KOREAN : Internal.Locale;
        get unicodeLocaleKeys(): Internal.Set<string>;
        get country(): string;
        get displayName(): string;
        get iSOLanguages(): string[];
        get displayVariant(): string;
        get language(): string;
        get displayLanguage(): string;
        get script(): string;
        get iSO3Country(): string;
        get availableLocales(): Internal.Locale[];
        get iSOCountries(): string[];
        get unicodeLocaleAttributes(): Internal.Set<string>;
        get default(): Internal.Locale;
        get displayCountry(): string;
        get variant(): string;
        get extensionKeys(): Internal.Set<string>;
        get displayScript(): string;
        get class(): Internal.Class<any>;
        get iSO3Language(): string;
        set default(arg0: Internal.Locale_);
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    type Locale_ = Locale;
    abstract class AbstractLong2ObjectMap <V> extends Internal.AbstractLong2ObjectFunction<V> implements Internal.Long2ObjectMap<V>, Internal.Serializable {
        getClass(): Internal.Class<any>;
        getOrDefault(arg0: number, arg1: V): V;
        getOrDefault(arg0: any, arg1: V): V;
        replace(arg0: number, arg1: V, arg2: V): boolean;
        replace(arg0: number, arg1: V): V;
        composeByte(arg0: Internal.Byte2LongFunction_): Internal.Byte2ObjectFunction<V>;
        andThen<V_>(arg0: java_.util.function_.Function_<V, V_>): java_.util.function_.Function<number, V_>;
        composeReference<T_>(arg0: Internal.Reference2LongFunction_<T_>): Internal.Reference2ObjectFunction<T_, V>;
        put(arg0: number, arg1: V): V;
        containsValue(arg0: any): boolean;
        compute(arg0: number, arg1: Internal.BiFunction_<number, V, V>): V;
        defaultReturnValue(arg0: V): void;
        defaultReturnValue(): V;
        andThenObject<T_>(arg0: Internal.Object2ObjectFunction_<V, T_>): Internal.Long2ObjectFunction<T_>;
        merge(arg0: number, arg1: V, arg2: Internal.BiFunction_<V, V, V>): V;
        composeLong(arg0: Internal.Long2LongFunction_): Internal.Long2ObjectFunction<V>;
        entrySet(): Internal.ObjectSet<Internal.Map$Entry<number, V>>;
        containsKey(arg0: number): boolean;
        containsKey(arg0: any): boolean;
        composeObject<T_>(arg0: Internal.Object2LongFunction_<T_>): Internal.Object2ObjectFunction<T_, V>;
        size(): number;
        compose<T_>(arg0: java_.util.function_.Function_<T_, number>): java_.util.function_.Function<T_, V>;
        composeShort(arg0: Internal.Short2LongFunction_): Internal.Short2ObjectFunction<V>;
        composeChar(arg0: Internal.Char2LongFunction_): Internal.Char2ObjectFunction<V>;
        composeDouble(arg0: Internal.Double2LongFunction_): Internal.Double2ObjectFunction<V>;
        long2ObjectEntrySet(): Internal.ObjectSet<Internal.Long2ObjectMap$Entry<V>>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        computeIfAbsent(arg0: number, arg1: Internal.Long2ObjectFunction_<V>): V;
        computeIfAbsent(arg0: number, arg1: Internal.LongFunction_<V>): V;
        computeIfAbsent(arg0: number, arg1: java_.util.function_.Function_<number, V>): V;
        notifyAll(): void;
        values(): Internal.ObjectCollection<V>;
        andThenShort(arg0: Internal.Object2ShortFunction_<V>): Internal.Long2ShortFunction;
        computeIfAbsentPartial(arg0: number, arg1: Internal.Long2ObjectFunction_<V>): V;
        replaceAll(arg0: Internal.BiFunction_<number, V, V>): void;
        andThenInt(arg0: Internal.Object2IntFunction_<V>): Internal.Long2IntFunction;
        remove(arg0: any): V;
        remove(arg0: number): V;
        remove(arg0: number, arg1: any): boolean;
        remove(arg0: any, arg1: any): boolean;
        notify(): void;
        andThenDouble(arg0: Internal.Object2DoubleFunction_<V>): Internal.Long2DoubleFunction;
        hashCode(): number;
        get(arg0: any): V;
        get(arg0: number): V;
        putAll(arg0: Internal.Map_<number, V>): void;
        andThenLong(arg0: Internal.Object2LongFunction_<V>): Internal.Long2LongFunction;
        keySet(): Internal.LongSet;
        andThenByte(arg0: Internal.Object2ByteFunction_<V>): Internal.Long2ByteFunction;
        andThenFloat(arg0: Internal.Object2FloatFunction_<V>): Internal.Long2FloatFunction;
        apply(arg0: number): V;
        forEach(arg0: Internal.BiConsumer_<number, V>): void;
        composeInt(arg0: Internal.Int2LongFunction_): Internal.Int2ObjectFunction<V>;
        clear(): void;
        isEmpty(): boolean;
        composeFloat(arg0: Internal.Float2LongFunction_): Internal.Float2ObjectFunction<V>;
        andThenChar(arg0: Internal.Object2CharFunction_<V>): Internal.Long2CharFunction;
        computeIfPresent(arg0: number, arg1: Internal.BiFunction_<number, V, V>): V;
        equals(arg0: any): boolean;
        andThenReference<T_>(arg0: Internal.Object2ReferenceFunction_<V, T_>): Internal.Long2ReferenceFunction<T_>;
        toString(): string;
        putIfAbsent(arg0: number, arg1: V): V;
        get class(): Internal.Class<any>;
        get empty(): boolean;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    type AbstractLong2ObjectMap_<V> = AbstractLong2ObjectMap<V>;
    class LootContextJS {
        getBlockPos(): BlockPos;
        cancel(): void;
        getClass(): Internal.Class<any>;
        findLoot(arg0: ItemFilter_): Internal.List<Internal.ItemStackJS>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        getPlayer(): Internal.PlayerJS<any>;
        getCustomData(): Internal.Map<string, any>;
        isCanceled(): boolean;
        notifyAll(): void;
        getTool(): Internal.ItemStackJS;
        getLootTableId(): ResourceLocation;
        notify(): void;
        lootSize(): number;
        isExploded(): boolean;
        getRandom(): Internal.Random;
        hashCode(): number;
        forEachLoot(arg0: Internal.Consumer_<Internal.ItemStackJS_>): void;
        getVanillaContext(): Internal.LootContext;
        getDestroyedBlock(): Internal.BlockContainerJS;
        getServer(): Internal.ServerJS;
        hasLoot(arg0: ItemFilter_): boolean;
        getLuck(): number;
        getEntity(): Internal.EntityJS;
        getLooting(): number;
        addLoot(arg0: Internal.ItemStackJS_): void;
        getLevel(): Internal.LevelJS;
        getPosition(): Vec3;
        getDamageSource(): Internal.DamageSource;
        getType(): LootType;
        equals(arg0: any): boolean;
        getExplosionRadius(): number;
        toString(): string;
        removeLoot(arg0: ItemFilter_): void;
        getKillerEntity(): Internal.EntityJS;
        get server(): Internal.ServerJS;
        get luck(): number;
        get blockPos(): BlockPos;
        get exploded(): boolean;
        get level(): Internal.LevelJS;
        get looting(): number;
        get damageSource(): Internal.DamageSource;
        get killerEntity(): Internal.EntityJS;
        get customData(): Internal.Map<string, any>;
        get vanillaContext(): Internal.LootContext;
        get type(): LootType;
        get tool(): Internal.ItemStackJS;
        get explosionRadius(): number;
        get lootTableId(): ResourceLocation;
        get canceled(): boolean;
        get random(): Internal.Random;
        get destroyedBlock(): Internal.BlockContainerJS;
        get position(): Vec3;
        get class(): Internal.Class<any>;
        get entity(): Internal.EntityJS;
        get player(): Internal.PlayerJS<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    type LootContextJS_ = LootContextJS;
    interface Stroke {
        createStrokedShape(arg0: Internal.Shape_): Internal.Shape;
    }
    type Stroke_ = Stroke;
    class IO extends Internal.Enum<Internal.IO> {
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        static valueOf(arg0: string): Internal.IO;
        static valueOf<T_>(arg0: Internal.Class_<T_>, arg1: string): T_;
        notifyAll(): void;
        static values(): Internal.IO[];
        compareTo(arg0: Internal.IO_): number;
        describeConstable(): Internal.Optional<Internal.Enum$EnumDesc<Internal.IO>>;
        notify(): void;
        getDeclaringClass(): Internal.Class<Internal.IO>;
        hashCode(): number;
        equals(arg0: any): boolean;
        name(): string;
        toString(): string;
        ordinal(): number;
        static readonly IN : Internal.IO;
        static readonly VALUES : Internal.IO[];
        static readonly NONE : Internal.IO;
        static readonly BOTH : Internal.IO;
        static readonly OUT : Internal.IO;
        get class(): Internal.Class<any>;
        get declaringClass(): Internal.Class<Internal.IO>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    type IO_ = "in" | "none" | "out" | "both" | IO;
    abstract class Enchantment extends Internal.ForgeRegistryEntry<Internal.Enchantment> {
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        hashCode(): number;
        notifyAll(): void;
        equals(arg0: any): boolean;
        getRegistryType(): Internal.Class<Internal.Enchantment>;
        getRegistryName(): ResourceLocation;
        toString(): string;
        setRegistryName(arg0: ResourceLocation_): Internal.Enchantment;
        setRegistryName(arg0: string): Internal.Enchantment;
        setRegistryName(arg0: string, arg1: string): Internal.Enchantment;
        isAllowedOnBooks(): boolean;
        notify(): void;
        canApplyAtEnchantingTable(arg0: Internal.ItemStack_): boolean;
        readonly delegate : Internal.IRegistryDelegate<Internal.Enchantment>;
        get registryType(): Internal.Class<Internal.Enchantment>;
        get allowedOnBooks(): boolean;
        get registryName(): ResourceLocation;
        get class(): Internal.Class<any>;
        set registryName(arg0: ResourceLocation_);
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    type Enchantment_ = Enchantment;
    interface Double2FloatFunction extends Internal.Function<number, number>, Internal.DoubleUnaryOperator {
        getOrDefault(arg0: any, arg1: number): number;
        getOrDefault(arg0: number, arg1: number): number;
        applyAsDouble(arg0: number): number;
        andThenShort(arg0: Internal.Float2ShortFunction_): Internal.Double2ShortFunction;
        composeByte(arg0: Internal.Byte2DoubleFunction_): Internal.Byte2FloatFunction;
        andThenInt(arg0: Internal.Float2IntFunction_): Internal.Double2IntFunction;
        composeReference<T_>(arg0: Internal.Reference2DoubleFunction_<T_>): Internal.Reference2FloatFunction<T_>;
        andThen<T_>(arg0: java_.util.function_.Function_<number, T_>): java_.util.function_.Function<number, T_>;
        andThen(arg0: Internal.DoubleUnaryOperator_): Internal.DoubleUnaryOperator;
        put(arg0: number, arg1: number): number;
        remove(arg0: number): number;
        remove(arg0: any): number;
        defaultReturnValue(): number;
        defaultReturnValue(arg0: number): void;
        andThenDouble(arg0: Internal.Float2DoubleFunction_): Internal.Double2DoubleFunction;
        andThenObject<T_>(arg0: Internal.Float2ObjectFunction_<T_>): Internal.Double2ObjectFunction<T_>;
        get(arg0: any): number;
        get(arg0: number): number;
        andThenLong(arg0: Internal.Float2LongFunction_): Internal.Double2LongFunction;
        composeLong(arg0: Internal.Long2DoubleFunction_): Internal.Long2FloatFunction;
        andThenByte(arg0: Internal.Float2ByteFunction_): Internal.Double2ByteFunction;
        andThenFloat(arg0: Internal.Float2FloatFunction_): Internal.Double2FloatFunction;
        apply(arg0: number): number;
        containsKey(arg0: any): boolean;
        containsKey(arg0: number): boolean;
        composeInt(arg0: Internal.Int2DoubleFunction_): Internal.Int2FloatFunction;
        clear(): void;
        composeFloat(arg0: Internal.Float2DoubleFunction_): Internal.Float2FloatFunction;
        andThenChar(arg0: Internal.Float2CharFunction_): Internal.Double2CharFunction;
        composeObject<T_>(arg0: Internal.Object2DoubleFunction_<T_>): Internal.Object2FloatFunction<T_>;
        size(): number;
        compose<T_>(arg0: java_.util.function_.Function_<T_, number>): java_.util.function_.Function<T_, number>;
        compose(arg0: Internal.DoubleUnaryOperator_): Internal.DoubleUnaryOperator;
        composeShort(arg0: Internal.Short2DoubleFunction_): Internal.Short2FloatFunction;
        andThenReference<T_>(arg0: Internal.Float2ReferenceFunction_<T_>): Internal.Double2ReferenceFunction<T_>;
        composeChar(arg0: Internal.Char2DoubleFunction_): Internal.Char2FloatFunction;
        composeDouble(arg0: Internal.Double2DoubleFunction_): Internal.Double2FloatFunction;
    }
    type Double2FloatFunction_ = ((arg0: number) => number) | Double2FloatFunction;
    interface WritableRenderedImage extends Internal.RenderedImage {
        getMinTileX(): number;
        getMinTileY(): number;
        getTileWidth(): number;
        isTileWritable(arg0: number, arg1: number): boolean;
        getNumYTiles(): number;
        getSources(): Internal.Vector<Internal.RenderedImage>;
        getWidth(): number;
        addTileObserver(arg0: Internal.TileObserver_): void;
        getTileGridXOffset(): number;
        getWritableTileIndices(): Internal.Point[];
        getSampleModel(): Internal.SampleModel;
        getHeight(): number;
        getWritableTile(arg0: number, arg1: number): Internal.WritableRaster;
        removeTileObserver(arg0: Internal.TileObserver_): void;
        getPropertyNames(): string[];
        getNumXTiles(): number;
        getData(): Internal.Raster;
        getData(arg0: Internal.Rectangle_): Internal.Raster;
        getTileHeight(): number;
        getTile(arg0: number, arg1: number): Internal.Raster;
        getColorModel(): Internal.ColorModel;
        getProperty(arg0: string): any;
        setData(arg0: Internal.Raster_): void;
        hasTileWriters(): boolean;
        copyData(arg0: Internal.WritableRaster_): Internal.WritableRaster;
        getTileGridYOffset(): number;
        releaseWritableTile(arg0: number, arg1: number): void;
        getMinX(): number;
        getMinY(): number;
    }
    type WritableRenderedImage_ = WritableRenderedImage;
    interface PrivilegedAction <T> {
        run(): T;
    }
    type PrivilegedAction_<T> = (() => T) | PrivilegedAction<T>;
    interface GenerationProperties {
        getFeatures(arg0: DecorationGenerationStep_): Internal.Iterable<Internal.Holder<Internal.PlacedFeature>>;
        getFeatures(): Internal.List<Internal.Iterable<Internal.Holder<Internal.PlacedFeature>>>;
        getCarvers(arg0: CarvingGenerationStep_): Internal.Iterable<Internal.Holder<Internal.ConfiguredWorldCarver<any>>>;
    }
    type GenerationProperties_ = GenerationProperties;
    interface Char2ByteFunction extends Internal.Function<string, number>, Internal.IntUnaryOperator {
        getOrDefault(arg0: any, arg1: number): number;
        getOrDefault(arg0: string, arg1: number): number;
        andThenShort(arg0: Internal.Byte2ShortFunction_): Internal.Char2ShortFunction;
        composeByte(arg0: Internal.Byte2CharFunction_): Internal.Byte2ByteFunction;
        andThenInt(arg0: Internal.Byte2IntFunction_): Internal.Char2IntFunction;
        composeReference<T_>(arg0: Internal.Reference2CharFunction_<T_>): Internal.Reference2ByteFunction<T_>;
        andThen<T_>(arg0: java_.util.function_.Function_<number, T_>): java_.util.function_.Function<string, T_>;
        andThen(arg0: Internal.IntUnaryOperator_): Internal.IntUnaryOperator;
        put(arg0: string, arg1: number): number;
        remove(arg0: string): number;
        remove(arg0: any): number;
        defaultReturnValue(): number;
        defaultReturnValue(arg0: number): void;
        andThenDouble(arg0: Internal.Byte2DoubleFunction_): Internal.Char2DoubleFunction;
        andThenObject<T_>(arg0: Internal.Byte2ObjectFunction_<T_>): Internal.Char2ObjectFunction<T_>;
        get(arg0: any): number;
        get(arg0: string): number;
        andThenLong(arg0: Internal.Byte2LongFunction_): Internal.Char2LongFunction;
        composeLong(arg0: Internal.Long2CharFunction_): Internal.Long2ByteFunction;
        andThenByte(arg0: Internal.Byte2ByteFunction_): Internal.Char2ByteFunction;
        andThenFloat(arg0: Internal.Byte2FloatFunction_): Internal.Char2FloatFunction;
        applyAsInt(arg0: number): number;
        apply(arg0: string): number;
        containsKey(arg0: any): boolean;
        containsKey(arg0: string): boolean;
        composeInt(arg0: Internal.Int2CharFunction_): Internal.Int2ByteFunction;
        clear(): void;
        composeFloat(arg0: Internal.Float2CharFunction_): Internal.Float2ByteFunction;
        andThenChar(arg0: Internal.Byte2CharFunction_): Internal.Char2CharFunction;
        composeObject<T_>(arg0: Internal.Object2CharFunction_<T_>): Internal.Object2ByteFunction<T_>;
        size(): number;
        compose<T_>(arg0: java_.util.function_.Function_<T_, string>): java_.util.function_.Function<T_, number>;
        compose(arg0: Internal.IntUnaryOperator_): Internal.IntUnaryOperator;
        composeShort(arg0: Internal.Short2CharFunction_): Internal.Short2ByteFunction;
        andThenReference<T_>(arg0: Internal.Byte2ReferenceFunction_<T_>): Internal.Char2ReferenceFunction<T_>;
        composeChar(arg0: Internal.Char2CharFunction_): Internal.Char2ByteFunction;
        composeDouble(arg0: Internal.Double2CharFunction_): Internal.Double2ByteFunction;
    }
    type Char2ByteFunction_ = ((arg0: string) => number) | Char2ByteFunction;
    class RecordItem extends Internal.Item {
        getClass(): Internal.Class<any>;
        canElytraFly(arg0: Internal.ItemStack_, arg1: Internal.LivingEntity_): boolean;
        setBurnTime(i: number): void;
        setDamage(arg0: Internal.ItemStack_, arg1: number): void;
        canPerformAction(arg0: Internal.ItemStack_, arg1: Internal.ToolAction_): boolean;
        damageItem<T_>(arg0: Internal.ItemStack_, arg1: number, arg2: T_, arg3: Internal.Consumer_<T_>): number;
        shouldCauseBlockBreakReset(arg0: Internal.ItemStack_, arg1: Internal.ItemStack_): boolean;
        getItemEnchantability(arg0: Internal.ItemStack_): number;
        getPlacer(): Internal.BlockPlacerItem;
        shouldCauseReequipAnimation(arg0: Internal.ItemStack_, arg1: Internal.ItemStack_, arg2: boolean): boolean;
        getXpRepairRatio(arg0: Internal.ItemStack_): number;
        readShareTag(arg0: Internal.ItemStack_, arg1: Internal.CompoundTag_): void;
        handler$bcn000$overrideOtherStackedOnMe(arg0: Internal.ItemStack_, arg1: Internal.ItemStack_, arg2: Internal.Slot_, arg3: Internal.ClickAction_, arg4: Internal.Player_, arg5: Internal.SlotAccess_, arg6: Internal.CallbackInfoReturnable_<any>): void;
        onEntityItemUpdate(arg0: Internal.ItemStack_, arg1: Internal.ItemEntity_): boolean;
        getDamage(arg0: Internal.ItemStack_): number;
        isBookEnchantable(arg0: Internal.ItemStack_, arg1: Internal.ItemStack_): boolean;
        canDisableShield(arg0: Internal.ItemStack_, arg1: Internal.ItemStack_, arg2: Internal.LivingEntity_, arg3: Internal.LivingEntity_): boolean;
        onUsingTick(arg0: Internal.ItemStack_, arg1: Internal.LivingEntity_, arg2: number): void;
        isPiglinCurrency(arg0: Internal.ItemStack_): boolean;
        getCreativeTabs(): Internal.Collection<Internal.CreativeModeTab>;
        createEntity(arg0: Internal.Level_, arg1: Internal.Entity_, arg2: Internal.ItemStack_): Internal.Entity;
        getSweepHitBox(arg0: Internal.ItemStack_, arg1: Internal.Player_, arg2: Internal.Entity_): Internal.AABB;
        isRepairable(arg0: Internal.ItemStack_): boolean;
        getPlaceableBlock(): Internal.Block;
        getShareTag(arg0: Internal.ItemStack_): Internal.CompoundTag;
        getBurnTime(arg0: Internal.ItemStack_, arg1: Internal.RecipeType_<any>): number;
        onDroppedByPlayer(arg0: Internal.ItemStack_, arg1: Internal.Player_): boolean;
        isDamageable(arg0: Internal.ItemStack_): boolean;
        onEntitySwing(arg0: Internal.ItemStack_, arg1: Internal.LivingEntity_): boolean;
        getRegistryType(): Internal.Class<Internal.Item>;
        setItemBuilderKJS(b: Internal.ItemBuilder_): void;
        elytraFlightTick(arg0: Internal.ItemStack_, arg1: Internal.LivingEntity_, arg2: number): boolean;
        getItemBuilderKJS(): Internal.ItemBuilder;
        handler$bcn000$overrideStackedOnOther(arg0: Internal.ItemStack_, arg1: Internal.Slot_, arg2: Internal.ClickAction_, arg3: Internal.Player_, arg4: Internal.CallbackInfoReturnable_<any>): void;
        getAttributeModifiers(arg0: EquipmentSlot_, arg1: Internal.ItemStack_): Internal.Multimap<Internal.Attribute, Internal.AttributeModifier>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        onLeftClickEntity(arg0: Internal.ItemStack_, arg1: Internal.Player_, arg2: Internal.Entity_): boolean;
        canEquip(arg0: Internal.ItemStack_, arg1: EquipmentSlot_, arg2: Internal.Entity_): boolean;
        notifyAll(): void;
        getId(): string;
        notify(): void;
        onBlockStartBreak(arg0: Internal.ItemStack_, arg1: BlockPos_, arg2: Internal.Player_): boolean;
        onHorseArmorTick(arg0: Internal.ItemStack_, arg1: Internal.Level_, arg2: Internal.Mob_): void;
        canContinueUsing(arg0: Internal.ItemStack_, arg1: Internal.ItemStack_): boolean;
        getEntityLifespan(arg0: Internal.ItemStack_, arg1: Internal.Level_): number;
        getRenderPropertiesInternal(): any;
        getArmorTexture(arg0: Internal.ItemStack_, arg1: Internal.Entity_, arg2: EquipmentSlot_, arg3: string): string;
        getDefaultTooltipHideFlags(arg0: Internal.ItemStack_): number;
        hashCode(): number;
        hasCustomEntity(arg0: Internal.ItemStack_): boolean;
        getHighlightTip(arg0: Internal.ItemStack_, arg1: Internal.Component_): Internal.Component;
        canWalkOnPowderedSnow(arg0: Internal.ItemStack_, arg1: Internal.LivingEntity_): boolean;
        initializeClient(arg0: Internal.Consumer_<Internal.IItemRenderProperties_>): void;
        getMaxDamage(arg0: Internal.ItemStack_): number;
        getCreatorModId(arg0: Internal.ItemStack_): string;
        isDamaged(arg0: Internal.ItemStack_): boolean;
        onArmorTick(arg0: Internal.ItemStack_, arg1: Internal.Level_, arg2: Internal.Player_): void;
        hasContainerItem(arg0: Internal.ItemStack_): boolean;
        getFoodProperties(arg0: Internal.ItemStack_, arg1: Internal.LivingEntity_): Internal.FoodProperties;
        doesSneakBypassUse(arg0: Internal.ItemStack_, arg1: Internal.LevelReader_, arg2: BlockPos_, arg3: Internal.Player_): boolean;
        makePlaceable(arg0: Internal.Block_): void;
        onItemUseFirst(arg0: Internal.ItemStack_, arg1: Internal.UseOnContext_): Internal.InteractionResult;
        getContainerItem(arg0: Internal.ItemStack_): Internal.ItemStack;
        getRegistryName(): ResourceLocation;
        setRegistryName(arg0: ResourceLocation_): Internal.Item;
        setRegistryName(arg0: string): Internal.Item;
        setRegistryName(arg0: string, arg1: string): Internal.Item;
        onDestroyed(arg0: Internal.ItemEntity_, arg1: Internal.DamageSource_): void;
        isCorrectToolForDrops(arg0: Internal.ItemStack_, arg1: Internal.BlockState_): boolean;
        getEquipmentSlot(arg0: Internal.ItemStack_): EquipmentSlot;
        getItemStackLimit(arg0: Internal.ItemStack_): number;
        initCapabilities(arg0: Internal.ItemStack_, arg1: Internal.CompoundTag_): Internal.ICapabilityProvider;
        equals(arg0: any): boolean;
        makesPiglinsNeutral(arg0: Internal.ItemStack_, arg1: Internal.LivingEntity_): boolean;
        getTypeData(): Internal.CompoundTag;
        toString(): string;
        isEnderMask(arg0: Internal.ItemStack_, arg1: Internal.Player_, arg2: Internal.EnderMan_): boolean;
        canApplyAtEnchantingTable(arg0: Internal.ItemStack_, arg1: Internal.Enchantment_): boolean;
        readonly delegate : Internal.IRegistryDelegate<Internal.Item>;
        renderProperties : any;
        get registryType(): Internal.Class<Internal.Item>;
        get itemBuilderKJS(): Internal.ItemBuilder;
        get renderPropertiesInternal(): any;
        get placer(): Internal.BlockPlacerItem;
        get placeableBlock(): Internal.Block;
        get creativeTabs(): Internal.Collection<Internal.CreativeModeTab>;
        get id(): string;
        get registryName(): ResourceLocation;
        get typeData(): Internal.CompoundTag;
        get class(): Internal.Class<any>;
        set itemBuilderKJS(b: Internal.ItemBuilder_);
        set burnTime(i: number);
        set registryName(arg0: ResourceLocation_);
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    type RecordItem_ = RecordItem;
    abstract class MinecraftServer extends Internal.ReentrantBlockableEventLoop<any> implements Internal.CommandSource, Internal.AutoCloseable, Internal.MinecraftServerAccess, Internal.ServerKillCountDown, Internal.MinecraftServerKJS {
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        redirect$znk000$onSaveALlChunks(arg0: Internal.MinecraftServer_, arg1: boolean, arg2: boolean, arg3: boolean): boolean;
        forgeGetWorldMap(): Internal.Map<Internal.ResourceKey<Internal.Level>, Internal.ServerLevel>;
        notifyAll(): void;
        setKillCountdown(arg0: number, arg1: boolean): void;
        getTickTime(arg0: Internal.ResourceKey_<Internal.Level_>): number[];
        execute(arg0: Internal.Runnable_): void;
        asKJS(): any;
        notify(): void;
        handler$zfn000$onHalt(arg0: boolean, arg1: Internal.CallbackInfo_): void;
        redirect$cdj000$wrapResourceManager(packType: Internal.PackType_, list: Internal.List_<any>): Internal.MultiPackResourceManager;
        hashCode(): number;
        equals(arg0: any): boolean;
        getServerResources(): Internal.MinecraftServer$ReloadableResources;
        markWorldsDirty(): void;
        toString(): string;
        close(): void;
        get serverResources(): Internal.MinecraftServer$ReloadableResources;
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    type MinecraftServer_ = MinecraftServer;
    interface CustomIngredientActionCallback {
        transform(arg0: Internal.ItemStackJS_, arg1: number, arg2: Internal.InventoryJS_): any;
    }
    type CustomIngredientActionCallback_ = ((arg0: Internal.ItemStackJS, arg1: number, arg2: Internal.InventoryJS) => any) | CustomIngredientActionCallback;
    interface EntityTypeTest <B, T> {
    }
    type EntityTypeTest_<B, T> = EntityTypeTest<B, T>;
    interface LongCollection extends Internal.Collection<number>, Internal.LongIterable {
        longIterator(): Internal.LongIterator;
        remove(arg0: any): boolean;
        removeAll(arg0: Internal.LongCollection_): boolean;
        removeAll(arg0: Internal.Collection_<any>): boolean;
        iterator(): Internal.LongIterator;
        stream(): Internal.Stream<number>;
        hashCode(): number;
        toArray(arg0: number[]): number[];
        toArray<T_>(arg0: T_[]): T_[];
        toArray<T_>(arg0: Internal.IntFunction_<T_[]>): T_[];
        toArray(): any[];
        longStream(): Internal.LongStream;
        parallelStream(): Internal.Stream<number>;
        rem(arg0: number): boolean;
        add(arg0: number): boolean;
        longSpliterator(): Internal.LongSpliterator;
        toLongArray(arg0: number[]): number[];
        toLongArray(): number[];
        spliterator(): Internal.LongSpliterator;
        forEach(arg0: Internal.Consumer_<number>): void;
        forEach(arg0: java_.util.function_.LongConsumer_): void;
        forEach(arg0: Internal.LongConsumer_): void;
        containsAll(arg0: Internal.LongCollection_): boolean;
        containsAll(arg0: Internal.Collection_<any>): boolean;
        isEmpty(): boolean;
        clear(): void;
        longParallelStream(): Internal.LongStream;
        removeIf(arg0: Internal.LongPredicate_): boolean;
        removeIf(arg0: Internal.Predicate_<number>): boolean;
        removeIf(arg0: it.unimi.dsi.fastutil.longs.LongPredicate_): boolean;
        contains(arg0: number): boolean;
        contains(arg0: any): boolean;
        size(): number;
        addAll(arg0: Internal.LongCollection_): boolean;
        addAll(arg0: Internal.Collection_<number>): boolean;
        equals(arg0: any): boolean;
        retainAll(arg0: Internal.LongCollection_): boolean;
        retainAll(arg0: Internal.Collection_<any>): boolean;
    }
    type LongCollection_ = LongCollection;
    interface ShaderInstanceInterface {
        iris$createGeometryShader(arg0: Internal.ResourceProvider_, arg1: ResourceLocation_): void;
    }
    type ShaderInstanceInterface_ = ShaderInstanceInterface;
    interface DoubleConsumer extends Internal.Consumer<number>, java_.util.function_.DoubleConsumer {
        andThen(arg0: java_.util.function_.DoubleConsumer_): Internal.DoubleConsumer;
        andThen(arg0: Internal.Consumer_<number>): Internal.Consumer<number>;
        andThen(arg0: Internal.DoubleConsumer_): Internal.DoubleConsumer;
        accept(arg0: number): void;
    }
    type DoubleConsumer_ = ((arg0: number) => void) | DoubleConsumer;
    interface ObjectCollection <K> extends Internal.Collection<K>, Internal.ObjectIterable<K> {
        add(arg0: K): boolean;
        spliterator(): Internal.ObjectSpliterator<K>;
        forEach(arg0: Internal.Consumer_<K>): void;
        containsAll(arg0: Internal.Collection_<any>): boolean;
        isEmpty(): boolean;
        clear(): void;
        remove(arg0: any): boolean;
        removeIf(arg0: Internal.Predicate_<K>): boolean;
        removeAll(arg0: Internal.Collection_<any>): boolean;
        contains(arg0: any): boolean;
        iterator(): Internal.ObjectIterator<K>;
        size(): number;
        addAll(arg0: Internal.Collection_<K>): boolean;
        stream(): Internal.Stream<K>;
        hashCode(): number;
        equals(arg0: any): boolean;
        toArray<T_>(arg0: T_[]): T_[];
        toArray<T_>(arg0: Internal.IntFunction_<T_[]>): T_[];
        toArray(): any[];
        parallelStream(): Internal.Stream<K>;
        retainAll(arg0: Internal.Collection_<any>): boolean;
    }
    type ObjectCollection_<K> = ObjectCollection<K>;
    abstract class StateHolder <O, S> {
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        hashCode(): number;
        notifyAll(): void;
        equals(arg0: any): boolean;
        toString(): string;
        notify(): void;
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    type StateHolder_<O, S> = StateHolder<O, S>;
    class ServerPlayer extends Internal.Player implements Internal.BYGPlayerTrackedData$Access, Internal.BYGAdditionalData {
        getClass(): Internal.Class<any>;
        setItemSwapAnimationTimer(count: number): void;
        resetDynamicLight(): void;
        getCapability<T_>(arg0: Internal.Capability_<T_>, arg1: Internal.Direction_): Internal.LazyOptional<T_>;
        getCapability<T_>(arg0: Internal.Capability_<T_>): Internal.LazyOptional<T_>;
        captureDrops(arg0: Internal.Collection_<Internal.ItemEntity_>): Internal.Collection<Internal.ItemEntity>;
        captureDrops(): Internal.Collection<Internal.ItemEntity>;
        botania$setCritTarget(arg0: Internal.LivingEntity_): void;
        canBeRiddenInWater(arg0: Internal.Entity_): boolean;
        setCitadelEntityData(arg0: Internal.CompoundTag_): void;
        isDynamicLightEnabled(): boolean;
        changeDimension(arg0: Internal.ServerLevel_, arg1: Internal.ITeleporter_): Internal.Entity;
        serializeNBT(): Internal.CompoundTag;
        invalidateCaps(): void;
        setDynamicLightEnabled(arg0: boolean): void;
        shouldUpdateDynamicLight(): boolean;
        foodEatenKJS(is: Internal.ItemStack_): void;
        redirect$bid001$elytraOverride(arg0: Internal.ItemStack_, arg1: Internal.LivingEntity_): boolean;
        revive(): void;
        setVisualScale(arg0: number): void;
        getDigSpeed(arg0: Internal.BlockState_, arg1: BlockPos_): number;
        write(): net.minecraft.nbt.Tag;
        dynamicLightTick(): void;
        readBYG(arg0: Internal.CompoundTag_): void;
        getPersistentDataKJS(): Internal.CompoundTag;
        canUpdate(): boolean;
        canUpdate(arg0: boolean): void;
        getDynamicLightY(): number;
        getSuffixes(): Internal.Collection<Internal.MutableComponent>;
        getDynamicLightZ(): number;
        handler$zbj000$curio$canFreeze(arg0: Internal.CallbackInfoReturnable_<any>): void;
        read(arg0: Internal.CompoundTag_): void;
        getDynamicLightX(): number;
        areCapsCompatible(arg0: Internal.CapabilityProvider_<Internal.Entity_>): boolean;
        areCapsCompatible(arg0: Internal.CapabilityDispatcher_): boolean;
        getSideSword(): Internal.ItemStack;
        redirect$bie002$elytraOverride(arg0: Internal.ItemStack_, arg1: Internal.LivingEntity_): boolean;
        getEyeHeightAccess(arg0: Internal.Pose_, arg1: Internal.EntityDimensions_): number;
        reviveCaps(): void;
        lambdynlights$updateDynamicLight(arg0: Internal.LevelRenderer_): boolean;
        handler$bih000$removed(arg0: Internal.CallbackInfo_): void;
        setForcedPose(arg0: Internal.Pose_): void;
        canRiderInteract(): boolean;
        lambdynlights$scheduleTrackedChunksRebuild(arg0: Internal.LevelRenderer_): void;
        handler$bih001$onTick(arg0: Internal.CallbackInfo_): void;
        setLastAnimationSwapTick(count: number): void;
        onAddedToWorld(): void;
        lastUpdate(): number;
        getItemSwapAnimationTimer(): number;
        getPrefixes(): Internal.Collection<Internal.MutableComponent>;
        canTrample(arg0: Internal.BlockState_, arg1: BlockPos_, arg2: number): boolean;
        getCitadelEntityData(): Internal.CompoundTag;
        getPoseOverwrite(): Internal.Pose;
        setUpdated(frameId: number): void;
        getClassification(arg0: boolean): Internal.MobCategory;
        handler$bih000$onRemove(arg0: Internal.CallbackInfo_): void;
        getLastAnimationSwapTick(): number;
        shouldRiderSit(): boolean;
        getPickedResult(arg0: Internal.HitResult_): Internal.ItemStack;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        notifyAll(): void;
        isActuallyReallyBlocking(): boolean;
        setSideSword(item: Internal.ItemStack_): void;
        isUpdated(frameId: number): boolean;
        getPersistentData(): Internal.CompoundTag;
        getStagesRawKJS(): Internal.Stages;
        handler$bjh000$tick(info: Internal.CallbackInfo_): void;
        notify(): void;
        redirect$bie000$eytraValidOverride(arg0: Internal.ItemStack_, arg1: Internal.LivingEntity_, arg2: number): boolean;
        getStages(): Internal.Stages;
        getLastHeldItems(): Internal.ItemStack[];
        hashCode(): number;
        getPlayerTrackedData(): Internal.BYGPlayerTrackedData;
        refreshTabListName(): void;
        setDimension(arg0: Internal.EntityDimensions_): void;
        isBodyRotationDisabled(): boolean;
        isAddedToWorld(): boolean;
        getData(holder: Internal.DataHolder_<any>, builder: Internal.Supplier_<any>): any;
        getParts(): any[];
        getDynamicLightWorld(): Internal.Level;
        writeBYG(arg0: Internal.CompoundTag_): void;
        getLanguage(): string;
        disableBodyRotation(val: boolean): void;
        onRemovedFromWorld(): void;
        getLuminance(): number;
        isMultipartEntity(): boolean;
        deserializeNBT(arg0: Internal.CompoundTag_): void;
        curePotionEffects(arg0: Internal.ItemStack_): boolean;
        asKJS(): any;
        setPlayerTrackedData(arg0: Internal.BYGPlayerTrackedData_): Internal.BYGPlayerTrackedData;
        handler$cfc000$getPortalWaitTime(arg0: Internal.CallbackInfoReturnable_<any>): void;
        shouldRiderFaceForward(arg0: Internal.Player_): boolean;
        setPoseOverwrite(state: Internal.Pose_): void;
        equals(arg0: any): boolean;
        toString(): string;
        getVisualScale(): number;
        getLastRotations(): number[];
        refreshDisplayName(): void;
        getForcedPose(): Internal.Pose;
        static readonly PERSISTED_NBT_TAG : "PlayerPersisted";
        get luminance(): number;
        get suffixes(): Internal.Collection<Internal.MutableComponent>;
        get citadelEntityData(): Internal.CompoundTag;
        get playerTrackedData(): Internal.BYGPlayerTrackedData;
        get stagesRawKJS(): Internal.Stages;
        get addedToWorld(): boolean;
        get language(): string;
        get dynamicLightY(): number;
        get dynamicLightZ(): number;
        get sideSword(): Internal.ItemStack;
        get dynamicLightX(): number;
        get visualScale(): number;
        get persistentDataKJS(): Internal.CompoundTag;
        get class(): Internal.Class<any>;
        get dynamicLightWorld(): Internal.Level;
        get dynamicLightEnabled(): boolean;
        get poseOverwrite(): Internal.Pose;
        get persistentData(): Internal.CompoundTag;
        get lastHeldItems(): Internal.ItemStack[];
        get multipartEntity(): boolean;
        get lastRotations(): number[];
        get prefixes(): Internal.Collection<Internal.MutableComponent>;
        get lastAnimationSwapTick(): number;
        get bodyRotationDisabled(): boolean;
        get forcedPose(): Internal.Pose;
        get actuallyReallyBlocking(): boolean;
        get stages(): Internal.Stages;
        get parts(): any[];
        get itemSwapAnimationTimer(): number;
        set poseOverwrite(state: Internal.Pose_);
        set dynamicLightEnabled(arg0: boolean);
        set visualScale(arg0: number);
        set lastAnimationSwapTick(count: number);
        set forcedPose(arg0: Internal.Pose_);
        set playerTrackedData(arg0: Internal.BYGPlayerTrackedData_);
        set citadelEntityData(arg0: Internal.CompoundTag_);
        set dimension(arg0: Internal.EntityDimensions_);
        set sideSword(item: Internal.ItemStack_);
        set updated(frameId: number);
        set itemSwapAnimationTimer(count: number);
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    type ServerPlayer_ = ServerPlayer;
    interface IForgeRegistryEntry <V> {
        getRegistryType(): Internal.Class<V>;
        getRegistryName(): ResourceLocation;
        setRegistryName(arg0: ResourceLocation_): V;
    }
    type IForgeRegistryEntry_<V> = IForgeRegistryEntry<V>;
    interface RandomAccess {
    }
    type RandomAccess_ = RandomAccess;
    abstract class LongSerializationPolicy extends Internal.Enum<Internal.LongSerializationPolicy> {
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        static valueOf(arg0: string): Internal.LongSerializationPolicy;
        static valueOf<T_>(arg0: Internal.Class_<T_>, arg1: string): T_;
        notifyAll(): void;
        static values(): Internal.LongSerializationPolicy[];
        compareTo(arg0: Internal.LongSerializationPolicy_): number;
        describeConstable(): Internal.Optional<Internal.Enum$EnumDesc<Internal.LongSerializationPolicy>>;
        notify(): void;
        getDeclaringClass(): Internal.Class<Internal.LongSerializationPolicy>;
        serialize(arg0: number): Internal.JsonElement;
        hashCode(): number;
        equals(arg0: any): boolean;
        name(): string;
        toString(): string;
        ordinal(): number;
        static readonly STRING : Internal.LongSerializationPolicy;
        static readonly DEFAULT : Internal.LongSerializationPolicy;
        get class(): Internal.Class<any>;
        get declaringClass(): Internal.Class<Internal.LongSerializationPolicy>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    type LongSerializationPolicy_ = "default" | "string" | LongSerializationPolicy;
    abstract class PlayerDataJS <E, P> implements Internal.WithAttachedData {
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        getPlayer(): P;
        getName(): string;
        notifyAll(): void;
        getProfile(): Internal.GameProfile;
        getId(): Internal.UUID;
        getOverworld(): Internal.LevelJS;
        notify(): void;
        getMinecraftPlayer(): E;
        hashCode(): number;
        equals(arg0: any): boolean;
        hasClientMod(): boolean;
        toString(): string;
        getData(): Internal.AttachedData;
        get data(): Internal.AttachedData;
        get minecraftPlayer(): E;
        get profile(): Internal.GameProfile;
        get name(): string;
        get id(): Internal.UUID;
        get overworld(): Internal.LevelJS;
        get class(): Internal.Class<any>;
        get player(): P;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    type PlayerDataJS_<E, P> = PlayerDataJS<E, P>;
    class FluidBucketItemBuilder extends Internal.ItemBuilder {
        barWidth(barWidth: Internal.ToIntFunction_<Internal.ItemStackJS_>): Internal.ItemBuilder;
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        maxStackSize(v: number): Internal.ItemBuilder;
        clientRegistry(minecraft: Internal.Minecraft_): void;
        transformObject(obj: Internal.Item_): Internal.Item;
        translationKey(key: string): Internal.BuilderBase<Internal.Item>;
        color(callback: Internal.ItemBuilder$ItemColorJS_): Internal.ItemBuilder;
        color(index: number, c: Internal.Color_): Internal.ItemBuilder;
        newID(pre: string, post: string): ResourceLocation;
        displayName(name: string): Internal.BuilderBase<Internal.Item>;
        use(use: Internal.ItemBuilder$UseCallback_): Internal.ItemBuilder;
        notifyAll(): void;
        maxDamage(v: number): Internal.ItemBuilder;
        textureJson(json: Internal.JsonObject_): Internal.ItemBuilder;
        tooltip(text: Internal.Component_): Internal.ItemBuilder;
        type(type: string): Internal.BuilderBase<Internal.Item>;
        barColor(barColor: java_.util.function_.Function_<Internal.ItemStackJS_, Internal.Color_>): Internal.ItemBuilder;
        containerItem(id: string): Internal.ItemBuilder;
        notify(): void;
        createAdditionalObjects(): void;
        subtypes(fn: java_.util.function_.Function_<Internal.ItemStackJS_, Internal.Collection_<Internal.ItemStackJS_>>): Internal.ItemBuilder;
        modelJson(json: Internal.JsonObject_): Internal.ItemBuilder;
        hashCode(): number;
        burnTime(v: number): Internal.ItemBuilder;
        get(): Internal.Item;
        useDuration(useDuration: Internal.ToIntFunction_<Internal.ItemStackJS_>): Internal.ItemBuilder;
        tag(tag: ResourceLocation_): Internal.BuilderBase<Internal.Item>;
        parentModel(m: string): Internal.ItemBuilder;
        generateDataJsons(generator: Internal.DataJsonGenerator_): void;
        group(g: string): Internal.ItemBuilder;
        generateAssetJsons(generator: Internal.AssetJsonGenerator_): void;
        getTranslationKeyGroup(): string;
        texture(key: string, tex: string): Internal.ItemBuilder;
        texture(tex: string): Internal.ItemBuilder;
        generateLang(lang: Internal.Map_<string, string>): void;
        static ofArmorMaterial(o: any): Internal.ArmorMaterial;
        food(b: Internal.Consumer_<Internal.FoodBuilder_>): Internal.ItemBuilder;
        createObject(): Internal.BucketItem;
        releaseUsing(releaseUsing: Internal.ItemBuilder$ReleaseUsingCallback_): Internal.ItemBuilder;
        unstackable(): Internal.ItemBuilder;
        addResourcePackLocations(path: string, list: Internal.List_<ResourceLocation_>, packType: Internal.PackType_): void;
        modifyAttribute(attribute: ResourceLocation_, identifier: string, d: number, operation: Internal.AttributeModifier$Operation_): Internal.ItemBuilder;
        equals(arg0: any): boolean;
        getRegistryType(): Internal.RegistryObjectBuilderTypes<Internal.Item>;
        toString(): string;
        finishUsing(finishUsing: Internal.ItemBuilder$FinishUsingCallback_): Internal.ItemBuilder;
        glow(v: boolean): Internal.ItemBuilder;
        useAnimation(animation: Internal.UseAnim_): Internal.ItemBuilder;
        rarity(v: Rarity_): Internal.ItemBuilder;
        createItemProperties(): Internal.Item$Properties;
        readonly fluidBuilder : Internal.FluidBuilder;
        static readonly TOOL_TIERS : {"gold":any,"diamond":any,"iron":any,"wood":any,"stone":any,"netherite":any};
        static readonly ARMOR_TIERS : {"gold":any,"chain":any,"diamond":any,"turtle":any,"iron":any,"leather":any,"netherite":any};
        readonly id : ResourceLocation;
        get registryType(): Internal.RegistryObjectBuilderTypes<Internal.Item>;
        get class(): Internal.Class<any>;
        get translationKeyGroup(): string;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    type FluidBucketItemBuilder_ = FluidBucketItemBuilder;
    abstract class Rectangle2D extends Internal.RectangularShape {
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        intersects(arg0: number, arg1: number, arg2: number, arg3: number): boolean;
        intersects(arg0: Internal.Rectangle2D_): boolean;
        notifyAll(): void;
        getFrame(): Internal.Rectangle2D;
        getWidth(): number;
        notify(): void;
        getBounds(): Internal.Rectangle;
        setFrameFromCenter(arg0: Internal.Point2D_, arg1: Internal.Point2D_): void;
        setFrameFromCenter(arg0: number, arg1: number, arg2: number, arg3: number): void;
        getHeight(): number;
        getPathIterator(arg0: Internal.AffineTransform_): Internal.PathIterator;
        getPathIterator(arg0: Internal.AffineTransform_, arg1: number): Internal.PathIterator;
        setFrame(arg0: number, arg1: number, arg2: number, arg3: number): void;
        setFrame(arg0: Internal.Rectangle2D_): void;
        setFrame(arg0: Internal.Point2D_, arg1: Internal.Dimension2D_): void;
        hashCode(): number;
        getCenterY(): number;
        getCenterX(): number;
        add(arg0: number, arg1: number): void;
        add(arg0: Internal.Point2D_): void;
        add(arg0: Internal.Rectangle2D_): void;
        static intersect(arg0: Internal.Rectangle2D_, arg1: Internal.Rectangle2D_, arg2: Internal.Rectangle2D_): void;
        getMaxX(): number;
        isEmpty(): boolean;
        getMaxY(): number;
        setRect(arg0: Internal.Rectangle2D_): void;
        setRect(arg0: number, arg1: number, arg2: number, arg3: number): void;
        static union(arg0: Internal.Rectangle2D_, arg1: Internal.Rectangle2D_, arg2: Internal.Rectangle2D_): void;
        setFrameFromDiagonal(arg0: number, arg1: number, arg2: number, arg3: number): void;
        setFrameFromDiagonal(arg0: Internal.Point2D_, arg1: Internal.Point2D_): void;
        getX(): number;
        intersectsLine(arg0: Internal.Line2D_): boolean;
        intersectsLine(arg0: number, arg1: number, arg2: number, arg3: number): boolean;
        contains(arg0: number, arg1: number): boolean;
        contains(arg0: number, arg1: number, arg2: number, arg3: number): boolean;
        contains(arg0: Internal.Point2D_): boolean;
        contains(arg0: Internal.Rectangle2D_): boolean;
        getY(): number;
        createUnion(arg0: Internal.Rectangle2D_): Internal.Rectangle2D;
        outcode(arg0: number, arg1: number): number;
        outcode(arg0: Internal.Point2D_): number;
        equals(arg0: any): boolean;
        clone(): any;
        getBounds2D(): Internal.Rectangle2D;
        toString(): string;
        createIntersection(arg0: Internal.Rectangle2D_): Internal.Rectangle2D;
        getMinX(): number;
        getMinY(): number;
        static readonly OUT_TOP : 2;
        static readonly OUT_RIGHT : 4;
        static readonly OUT_BOTTOM : 8;
        static readonly OUT_LEFT : 1;
        get centerY(): number;
        get centerX(): number;
        get maxY(): number;
        get maxX(): number;
        get bounds2D(): Internal.Rectangle2D;
        get empty(): boolean;
        get minY(): number;
        get minX(): number;
        get width(): number;
        get bounds(): Internal.Rectangle;
        get x(): number;
        get y(): number;
        get class(): Internal.Class<any>;
        get frame(): Internal.Rectangle2D;
        get height(): number;
        set rect(arg0: Internal.Rectangle2D_);
        set frame(arg0: Internal.Rectangle2D_);
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    type Rectangle2D_ = Rectangle2D;
    class MapJS extends Internal.LinkedHashMap<string, any> implements Internal.StringBuilderAppendable, Internal.ChangeListener<any>, Internal.Copyable, Internal.JsonSerializable, Internal.NBTSerializable {
        getClass(): Internal.Class<any>;
        static nbt(map: any): Internal.CompoundTag;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        getOrDefault(arg0: any, arg1: any): any;
        notifyAll(): void;
        computeIfAbsent(arg0: string, arg1: java_.util.function_.Function_<string, any>): any;
        values(): Internal.Collection<any>;
        replace(arg0: string, arg1: any): any;
        replace(arg0: string, arg1: any, arg2: any): boolean;
        replaceAll(arg0: Internal.BiFunction_<string, any, any>): void;
        notify(): void;
        containsValue(arg0: any): boolean;
        put(key: string, value: any): any;
        remove(key: any): any;
        remove(arg0: any, arg1: any): boolean;
        compute(arg0: string, arg1: Internal.BiFunction_<string, any, any>): any;
        toNBT(): Internal.CompoundTag;
        getOrNewList(id: string): Internal.ListJS;
        hashCode(): number;
        merge(arg0: string, arg1: any, arg2: Internal.BiFunction_<any, any, any>): any;
        get(arg0: any): any;
        putAll(m: Internal.Map_<string, any>): void;
        static of(o: any): Internal.MapJS;
        static json(map: any): Internal.JsonObject;
        copy(): Internal.MapJS;
        keySet(): Internal.Set<string>;
        appendString(builder: Internal.StringBuilder_): void;
        onChanged(o: any): void;
        entrySet(): Internal.Set<Internal.Map$Entry<string, any>>;
        containsKey(arg0: any): boolean;
        forEach(arg0: Internal.BiConsumer_<string, any>): void;
        containsAll(other: Internal.MapJS_): boolean;
        isEmpty(): boolean;
        containsAny(other: Internal.MapJS_): boolean;
        clear(): void;
        toJson(): Internal.JsonObject;
        computeIfPresent(arg0: string, arg1: Internal.BiFunction_<string, any, any>): any;
        size(): number;
        getOrNewMap(id: string): Internal.MapJS;
        equals(arg0: any): boolean;
        clone(): any;
        getLength(): number;
        toString(): string;
        putIfAbsent(arg0: string, arg1: any): any;
        changeListener : ((arg0: Internal.MapJS) => void);
        get length(): number;
        get class(): Internal.Class<any>;
        get empty(): boolean;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    type MapJS_ = MapJS;
    class AttachedData extends Internal.HashMap<string, any> {
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        getOrDefault(arg0: any, arg1: any): any;
        notifyAll(): void;
        computeIfAbsent(arg0: string, arg1: java_.util.function_.Function_<string, any>): any;
        values(): Internal.Collection<any>;
        replace(arg0: string, arg1: any): any;
        replace(arg0: string, arg1: any, arg2: any): boolean;
        replaceAll(arg0: Internal.BiFunction_<string, any, any>): void;
        notify(): void;
        containsValue(arg0: any): boolean;
        put(arg0: string, arg1: any): any;
        remove(arg0: any, arg1: any): boolean;
        remove(arg0: any): any;
        compute(arg0: string, arg1: Internal.BiFunction_<string, any, any>): any;
        hashCode(): number;
        putAll(arg0: Internal.Map_<string, any>): void;
        merge(arg0: string, arg1: any, arg2: Internal.BiFunction_<any, any, any>): any;
        get(arg0: any): any;
        keySet(): Internal.Set<string>;
        getParent(): any;
        entrySet(): Internal.Set<Internal.Map$Entry<string, any>>;
        containsKey(arg0: any): boolean;
        forEach(arg0: Internal.BiConsumer_<string, any>): void;
        isEmpty(): boolean;
        clear(): void;
        computeIfPresent(arg0: string, arg1: Internal.BiFunction_<string, any, any>): any;
        size(): number;
        equals(arg0: any): boolean;
        clone(): any;
        toString(): string;
        putIfAbsent(arg0: string, arg1: any): any;
        get parent(): any;
        get class(): Internal.Class<any>;
        get empty(): boolean;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    type AttachedData_ = AttachedData;
    abstract class AbstractByteBuf extends Internal.ByteBuf {
        asReadOnly(): Internal.ByteBuf;
        markReaderIndex(): Internal.ByteBuf;
        getByte(arg0: number): number;
        release(arg0: number): boolean;
        release(): boolean;
        readDoubleLE(): number;
        writeZero(arg0: number): Internal.ByteBuf;
        resetReaderIndex(): Internal.ByteBuf;
        writeFloat(arg0: number): Internal.ByteBuf;
        setLongLE(arg0: number, arg1: number): Internal.ByteBuf;
        readRetainedSlice(arg0: number): Internal.ByteBuf;
        slice(): Internal.ByteBuf;
        slice(arg0: number, arg1: number): Internal.ByteBuf;
        setDoubleLE(arg0: number, arg1: number): Internal.ByteBuf;
        getMediumLE(arg0: number): number;
        readUnsignedIntLE(): number;
        writeFloatLE(arg0: number): Internal.ByteBuf;
        readInt(): number;
        order(arg0: Internal.ByteOrder_): Internal.ByteBuf;
        order(): Internal.ByteOrder;
        writeMedium(arg0: number): Internal.ByteBuf;
        resetWriterIndex(): Internal.ByteBuf;
        writableBytes(): number;
        maxCapacity(): number;
        getUnsignedShort(arg0: number): number;
        nioBufferCount(): number;
        bytesBefore(arg0: number): number;
        bytesBefore(arg0: number, arg1: number, arg2: number): number;
        bytesBefore(arg0: number, arg1: number): number;
        setInt(arg0: number, arg1: number): Internal.ByteBuf;
        getInt(arg0: number): number;
        markWriterIndex(): Internal.ByteBuf;
        isReadable(arg0: number): boolean;
        isReadable(): boolean;
        writeBoolean(arg0: boolean): Internal.ByteBuf;
        setIntLE(arg0: number, arg1: number): Internal.ByteBuf;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        writeLongLE(arg0: number): Internal.ByteBuf;
        setShortLE(arg0: number, arg1: number): Internal.ByteBuf;
        retain(): Internal.ByteBuf;
        retain(arg0: number): Internal.ByteBuf;
        isWritable(): boolean;
        isWritable(arg0: number): boolean;
        notify(): void;
        readChar(): string;
        hasMemoryAddress(): boolean;
        capacity(): number;
        capacity(arg0: number): Internal.ByteBuf;
        readCharSequence(arg0: number, arg1: Internal.Charset_): Internal.CharSequence;
        isReadOnly(): boolean;
        readUnsignedShortLE(): number;
        readDouble(): number;
        readFloat(): number;
        getLongLE(arg0: number): number;
        getBoolean(arg0: number): boolean;
        copy(): Internal.ByteBuf;
        copy(arg0: number, arg1: number): Internal.ByteBuf;
        readShortLE(): number;
        readUnsignedMedium(): number;
        ensureWritable(arg0: number): Internal.ByteBuf;
        ensureWritable(arg0: number, arg1: boolean): number;
        writeInt(arg0: number): Internal.ByteBuf;
        readFloatLE(): number;
        getDoubleLE(arg0: number): number;
        hasArray(): boolean;
        memoryAddress(): number;
        maxFastWritableBytes(): number;
        readableBytes(): number;
        readSlice(arg0: number): Internal.ByteBuf;
        getIntLE(arg0: number): number;
        nioBuffers(): Internal.ByteBuffer[];
        nioBuffers(arg0: number, arg1: number): Internal.ByteBuffer[];
        forEachByteDesc(arg0: Internal.ByteProcessor_): number;
        forEachByteDesc(arg0: number, arg1: number, arg2: Internal.ByteProcessor_): number;
        skipBytes(arg0: number): Internal.ByteBuf;
        getLong(arg0: number): number;
        readLong(): number;
        readShort(): number;
        equals(arg0: any): boolean;
        setZero(arg0: number, arg1: number): Internal.ByteBuf;
        getUnsignedMedium(arg0: number): number;
        readBytes(arg0: number[]): Internal.ByteBuf;
        readBytes(arg0: Internal.ByteBuf_): Internal.ByteBuf;
        readBytes(arg0: number): Internal.ByteBuf;
        readBytes(arg0: Internal.GatheringByteChannel_, arg1: number): number;
        readBytes(arg0: Internal.FileChannel_, arg1: number, arg2: number): number;
        readBytes(arg0: Internal.OutputStream_, arg1: number): Internal.ByteBuf;
        readBytes(arg0: number[], arg1: number, arg2: number): Internal.ByteBuf;
        readBytes(arg0: Internal.ByteBuf_, arg1: number): Internal.ByteBuf;
        readBytes(arg0: Internal.ByteBuf_, arg1: number, arg2: number): Internal.ByteBuf;
        readBytes(arg0: Internal.ByteBuffer_): Internal.ByteBuf;
        readBoolean(): boolean;
        toString(): string;
        toString(arg0: number, arg1: number, arg2: Internal.Charset_): string;
        toString(arg0: Internal.Charset_): string;
        retainedSlice(arg0: number, arg1: number): Internal.ByteBuf;
        retainedSlice(): Internal.ByteBuf;
        readMediumLE(): number;
        isDirect(): boolean;
        setMedium(arg0: number, arg1: number): Internal.ByteBuf;
        setBoolean(arg0: number, arg1: boolean): Internal.ByteBuf;
        getClass(): Internal.Class<any>;
        getFloatLE(arg0: number): number;
        readerIndex(): number;
        readerIndex(arg0: number): Internal.ByteBuf;
        getCharSequence(arg0: number, arg1: number, arg2: Internal.Charset_): Internal.CharSequence;
        setShort(arg0: number, arg1: number): Internal.ByteBuf;
        compareTo(arg0: Internal.ByteBuf_): number;
        getBytes(arg0: number, arg1: Internal.ByteBuf_, arg2: number): Internal.ByteBuf;
        getBytes(arg0: number, arg1: Internal.ByteBuf_): Internal.ByteBuf;
        getBytes(arg0: number, arg1: number[]): Internal.ByteBuf;
        getBytes(arg0: number, arg1: Internal.ByteBuf_, arg2: number, arg3: number): Internal.ByteBuf;
        getBytes(arg0: number, arg1: Internal.FileChannel_, arg2: number, arg3: number): number;
        getBytes(arg0: number, arg1: Internal.GatheringByteChannel_, arg2: number): number;
        getBytes(arg0: number, arg1: Internal.OutputStream_, arg2: number): Internal.ByteBuf;
        getBytes(arg0: number, arg1: number[], arg2: number, arg3: number): Internal.ByteBuf;
        getBytes(arg0: number, arg1: Internal.ByteBuffer_): Internal.ByteBuf;
        unwrap(): Internal.ByteBuf;
        setDouble(arg0: number, arg1: number): Internal.ByteBuf;
        setChar(arg0: number, arg1: number): Internal.ByteBuf;
        refCnt(): number;
        getUnsignedIntLE(arg0: number): number;
        setFloatLE(arg0: number, arg1: number): Internal.ByteBuf;
        getUnsignedInt(arg0: number): number;
        indexOf(arg0: number, arg1: number, arg2: number): number;
        writeByte(arg0: number): Internal.ByteBuf;
        nioBuffer(): Internal.ByteBuffer;
        nioBuffer(arg0: number, arg1: number): Internal.ByteBuffer;
        touch(arg0: any): Internal.ByteBuf;
        touch(): Internal.ByteBuf;
        discardSomeReadBytes(): Internal.ByteBuf;
        duplicate(): Internal.ByteBuf;
        writerIndex(arg0: number): Internal.ByteBuf;
        writerIndex(): number;
        writeCharSequence(arg0: Internal.CharSequence_, arg1: Internal.Charset_): number;
        readUnsignedInt(): number;
        getUnsignedShortLE(arg0: number): number;
        retainedDuplicate(): Internal.ByteBuf;
        getChar(arg0: number): string;
        setLong(arg0: number, arg1: number): Internal.ByteBuf;
        readMedium(): number;
        writeBytes(arg0: Internal.ScatteringByteChannel_, arg1: number): number;
        writeBytes(arg0: Internal.InputStream_, arg1: number): number;
        writeBytes(arg0: Internal.ByteBuffer_): Internal.ByteBuf;
        writeBytes(arg0: number[], arg1: number, arg2: number): Internal.ByteBuf;
        writeBytes(arg0: number[]): Internal.ByteBuf;
        writeBytes(arg0: Internal.ByteBuf_): Internal.ByteBuf;
        writeBytes(arg0: Internal.FileChannel_, arg1: number, arg2: number): number;
        writeBytes(arg0: Internal.ByteBuf_, arg1: number, arg2: number): Internal.ByteBuf;
        writeBytes(arg0: Internal.ByteBuf_, arg1: number): Internal.ByteBuf;
        forEachByte(arg0: Internal.ByteProcessor_): number;
        forEachByte(arg0: number, arg1: number, arg2: Internal.ByteProcessor_): number;
        setIndex(arg0: number, arg1: number): Internal.ByteBuf;
        writeShort(arg0: number): Internal.ByteBuf;
        alloc(): Internal.ByteBufAllocator;
        getShortLE(arg0: number): number;
        getMedium(arg0: number): number;
        readUnsignedShort(): number;
        setByte(arg0: number, arg1: number): Internal.ByteBuf;
        writeShortLE(arg0: number): Internal.ByteBuf;
        maxWritableBytes(): number;
        notifyAll(): void;
        getDouble(arg0: number): number;
        getFloat(arg0: number): number;
        writeLong(arg0: number): Internal.ByteBuf;
        writeIntLE(arg0: number): Internal.ByteBuf;
        array(): number[];
        setCharSequence(arg0: number, arg1: Internal.CharSequence_, arg2: Internal.Charset_): number;
        hashCode(): number;
        internalNioBuffer(arg0: number, arg1: number): Internal.ByteBuffer;
        arrayOffset(): number;
        readIntLE(): number;
        setMediumLE(arg0: number, arg1: number): Internal.ByteBuf;
        readUnsignedByte(): number;
        readUnsignedMediumLE(): number;
        readLongLE(): number;
        writeDouble(arg0: number): Internal.ByteBuf;
        setBytes(arg0: number, arg1: Internal.ByteBuf_): Internal.ByteBuf;
        setBytes(arg0: number, arg1: number[]): Internal.ByteBuf;
        setBytes(arg0: number, arg1: Internal.ByteBuf_, arg2: number): Internal.ByteBuf;
        setBytes(arg0: number, arg1: Internal.ByteBuf_, arg2: number, arg3: number): Internal.ByteBuf;
        setBytes(arg0: number, arg1: Internal.FileChannel_, arg2: number, arg3: number): number;
        setBytes(arg0: number, arg1: Internal.InputStream_, arg2: number): number;
        setBytes(arg0: number, arg1: Internal.ScatteringByteChannel_, arg2: number): number;
        setBytes(arg0: number, arg1: number[], arg2: number, arg3: number): Internal.ByteBuf;
        setBytes(arg0: number, arg1: Internal.ByteBuffer_): Internal.ByteBuf;
        setFloat(arg0: number, arg1: number): Internal.ByteBuf;
        getShort(arg0: number): number;
        writeMediumLE(arg0: number): Internal.ByteBuf;
        clear(): Internal.ByteBuf;
        getUnsignedByte(arg0: number): number;
        discardReadBytes(): Internal.ByteBuf;
        writeChar(arg0: number): Internal.ByteBuf;
        isContiguous(): boolean;
        writeDoubleLE(arg0: number): Internal.ByteBuf;
        getUnsignedMediumLE(arg0: number): number;
        readByte(): number;
        get readable(): boolean;
        get direct(): boolean;
        get readOnly(): boolean;
        get class(): Internal.Class<any>;
        get contiguous(): boolean;
        get writable(): boolean;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    type AbstractByteBuf_ = AbstractByteBuf;
    interface Byte2ObjectMap$Entry <V> extends Internal.Map$Entry<number, V> {
        getValue(): V;
        getKey(): number;
        hashCode(): number;
        setValue(arg0: V): V;
        equals(arg0: any): boolean;
        getByteKey(): number;
    }
    type Byte2ObjectMap$Entry_<V> = Byte2ObjectMap$Entry<V>;
    abstract class Team extends Internal.TeamBase {
        msg(player: Internal.ServerPlayer_, message: string): number;
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        getName(): Internal.Component;
        notifyAll(): void;
        getHighestRank(playerId: Internal.UUID_): Internal.TeamRank;
        save(): void;
        getId(): Internal.UUID;
        isMember(uuid: Internal.UUID_): boolean;
        getOwner(): Internal.UUID;
        isOfficer(profile: Internal.UUID_): boolean;
        getDescription(): string;
        notify(): void;
        getColoredName(): Internal.Component;
        serializeNBT(): Internal.SNBTCompoundTag;
        hashCode(): number;
        info(source: Internal.CommandSourceStack_): number;
        settings(source: Internal.CommandSourceStack_, key: Internal.TeamProperty_<any>, value: string): number;
        isAlly(profile: Internal.UUID_): boolean;
        getProperty<T_>(property: Internal.TeamProperty_<T_>): T_;
        isValid(): boolean;
        getExtraData(): Internal.CompoundTag;
        getColor(): number;
        sendMessage(from: Internal.UUID_, text: Internal.Component_): void;
        deserializeNBT(tag: Internal.CompoundTag_): void;
        getRanked(rank: Internal.TeamRank_): Internal.Map<Internal.UUID, Internal.TeamRank>;
        getOnlineRanked(rank: Internal.TeamRank_): Internal.List<Internal.ServerPlayer>;
        denyInvite(source: Internal.CommandSourceStack_): number;
        isFreeToJoin(): boolean;
        isInvited(profile: Internal.UUID_): boolean;
        getStringID(): string;
        getDisplayName(): string;
        getType(): Internal.TeamType;
        getOnlineMembers(): Internal.List<Internal.ServerPlayer>;
        setProperty<T_>(property: Internal.TeamProperty_<T_>, value: T_): void;
        equals(o: any): boolean;
        toString(): string;
        getMembers(): Internal.Set<Internal.UUID>;
        static readonly FREE_TO_JOIN : Internal.BooleanProperty;
        readonly manager : Internal.TeamManager;
        static readonly DESCRIPTION : Internal.StringProperty;
        static readonly COLOR : Internal.ColorProperty;
        readonly messageHistory : Internal.List<Internal.TeamMessage>;
        static readonly DISPLAY_NAME : Internal.StringProperty;
        readonly properties : Internal.TeamProperties;
        get owner(): Internal.UUID;
        get onlineMembers(): Internal.List<Internal.ServerPlayer>;
        get color(): number;
        get extraData(): Internal.CompoundTag;
        get displayName(): string;
        get description(): string;
        get type(): Internal.TeamType;
        get freeToJoin(): boolean;
        get valid(): boolean;
        get stringID(): string;
        get members(): Internal.Set<Internal.UUID>;
        get name(): Internal.Component;
        get id(): Internal.UUID;
        get class(): Internal.Class<any>;
        get coloredName(): Internal.Component;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    type Team_ = Team;
    class GlyphMetrics {
        isLigature(): boolean;
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        getRSB(): number;
        isCombining(): boolean;
        notifyAll(): void;
        isWhitespace(): boolean;
        getAdvanceY(): number;
        getLSB(): number;
        getAdvanceX(): number;
        notify(): void;
        isStandard(): boolean;
        getType(): number;
        hashCode(): number;
        getAdvance(): number;
        equals(arg0: any): boolean;
        getBounds2D(): Internal.Rectangle2D;
        toString(): string;
        isComponent(): boolean;
        static readonly COMBINING : 2;
        static readonly WHITESPACE : 4;
        static readonly LIGATURE : 1;
        static readonly COMPONENT : 3;
        static readonly STANDARD : 0;
        get rSB(): number;
        get standard(): boolean;
        get combining(): boolean;
        get type(): number;
        get bounds2D(): Internal.Rectangle2D;
        get advance(): number;
        get advanceY(): number;
        get advanceX(): number;
        get component(): boolean;
        get ligature(): boolean;
        get lSB(): number;
        get whitespace(): boolean;
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    type GlyphMetrics_ = GlyphMetrics;
    class ItemRenderer implements Internal.ResourceManagerReloadListener, Internal.AccessorItemRenderer {
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        hashCode(): number;
        notifyAll(): void;
        equals(arg0: any): boolean;
        getBlockEntityRenderer(): Internal.BlockEntityWithoutLevelRenderer;
        toString(): string;
        handler$zda000$injectRenderItem(arg0: Internal.ItemStack_, arg1: Internal.ItemTransforms$TransformType_, arg2: boolean, arg3: Internal.PoseStack_, arg4: Internal.MultiBufferSource_, arg5: number, arg6: number, arg7: Internal.BakedModel_, arg8: Internal.CallbackInfo_): void;
        handler$bej000$renderQuads(arg0: Internal.PoseStack_, arg1: Internal.VertexConsumer_, arg2: Internal.List_<any>, arg3: Internal.ItemStack_, arg4: number, arg5: number, arg6: Internal.CallbackInfo_): void;
        notify(): void;
        get blockEntityRenderer(): Internal.BlockEntityWithoutLevelRenderer;
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    type ItemRenderer_ = ItemRenderer;
    interface BytePredicate extends Internal.Predicate<number>, java_.util.function_.IntPredicate {
        or(arg0: Internal.BytePredicate_): Internal.BytePredicate;
        or(arg0: java_.util.function_.IntPredicate_): Internal.BytePredicate;
        or(arg0: Internal.Predicate_<number>): Internal.Predicate<number>;
        test(arg0: number): boolean;
        and(arg0: java_.util.function_.IntPredicate_): Internal.BytePredicate;
        and(arg0: Internal.BytePredicate_): Internal.BytePredicate;
        and(arg0: Internal.Predicate_<number>): Internal.Predicate<number>;
        negate(): Internal.BytePredicate;
    }
    type BytePredicate_ = ((arg0: number) => boolean) | BytePredicate;
    class Stat <T> extends Internal.ObjectiveCriteria {
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        hashCode(): number;
        notifyAll(): void;
        equals(arg0: any): boolean;
        toString(): string;
        notify(): void;
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    type Stat_<T> = Stat<T>;
    interface IRecipeSlotView {
        getDisplayedIngredient(): Internal.Optional<Internal.ITypedIngredient<any>>;
        getDisplayedIngredient<T>(arg0: Internal.IIngredientType_<T>): Internal.Optional<T>;
        getRole(): Internal.RecipeIngredientRole;
        getAllIngredients(): Internal.Stream<Internal.ITypedIngredient<any>>;
        isEmpty(): boolean;
        getSlotName(): Internal.Optional<string>;
        drawHighlight(arg0: Internal.PoseStack_, arg1: number): void;
        getIngredients<T>(arg0: Internal.IIngredientType_<T>): Internal.Stream<T>;
    }
    type IRecipeSlotView_ = IRecipeSlotView;
    interface AccessorNoiseChunk {
        botania_cachedClimateSampler(arg0: Internal.NoiseRouter_): Internal.Climate$Sampler;
    }
    type AccessorNoiseChunk_ = AccessorNoiseChunk;
    interface Copyable {
        copy(): Internal.Copyable;
    }
    type Copyable_ = Copyable;
    abstract class AbstractClientPlayer extends Internal.Player {
        getClass(): Internal.Class<any>;
        setItemSwapAnimationTimer(count: number): void;
        resetDynamicLight(): void;
        getCapability<T_>(arg0: Internal.Capability_<T_>, arg1: Internal.Direction_): Internal.LazyOptional<T_>;
        getCapability<T_>(arg0: Internal.Capability_<T_>): Internal.LazyOptional<T_>;
        captureDrops(arg0: Internal.Collection_<Internal.ItemEntity_>): Internal.Collection<Internal.ItemEntity>;
        captureDrops(): Internal.Collection<Internal.ItemEntity>;
        botania$setCritTarget(arg0: Internal.LivingEntity_): void;
        canBeRiddenInWater(arg0: Internal.Entity_): boolean;
        setCitadelEntityData(arg0: Internal.CompoundTag_): void;
        isDynamicLightEnabled(): boolean;
        changeDimension(arg0: Internal.ServerLevel_, arg1: Internal.ITeleporter_): Internal.Entity;
        serializeNBT(): Internal.CompoundTag;
        invalidateCaps(): void;
        setDynamicLightEnabled(arg0: boolean): void;
        shouldUpdateDynamicLight(): boolean;
        foodEatenKJS(is: Internal.ItemStack_): void;
        redirect$bid001$elytraOverride(arg0: Internal.ItemStack_, arg1: Internal.LivingEntity_): boolean;
        revive(): void;
        setVisualScale(arg0: number): void;
        getDigSpeed(arg0: Internal.BlockState_, arg1: BlockPos_): number;
        write(): net.minecraft.nbt.Tag;
        dynamicLightTick(): void;
        readBYG(arg0: Internal.CompoundTag_): void;
        getPersistentDataKJS(): Internal.CompoundTag;
        canUpdate(): boolean;
        canUpdate(arg0: boolean): void;
        getDynamicLightY(): number;
        getSuffixes(): Internal.Collection<Internal.MutableComponent>;
        getDynamicLightZ(): number;
        handler$zbj000$curio$canFreeze(arg0: Internal.CallbackInfoReturnable_<any>): void;
        read(arg0: Internal.CompoundTag_): void;
        getDynamicLightX(): number;
        areCapsCompatible(arg0: Internal.CapabilityProvider_<Internal.Entity_>): boolean;
        areCapsCompatible(arg0: Internal.CapabilityDispatcher_): boolean;
        getSideSword(): Internal.ItemStack;
        redirect$bie002$elytraOverride(arg0: Internal.ItemStack_, arg1: Internal.LivingEntity_): boolean;
        getEyeHeightAccess(arg0: Internal.Pose_, arg1: Internal.EntityDimensions_): number;
        reviveCaps(): void;
        lambdynlights$updateDynamicLight(arg0: Internal.LevelRenderer_): boolean;
        handler$bih000$removed(arg0: Internal.CallbackInfo_): void;
        setForcedPose(arg0: Internal.Pose_): void;
        canRiderInteract(): boolean;
        lambdynlights$scheduleTrackedChunksRebuild(arg0: Internal.LevelRenderer_): void;
        handler$bih001$onTick(arg0: Internal.CallbackInfo_): void;
        setLastAnimationSwapTick(count: number): void;
        onAddedToWorld(): void;
        lastUpdate(): number;
        getItemSwapAnimationTimer(): number;
        getPrefixes(): Internal.Collection<Internal.MutableComponent>;
        canTrample(arg0: Internal.BlockState_, arg1: BlockPos_, arg2: number): boolean;
        getCitadelEntityData(): Internal.CompoundTag;
        getPoseOverwrite(): Internal.Pose;
        setUpdated(frameId: number): void;
        getClassification(arg0: boolean): Internal.MobCategory;
        handler$bih000$onRemove(arg0: Internal.CallbackInfo_): void;
        getLastAnimationSwapTick(): number;
        shouldRiderSit(): boolean;
        getPickedResult(arg0: Internal.HitResult_): Internal.ItemStack;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        notifyAll(): void;
        isActuallyReallyBlocking(): boolean;
        setSideSword(item: Internal.ItemStack_): void;
        isUpdated(frameId: number): boolean;
        getPersistentData(): Internal.CompoundTag;
        getStagesRawKJS(): Internal.Stages;
        handler$bjh000$tick(info: Internal.CallbackInfo_): void;
        notify(): void;
        redirect$bie000$eytraValidOverride(arg0: Internal.ItemStack_, arg1: Internal.LivingEntity_, arg2: number): boolean;
        getStages(): Internal.Stages;
        getLastHeldItems(): Internal.ItemStack[];
        hashCode(): number;
        getPlayerTrackedData(): Internal.BYGPlayerTrackedData;
        setDimension(arg0: Internal.EntityDimensions_): void;
        isBodyRotationDisabled(): boolean;
        isAddedToWorld(): boolean;
        getData(holder: Internal.DataHolder_<any>, builder: Internal.Supplier_<any>): any;
        getParts(): any[];
        getDynamicLightWorld(): Internal.Level;
        writeBYG(arg0: Internal.CompoundTag_): void;
        disableBodyRotation(val: boolean): void;
        onRemovedFromWorld(): void;
        getLuminance(): number;
        isMultipartEntity(): boolean;
        deserializeNBT(arg0: Internal.CompoundTag_): void;
        curePotionEffects(arg0: Internal.ItemStack_): boolean;
        asKJS(): any;
        setPlayerTrackedData(arg0: Internal.BYGPlayerTrackedData_): Internal.BYGPlayerTrackedData;
        handler$cfc000$getPortalWaitTime(arg0: Internal.CallbackInfoReturnable_<any>): void;
        shouldRiderFaceForward(arg0: Internal.Player_): boolean;
        setPoseOverwrite(state: Internal.Pose_): void;
        equals(arg0: any): boolean;
        toString(): string;
        getVisualScale(): number;
        getLastRotations(): number[];
        refreshDisplayName(): void;
        getForcedPose(): Internal.Pose;
        static readonly PERSISTED_NBT_TAG : "PlayerPersisted";
        get luminance(): number;
        get suffixes(): Internal.Collection<Internal.MutableComponent>;
        get citadelEntityData(): Internal.CompoundTag;
        get playerTrackedData(): Internal.BYGPlayerTrackedData;
        get stagesRawKJS(): Internal.Stages;
        get addedToWorld(): boolean;
        get dynamicLightY(): number;
        get dynamicLightZ(): number;
        get sideSword(): Internal.ItemStack;
        get dynamicLightX(): number;
        get visualScale(): number;
        get persistentDataKJS(): Internal.CompoundTag;
        get class(): Internal.Class<any>;
        get dynamicLightWorld(): Internal.Level;
        get dynamicLightEnabled(): boolean;
        get poseOverwrite(): Internal.Pose;
        get persistentData(): Internal.CompoundTag;
        get lastHeldItems(): Internal.ItemStack[];
        get multipartEntity(): boolean;
        get lastRotations(): number[];
        get prefixes(): Internal.Collection<Internal.MutableComponent>;
        get lastAnimationSwapTick(): number;
        get bodyRotationDisabled(): boolean;
        get forcedPose(): Internal.Pose;
        get actuallyReallyBlocking(): boolean;
        get stages(): Internal.Stages;
        get parts(): any[];
        get itemSwapAnimationTimer(): number;
        set poseOverwrite(state: Internal.Pose_);
        set dynamicLightEnabled(arg0: boolean);
        set visualScale(arg0: number);
        set lastAnimationSwapTick(count: number);
        set forcedPose(arg0: Internal.Pose_);
        set playerTrackedData(arg0: Internal.BYGPlayerTrackedData_);
        set citadelEntityData(arg0: Internal.CompoundTag_);
        set dimension(arg0: Internal.EntityDimensions_);
        set sideSword(item: Internal.ItemStack_);
        set updated(frameId: number);
        set itemSwapAnimationTimer(count: number);
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    type AbstractClientPlayer_ = AbstractClientPlayer;
    interface TypeWrapperFactory <T> {
        wrap(arg0: any): T;
    }
    type TypeWrapperFactory_<T> = ((arg0: any) => T) | TypeWrapperFactory<T>;
    abstract class GraphicsConfigTemplate implements Internal.Serializable {
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        isGraphicsConfigSupported(arg0: Internal.GraphicsConfiguration_): boolean;
        hashCode(): number;
        getBestConfiguration(arg0: Internal.GraphicsConfiguration_[]): Internal.GraphicsConfiguration;
        notifyAll(): void;
        equals(arg0: any): boolean;
        toString(): string;
        notify(): void;
        static readonly UNNECESSARY : 3;
        static readonly PREFERRED : 2;
        static readonly REQUIRED : 1;
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    type GraphicsConfigTemplate_ = GraphicsConfigTemplate;
    interface BlittableVertexType <T> extends Internal.BufferVertexType<T> {
        getBufferVertexFormat(): Internal.BufferVertexFormat;
        createFallbackWriter(arg0: Internal.VertexConsumer_): T;
        createBufferWriter(arg0: Internal.VertexBufferView_, arg1: boolean): T;
        createBufferWriter(buffer: Internal.VertexBufferView_): T;
        asBlittable(): Internal.BlittableVertexType<T>;
    }
    type BlittableVertexType_<T> = BlittableVertexType<T>;
    interface Reference2FloatFunction <K> extends Internal.Function<K, number>, Internal.ToDoubleFunction<K> {
        getOrDefault(arg0: any, arg1: number): number;
        applyAsDouble(arg0: K): number;
        andThenShort(arg0: Internal.Float2ShortFunction_): Internal.Reference2ShortFunction<K>;
        composeByte(arg0: Internal.Byte2ReferenceFunction_<K>): Internal.Byte2FloatFunction;
        getFloat(arg0: any): number;
        andThenInt(arg0: Internal.Float2IntFunction_): Internal.Reference2IntFunction<K>;
        composeReference<T_>(arg0: Internal.Reference2ReferenceFunction_<T_, K>): Internal.Reference2FloatFunction<T_>;
        andThen<T_>(arg0: java_.util.function_.Function_<number, T_>): java_.util.function_.Function<K, T_>;
        put(arg0: K, arg1: number): number;
        remove(arg0: any): number;
        defaultReturnValue(): number;
        defaultReturnValue(arg0: number): void;
        andThenDouble(arg0: Internal.Float2DoubleFunction_): Internal.Reference2DoubleFunction<K>;
        andThenObject<T_>(arg0: Internal.Float2ObjectFunction_<T_>): Internal.Reference2ObjectFunction<K, T_>;
        get(arg0: any): number;
        andThenLong(arg0: Internal.Float2LongFunction_): Internal.Reference2LongFunction<K>;
        composeLong(arg0: Internal.Long2ReferenceFunction_<K>): Internal.Long2FloatFunction;
        andThenByte(arg0: Internal.Float2ByteFunction_): Internal.Reference2ByteFunction<K>;
        andThenFloat(arg0: Internal.Float2FloatFunction_): Internal.Reference2FloatFunction<K>;
        removeFloat(arg0: any): number;
        apply(arg0: K): number;
        containsKey(arg0: any): boolean;
        composeInt(arg0: Internal.Int2ReferenceFunction_<K>): Internal.Int2FloatFunction;
        clear(): void;
        composeFloat(arg0: Internal.Float2ReferenceFunction_<K>): Internal.Float2FloatFunction;
        andThenChar(arg0: Internal.Float2CharFunction_): Internal.Reference2CharFunction<K>;
        composeObject<T_>(arg0: Internal.Object2ReferenceFunction_<T_, K>): Internal.Object2FloatFunction<T_>;
        size(): number;
        compose<V_>(arg0: java_.util.function_.Function_<V_, K>): java_.util.function_.Function<V_, number>;
        composeShort(arg0: Internal.Short2ReferenceFunction_<K>): Internal.Short2FloatFunction;
        andThenReference<T_>(arg0: Internal.Float2ReferenceFunction_<T_>): Internal.Reference2ReferenceFunction<K, T_>;
        composeChar(arg0: Internal.Char2ReferenceFunction_<K>): Internal.Char2FloatFunction;
        composeDouble(arg0: Internal.Double2ReferenceFunction_<K>): Internal.Double2FloatFunction;
    }
    type Reference2FloatFunction_<K> = ((arg0: any) => number) | Reference2FloatFunction<K>;
    class Either$Mu <R> implements Internal.K1 {
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        hashCode(): number;
        notifyAll(): void;
        equals(arg0: any): boolean;
        toString(): string;
        notify(): void;
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    type Either$Mu_<R> = Either$Mu<R>;
    abstract class AbstractContainerMenu implements Internal.AbstractContainerMenuInvoker {
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        hashCode(): number;
        notifyAll(): void;
        equals(arg0: any): boolean;
        handler$bmb000$doClick(arg0: number, arg1: number, arg2: Internal.ClickType_, arg3: Internal.Player_, arg4: Internal.CallbackInfo_): void;
        toString(): string;
        notify(): void;
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    type AbstractContainerMenu_ = AbstractContainerMenu;
    interface MenuContainer {
        getFont(): Internal.Font;
        remove(arg0: Internal.MenuComponent_): void;
        postEvent(arg0: java_.awt.Event_): boolean;
    }
    type MenuContainer_ = MenuContainer;
    interface AccessorRecipeManager {
        botania_getAll<C, T>(arg0: Internal.RecipeType_<T>): Internal.Map<ResourceLocation, Internal.Recipe<C>>;
    }
    type AccessorRecipeManager_ = AccessorRecipeManager;
    class ServerPlayerJS extends Internal.PlayerJS<Internal.ServerPlayer> {
        getXpLevel(): number;
        getLastAttackedEntity(): Internal.LivingEntityJS;
        setY(y: number): void;
        setX(x: number): void;
        isOnScoreboardTeam(teamID: string): boolean;
        isLiving(): boolean;
        isSprinting(): boolean;
        getItem(): Internal.ItemStackJS;
        paint(renderer: Internal.CompoundTag_): void;
        getOffHandItem(): Internal.ItemStackJS;
        setGlowing(glowing: boolean): void;
        setZ(z: number): void;
        setXpLevel(l: number): void;
        getHasCustomName(): boolean;
        ban(banner: string, reason: string, expiresInMillis: number): void;
        runCommandSilent(command: string): number;
        setSelectedSlot(index: number): void;
        getDistanceSq(pos: BlockPos_): number;
        getDistanceSq(x: number, y: number, z: number): number;
        isBoss(): boolean;
        setMovementSpeedAddition(speed: number): void;
        isGlowing(): boolean;
        getHorizontalFacing(): Internal.Direction;
        setLegsArmorItem(item: Internal.ItemStackJS_): void;
        isAdvancementDone(id: ResourceLocation_): boolean;
        setMotion(x: number, y: number, z: number): void;
        getProfile(): Internal.GameProfile;
        setRotation(yaw: number, pitch: number): void;
        setGameMode(mode: string): void;
        isMiningBlock(): boolean;
        setAbsorptionAmount(amount: number): void;
        isOnSameTeam(e: Internal.EntityJS_): boolean;
        isAnimal(): boolean;
        getType(): string;
        setCustomNameAlwaysVisible(b: boolean): void;
        addMotion(x: number, y: number, z: number): void;
        isFake(): boolean;
        setCreativeMode(mode: boolean): void;
        getFallDistance(): number;
        damageHeldItem(hand: Hand_, amount: number): void;
        damageHeldItem(hand: Hand_, amount: number, onBroken: Internal.Consumer_<Internal.ItemStackJS_>): void;
        damageHeldItem(): void;
        setOnFire(seconds: number): void;
        attack(source: string, hp: number): void;
        attack(hp: number): void;
        isUndead(): boolean;
        getInventory(): Internal.InventoryJS;
        getDistance(x: number, y: number, z: number): number;
        getDistance(pos: BlockPos_): number;
        getReachDistance(): number;
        getCustomName(): Internal.Text;
        getStepHeight(): number;
        getDefaultMovementSpeed(): number;
        getRidingEntity(): Internal.EntityJS;
        setPositionAndRotation(x: number, y: number, z: number, yaw: number, pitch: number): void;
        kick(): void;
        kick(reason: Internal.Component_): void;
        getLastAttackedEntityTime(): number;
        isMonster(): boolean;
        addItemCooldown(item: Internal.Item_, ticks: number): void;
        setPitch(pitch: number): void;
        getFacing(): Internal.Direction;
        isOnGround(): boolean;
        toString(): string;
        isSilent(): boolean;
        setXp(xp: number): void;
        getMaxAirSupply(): number;
        getName(): Internal.Text;
        getFeetArmorItem(): Internal.ItemStackJS;
        getHasClientMod(): boolean;
        setStepHeight(stepHeight: number): void;
        isWaterCreature(): boolean;
        setPosition(x: number, y: number, z: number): void;
        setPosition(block: Internal.BlockContainerJS_): void;
        closeInventory(): void;
        extinguish(): void;
        setInvulnerable(invulnerable: boolean): void;
        isOp(): boolean;
        setMovementSpeed(speed: number): void;
        isChild(): boolean;
        setDefaultMovementSpeed(speed: number): void;
        setEquipment(slot: EquipmentSlot_, item: Internal.ItemStackJS_): void;
        giveInHand(item: Internal.ItemStackJS_): void;
        getLegsArmorItem(): Internal.ItemStackJS;
        isCreativeMode(): boolean;
        getFullNBT(): Internal.CompoundTag;
        getNoClip(): boolean;
        setYaw(yaw: number): void;
        getYaw(): number;
        getTotalMovementSpeed(): number;
        setNoGravity(noGravity: boolean): void;
        setHeldItem(hand: Hand_, item: Internal.ItemStackJS_): void;
        getRevengeTimer(): number;
        notifyAll(): void;
        unlockAdvancement(id: ResourceLocation_): void;
        getId(): Internal.UUID;
        addXPLevels(l: number): void;
        getOpenInventory(): Internal.AbstractContainerMenu;
        hashCode(): number;
        getChestArmorItem(): Internal.ItemStackJS;
        isFrame(): boolean;
        startRiding(e: Internal.EntityJS_, force: boolean): boolean;
        runCommand(command: string): number;
        setChestArmorItem(item: Internal.ItemStackJS_): void;
        getCustomNameAlwaysVisible(): boolean;
        removeAttribute(attribute: Internal.Attribute_, identifier: string): void;
        addXP(xp: number): void;
        getMainHandItem(): Internal.ItemStackJS;
        setHealth(hp: number): void;
        getBlock(): Internal.BlockContainerJS;
        isElytraFlying(): boolean;
        isInWater(): boolean;
        dismountRidingEntity(): void;
        isSleeping(): boolean;
        swingArm(hand: Hand_): void;
        getPotionEffects(): Internal.EntityPotionEffectsJS;
        isInvulnerable(): boolean;
        revokeAdvancement(id: ResourceLocation_): void;
        setHeadArmorItem(item: Internal.ItemStackJS_): void;
        isPeacefulCreature(): boolean;
        getMouseItem(): Internal.ItemStackJS;
        getMotionZ(): number;
        getMotionX(): number;
        getMotionY(): number;
        sendData(channel: string, data: Internal.CompoundTag_): void;
        getRevengeTarget(): Internal.LivingEntityJS;
        getTags(): Internal.Set<string>;
        setInvisible(invisible: boolean): void;
        getIdleTime(): number;
        getMovementSpeed(): number;
        setDefaultMovementSpeedMultiplier(speed: number): void;
        addFood(f: number, m: number): void;
        getHealth(): number;
        getServer(): Internal.ServerJS;
        setFeetArmorItem(item: Internal.ItemStackJS_): void;
        getAttributeBaseValue(attribute: Internal.Attribute_): number;
        give(item: Internal.ItemStackJS_): void;
        setMaxHealth(hp: number): void;
        setSpawnLocation(c: Internal.BlockContainerJS_): void;
        isSpectator(): boolean;
        getDisplayName(): Internal.Text;
        getXp(): number;
        addExhaustion(exhaustion: number): void;
        setOffHandItem(item: Internal.ItemStackJS_): void;
        getFoodLevel(): number;
        isInvisible(): boolean;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        getMaxHealth(): number;
        isUnderWater(): boolean;
        getHeldItem(hand: Hand_): Internal.ItemStackJS;
        getEyeHeight(): number;
        getEquipment(slot: EquipmentSlot_): Internal.ItemStackJS;
        notify(): void;
        setAirSupply(air: number): void;
        setTotalMovementSpeedMultiplier(speed: number): void;
        removePassengers(): void;
        isOnLadder(): boolean;
        playSound(id: Internal.SoundEvent_, volume: number, pitch: number): void;
        playSound(id: Internal.SoundEvent_): void;
        boostElytraFlight(): void;
        getData(): Internal.AttachedData;
        getLastDamageSource(): Internal.DamageSource;
        setStatusMessage(message: Internal.Component_): void;
        isSwimming(): boolean;
        mergeFullNBT(tag: Internal.CompoundTag_): Internal.EntityJS;
        kill(): void;
        getLevel(): Internal.LevelJS;
        getPitch(): number;
        getPassengers(): Internal.EntityArrayList;
        equals(arg0: any): boolean;
        isPassenger(e: Internal.EntityJS_): boolean;
        getClass(): Internal.Class<any>;
        getRecursivePassengers(): Internal.EntityArrayList;
        getNbt(): Internal.CompoundTag;
        setFallDistance(fallDistance: number): void;
        sendInventoryUpdate(): void;
        setCustomName(name: Internal.Component_): void;
        setMainHandItem(item: Internal.ItemStackJS_): void;
        tell(message: Internal.Component_): void;
        getTeamId(): string;
        setNoClip(noClip: boolean): void;
        getAttributeTotalValue(attribute: Internal.Attribute_): number;
        setRevengeTarget(target: Internal.LivingEntityJS_): void;
        getAirSupply(): number;
        setFullNBT(nbt: Internal.CompoundTag_): void;
        getAttackingEntity(): Internal.LivingEntityJS;
        isHoldingInAnyHand(ingredient: any): boolean;
        damageEquipment(slot: EquipmentSlot_): void;
        damageEquipment(slot: EquipmentSlot_, amount: number, onBroken: Internal.Consumer_<Internal.ItemStackJS_>): void;
        damageEquipment(slot: EquipmentSlot_, amount: number): void;
        isAlive(): boolean;
        modifyAttribute(attribute: Internal.Attribute_, identifier: string, d: number, operation: Internal.AttributeModifier$Operation_): void;
        getHeadArmorItem(): Internal.ItemStackJS;
        setMouseItem(item: Internal.ItemStackJS_): void;
        setAttributeBaseValue(attribute: Internal.Attribute_, value: number): void;
        isPlayer(): boolean;
        getStats(): Internal.PlayerStatsJS;
        getAbsorptionAmount(): number;
        isCrouching(): boolean;
        getSpawnLocation(): Internal.BlockContainerJS;
        getTicksExisted(): number;
        getStages(): Internal.Stages;
        setSilent(isSilent: boolean): void;
        heal(hp: number): void;
        setMotionZ(z: number): void;
        setMotionY(y: number): void;
        setMotionX(x: number): void;
        isAmbientCreature(): boolean;
        rayTrace(): Internal.RayTraceResultJS;
        rayTrace(distance: number): Internal.RayTraceResultJS;
        getSelectedSlot(): number;
        canEntityBeSeen(entity: Internal.LivingEntityJS_): boolean;
        getX(): number;
        getY(): number;
        spawn(): void;
        getZ(): number;
        setFoodLevel(foodLevel: number): void;
        getNoGravity(): boolean;
        readonly server : Internal.ServerJS;
        static readonly PLAYER_CUSTOM_SPEED : Internal.UUID;
        static readonly PLAYER_CUSTOM_SPEED_NAME : "kubejs.player.speed.modifier";
        readonly persistentData : Internal.CompoundTag;
        readonly minecraftPlayer : Internal.ServerPlayer;
        readonly minecraftEntity : Internal.Entity;
        readonly minecraftLivingEntity : Internal.LivingEntity;
        get xpLevel(): number;
        get invisible(): boolean;
        get creativeMode(): boolean;
        get customNameAlwaysVisible(): boolean;
        get type(): string;
        get defaultMovementSpeed(): number;
        get movementSpeed(): number;
        get stats(): Internal.PlayerStatsJS;
        get revengeTarget(): Internal.LivingEntityJS;
        get hasCustomName(): boolean;
        get block(): Internal.BlockContainerJS;
        get maxHealth(): number;
        get id(): Internal.UUID;
        get pitch(): number;
        get item(): Internal.ItemStackJS;
        get passengers(): Internal.EntityArrayList;
        get profile(): Internal.GameProfile;
        get onLadder(): boolean;
        get offHandItem(): Internal.ItemStackJS;
        get customName(): Internal.Text;
        get lastAttackedEntityTime(): number;
        get tags(): Internal.Set<string>;
        get crouching(): boolean;
        get animal(): boolean;
        get lastDamageSource(): Internal.DamageSource;
        get stepHeight(): number;
        get noClip(): boolean;
        get nbt(): Internal.CompoundTag;
        get boss(): boolean;
        get alive(): boolean;
        get revengeTimer(): number;
        get displayName(): Internal.Text;
        get mainHandItem(): Internal.ItemStackJS;
        get facing(): Internal.Direction;
        get ambientCreature(): boolean;
        get swimming(): boolean;
        get selectedSlot(): number;
        get eyeHeight(): number;
        get underWater(): boolean;
        get openInventory(): Internal.AbstractContainerMenu;
        get motionZ(): number;
        get silent(): boolean;
        get motionY(): number;
        get motionX(): number;
        get health(): number;
        get chestArmorItem(): Internal.ItemStackJS;
        get yaw(): number;
        get monster(): boolean;
        get glowing(): boolean;
        get onGround(): boolean;
        get spectator(): boolean;
        get x(): number;
        get hasClientMod(): boolean;
        get y(): number;
        get fake(): boolean;
        get z(): number;
        get foodLevel(): number;
        get data(): Internal.AttachedData;
        get idleTime(): number;
        get legsArmorItem(): Internal.ItemStackJS;
        get maxAirSupply(): number;
        get undead(): boolean;
        get lastAttackedEntity(): Internal.LivingEntityJS;
        get potionEffects(): Internal.EntityPotionEffectsJS;
        get spawnLocation(): Internal.BlockContainerJS;
        get level(): Internal.LevelJS;
        get feetArmorItem(): Internal.ItemStackJS;
        get horizontalFacing(): Internal.Direction;
        get sprinting(): boolean;
        get mouseItem(): Internal.ItemStackJS;
        get noGravity(): boolean;
        get fullNBT(): Internal.CompoundTag;
        get name(): Internal.Text;
        get peacefulCreature(): boolean;
        get child(): boolean;
        get frame(): boolean;
        get ticksExisted(): number;
        get fallDistance(): number;
        get elytraFlying(): boolean;
        get inventory(): Internal.InventoryJS;
        get sleeping(): boolean;
        get airSupply(): number;
        get waterCreature(): boolean;
        get invulnerable(): boolean;
        get miningBlock(): boolean;
        get headArmorItem(): Internal.ItemStackJS;
        get class(): Internal.Class<any>;
        get reachDistance(): number;
        get player(): boolean;
        get op(): boolean;
        get absorptionAmount(): number;
        get living(): boolean;
        get ridingEntity(): Internal.EntityJS;
        get inWater(): boolean;
        get recursivePassengers(): Internal.EntityArrayList;
        get attackingEntity(): Internal.LivingEntityJS;
        get totalMovementSpeed(): number;
        get teamId(): string;
        get xp(): number;
        get stages(): Internal.Stages;
        set noClip(noClip: boolean);
        set xpLevel(l: number);
        set fallDistance(fallDistance: number);
        set mainHandItem(item: Internal.ItemStackJS_);
        set invisible(invisible: boolean);
        set creativeMode(mode: boolean);
        set customNameAlwaysVisible(b: boolean);
        set defaultMovementSpeed(speed: number);
        set movementSpeed(speed: number);
        set airSupply(air: number);
        set invulnerable(invulnerable: boolean);
        set legsArmorItem(item: Internal.ItemStackJS_);
        set totalMovementSpeedMultiplier(speed: number);
        set selectedSlot(index: number);
        set revengeTarget(target: Internal.LivingEntityJS_);
        set maxHealth(hp: number);
        set headArmorItem(item: Internal.ItemStackJS_);
        set pitch(pitch: number);
        set movementSpeedAddition(speed: number);
        set motionZ(z: number);
        set spawnLocation(c: Internal.BlockContainerJS_);
        set absorptionAmount(amount: number);
        set silent(isSilent: boolean);
        set motionY(y: number);
        set motionX(x: number);
        set feetArmorItem(item: Internal.ItemStackJS_);
        set health(hp: number);
        set offHandItem(item: Internal.ItemStackJS_);
        set chestArmorItem(item: Internal.ItemStackJS_);
        set defaultMovementSpeedMultiplier(speed: number);
        set onFire(seconds: number);
        set statusMessage(message: Internal.Component_);
        set yaw(yaw: number);
        set glowing(glowing: boolean);
        set mouseItem(item: Internal.ItemStackJS_);
        set noGravity(noGravity: boolean);
        set fullNBT(nbt: Internal.CompoundTag_);
        set xp(xp: number);
        set x(x: number);
        set y(y: number);
        set z(z: number);
        set foodLevel(foodLevel: number);
        set position(block: Internal.BlockContainerJS_);
        set gameMode(mode: string);
        set stepHeight(stepHeight: number);
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    type ServerPlayerJS_ = ServerPlayerJS;
    class ImmutableSetMultimap$Builder <K, V> extends Internal.ImmutableMultimap$Builder<K, V> {
        orderKeysBy(arg0: Internal.Comparator_<K>): Internal.ImmutableSetMultimap$Builder<K, V>;
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        build(): Internal.ImmutableSetMultimap<K, V>;
        hashCode(): number;
        orderValuesBy(arg0: Internal.Comparator_<V>): Internal.ImmutableSetMultimap$Builder<K, V>;
        notifyAll(): void;
        equals(arg0: any): boolean;
        putAll(arg0: Internal.Iterable_<Internal.Map$Entry_<K, V>>): Internal.ImmutableSetMultimap$Builder<K, V>;
        putAll(arg0: K, arg1: Internal.Iterable_<V>): Internal.ImmutableSetMultimap$Builder<K, V>;
        putAll(arg0: K, arg1: V[]): Internal.ImmutableSetMultimap$Builder<K, V>;
        putAll(arg0: Internal.Multimap_<K, V>): Internal.ImmutableSetMultimap$Builder<K, V>;
        toString(): string;
        notify(): void;
        put(arg0: Internal.Map$Entry_<K, V>): Internal.ImmutableSetMultimap$Builder<K, V>;
        put(arg0: K, arg1: V): Internal.ImmutableSetMultimap$Builder<K, V>;
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    type ImmutableSetMultimap$Builder_<K, V> = ImmutableSetMultimap$Builder<K, V>;
    abstract class BaseFilterItem extends Internal.Item implements Internal.IItemFilter {
        getClass(): Internal.Class<any>;
        canElytraFly(arg0: Internal.ItemStack_, arg1: Internal.LivingEntity_): boolean;
        setBurnTime(i: number): void;
        setDamage(arg0: Internal.ItemStack_, arg1: number): void;
        canPerformAction(arg0: Internal.ItemStack_, arg1: Internal.ToolAction_): boolean;
        getItems(filter: Internal.ItemStack_, set: Internal.Set_<Internal.Item_>): void;
        damageItem<T_>(arg0: Internal.ItemStack_, arg1: number, arg2: T_, arg3: Internal.Consumer_<T_>): number;
        shouldCauseBlockBreakReset(arg0: Internal.ItemStack_, arg1: Internal.ItemStack_): boolean;
        getItemEnchantability(arg0: Internal.ItemStack_): number;
        getPlacer(): Internal.BlockPlacerItem;
        shouldCauseReequipAnimation(arg0: Internal.ItemStack_, arg1: Internal.ItemStack_, arg2: boolean): boolean;
        getXpRepairRatio(arg0: Internal.ItemStack_): number;
        readShareTag(arg0: Internal.ItemStack_, arg1: Internal.CompoundTag_): void;
        handler$bcn000$overrideOtherStackedOnMe(arg0: Internal.ItemStack_, arg1: Internal.ItemStack_, arg2: Internal.Slot_, arg3: Internal.ClickAction_, arg4: Internal.Player_, arg5: Internal.SlotAccess_, arg6: Internal.CallbackInfoReturnable_<any>): void;
        onEntityItemUpdate(arg0: Internal.ItemStack_, arg1: Internal.ItemEntity_): boolean;
        getDamage(arg0: Internal.ItemStack_): number;
        isBookEnchantable(arg0: Internal.ItemStack_, arg1: Internal.ItemStack_): boolean;
        getDisplayItemStacks(filter: Internal.ItemStack_, list: Internal.List_<Internal.ItemStack_>): void;
        canDisableShield(arg0: Internal.ItemStack_, arg1: Internal.ItemStack_, arg2: Internal.LivingEntity_, arg3: Internal.LivingEntity_): boolean;
        onUsingTick(arg0: Internal.ItemStack_, arg1: Internal.LivingEntity_, arg2: number): void;
        isPiglinCurrency(arg0: Internal.ItemStack_): boolean;
        getCreativeTabs(): Internal.Collection<Internal.CreativeModeTab>;
        createEntity(arg0: Internal.Level_, arg1: Internal.Entity_, arg2: Internal.ItemStack_): Internal.Entity;
        getSweepHitBox(arg0: Internal.ItemStack_, arg1: Internal.Player_, arg2: Internal.Entity_): Internal.AABB;
        isRepairable(arg0: Internal.ItemStack_): boolean;
        getPlaceableBlock(): Internal.Block;
        getShareTag(arg0: Internal.ItemStack_): Internal.CompoundTag;
        getBurnTime(arg0: Internal.ItemStack_, arg1: Internal.RecipeType_<any>): number;
        onDroppedByPlayer(arg0: Internal.ItemStack_, arg1: Internal.Player_): boolean;
        isDamageable(arg0: Internal.ItemStack_): boolean;
        onEntitySwing(arg0: Internal.ItemStack_, arg1: Internal.LivingEntity_): boolean;
        getRegistryType(): Internal.Class<Internal.Item>;
        setItemBuilderKJS(b: Internal.ItemBuilder_): void;
        elytraFlightTick(arg0: Internal.ItemStack_, arg1: Internal.LivingEntity_, arg2: number): boolean;
        getItemBuilderKJS(): Internal.ItemBuilder;
        handler$bcn000$overrideStackedOnOther(arg0: Internal.ItemStack_, arg1: Internal.Slot_, arg2: Internal.ClickAction_, arg3: Internal.Player_, arg4: Internal.CallbackInfoReturnable_<any>): void;
        getAttributeModifiers(arg0: EquipmentSlot_, arg1: Internal.ItemStack_): Internal.Multimap<Internal.Attribute, Internal.AttributeModifier>;
        filterItem(filter: Internal.ItemStack_, item: Internal.Item_): boolean;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        onLeftClickEntity(arg0: Internal.ItemStack_, arg1: Internal.Player_, arg2: Internal.Entity_): boolean;
        canEquip(arg0: Internal.ItemStack_, arg1: EquipmentSlot_, arg2: Internal.Entity_): boolean;
        notifyAll(): void;
        getId(): string;
        notify(): void;
        onBlockStartBreak(arg0: Internal.ItemStack_, arg1: BlockPos_, arg2: Internal.Player_): boolean;
        onHorseArmorTick(arg0: Internal.ItemStack_, arg1: Internal.Level_, arg2: Internal.Mob_): void;
        canContinueUsing(arg0: Internal.ItemStack_, arg1: Internal.ItemStack_): boolean;
        getEntityLifespan(arg0: Internal.ItemStack_, arg1: Internal.Level_): number;
        getRenderPropertiesInternal(): any;
        getArmorTexture(arg0: Internal.ItemStack_, arg1: Internal.Entity_, arg2: EquipmentSlot_, arg3: string): string;
        getDefaultTooltipHideFlags(arg0: Internal.ItemStack_): number;
        hashCode(): number;
        hasCustomEntity(arg0: Internal.ItemStack_): boolean;
        getHighlightTip(arg0: Internal.ItemStack_, arg1: Internal.Component_): Internal.Component;
        clearFilterCache(filter: Internal.ItemStack_): void;
        canWalkOnPowderedSnow(arg0: Internal.ItemStack_, arg1: Internal.LivingEntity_): boolean;
        initializeClient(arg0: Internal.Consumer_<Internal.IItemRenderProperties_>): void;
        getMaxDamage(arg0: Internal.ItemStack_): number;
        getCreatorModId(arg0: Internal.ItemStack_): string;
        isDamaged(arg0: Internal.ItemStack_): boolean;
        onArmorTick(arg0: Internal.ItemStack_, arg1: Internal.Level_, arg2: Internal.Player_): void;
        hasContainerItem(arg0: Internal.ItemStack_): boolean;
        getFoodProperties(arg0: Internal.ItemStack_, arg1: Internal.LivingEntity_): Internal.FoodProperties;
        doesSneakBypassUse(arg0: Internal.ItemStack_, arg1: Internal.LevelReader_, arg2: BlockPos_, arg3: Internal.Player_): boolean;
        makePlaceable(arg0: Internal.Block_): void;
        onItemUseFirst(arg0: Internal.ItemStack_, arg1: Internal.UseOnContext_): Internal.InteractionResult;
        getContainerItem(arg0: Internal.ItemStack_): Internal.ItemStack;
        getRegistryName(): ResourceLocation;
        addInfo(filter: Internal.ItemStack_, info: Internal.FilterInfo_, expanded: boolean): void;
        setRegistryName(arg0: ResourceLocation_): Internal.Item;
        setRegistryName(arg0: string): Internal.Item;
        setRegistryName(arg0: string, arg1: string): Internal.Item;
        onDestroyed(arg0: Internal.ItemEntity_, arg1: Internal.DamageSource_): void;
        resetFilterData(filter: Internal.ItemStack_): void;
        filter(arg0: Internal.ItemStack_, arg1: Internal.ItemStack_): boolean;
        isCorrectToolForDrops(arg0: Internal.ItemStack_, arg1: Internal.BlockState_): boolean;
        getEquipmentSlot(arg0: Internal.ItemStack_): EquipmentSlot;
        getItemStackLimit(arg0: Internal.ItemStack_): number;
        initCapabilities(arg0: Internal.ItemStack_, arg1: Internal.CompoundTag_): Internal.ICapabilityProvider;
        equals(arg0: any): boolean;
        makesPiglinsNeutral(arg0: Internal.ItemStack_, arg1: Internal.LivingEntity_): boolean;
        getTypeData(): Internal.CompoundTag;
        toString(): string;
        isEnderMask(arg0: Internal.ItemStack_, arg1: Internal.Player_, arg2: Internal.EnderMan_): boolean;
        canApplyAtEnchantingTable(arg0: Internal.ItemStack_, arg1: Internal.Enchantment_): boolean;
        readonly delegate : Internal.IRegistryDelegate<Internal.Item>;
        renderProperties : any;
        get registryType(): Internal.Class<Internal.Item>;
        get itemBuilderKJS(): Internal.ItemBuilder;
        get renderPropertiesInternal(): any;
        get placer(): Internal.BlockPlacerItem;
        get placeableBlock(): Internal.Block;
        get creativeTabs(): Internal.Collection<Internal.CreativeModeTab>;
        get id(): string;
        get registryName(): ResourceLocation;
        get typeData(): Internal.CompoundTag;
        get class(): Internal.Class<any>;
        set itemBuilderKJS(b: Internal.ItemBuilder_);
        set burnTime(i: number);
        set registryName(arg0: ResourceLocation_);
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    type BaseFilterItem_ = BaseFilterItem;
    abstract class BlockableEventLoop <R> implements Internal.ProfilerMeasured, Internal.ProcessorHandle<R>, Internal.Executor {
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        hashCode(): number;
        notifyAll(): void;
        equals(arg0: any): boolean;
        toString(): string;
        close(): void;
        execute(arg0: Internal.Runnable_): void;
        notify(): void;
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    type BlockableEventLoop_<R> = BlockableEventLoop<R>;
    interface BufferedImageOp {
        getPoint2D(arg0: Internal.Point2D_, arg1: Internal.Point2D_): Internal.Point2D;
        filter(arg0: Internal.BufferedImage_, arg1: Internal.BufferedImage_): Internal.BufferedImage;
        getBounds2D(arg0: Internal.BufferedImage_): Internal.Rectangle2D;
        getRenderingHints(): Internal.RenderingHints;
        createCompatibleDestImage(arg0: Internal.BufferedImage_, arg1: Internal.ColorModel_): Internal.BufferedImage;
    }
    type BufferedImageOp_ = BufferedImageOp;
    class FontRenderContext {
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        isTransformed(): boolean;
        notifyAll(): void;
        notify(): void;
        getAntiAliasingHint(): any;
        usesFractionalMetrics(): boolean;
        hashCode(): number;
        equals(arg0: any): boolean;
        equals(arg0: Internal.FontRenderContext_): boolean;
        toString(): string;
        getTransformType(): number;
        getFractionalMetricsHint(): any;
        getTransform(): Internal.AffineTransform;
        isAntiAliased(): boolean;
        get transform(): Internal.AffineTransform;
        get antiAliased(): boolean;
        get transformed(): boolean;
        get transformType(): number;
        get class(): Internal.Class<any>;
        get fractionalMetricsHint(): any;
        get antiAliasingHint(): any;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    type FontRenderContext_ = FontRenderContext;
    interface Short2FloatFunction extends Internal.Function<number, number>, Internal.IntToDoubleFunction {
        getOrDefault(arg0: any, arg1: number): number;
        getOrDefault(arg0: number, arg1: number): number;
        applyAsDouble(arg0: number): number;
        andThenShort(arg0: Internal.Float2ShortFunction_): Internal.Short2ShortFunction;
        composeByte(arg0: Internal.Byte2ShortFunction_): Internal.Byte2FloatFunction;
        andThenInt(arg0: Internal.Float2IntFunction_): Internal.Short2IntFunction;
        composeReference<T_>(arg0: Internal.Reference2ShortFunction_<T_>): Internal.Reference2FloatFunction<T_>;
        andThen<T_>(arg0: java_.util.function_.Function_<number, T_>): java_.util.function_.Function<number, T_>;
        put(arg0: number, arg1: number): number;
        remove(arg0: number): number;
        remove(arg0: any): number;
        defaultReturnValue(): number;
        defaultReturnValue(arg0: number): void;
        andThenDouble(arg0: Internal.Float2DoubleFunction_): Internal.Short2DoubleFunction;
        andThenObject<T_>(arg0: Internal.Float2ObjectFunction_<T_>): Internal.Short2ObjectFunction<T_>;
        get(arg0: any): number;
        get(arg0: number): number;
        andThenLong(arg0: Internal.Float2LongFunction_): Internal.Short2LongFunction;
        composeLong(arg0: Internal.Long2ShortFunction_): Internal.Long2FloatFunction;
        andThenByte(arg0: Internal.Float2ByteFunction_): Internal.Short2ByteFunction;
        andThenFloat(arg0: Internal.Float2FloatFunction_): Internal.Short2FloatFunction;
        apply(arg0: number): number;
        containsKey(arg0: any): boolean;
        containsKey(arg0: number): boolean;
        composeInt(arg0: Internal.Int2ShortFunction_): Internal.Int2FloatFunction;
        clear(): void;
        composeFloat(arg0: Internal.Float2ShortFunction_): Internal.Float2FloatFunction;
        andThenChar(arg0: Internal.Float2CharFunction_): Internal.Short2CharFunction;
        composeObject<T_>(arg0: Internal.Object2ShortFunction_<T_>): Internal.Object2FloatFunction<T_>;
        size(): number;
        compose<T_>(arg0: java_.util.function_.Function_<T_, number>): java_.util.function_.Function<T_, number>;
        composeShort(arg0: Internal.Short2ShortFunction_): Internal.Short2FloatFunction;
        andThenReference<T_>(arg0: Internal.Float2ReferenceFunction_<T_>): Internal.Short2ReferenceFunction<T_>;
        composeChar(arg0: Internal.Char2ShortFunction_): Internal.Char2FloatFunction;
        composeDouble(arg0: Internal.Double2ShortFunction_): Internal.Double2FloatFunction;
    }
    type Short2FloatFunction_ = ((arg0: number) => number) | Short2FloatFunction;
    interface MemoryTrackingRenderBuffers {
        getMiscBufferAllocatedSize(): number;
        getMaxBegins(): number;
        getEntityBufferAllocatedSize(): number;
    }
    type MemoryTrackingRenderBuffers_ = MemoryTrackingRenderBuffers;
    interface FocusListener extends Internal.EventListener {
        focusGained(arg0: Internal.FocusEvent_): void;
        focusLost(arg0: Internal.FocusEvent_): void;
    }
    type FocusListener_ = FocusListener;
    interface MemoryTrackingBuffer {
        getUsedSize(): number;
        getAllocatedSize(): number;
    }
    type MemoryTrackingBuffer_ = MemoryTrackingBuffer;
    class RecipeBuilder {
        outputs<T>(arg0: Internal.MultiblockCapability_<T>, arg1: any[]): Internal.RecipeBuilder;
        getClass(): Internal.Class<any>;
        inputPigments(arg0: any[]): Internal.RecipeBuilder;
        data(arg0: string, arg1: Internal.CompoundTag_): Internal.RecipeBuilder;
        inputs<T>(arg0: Internal.MultiblockCapability_<T>, arg1: any[]): Internal.RecipeBuilder;
        addCondition(arg0: Internal.RecipeCondition_): Internal.RecipeBuilder;
        thunder(arg0: number): Internal.RecipeBuilder;
        thunder(arg0: number, arg1: boolean): Internal.RecipeBuilder;
        inputMana(arg0: number): Internal.RecipeBuilder;
        outputSlurries(arg0: any[]): Internal.RecipeBuilder;
        inputFE(arg0: number): Internal.RecipeBuilder;
        outputAura(arg0: number): Internal.RecipeBuilder;
        slotName(arg0: string): Internal.RecipeBuilder;
        output<T>(arg0: Internal.MultiblockCapability_<T>, arg1: T[]): Internal.RecipeBuilder;
        outputCreate(arg0: number): Internal.RecipeBuilder;
        outputItems(arg0: Internal.ItemStack_[]): Internal.RecipeBuilder;
        block(arg0: Internal.BlockState_, arg1: number): Internal.RecipeBuilder;
        block(arg0: Internal.BlockState_, arg1: number, arg2: boolean): Internal.RecipeBuilder;
        text(arg0: Internal.Component_): Internal.RecipeBuilder;
        outputHeat(arg0: number): Internal.RecipeBuilder;
        buildAndRegister(): void;
        inputEMC(arg0: Internal.BigInteger_): Internal.RecipeBuilder;
        rain(arg0: number, arg1: boolean): Internal.RecipeBuilder;
        rain(arg0: number): Internal.RecipeBuilder;
        outputFE(arg0: number): Internal.RecipeBuilder;
        posY(arg0: number, arg1: number): Internal.RecipeBuilder;
        posY(arg0: number, arg1: number, arg2: boolean): Internal.RecipeBuilder;
        input<T>(arg0: Internal.MultiblockCapability_<T>, arg1: T[]): Internal.RecipeBuilder;
        inputCreate(arg0: number): Internal.RecipeBuilder;
        biome(arg0: ResourceLocation_): Internal.RecipeBuilder;
        biome(arg0: ResourceLocation_, arg1: boolean): Internal.RecipeBuilder;
        outputInfusions(arg0: any[]): Internal.RecipeBuilder;
        name(arg0: string): Internal.RecipeBuilder;
        inputSlurries(arg0: any[]): Internal.RecipeBuilder;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        outputPigments(arg0: any[]): Internal.RecipeBuilder;
        notifyAll(): void;
        outputGases(arg0: any[]): Internal.RecipeBuilder;
        notify(): void;
        duration(arg0: number): Internal.RecipeBuilder;
        inputGases(arg0: any[]): Internal.RecipeBuilder;
        hashCode(): number;
        outputFluids(arg0: net.minecraftforge.fluids.FluidStack_[]): Internal.RecipeBuilder;
        outputEMC(arg0: Internal.BigInteger_): Internal.RecipeBuilder;
        perTick(arg0: boolean): Internal.RecipeBuilder;
        copy(): Internal.RecipeBuilder;
        dimension(arg0: ResourceLocation_): Internal.RecipeBuilder;
        dimension(arg0: ResourceLocation_, arg1: boolean): Internal.RecipeBuilder;
        inputHeat(arg0: number): Internal.RecipeBuilder;
        chance(arg0: number): Internal.RecipeBuilder;
        inputItems(arg0: Internal.Ingredient_[]): Internal.RecipeBuilder;
        outputMana(arg0: number): Internal.RecipeBuilder;
        build(): com.lowdragmc.multiblocked.api.recipe.Recipe;
        equals(arg0: any): boolean;
        inputFluids(arg0: net.minecraftforge.fluids.FluidStack_[]): Internal.RecipeBuilder;
        inputInfusions(arg0: any[]): Internal.RecipeBuilder;
        inputAura(arg0: number): Internal.RecipeBuilder;
        toString(): string;
        readonly recipeMap : MbdRecipeMap;
        readonly outputBuilder : Internal.Map<Internal.MultiblockCapability<any>, Internal.ImmutableList$Builder<Internal.Content>>;
        readonly tickInputBuilder : Internal.Map<Internal.MultiblockCapability<any>, Internal.ImmutableList$Builder<Internal.Content>>;
        readonly tickOutputBuilder : Internal.Map<Internal.MultiblockCapability<any>, Internal.ImmutableList$Builder<Internal.Content>>;
        readonly conditions : Internal.Map<string, Internal.RecipeCondition>;
        readonly inputBuilder : Internal.Map<Internal.MultiblockCapability<any>, Internal.ImmutableList$Builder<Internal.Content>>;
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    type RecipeBuilder_ = RecipeBuilder;
    interface ItemEntityAccess {
        getHealth(): number;
        setHealth(arg0: number): void;
    }
    type ItemEntityAccess_ = ItemEntityAccess;
    class PlayerAdvancementEventJS extends Internal.PlayerEventJS {
        cancel(): void;
        getServer(): Internal.ServerJS;
        getAdvancement(): Internal.AdvancementJS;
        getClass(): Internal.Class<any>;
        addGameStage(stage: string): void;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        isCancelled(): boolean;
        getPlayer(): Internal.PlayerJS<any>;
        notifyAll(): void;
        getEntity(): Internal.EntityJS;
        notify(): void;
        getLevel(): Internal.LevelJS;
        getMinecraftPlayer(): Internal.Player;
        post(id: string): boolean;
        post(id: string, sub: string): boolean;
        post(t: Internal.ScriptType_, id: string, sub: string): boolean;
        post(t: Internal.ScriptType_, id: string): boolean;
        hasGameStage(stage: string): boolean;
        hashCode(): number;
        equals(arg0: any): boolean;
        removeGameStage(stage: string): void;
        toString(): string;
        canCancel(): boolean;
        get server(): Internal.ServerJS;
        get advancement(): Internal.AdvancementJS;
        get level(): Internal.LevelJS;
        get minecraftPlayer(): Internal.Player;
        get cancelled(): boolean;
        get class(): Internal.Class<any>;
        get entity(): Internal.EntityJS;
        get player(): Internal.PlayerJS<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    type PlayerAdvancementEventJS_ = PlayerAdvancementEventJS;
    interface Iterator <E> {
        next(): E;
        hasNext(): boolean;
        forEachRemaining(arg0: Internal.Consumer_<E>): void;
        remove(): void;
    }
    type Iterator_<E> = Iterator<E>;
    interface ModelQuadView {
        getNormal(arg0: number): number;
        getTexV(arg0: number): number;
        getLight(arg0: number): number;
        getTexU(arg0: number): number;
        getX(arg0: number): number;
        getColorIndex(): number;
        getY(arg0: number): number;
        getZ(arg0: number): number;
        getColor(arg0: number): number;
        getFlags(): number;
        getSprite(): Internal.TextureAtlasSprite;
    }
    type ModelQuadView_ = ModelQuadView;
    interface IdFunctionCall {
        execIdCall(arg0: Internal.IdFunctionObject_, arg1: Internal.Context_, arg2: Internal.Scriptable_, arg3: Internal.Scriptable_, arg4: any[]): any;
    }
    type IdFunctionCall_ = IdFunctionCall;
    interface Principal {
        getName(): string;
        hashCode(): number;
        equals(arg0: any): boolean;
        toString(): string;
        implies(arg0: Internal.Subject_): boolean;
    }
    type Principal_ = Principal;
    class ListTag extends Internal.CollectionTag<net.minecraft.nbt.Tag> {
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        notifyAll(): void;
        replaceAll(arg0: Internal.UnaryOperator_<net.minecraft.nbt.Tag_>): void;
        notify(): void;
        remove(arg0: number): net.minecraft.nbt.Tag;
        remove(arg0: any): boolean;
        removeAll(arg0: Internal.Collection_<any>): boolean;
        iterator(): Internal.Iterator<net.minecraft.nbt.Tag>;
        stream(): Internal.Stream<net.minecraft.nbt.Tag>;
        hashCode(): number;
        get(arg0: number): net.minecraft.nbt.Tag;
        toArray(): any[];
        toArray<T_>(arg0: T_[]): T_[];
        toArray<T_>(arg0: Internal.IntFunction_<T_[]>): T_[];
        parallelStream(): Internal.Stream<net.minecraft.nbt.Tag>;
        indexOf(arg0: any): number;
        add(arg0: number, arg1: net.minecraft.nbt.Tag_): void;
        add(arg0: net.minecraft.nbt.Tag_): boolean;
        subList(arg0: number, arg1: number): Internal.List<net.minecraft.nbt.Tag>;
        set(arg0: number, arg1: net.minecraft.nbt.Tag_): net.minecraft.nbt.Tag;
        spliterator(): Internal.Spliterator<net.minecraft.nbt.Tag>;
        forEach(arg0: Internal.Consumer_<net.minecraft.nbt.Tag_>): void;
        containsAll(arg0: Internal.Collection_<any>): boolean;
        isEmpty(): boolean;
        clear(): void;
        sort(arg0: Internal.Comparator_<net.minecraft.nbt.Tag_>): void;
        removeIf(arg0: Internal.Predicate_<net.minecraft.nbt.Tag_>): boolean;
        lastIndexOf(arg0: any): number;
        contains(arg0: any): boolean;
        size(): number;
        addAll(arg0: number, arg1: Internal.Collection_<net.minecraft.nbt.Tag_>): boolean;
        addAll(arg0: Internal.Collection_<net.minecraft.nbt.Tag_>): boolean;
        equals(arg0: any): boolean;
        listIterator(): Internal.ListIterator<net.minecraft.nbt.Tag>;
        listIterator(arg0: number): Internal.ListIterator<net.minecraft.nbt.Tag>;
        toString(): string;
        retainAll(arg0: Internal.Collection_<any>): boolean;
        get class(): Internal.Class<any>;
        get empty(): boolean;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    type ListTag_ = ListTag;
    class FluidStack {
        getClass(): Internal.Class<any>;
        getRawFluidSupplier(): Internal.Supplier<Internal.Fluid>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        getRawFluid(): Internal.Fluid;
        getName(): Internal.Component;
        isTagEqual(other: Internal.FluidStack_): boolean;
        notifyAll(): void;
        getOrCreateChildTag(childName: string): Internal.CompoundTag;
        notify(): void;
        copyWithAmount(amount: number): Internal.FluidStack;
        static empty(): Internal.FluidStack;
        getChildTag(childName: string): Internal.CompoundTag;
        hashCode(): number;
        static create(fluid: Internal.Fluid_, amount: number, tag: Internal.CompoundTag_): Internal.FluidStack;
        static create(stack: Internal.FluidStack_, amount: number): Internal.FluidStack;
        static create(fluid: Internal.Supplier_<Internal.Fluid_>, amount: number, tag: Internal.CompoundTag_): Internal.FluidStack;
        static create(fluid: Internal.Fluid_, amount: number): Internal.FluidStack;
        static create(fluid: Internal.Supplier_<Internal.Fluid_>, amount: number): Internal.FluidStack;
        setTag(tag: Internal.CompoundTag_): void;
        copy(): Internal.FluidStack;
        setAmount(amount: number): void;
        write(buf: Internal.FriendlyByteBuf_): void;
        write(tag: Internal.CompoundTag_): Internal.CompoundTag;
        isFluidEqual(other: Internal.FluidStack_): boolean;
        getAmount(): number;
        static init(): void;
        removeChildTag(childName: string): void;
        grow(amount: number): void;
        static read(tag: Internal.CompoundTag_): Internal.FluidStack;
        static read(buf: Internal.FriendlyByteBuf_): Internal.FluidStack;
        hasTag(): boolean;
        shrink(amount: number): void;
        getTranslationKey(): string;
        isEmpty(): boolean;
        getTag(): Internal.CompoundTag;
        isFluidStackEqual(other: Internal.FluidStack_): boolean;
        static bucketAmount(): number;
        getOrCreateTag(): Internal.CompoundTag;
        equals(o: any): boolean;
        getFluid(): Internal.Fluid;
        toString(): string;
        get orCreateTag(): Internal.CompoundTag;
        get rawFluid(): Internal.Fluid;
        get amount(): number;
        get rawFluidSupplier(): Internal.Supplier<Internal.Fluid>;
        get translationKey(): string;
        get name(): Internal.Component;
        get fluid(): Internal.Fluid;
        get tag(): Internal.CompoundTag;
        get class(): Internal.Class<any>;
        set amount(amount: number);
        set tag(tag: Internal.CompoundTag_);
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    type FluidStack_ = FluidStack;
    class ForgeConfigSpec$ConfigValue <T> {
        next(): Internal.ForgeConfigSpec$Builder;
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        set(arg0: T): void;
        hashCode(): number;
        notifyAll(): void;
        equals(arg0: any): boolean;
        get(): T;
        getPath(): Internal.List<string>;
        save(): void;
        toString(): string;
        clearCache(): void;
        notify(): void;
        get path(): Internal.List<string>;
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    type ForgeConfigSpec$ConfigValue_<T> = ForgeConfigSpec$ConfigValue<T>;
    class UUID implements Internal.Serializable, Internal.Comparable<Internal.UUID> {
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        notifyAll(): void;
        static nameUUIDFromBytes(arg0: number[]): Internal.UUID;
        compareTo(arg0: Internal.UUID_): number;
        getLeastSignificantBits(): number;
        version(): number;
        notify(): void;
        node(): number;
        getMostSignificantBits(): number;
        hashCode(): number;
        equals(arg0: any): boolean;
        variant(): number;
        static randomUUID(): Internal.UUID;
        toString(): string;
        static fromString(arg0: string): Internal.UUID;
        clockSequence(): number;
        timestamp(): number;
        get mostSignificantBits(): number;
        get class(): Internal.Class<any>;
        get leastSignificantBits(): number;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    type UUID_ = UUID;
    class Products$P15 <F, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15> {
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        apply<R>(arg0: Internal.Applicative_<F, any>, arg1: Internal.Function15_<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, R>): Internal.App<F, R>;
        apply<R>(arg0: Internal.Applicative_<F, any>, arg1: Internal.App_<F, Internal.Function15_<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, R>>): Internal.App<F, R>;
        hashCode(): number;
        notifyAll(): void;
        equals(arg0: any): boolean;
        toString(): string;
        notify(): void;
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    type Products$P15_<F, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15> = Products$P15<F, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15>;
    class Window$Type extends Internal.Enum<Internal.Window$Type> {
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        static valueOf(arg0: string): Internal.Window$Type;
        static valueOf<T_>(arg0: Internal.Class_<T_>, arg1: string): T_;
        notifyAll(): void;
        static values(): Internal.Window$Type[];
        compareTo(arg0: Internal.Window$Type_): number;
        describeConstable(): Internal.Optional<Internal.Enum$EnumDesc<Internal.Window$Type>>;
        notify(): void;
        getDeclaringClass(): Internal.Class<Internal.Window$Type>;
        hashCode(): number;
        equals(arg0: any): boolean;
        name(): string;
        toString(): string;
        ordinal(): number;
        static readonly POPUP : Internal.Window$Type;
        static readonly UTILITY : Internal.Window$Type;
        static readonly NORMAL : Internal.Window$Type;
        get class(): Internal.Class<any>;
        get declaringClass(): Internal.Class<Internal.Window$Type>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    type Window$Type_ = "normal" | "popup" | "utility" | Window$Type;
    class NativeJavaObject implements Internal.Scriptable, Internal.SymbolScriptable, Internal.Wrapper, Internal.Serializable {
        enumerationIteratorNext(cx: Internal.Context_, currentId: Internal.Consumer_<any>): boolean;
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        hasInstance(value: Internal.Scriptable_): boolean;
        setParentScope(m: Internal.Scriptable_): void;
        static canConvert(cx: Internal.Context_, fromObj: any, to: Internal.Class_<any>): boolean;
        notifyAll(): void;
        getIds(): any[];
        addCustomProperty(name: string, getter: Internal.CustomProperty_): void;
        getAllIds(): any[];
        delete(name: string): void;
        delete(index: number): void;
        delete(key: Internal.Symbol_): void;
        notify(): void;
        put(symbol: Internal.Symbol_, start: Internal.Scriptable_, value: any): void;
        put(name: string, start: Internal.Scriptable_, value: any): void;
        put(index: number, start: Internal.Scriptable_, value: any): void;
        unwrap(): any;
        getDefaultValue(hint: Internal.Class_<any>): any;
        setPrototype(m: Internal.Scriptable_): void;
        getPrototype(): Internal.Scriptable;
        hashCode(): number;
        equals(arg0: any): boolean;
        get(name: string, start: Internal.Scriptable_): any;
        get(index: number, start: Internal.Scriptable_): any;
        get(key: Internal.Symbol_, start: Internal.Scriptable_): any;
        toString(): string;
        enumerationIteratorHasNext(cx: Internal.Context_, currentId: Internal.Consumer_<any>): boolean;
        has(key: Internal.Symbol_, start: Internal.Scriptable_): boolean;
        has(index: number, start: Internal.Scriptable_): boolean;
        has(name: string, start: Internal.Scriptable_): boolean;
        getClassName(): string;
        getParentScope(): Internal.Scriptable;
        static readonly NOT_FOUND : any;
        get parentScope(): Internal.Scriptable;
        get ids(): any[];
        get className(): string;
        get class(): Internal.Class<any>;
        get allIds(): any[];
        get prototype(): Internal.Scriptable;
        set parentScope(m: Internal.Scriptable_);
        set prototype(m: Internal.Scriptable_);
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    type NativeJavaObject_ = NativeJavaObject;
    class FTBQuestsKubeJSPlayerData extends Internal.FTBQuestsKubeJSTeamData {
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        getRelativeProgress(id: any): number;
        notifyAll(): void;
        getTaskProgress(id: any): number;
        isStarted(id: any): boolean;
        addProgress(id: any, progress: number): boolean;
        getLocked(): boolean;
        getFile(): Internal.QuestFile;
        notify(): void;
        setLocked(v: boolean): void;
        changeProgress(id: any, consumer: Internal.Consumer_<Internal.ProgressChange_>): void;
        getOnlineMembers(): Internal.EntityArrayList;
        hashCode(): number;
        equals(arg0: any): boolean;
        canStartQuest(id: any): boolean;
        reset(id: any): void;
        toString(): string;
        complete(id: any): void;
        getData(): Internal.TeamData;
        isCompleted(id: any): boolean;
        get file(): Internal.QuestFile;
        get onlineMembers(): Internal.EntityArrayList;
        get data(): Internal.TeamData;
        get locked(): boolean;
        get class(): Internal.Class<any>;
        set locked(v: boolean);
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    type FTBQuestsKubeJSPlayerData_ = FTBQuestsKubeJSPlayerData;
    class CommandSourceStack implements Internal.SharedSuggestionProvider, Internal.IForgeCommandSourceStack, Internal.CommandSourceStackAccess {
        getAdvancement(arg0: ResourceLocation_): Internal.Advancement;
        getRecipeManager(): Internal.RecipeManager;
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        getUnsidedLevel(): Internal.Level;
        hashCode(): number;
        notifyAll(): void;
        equals(arg0: any): boolean;
        getScoreboard(): Internal.Scoreboard;
        toString(): string;
        notify(): void;
        get unsidedLevel(): Internal.Level;
        get recipeManager(): Internal.RecipeManager;
        get scoreboard(): Internal.Scoreboard;
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    type CommandSourceStack_ = CommandSourceStack;
    interface Object2FloatMap$Entry <K> extends Internal.Map$Entry<K, number> {
        getKey(): K;
        getValue(): number;
        hashCode(): number;
        getFloatValue(): number;
        equals(arg0: any): boolean;
        setValue(arg0: number): number;
    }
    type Object2FloatMap$Entry_<K> = Object2FloatMap$Entry<K>;
    class ColorProperty extends Internal.TeamProperty<Internal.Color4I> {
        getClass(): Internal.Class<any>;
        readValue(buf: Internal.FriendlyByteBuf_): Internal.Color4I;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        fromNBT(tag: net.minecraft.nbt.Tag_): Internal.Optional<Internal.Color4I>;
        notifyAll(): void;
        notify(): void;
        toNBT(value: Internal.Color4I_): net.minecraft.nbt.Tag;
        getType(): Internal.TeamPropertyType<Internal.Color4I>;
        hashCode(): number;
        equals(o: any): boolean;
        toString(value: Internal.Color4I_): string;
        toString(): string;
        fromString(string: string): Internal.Optional<Internal.Color4I>;
        writeValue(buf: Internal.FriendlyByteBuf_, value: Internal.Color4I_): void;
        config(config: Internal.ConfigGroup_, value: Internal.TeamPropertyValue_<Internal.Color4I_>): void;
        write(buf: Internal.FriendlyByteBuf_): void;
        readonly defaultValue : Internal.Color4I;
        readonly id : ResourceLocation;
        get type(): Internal.TeamPropertyType<Internal.Color4I>;
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    type ColorProperty_ = ColorProperty;
    interface BiPredicate <T, U> {
        or(arg0: Internal.BiPredicate_<T, U>): Internal.BiPredicate<T, U>;
        test(arg0: T, arg1: U): boolean;
        and(arg0: Internal.BiPredicate_<T, U>): Internal.BiPredicate<T, U>;
        negate(): Internal.BiPredicate<T, U>;
    }
    type BiPredicate_<T, U> = ((arg0: T, arg1: U) => boolean) | BiPredicate<T, U>;
    abstract class ForwardingObject {
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        hashCode(): number;
        notifyAll(): void;
        equals(arg0: any): boolean;
        toString(): string;
        notify(): void;
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    type ForwardingObject_ = ForwardingObject;
    interface BlockStateKJS {
        setDestroySpeedKJS(arg0: number): void;
        setLightEmissionKJS(arg0: number): void;
        setRequiresToolKJS(arg0: boolean): void;
        setMaterialKJS(arg0: Internal.Material_): void;
    }
    type BlockStateKJS_ = BlockStateKJS;
    class Camera {
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        setAnglesInternal(arg0: number, arg1: number): void;
        hashCode(): number;
        notifyAll(): void;
        equals(arg0: any): boolean;
        toString(): string;
        getBlockAtCamera(): Internal.BlockState;
        notify(): void;
        get blockAtCamera(): Internal.BlockState;
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    type Camera_ = Camera;
    interface TemporalField {
        resolve(arg0: Internal.Map_<Internal.TemporalField_, number>, arg1: Internal.TemporalAccessor_, arg2: Internal.ResolverStyle_): Internal.TemporalAccessor;
        getBaseUnit(): Internal.TemporalUnit;
        rangeRefinedBy(arg0: Internal.TemporalAccessor_): Internal.ValueRange;
        getDisplayName(arg0: Internal.Locale_): string;
        isTimeBased(): boolean;
        adjustInto<R>(arg0: R, arg1: number): R;
        range(): Internal.ValueRange;
        getRangeUnit(): Internal.TemporalUnit;
        toString(): string;
        isDateBased(): boolean;
        getFrom(arg0: Internal.TemporalAccessor_): number;
        isSupportedBy(arg0: Internal.TemporalAccessor_): boolean;
    }
    type TemporalField_ = TemporalField;
    interface JsonSerializable {
        toJson(): Internal.JsonElement;
    }
    type JsonSerializable_ = JsonSerializable;
    abstract class CapabilityTrait implements Internal.IInnerCapabilityProvider {
        readFromNBT(arg0: Internal.CompoundTag_): void;
        getClass(): Internal.Class<any>;
        openConfigurator(arg0: Internal.WidgetGroup_): void;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        getCapability<T_>(arg0: Internal.Capability_<T_>, arg1: Internal.Direction_): Internal.LazyOptional<T_>;
        getCapability<T_>(arg0: Internal.Capability_<T_>): Internal.LazyOptional<T_>;
        writeCustomData(arg0: number, arg1: Internal.Consumer_<Internal.FriendlyByteBuf_>): void;
        notifyAll(): void;
        onChunkUnload(): void;
        update(): void;
        notify(): void;
        createUI(arg0: Internal.ComponentTileEntity_<any>, arg1: Internal.WidgetGroup_, arg2: Internal.Player_): void;
        receiveCustomData(arg0: number, arg1: Internal.FriendlyByteBuf_): void;
        hashCode(): number;
        getInnerCapability<T_>(arg0: Internal.Capability_<T_>, arg1: Internal.Direction_): Internal.LazyOptional<T_>;
        markAsDirty(): void;
        writeToNBT(arg0: Internal.CompoundTag_): void;
        deserialize(): Internal.JsonElement;
        receiveClientEvent(arg0: number, arg1: number): boolean;
        setComponent(arg0: Internal.ComponentTileEntity_<any>): void;
        invalidate(): void;
        hasCapability(arg0: Internal.Capability_<any>, arg1: Internal.Direction_): boolean;
        serialize(arg0: Internal.JsonElement_): void;
        hasUpdate(): boolean;
        equals(arg0: any): boolean;
        onDrops(arg0: Internal.NonNullList_<Internal.ItemStack_>, arg1: Internal.Player_): void;
        onLoad(): void;
        toString(): string;
        readonly capability : Internal.MultiblockCapability<any>;
        get class(): Internal.Class<any>;
        set component(arg0: Internal.ComponentTileEntity_<any>);
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    type CapabilityTrait_ = CapabilityTrait;
    class MobEffect extends Internal.ForgeRegistryEntry<Internal.MobEffect> implements Internal.IForgeMobEffect, Internal.AccessorMobEffect {
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        notifyAll(): void;
        getRegistryName(): ResourceLocation;
        setRegistryName(arg0: ResourceLocation_): Internal.MobEffect;
        setRegistryName(arg0: string): Internal.MobEffect;
        setRegistryName(arg0: string, arg1: string): Internal.MobEffect;
        getSortOrder(arg0: Internal.MobEffectInstance_): number;
        notify(): void;
        hashCode(): number;
        equals(arg0: any): boolean;
        getRegistryType(): Internal.Class<Internal.MobEffect>;
        toString(): string;
        initializeClient(arg0: Internal.Consumer_<Internal.EffectRenderer_>): void;
        getCurativeItems(): Internal.List<Internal.ItemStack>;
        getEffectRendererInternal(): any;
        readonly delegate : Internal.IRegistryDelegate<Internal.MobEffect>;
        get registryType(): Internal.Class<Internal.MobEffect>;
        get curativeItems(): Internal.List<Internal.ItemStack>;
        get effectRendererInternal(): any;
        get registryName(): ResourceLocation;
        get class(): Internal.Class<any>;
        set registryName(arg0: ResourceLocation_);
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    type MobEffect_ = "alexsmobs:bug_pheromones" | "alexsmobs:clinging" | "alexsmobs:debilitating_sting" | "alexsmobs:earthquake" | "alexsmobs:ender_flu" | "alexsmobs:exsanguination" | "alexsmobs:fear" | "alexsmobs:fleet_footed" | "alexsmobs:knockback_resistance" | "alexsmobs:lava_vision" | "alexsmobs:oiled" | "alexsmobs:orcas_might" | "alexsmobs:poison_resistance" | "alexsmobs:power_down" | "alexsmobs:soulsteal" | "alexsmobs:sunbird_blessing" | "alexsmobs:sunbird_curse" | "alexsmobs:tigers_blessing" | "ars_elemental:enthralled" | "ars_elemental:hellfire" | "ars_elemental:life_link" | "ars_elemental:watery_grave" | "ars_nouveau:bounce" | "ars_nouveau:familiar_sickness" | "ars_nouveau:flight" | "ars_nouveau:glide" | "ars_nouveau:gravity" | "ars_nouveau:hex" | "ars_nouveau:magic_find" | "ars_nouveau:mana_regen" | "ars_nouveau:scrying" | "ars_nouveau:shield" | "ars_nouveau:shocked" | "ars_nouveau:snared" | "ars_nouveau:spell_damage" | "ars_nouveau:summoning_sickness" | "arsomega:adrenaline" | "arsomega:burned" | "arsomega:demonic_curse" | "arsomega:lead_skin" | "arsomega:no_magic_break" | "arsomega:perma_flight" | "arsomega:soulfire" | "arsomega:stone_petrification" | "arsomega:vine_bind" | "blue_skies:deadly_venom" | "botania:allure" | "botania:bloodthirst" | "botania:clear" | "botania:emptiness" | "botania:feather_feet" | "botania:soul_cross" | "castle_in_the_sky:sacred_castle_effect" | "cataclysm:blazing_brand" | "cataclysm:monstrous" | "champions:paralysis" | "champions:wound" | "cofh_core:chilled" | "cofh_core:clarity" | "cofh_core:enderference" | "cofh_core:explosion_resistance" | "cofh_core:lightning_resistance" | "cofh_core:love" | "cofh_core:magic_resistance" | "cofh_core:panacea" | "cofh_core:shocked" | "cofh_core:slimed" | "cofh_core:sundered" | "cofh_core:supercharge" | "cofh_core:wrenched" | "cyclic:stun" | "cyclic:swimspeed" | "ecologics:slippery" | "enigmaticlegacy:blazing_strength" | "enigmaticlegacy:molten_heart" | "evilcraft:paling" | "farmersdelight:comfort" | "farmersdelight:nourishment" | "forbidden_arcanus:darkened" | "forbidden_arcanus:spectral_vision" | "mahoutsukai:binding_eyes" | "mahoutsukai:black_burning" | "mahoutsukai:black_flame_eyes" | "mahoutsukai:bleeding" | "mahoutsukai:borrowed_authority" | "mahoutsukai:bound" | "mahoutsukai:clairvoyance_eyes" | "mahoutsukai:cm_cooldown" | "mahoutsukai:confusion" | "mahoutsukai:death_collection_eyes" | "mahoutsukai:fay_sight_eyes" | "mahoutsukai:fear" | "mahoutsukai:flung" | "mahoutsukai:foresight" | "mahoutsukai:immunity_exchange" | "mahoutsukai:insight_eyes" | "mahoutsukai:interesting_block" | "mahoutsukai:misfortune" | "mahoutsukai:peaceful_garden" | "mahoutsukai:probability_alter" | "mahoutsukai:rage" | "mahoutsukai:reversion_eyes" | "mahoutsukai:reverted" | "mahoutsukai:ripper_cooldown" | "mahoutsukai:ripper_invis" | "mahoutsukai:ripper_invis_cooldown" | "mahoutsukai:rpsw_cooldown" | "mahoutsukai:selective_displacement" | "mahoutsukai:selective_displacement_cooldown" | "mahoutsukai:wounded" | "mahoutsukai:zap_cooldown" | "malum:aerial_aura" | "malum:aqueous_aura" | "malum:corrupted_aerial_aura" | "malum:corrupted_earthen_aura" | "malum:earthen_aura" | "malum:infernal_aura" | "malum:sacred_aura" | "absorption" | "minecraft:absorption" | "bad_omen" | "minecraft:bad_omen" | "blindness" | "minecraft:blindness" | "conduit_power" | "minecraft:conduit_power" | "dolphins_grace" | "minecraft:dolphins_grace" | "fire_resistance" | "minecraft:fire_resistance" | "glowing" | "minecraft:glowing" | "haste" | "minecraft:haste" | "health_boost" | "minecraft:health_boost" | "hero_of_the_village" | "minecraft:hero_of_the_village" | "hunger" | "minecraft:hunger" | "instant_damage" | "minecraft:instant_damage" | "instant_health" | "minecraft:instant_health" | "invisibility" | "minecraft:invisibility" | "jump_boost" | "minecraft:jump_boost" | "levitation" | "minecraft:levitation" | "luck" | "minecraft:luck" | "mining_fatigue" | "minecraft:mining_fatigue" | "nausea" | "minecraft:nausea" | "night_vision" | "minecraft:night_vision" | "poison" | "minecraft:poison" | "regeneration" | "minecraft:regeneration" | "resistance" | "minecraft:resistance" | "saturation" | "minecraft:saturation" | "slow_falling" | "minecraft:slow_falling" | "slowness" | "minecraft:slowness" | "speed" | "minecraft:speed" | "strength" | "minecraft:strength" | "unluck" | "minecraft:unluck" | "water_breathing" | "minecraft:water_breathing" | "weakness" | "minecraft:weakness" | "wither" | "minecraft:wither" | "naturesaura:breathless" | "occultism:bat_lifesteal" | "occultism:beaver_harvest" | "occultism:double_jump" | "occultism:dragon_greed" | "occultism:mummy_dodge" | "occultism:third_eye" | "orcz:bombtriggered" | "orcz:bosstooclose" | "orcz:enrage" | "orcz:getreadytobestriked" | "orcz:gettingstriked" | "orcz:goblinsblock" | "orcz:goblinsexistance" | "orcz:hitrunactflee" | "orcz:posessedsquig" | "orcz:rageburstorcc" | "orcz:smokysmell" | "orcz:soulforpower" | "orcz:strikeorder" | "orcz:weridexistance" | "orcz:witherstrikeready" | "paraglider:exhausted" | "quark:resilience" | "reliquary:cure" | "reliquary:flight" | "reliquary:pacification" | "sons_of_sins:blur_effect" | "sons_of_sins:greed" | "sons_of_sins:sloth" | "sons_of_sins:very_bad_omen" | "stalwart_dungeons:burning" | "stalwart_dungeons:spore" | "twilightforest:frosted" | "undergarden:brittleness" | "undergarden:featherweight" | "undergarden:gooey" | "undergarden:virulent_resistance" | MobEffect;
    interface Stream <T> extends Internal.BaseStream<T, Internal.Stream<T>> {
        sequential(): Internal.Stream<T>;
        takeWhile(arg0: Internal.Predicate_<T>): Internal.Stream<T>;
        distinct(): Internal.Stream<T>;
        findFirst(): Internal.Optional<T>;
        skip(arg0: number): Internal.Stream<T>;
        toList(): Internal.List<T>;
        allMatch(arg0: Internal.Predicate_<T>): boolean;
        mapMultiToDouble(arg0: Internal.BiConsumer_<T, java_.util.function_.DoubleConsumer_>): Internal.DoubleStream;
        iterator(): Internal.Iterator<T>;
        mapMulti<R_>(arg0: Internal.BiConsumer_<T, Internal.Consumer_<R_>>): Internal.Stream<R_>;
        flatMapToInt(arg0: java_.util.function_.Function_<T, Internal.IntStream_>): Internal.IntStream;
        min(arg0: Internal.Comparator_<T>): Internal.Optional<T>;
        flatMapToLong(arg0: java_.util.function_.Function_<T, Internal.LongStream_>): Internal.LongStream;
        parallel(): Internal.Stream<T>;
        mapToLong(arg0: Internal.ToLongFunction_<T>): Internal.LongStream;
        noneMatch(arg0: Internal.Predicate_<T>): boolean;
        findAny(): Internal.Optional<T>;
        isParallel(): boolean;
        limit(arg0: number): Internal.Stream<T>;
        toArray(): any[];
        toArray<A_>(arg0: Internal.IntFunction_<A_[]>): A_[];
        forEachOrdered(arg0: Internal.Consumer_<T>): void;
        close(): void;
        anyMatch(arg0: Internal.Predicate_<T>): boolean;
        map<R_>(arg0: java_.util.function_.Function_<T, R_>): Internal.Stream<R_>;
        mapToDouble(arg0: Internal.ToDoubleFunction_<T>): Internal.DoubleStream;
        unordered(): Internal.Stream<T>;
        mapMultiToLong(arg0: Internal.BiConsumer_<T, java_.util.function_.LongConsumer_>): Internal.LongStream;
        mapMultiToInt(arg0: Internal.BiConsumer_<T, java_.util.function_.IntConsumer_>): Internal.IntStream;
        reduce<U_>(arg0: U_, arg1: Internal.BiFunction_<U_, T, U_>, arg2: Internal.BinaryOperator_<U_>): U_;
        reduce(arg0: T, arg1: Internal.BinaryOperator_<T>): T;
        reduce(arg0: Internal.BinaryOperator_<T>): Internal.Optional<T>;
        spliterator(): Internal.Spliterator<T>;
        max(arg0: Internal.Comparator_<T>): Internal.Optional<T>;
        forEach(arg0: Internal.Consumer_<T>): void;
        count(): number;
        dropWhile(arg0: Internal.Predicate_<T>): Internal.Stream<T>;
        flatMapToDouble(arg0: java_.util.function_.Function_<T, Internal.DoubleStream_>): Internal.DoubleStream;
        peek(arg0: Internal.Consumer_<T>): Internal.Stream<T>;
        flatMap<R_>(arg0: java_.util.function_.Function_<T, Internal.Stream_<R_>>): Internal.Stream<R_>;
        filter(arg0: Internal.Predicate_<T>): Internal.Stream<T>;
        onClose(arg0: Internal.Runnable_): Internal.Stream<T>;
        sorted(): Internal.Stream<T>;
        sorted(arg0: Internal.Comparator_<T>): Internal.Stream<T>;
        mapToInt(arg0: Internal.ToIntFunction_<T>): Internal.IntStream;
        collect<R_>(arg0: Internal.Supplier_<R_>, arg1: Internal.BiConsumer_<R_, T>, arg2: Internal.BiConsumer_<R_, R_>): R_;
        collect<R_, A_>(arg0: Internal.Collector_<T, A_, R_>): R_;
    }
    type Stream_<T> = Stream<T>;
    interface Float2FloatFunction extends Internal.Function<number, number>, Internal.DoubleUnaryOperator {
        getOrDefault(arg0: any, arg1: number): number;
        getOrDefault(arg0: number, arg1: number): number;
        applyAsDouble(arg0: number): number;
        andThenShort(arg0: Internal.Float2ShortFunction_): Internal.Float2ShortFunction;
        composeByte(arg0: Internal.Byte2FloatFunction_): Internal.Byte2FloatFunction;
        andThenInt(arg0: Internal.Float2IntFunction_): Internal.Float2IntFunction;
        composeReference<T_>(arg0: Internal.Reference2FloatFunction_<T_>): Internal.Reference2FloatFunction<T_>;
        andThen<T_>(arg0: java_.util.function_.Function_<number, T_>): java_.util.function_.Function<number, T_>;
        andThen(arg0: Internal.DoubleUnaryOperator_): Internal.DoubleUnaryOperator;
        put(arg0: number, arg1: number): number;
        remove(arg0: number): number;
        remove(arg0: any): number;
        defaultReturnValue(): number;
        defaultReturnValue(arg0: number): void;
        andThenDouble(arg0: Internal.Float2DoubleFunction_): Internal.Float2DoubleFunction;
        andThenObject<T_>(arg0: Internal.Float2ObjectFunction_<T_>): Internal.Float2ObjectFunction<T_>;
        get(arg0: any): number;
        get(arg0: number): number;
        andThenLong(arg0: Internal.Float2LongFunction_): Internal.Float2LongFunction;
        composeLong(arg0: Internal.Long2FloatFunction_): Internal.Long2FloatFunction;
        andThenByte(arg0: Internal.Float2ByteFunction_): Internal.Float2ByteFunction;
        andThenFloat(arg0: Internal.Float2FloatFunction_): Internal.Float2FloatFunction;
        apply(arg0: number): number;
        containsKey(arg0: any): boolean;
        containsKey(arg0: number): boolean;
        composeInt(arg0: Internal.Int2FloatFunction_): Internal.Int2FloatFunction;
        clear(): void;
        composeFloat(arg0: Internal.Float2FloatFunction_): Internal.Float2FloatFunction;
        andThenChar(arg0: Internal.Float2CharFunction_): Internal.Float2CharFunction;
        composeObject<T_>(arg0: Internal.Object2FloatFunction_<T_>): Internal.Object2FloatFunction<T_>;
        size(): number;
        compose<T_>(arg0: java_.util.function_.Function_<T_, number>): java_.util.function_.Function<T_, number>;
        compose(arg0: Internal.DoubleUnaryOperator_): Internal.DoubleUnaryOperator;
        composeShort(arg0: Internal.Short2FloatFunction_): Internal.Short2FloatFunction;
        andThenReference<T_>(arg0: Internal.Float2ReferenceFunction_<T_>): Internal.Float2ReferenceFunction<T_>;
        composeChar(arg0: Internal.Char2FloatFunction_): Internal.Char2FloatFunction;
        composeDouble(arg0: Internal.Double2FloatFunction_): Internal.Double2FloatFunction;
    }
    type Float2FloatFunction_ = ((arg0: number) => number) | Float2FloatFunction;
    interface ScreenAccess {
        byg_invokeOpenLink(arg0: Internal.URI_): void;
    }
    type ScreenAccess_ = ScreenAccess;
    class CPacketUIClientAction implements Internal.IPacket {
        encode(arg0: Internal.FriendlyByteBuf_): void;
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        hashCode(): number;
        notifyAll(): void;
        equals(arg0: any): boolean;
        toString(): string;
        decode(arg0: Internal.FriendlyByteBuf_): void;
        execute(arg0: Internal.NetworkEvent$Context_): void;
        notify(): void;
        updateData : Internal.FriendlyByteBuf;
        windowId : number;
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    type CPacketUIClientAction_ = CPacketUIClientAction;
    interface ItemBuilder$ItemColorJS {
        getColor(arg0: Internal.ItemStackJS_, arg1: number): Internal.Color;
    }
    type ItemBuilder$ItemColorJS_ = ((arg0: Internal.ItemStackJS, arg1: number) => Internal.Color) | ItemBuilder$ItemColorJS;
    abstract class MultiblockCapability <T> implements Internal.JsonSerializer<T>, Internal.JsonDeserializer<T> {
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        getCapability<C_>(arg0: Internal.Capability_<C_>, arg1: Internal.BlockEntity_): Internal.Set<C_>;
        notifyAll(): void;
        copyInner(arg0: T): T;
        getCandidates(): Internal.BlockInfo[];
        createTrait(): Internal.CapabilityTrait;
        getUnlocalizedName(): string;
        notify(): void;
        createContentWidget(): Internal.ContentWidget<T>;
        isBlockHasCapability(arg0: Internal.IO_, arg1: Internal.BlockEntity_): boolean;
        serialize(arg0: T, arg1: java_.lang.reflect.Type_, arg2: Internal.JsonSerializationContext_): Internal.JsonElement;
        serialize(arg0: any): Internal.JsonElement;
        createProxy(arg0: Internal.IO_, arg1: Internal.BlockEntity_): Internal.CapabilityProxy<T>;
        defaultContent(): T;
        hashCode(): number;
        equals(arg0: any): boolean;
        of(arg0: any): T;
        toString(): string;
        hasTrait(): boolean;
        getAnyBlock(): Internal.BlockComponent;
        deserialize(arg0: Internal.JsonElement_, arg1: java_.lang.reflect.Type_, arg2: Internal.JsonDeserializationContext_): T;
        deserialize(arg0: Internal.JsonElement_): T;
        readonly color : number;
        readonly name : string;
        serializer : Internal.IContentSerializer<T>;
        get candidates(): Internal.BlockInfo[];
        get unlocalizedName(): string;
        get class(): Internal.Class<any>;
        get anyBlock(): Internal.BlockComponent;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    type MultiblockCapability_<T> = MultiblockCapability<T>;
    class Explosion$BlockInteraction extends Internal.Enum<Internal.Explosion$BlockInteraction> {
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        static valueOf(arg0: string): Internal.Explosion$BlockInteraction;
        static valueOf<T_>(arg0: Internal.Class_<T_>, arg1: string): T_;
        notifyAll(): void;
        static values(): Internal.Explosion$BlockInteraction[];
        compareTo(arg0: Internal.Explosion$BlockInteraction_): number;
        describeConstable(): Internal.Optional<Internal.Enum$EnumDesc<Internal.Explosion$BlockInteraction>>;
        notify(): void;
        getDeclaringClass(): Internal.Class<Internal.Explosion$BlockInteraction>;
        hashCode(): number;
        equals(arg0: any): boolean;
        name(): string;
        toString(): string;
        ordinal(): number;
        static readonly DESTROY : Internal.Explosion$BlockInteraction;
        static readonly BREAK : Internal.Explosion$BlockInteraction;
        static readonly NONE : Internal.Explosion$BlockInteraction;
        get class(): Internal.Class<any>;
        get declaringClass(): Internal.Class<Internal.Explosion$BlockInteraction>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    type Explosion$BlockInteraction_ = "break" | "destroy" | "none" | Explosion$BlockInteraction;
    interface Remapper {
        remapMethod(arg0: Internal.Class_<any>, arg1: Internal.Method_, arg2: string): string;
        unmapClass(arg0: string): string;
        getMappedClass(from: Internal.Class_<any>): string;
        getMappedField(from: Internal.Class_<any>, field: Internal.Field_): string;
        getMappedField(from: Internal.Class_<any>, field: Internal.Field_, fieldName: string): string;
        remapField(arg0: Internal.Class_<any>, arg1: Internal.Field_, arg2: string): string;
        getMappedMethod(from: Internal.Class_<any>, method: Internal.Method_, methodString: string): string;
        getMappedMethod(from: Internal.Class_<any>, method: Internal.Method_): string;
        getUnmappedClass(from: string): string;
        remapClass(arg0: Internal.Class_<any>, arg1: string): string;
    }
    type Remapper_ = Remapper;
    interface AccessibleAction {
        getAccessibleActionDescription(arg0: number): string;
        doAccessibleAction(arg0: number): boolean;
        getAccessibleActionCount(): number;
    }
    type AccessibleAction_ = AccessibleAction;
    class RemoveJEICategoriesEvent extends Internal.EventJS {
        cancel(): void;
        getClass(): Internal.Class<any>;
        yeetIf(filter: Internal.Predicate_<Internal.IRecipeCategory_<any>>): void;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        isCancelled(): boolean;
        yeet(categoriesToRemove: string[]): void;
        notifyAll(): void;
        notify(): void;
        remove(categoriesToYeet: string[]): void;
        removeIf(filter: Internal.Predicate_<Internal.IRecipeCategory_<any>>): void;
        post(t: Internal.ScriptType_, id: string, sub: string): boolean;
        post(t: Internal.ScriptType_, id: string): boolean;
        getCategories(): Internal.Collection<Internal.IRecipeCategory<any>>;
        hashCode(): number;
        equals(arg0: any): boolean;
        toString(): string;
        getCategoryIds(): Internal.Collection<ResourceLocation>;
        canCancel(): boolean;
        get categoryIds(): Internal.Collection<ResourceLocation>;
        get cancelled(): boolean;
        get categories(): Internal.Collection<Internal.IRecipeCategory<any>>;
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    type RemoveJEICategoriesEvent_ = RemoveJEICategoriesEvent;
    class InputContext {
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        dispatchEvent(arg0: Internal.AWTEvent_): void;
        notifyAll(): void;
        reconvert(): void;
        getInputMethodControlObject(): any;
        notify(): void;
        isCompositionEnabled(): boolean;
        setCharacterSubsets(arg0: any_[]): void;
        setCompositionEnabled(arg0: boolean): void;
        endComposition(): void;
        hashCode(): number;
        equals(arg0: any): boolean;
        removeNotify(arg0: java_.awt.Component_): void;
        toString(): string;
        dispose(): void;
        selectInputMethod(arg0: Internal.Locale_): boolean;
        static getInstance(): Internal.InputContext;
        getLocale(): Internal.Locale;
        get inputMethodControlObject(): any;
        get compositionEnabled(): boolean;
        get instance(): Internal.InputContext;
        get locale(): Internal.Locale;
        get class(): Internal.Class<any>;
        set compositionEnabled(arg0: boolean);
        set characterSubsets(arg0: any_[]);
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    type InputContext_ = InputContext;
    interface ChannelId extends Internal.Serializable, Internal.Comparable<Internal.ChannelId> {
        asShortText(): string;
        compareTo(arg0: Internal.ChannelId_): number;
        asLongText(): string;
    }
    type ChannelId_ = ChannelId;
    class TextureStitchEvent$Pre extends Internal.TextureStitchEvent {
        setCanceled(arg0: boolean): void;
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        isCanceled(): boolean;
        setResult(arg0: Internal.Event$Result_): void;
        notifyAll(): void;
        hasResult(): boolean;
        notify(): void;
        getListenerList(): Internal.ListenerList;
        addSprite(arg0: ResourceLocation_): boolean;
        hashCode(): number;
        equals(arg0: any): boolean;
        getResult(): Internal.Event$Result;
        toString(): string;
        isCancelable(): boolean;
        getPhase(): Internal.EventPriority;
        setPhase(arg0: Internal.EventPriority_): void;
        getAtlas(): Internal.TextureAtlas;
        get result(): Internal.Event$Result;
        get phase(): Internal.EventPriority;
        get canceled(): boolean;
        get cancelable(): boolean;
        get listenerList(): Internal.ListenerList;
        get atlas(): Internal.TextureAtlas;
        get class(): Internal.Class<any>;
        set phase(arg0: Internal.EventPriority_);
        set result(arg0: Internal.Event$Result_);
        set canceled(arg0: boolean);
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    type TextureStitchEvent$Pre_ = TextureStitchEvent$Pre;
    class Method extends Internal.Executable {
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        getName(): string;
        getParameterCount(): number;
        isAnnotationPresent(arg0: Internal.Class_<Internal.Annotation_>): boolean;
        getGenericReturnType(): java_.lang.reflect.Type;
        notifyAll(): void;
        isSynthetic(): boolean;
        getAnnotatedParameterTypes(): Internal.AnnotatedType[];
        getParameterTypes(): Internal.Class<any>[];
        invoke(arg0: any, arg1: any[]): any;
        isBridge(): boolean;
        getGenericExceptionTypes(): java_.lang.reflect.Type[];
        notify(): void;
        getAnnotatedReceiverType(): Internal.AnnotatedType;
        getDefaultValue(): any;
        getDeclaredAnnotations(): Internal.Annotation[];
        getDeclaringClass(): Internal.Class<any>;
        getAnnotationsByType<T_>(arg0: Internal.Class_<T_>): T_[];
        hashCode(): number;
        canAccess(arg0: any): boolean;
        toGenericString(): string;
        getTypeParameters(): any[];
        getModifiers(): number;
        trySetAccessible(): boolean;
        isAccessible(): boolean;
        setAccessible(arg0: boolean): void;
        static setAccessible(arg0: Internal.AccessibleObject_[], arg1: boolean): void;
        isVarArgs(): boolean;
        getAnnotations(): Internal.Annotation[];
        getAnnotatedExceptionTypes(): Internal.AnnotatedType[];
        getExceptionTypes(): Internal.Class<any>[];
        isDefault(): boolean;
        getGenericParameterTypes(): java_.lang.reflect.Type[];
        getReturnType(): Internal.Class<any>;
        getDeclaredAnnotationsByType<T_>(arg0: Internal.Class_<T_>): T_[];
        getAnnotation<T_>(arg0: Internal.Class_<T_>): T_;
        equals(arg0: any): boolean;
        getDeclaredAnnotation<T_>(arg0: Internal.Class_<T_>): T_;
        getParameters(): any[];
        toString(): string;
        getAnnotatedReturnType(): Internal.AnnotatedType;
        getParameterAnnotations(): Internal.Annotation[][];
        static readonly PUBLIC : 0;
        static readonly DECLARED : 1;
        get accessible(): boolean;
        get annotatedReturnType(): Internal.AnnotatedType;
        get defaultValue(): any;
        get annotations(): Internal.Annotation[];
        get modifiers(): number;
        get typeParameters(): any[];
        get default(): boolean;
        get exceptionTypes(): Internal.Class<any>[];
        get genericReturnType(): java_.lang.reflect.Type;
        get annotatedReceiverType(): Internal.AnnotatedType;
        get genericExceptionTypes(): java_.lang.reflect.Type[];
        get class(): Internal.Class<any>;
        get annotatedParameterTypes(): Internal.AnnotatedType[];
        get declaredAnnotations(): Internal.Annotation[];
        get parameterTypes(): Internal.Class<any>[];
        get parameterCount(): number;
        get declaringClass(): Internal.Class<any>;
        get varArgs(): boolean;
        get synthetic(): boolean;
        get genericParameterTypes(): java_.lang.reflect.Type[];
        get name(): string;
        get bridge(): boolean;
        get parameterAnnotations(): Internal.Annotation[][];
        get parameters(): any[];
        get annotatedExceptionTypes(): Internal.AnnotatedType[];
        get returnType(): Internal.Class<any>;
        set accessible(arg0: boolean);
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    type Method_ = Method;
    interface DirectoryStream <T> extends Internal.Closeable, Internal.Iterable<T> {
        iterator(): Internal.Iterator<T>;
        spliterator(): Internal.Spliterator<T>;
        forEach(arg0: Internal.Consumer_<T>): void;
        close(): void;
    }
    type DirectoryStream_<T> = DirectoryStream<T>;
    interface Object2LongFunction <K> extends Internal.Function<K, number>, Internal.ToLongFunction<K> {
        getOrDefault(arg0: any, arg1: number): number;
        andThenShort(arg0: Internal.Long2ShortFunction_): Internal.Object2ShortFunction<K>;
        composeByte(arg0: Internal.Byte2ObjectFunction_<K>): Internal.Byte2LongFunction;
        andThenInt(arg0: Internal.Long2IntFunction_): Internal.Object2IntFunction<K>;
        composeReference<T_>(arg0: Internal.Reference2ObjectFunction_<T_, K>): Internal.Reference2LongFunction<T_>;
        andThen<T_>(arg0: java_.util.function_.Function_<number, T_>): java_.util.function_.Function<K, T_>;
        put(arg0: K, arg1: number): number;
        remove(arg0: any): number;
        defaultReturnValue(): number;
        defaultReturnValue(arg0: number): void;
        andThenDouble(arg0: Internal.Long2DoubleFunction_): Internal.Object2DoubleFunction<K>;
        andThenObject<T_>(arg0: Internal.Long2ObjectFunction_<T_>): Internal.Object2ObjectFunction<K, T_>;
        removeLong(arg0: any): number;
        get(arg0: any): number;
        andThenLong(arg0: Internal.Long2LongFunction_): Internal.Object2LongFunction<K>;
        composeLong(arg0: Internal.Long2ObjectFunction_<K>): Internal.Long2LongFunction;
        andThenByte(arg0: Internal.Long2ByteFunction_): Internal.Object2ByteFunction<K>;
        andThenFloat(arg0: Internal.Long2FloatFunction_): Internal.Object2FloatFunction<K>;
        apply(arg0: K): number;
        containsKey(arg0: any): boolean;
        composeInt(arg0: Internal.Int2ObjectFunction_<K>): Internal.Int2LongFunction;
        clear(): void;
        composeFloat(arg0: Internal.Float2ObjectFunction_<K>): Internal.Float2LongFunction;
        andThenChar(arg0: Internal.Long2CharFunction_): Internal.Object2CharFunction<K>;
        getLong(arg0: any): number;
        applyAsLong(arg0: K): number;
        composeObject<T_>(arg0: Internal.Object2ObjectFunction_<T_, K>): Internal.Object2LongFunction<T_>;
        size(): number;
        compose<V_>(arg0: java_.util.function_.Function_<V_, K>): java_.util.function_.Function<V_, number>;
        composeShort(arg0: Internal.Short2ObjectFunction_<K>): Internal.Short2LongFunction;
        andThenReference<T_>(arg0: Internal.Long2ReferenceFunction_<T_>): Internal.Object2ReferenceFunction<K, T_>;
        composeChar(arg0: Internal.Char2ObjectFunction_<K>): Internal.Char2LongFunction;
        composeDouble(arg0: Internal.Double2ObjectFunction_<K>): Internal.Double2LongFunction;
    }
    type Object2LongFunction_<K> = ((arg0: any) => number) | Object2LongFunction<K>;
    class Module implements Internal.AnnotatedElement {
        getDescriptor(): Internal.ModuleDescriptor;
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        getName(): string;
        isAnnotationPresent(arg0: Internal.Class_<Internal.Annotation_>): boolean;
        canRead(arg0: Internal.Module_): boolean;
        notifyAll(): void;
        addUses(arg0: Internal.Class_<any>): Internal.Module;
        getClassLoader(): Internal.ClassLoader;
        isNamed(): boolean;
        notify(): void;
        getDeclaredAnnotations(): Internal.Annotation[];
        getAnnotationsByType<T_>(arg0: Internal.Class_<T_>): T_[];
        hashCode(): number;
        addReads(arg0: Internal.Module_): Internal.Module;
        getLayer(): Internal.ModuleLayer;
        getResourceAsStream(arg0: string): Internal.InputStream;
        addExports(arg0: string, arg1: Internal.Module_): Internal.Module;
        getAnnotations(): Internal.Annotation[];
        canUse(arg0: Internal.Class_<any>): boolean;
        isOpen(arg0: string): boolean;
        isOpen(arg0: string, arg1: Internal.Module_): boolean;
        getDeclaredAnnotationsByType<T_>(arg0: Internal.Class_<T_>): T_[];
        getAnnotation<T_>(arg0: Internal.Class_<T_>): T_;
        equals(arg0: any): boolean;
        isExported(arg0: string, arg1: Internal.Module_): boolean;
        isExported(arg0: string): boolean;
        getDeclaredAnnotation<T_>(arg0: Internal.Class_<T_>): T_;
        getPackages(): Internal.Set<string>;
        toString(): string;
        addOpens(arg0: string, arg1: Internal.Module_): Internal.Module;
        get declaredAnnotations(): Internal.Annotation[];
        get named(): boolean;
        get classLoader(): Internal.ClassLoader;
        get name(): string;
        get annotations(): Internal.Annotation[];
        get descriptor(): Internal.ModuleDescriptor;
        get packages(): Internal.Set<string>;
        get class(): Internal.Class<any>;
        get layer(): Internal.ModuleLayer;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    type Module_ = Module;
    interface Function12 <T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, R> {
        curry9(): Internal.Function9<T1, T2, T3, T4, T5, T6, T7, T8, T9, Internal.Function3<T10, T11, T12, R>>;
        apply(arg0: T1, arg1: T2, arg2: T3, arg3: T4, arg4: T5, arg5: T6, arg6: T7, arg7: T8, arg8: T9, arg9: T10, arg10: T11, arg11: T12): R;
        curry7(): Internal.Function7<T1, T2, T3, T4, T5, T6, T7, Internal.Function5<T8, T9, T10, T11, T12, R>>;
        curry8(): Internal.Function8<T1, T2, T3, T4, T5, T6, T7, T8, Internal.Function4<T9, T10, T11, T12, R>>;
        curry5(): Internal.Function5<T1, T2, T3, T4, T5, Internal.Function7<T6, T7, T8, T9, T10, T11, T12, R>>;
        curry6(): Internal.Function6<T1, T2, T3, T4, T5, T6, Internal.Function6<T7, T8, T9, T10, T11, T12, R>>;
        curry3(): Internal.Function3<T1, T2, T3, Internal.Function9<T4, T5, T6, T7, T8, T9, T10, T11, T12, R>>;
        curry10(): Internal.Function10<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, Internal.BiFunction<T11, T12, R>>;
        curry4(): Internal.Function4<T1, T2, T3, T4, Internal.Function8<T5, T6, T7, T8, T9, T10, T11, T12, R>>;
        curry11(): Internal.Function11<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, java_.util.function_.Function<T12, R>>;
        curry2(): Internal.BiFunction<T1, T2, Internal.Function10<T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, R>>;
        curry(): java_.util.function_.Function<T1, Internal.Function11<T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, R>>;
    }
    type Function12_<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, R> = Function12<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, R>;
    abstract class Direction$Axis extends Internal.Enum<Internal.Direction$Axis> implements Internal.StringRepresentable, Internal.Predicate<Internal.Direction> {
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        or(arg0: Internal.Predicate_<Internal.Direction_>): Internal.Predicate<Internal.Direction>;
        test(arg0: Internal.Direction_): boolean;
        static valueOf(arg0: string): Internal.Direction$Axis;
        static valueOf<T_>(arg0: Internal.Class_<T_>, arg1: string): T_;
        notifyAll(): void;
        static values(): Internal.Direction$Axis[];
        compareTo(arg0: Internal.Direction$Axis_): number;
        describeConstable(): Internal.Optional<Internal.Enum$EnumDesc<Internal.Direction$Axis>>;
        notify(): void;
        getDeclaringClass(): Internal.Class<Internal.Direction$Axis>;
        and(arg0: Internal.Predicate_<Internal.Direction_>): Internal.Predicate<Internal.Direction>;
        negate(): Internal.Predicate<Internal.Direction>;
        hashCode(): number;
        equals(arg0: any): boolean;
        name(): string;
        toString(): string;
        ordinal(): number;
        static readonly X : Internal.Direction$Axis;
        static readonly Y : Internal.Direction$Axis;
        static readonly Z : Internal.Direction$Axis;
        get class(): Internal.Class<any>;
        get declaringClass(): Internal.Class<Internal.Direction$Axis>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    type Direction$Axis_ = "x" | "y" | "z" | Direction$Axis;
    abstract class PathfinderMob extends Internal.Mob {
        getClass(): Internal.Class<any>;
        resetDynamicLight(): void;
        getCapability<T_>(arg0: Internal.Capability_<T_>, arg1: Internal.Direction_): Internal.LazyOptional<T_>;
        getCapability<T_>(arg0: Internal.Capability_<T_>): Internal.LazyOptional<T_>;
        captureDrops(arg0: Internal.Collection_<Internal.ItemEntity_>): Internal.Collection<Internal.ItemEntity>;
        captureDrops(): Internal.Collection<Internal.ItemEntity>;
        canBeRiddenInWater(arg0: Internal.Entity_): boolean;
        setCitadelEntityData(arg0: Internal.CompoundTag_): void;
        isDynamicLightEnabled(): boolean;
        changeDimension(arg0: Internal.ServerLevel_, arg1: Internal.ITeleporter_): Internal.Entity;
        serializeNBT(): Internal.CompoundTag;
        invalidateCaps(): void;
        setDynamicLightEnabled(arg0: boolean): void;
        shouldUpdateDynamicLight(): boolean;
        foodEatenKJS(is: Internal.ItemStack_): void;
        revive(): void;
        setVisualScale(arg0: number): void;
        dynamicLightTick(): void;
        getPersistentDataKJS(): Internal.CompoundTag;
        canUpdate(): boolean;
        canUpdate(arg0: boolean): void;
        getDynamicLightY(): number;
        getDynamicLightZ(): number;
        handler$zbj000$curio$canFreeze(arg0: Internal.CallbackInfoReturnable_<any>): void;
        getDynamicLightX(): number;
        areCapsCompatible(arg0: Internal.CapabilityProvider_<Internal.Entity_>): boolean;
        areCapsCompatible(arg0: Internal.CapabilityDispatcher_): boolean;
        redirect$bie002$elytraOverride(arg0: Internal.ItemStack_, arg1: Internal.LivingEntity_): boolean;
        getEyeHeightAccess(arg0: Internal.Pose_, arg1: Internal.EntityDimensions_): number;
        reviveCaps(): void;
        lambdynlights$updateDynamicLight(arg0: Internal.LevelRenderer_): boolean;
        handler$bih000$removed(arg0: Internal.CallbackInfo_): void;
        canRiderInteract(): boolean;
        lambdynlights$scheduleTrackedChunksRebuild(arg0: Internal.LevelRenderer_): void;
        handler$bih001$onTick(arg0: Internal.CallbackInfo_): void;
        onAddedToWorld(): void;
        canTrample(arg0: Internal.BlockState_, arg1: BlockPos_, arg2: number): boolean;
        getCitadelEntityData(): Internal.CompoundTag;
        getClassification(arg0: boolean): Internal.MobCategory;
        handler$bih000$onRemove(arg0: Internal.CallbackInfo_): void;
        shouldRiderSit(): boolean;
        getPickedResult(arg0: Internal.HitResult_): Internal.ItemStack;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        notifyAll(): void;
        isActuallyReallyBlocking(): boolean;
        getPersistentData(): Internal.CompoundTag;
        notify(): void;
        redirect$bie000$eytraValidOverride(arg0: Internal.ItemStack_, arg1: Internal.LivingEntity_, arg2: number): boolean;
        hashCode(): number;
        setDimension(arg0: Internal.EntityDimensions_): void;
        isAddedToWorld(): boolean;
        getParts(): any[];
        getDynamicLightWorld(): Internal.Level;
        onRemovedFromWorld(): void;
        getLuminance(): number;
        isMultipartEntity(): boolean;
        deserializeNBT(arg0: Internal.CompoundTag_): void;
        curePotionEffects(arg0: Internal.ItemStack_): boolean;
        asKJS(): any;
        shouldRiderFaceForward(arg0: Internal.Player_): boolean;
        equals(arg0: any): boolean;
        toString(): string;
        getVisualScale(): number;
        get luminance(): number;
        get dynamicLightEnabled(): boolean;
        get citadelEntityData(): Internal.CompoundTag;
        get persistentData(): Internal.CompoundTag;
        get multipartEntity(): boolean;
        get addedToWorld(): boolean;
        get dynamicLightY(): number;
        get dynamicLightZ(): number;
        get dynamicLightX(): number;
        get visualScale(): number;
        get persistentDataKJS(): Internal.CompoundTag;
        get actuallyReallyBlocking(): boolean;
        get parts(): any[];
        get class(): Internal.Class<any>;
        get dynamicLightWorld(): Internal.Level;
        set dynamicLightEnabled(arg0: boolean);
        set visualScale(arg0: number);
        set citadelEntityData(arg0: Internal.CompoundTag_);
        set dimension(arg0: Internal.EntityDimensions_);
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    type PathfinderMob_ = PathfinderMob;
    class MobCategory extends Internal.Enum<Internal.MobCategory> implements Internal.StringRepresentable, Internal.IExtensibleEnum {
        getClass(): Internal.Class<any>;
        init(): void;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        static valueOf(arg0: string): Internal.MobCategory;
        static valueOf<T_>(arg0: Internal.Class_<T_>, arg1: string): T_;
        notifyAll(): void;
        static values(): Internal.MobCategory[];
        compareTo(arg0: Internal.MobCategory_): number;
        describeConstable(): Internal.Optional<Internal.Enum$EnumDesc<Internal.MobCategory>>;
        notify(): void;
        getDeclaringClass(): Internal.Class<Internal.MobCategory>;
        hashCode(): number;
        equals(arg0: any): boolean;
        name(): string;
        static create(arg0: string, arg1: string, arg2: number, arg3: boolean, arg4: boolean, arg5: number): Internal.MobCategory;
        toString(): string;
        ordinal(): number;
        static readonly UNDERGROUND_WATER_CREATURE : Internal.MobCategory;
        static readonly WATER_CREATURE : Internal.MobCategory;
        static readonly WATER_AMBIENT : Internal.MobCategory;
        static readonly AXOLOTLS : Internal.MobCategory;
        static readonly AMBIENT : Internal.MobCategory;
        static readonly CREATURE : Internal.MobCategory;
        static readonly MISC : Internal.MobCategory;
        static readonly MONSTER : Internal.MobCategory;
        get class(): Internal.Class<any>;
        get declaringClass(): Internal.Class<Internal.MobCategory>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    type MobCategory_ = "eitd_eyes" | "water_creature" | "underground_water_creature" | "ambient" | "axolotls" | "creature" | "water_ambient" | "monster" | "misc" | MobCategory;
    abstract class LineMetrics {
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        getUnderlineThickness(): number;
        getBaselineOffsets(): number[];
        notifyAll(): void;
        notify(): void;
        getBaselineIndex(): number;
        getAscent(): number;
        getStrikethroughOffset(): number;
        getHeight(): number;
        hashCode(): number;
        equals(arg0: any): boolean;
        getStrikethroughThickness(): number;
        getNumChars(): number;
        toString(): string;
        getUnderlineOffset(): number;
        getDescent(): number;
        getLeading(): number;
        get strikethroughThickness(): number;
        get descent(): number;
        get ascent(): number;
        get leading(): number;
        get underlineThickness(): number;
        get strikethroughOffset(): number;
        get baselineOffsets(): number[];
        get baselineIndex(): number;
        get numChars(): number;
        get class(): Internal.Class<any>;
        get height(): number;
        get underlineOffset(): number;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    type LineMetrics_ = LineMetrics;
    interface ClipboardOwner {
        lostOwnership(arg0: Internal.Clipboard_, arg1: Internal.Transferable_): void;
    }
    type ClipboardOwner_ = ClipboardOwner;
    class PacketFlow extends Internal.Enum<Internal.PacketFlow> {
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        static valueOf(arg0: string): Internal.PacketFlow;
        static valueOf<T_>(arg0: Internal.Class_<T_>, arg1: string): T_;
        notifyAll(): void;
        static values(): Internal.PacketFlow[];
        compareTo(arg0: Internal.PacketFlow_): number;
        describeConstable(): Internal.Optional<Internal.Enum$EnumDesc<Internal.PacketFlow>>;
        notify(): void;
        getDeclaringClass(): Internal.Class<Internal.PacketFlow>;
        hashCode(): number;
        equals(arg0: any): boolean;
        name(): string;
        toString(): string;
        ordinal(): number;
        static readonly CLIENTBOUND : Internal.PacketFlow;
        static readonly SERVERBOUND : Internal.PacketFlow;
        get class(): Internal.Class<any>;
        get declaringClass(): Internal.Class<Internal.PacketFlow>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    type PacketFlow_ = "serverbound" | "clientbound" | PacketFlow;
    class ZoneOffset extends Internal.ZoneId implements Internal.TemporalAccessor, Internal.TemporalAdjuster, Internal.Comparable<Internal.ZoneOffset>, Internal.Serializable {
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        normalized(): Internal.ZoneId;
        notifyAll(): void;
        adjustInto(arg0: Internal.Temporal_): Internal.Temporal;
        range(arg0: Internal.TemporalField_): Internal.ValueRange;
        getId(): string;
        compareTo(arg0: Internal.ZoneOffset_): number;
        notify(): void;
        static systemDefault(): Internal.ZoneId;
        static getAvailableZoneIds(): Internal.Set<string>;
        hashCode(): number;
        static of(arg0: string): Internal.ZoneOffset;
        static of(arg0: string): Internal.ZoneId;
        static of(arg0: string, arg1: Internal.Map_<string, string>): Internal.ZoneId;
        get(arg0: Internal.TemporalField_): number;
        static from(arg0: Internal.TemporalAccessor_): Internal.ZoneOffset;
        static from(arg0: Internal.TemporalAccessor_): Internal.ZoneId;
        getRules(): Internal.ZoneRules;
        getTotalSeconds(): number;
        static ofHoursMinutes(arg0: number, arg1: number): Internal.ZoneOffset;
        query<R_>(arg0: Internal.TemporalQuery_<R_>): R_;
        isSupported(arg0: Internal.TemporalField_): boolean;
        static ofOffset(arg0: string, arg1: Internal.ZoneOffset_): Internal.ZoneId;
        getLong(arg0: Internal.TemporalField_): number;
        static ofHours(arg0: number): Internal.ZoneOffset;
        getDisplayName(arg0: Internal.TextStyle_, arg1: Internal.Locale_): string;
        equals(arg0: any): boolean;
        toString(): string;
        static ofHoursMinutesSeconds(arg0: number, arg1: number, arg2: number): Internal.ZoneOffset;
        static ofTotalSeconds(arg0: number): Internal.ZoneOffset;
        static readonly MIN : Internal.ZoneOffset;
        static readonly UTC : Internal.ZoneOffset;
        static readonly MAX : Internal.ZoneOffset;
        static readonly SHORT_IDS : {"EAT":"Africa/Addis_Ababa","EST":"-05:00","PNT":"America/Phoenix","PLT":"Asia/Karachi","CNT":"America/St_Johns","IET":"America/Indiana/Indianapolis","VST":"Asia/Ho_Chi_Minh","JST":"Asia/Tokyo","ART":"Africa/Cairo","PST":"America/Los_Angeles","BET":"America/Sao_Paulo","MIT":"Pacific/Apia","CAT":"Africa/Harare","AGT":"America/Argentina/Buenos_Aires","NET":"Asia/Yerevan","CST":"America/Chicago","IST":"Asia/Kolkata","AET":"Australia/Sydney","BST":"Asia/Dhaka","ACT":"Australia/Darwin","HST":"-10:00","NST":"Pacific/Auckland","AST":"America/Anchorage","MST":"-07:00","SST":"Pacific/Guadalcanal","CTT":"Asia/Shanghai","PRT":"America/Puerto_Rico","ECT":"Europe/Paris"};
        get availableZoneIds(): Internal.Set<string>;
        get totalSeconds(): number;
        get rules(): Internal.ZoneRules;
        get id(): string;
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    type ZoneOffset_ = ZoneOffset;
    abstract class ConfigFromString <T> extends Internal.ConfigValue<T> {
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        getName(): string;
        setCanEdit(e: boolean): Internal.ConfigValue<Internal.ConfigValue<Internal.ConfigValue<T>>>;
        notifyAll(): void;
        isEqual(v1: Internal.ConfigValue_<Internal.ConfigValue_<T>>, v2: Internal.ConfigValue_<Internal.ConfigValue_<T>>): boolean;
        compareTo(o: Internal.ConfigValue_<Internal.ConfigValue_<Internal.ConfigValue_<T>>>): number;
        notify(): void;
        getCanEdit(): boolean;
        getStringFromValue(v: Internal.ConfigValue_<Internal.ConfigValue_<T>>): string;
        getTooltip(): string;
        hashCode(): number;
        getStringForGUI(v: Internal.ConfigValue_<Internal.ConfigValue_<T>>): Internal.Component;
        getPath(): string;
        copy(value: Internal.ConfigValue_<Internal.ConfigValue_<T>>): Internal.ConfigValue<Internal.ConfigValue<T>>;
        static info(key: string, value: any): Internal.Component;
        init(g: Internal.ConfigGroup_, i: string, v: Internal.ConfigValue_<Internal.ConfigValue_<T>>, c: Internal.Consumer_<Internal.ConfigValue_<Internal.ConfigValue_<T>>>, def: Internal.ConfigValue_<Internal.ConfigValue_<T>>): Internal.ConfigValue<Internal.ConfigValue<Internal.ConfigValue<T>>>;
        getColor(v: Internal.ConfigValue_<Internal.ConfigValue_<T>>): Internal.Color4I;
        addInfo(list: Internal.TooltipList_): void;
        parse(arg0: Internal.Consumer_<Internal.ConfigValue_<Internal.ConfigValue_<T>>>, arg1: string): boolean;
        getIcon(v: Internal.ConfigValue_<Internal.ConfigValue_<T>>): Internal.Icon;
        setIcon(i: Internal.Icon_): Internal.ConfigValue<Internal.ConfigValue<Internal.ConfigValue<T>>>;
        setOrder(o: number): Internal.ConfigValue<Internal.ConfigValue<Internal.ConfigValue<T>>>;
        getNameKey(): string;
        setNameKey(key: string): Internal.ConfigValue<Internal.ConfigValue<Internal.ConfigValue<T>>>;
        equals(arg0: any): boolean;
        onClicked(button: Internal.MouseButton_, callback: Internal.ConfigCallback_): void;
        toString(): string;
        setCurrentValue(v: Internal.ConfigValue_<Internal.ConfigValue_<T>>): boolean;
        defaultValue : Internal.ConfigValue<Internal.ConfigValue<T>>;
        id : string;
        static readonly NULL_TEXT : Internal.TextComponent;
        setter : ((arg0: Internal.ConfigValue<Internal.ConfigValue<T>>) => void);
        value : Internal.ConfigValue<Internal.ConfigValue<T>>;
        group : Internal.ConfigGroup;
        get path(): string;
        get nameKey(): string;
        get canEdit(): boolean;
        get name(): string;
        get tooltip(): string;
        get class(): Internal.Class<any>;
        set nameKey(key: string);
        set canEdit(e: boolean);
        set icon(i: Internal.Icon_);
        set currentValue(v: Internal.ConfigValue_<Internal.ConfigValue_<T>>);
        set order(o: number);
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    type ConfigFromString_<T> = ConfigFromString<T>;
    abstract class Task extends Internal.QuestObject {
        getClass(): Internal.Class<any>;
        autoSubmitOnPlayerTick(): number;
        getMutableTitle(): Internal.MutableComponent;
        getTags(): Internal.Set<string>;
        submitTask(teamData: Internal.TeamData_, player: Internal.ServerPlayer_): void;
        submitTask(teamData: Internal.TeamData_, player: Internal.ServerPlayer_, craftedItem: Internal.ItemStack_): void;
        static getCodeString(object: Internal.QuestObjectBase_): string;
        getCodeString(): string;
        static getCodeString(id: number): string;
        writeData(nbt: Internal.CompoundTag_): void;
        editedFromGUIOnServer(): void;
        createSubGroup(group: Internal.ConfigGroup_): Internal.ConfigGroup;
        forceProgress(teamData: Internal.TeamData_, progressChange: Internal.ProgressChange_): void;
        isCompletedRaw(data: Internal.TeamData_): boolean;
        getTitle(): Internal.Component;
        submitItemsOnInventoryChange(): boolean;
        getPath(): string;
        clearCachedData(): void;
        static parseCodeString(id: string): number;
        readData(nbt: Internal.CompoundTag_): void;
        editedFromGUI(): void;
        hasTag(tag: string): boolean;
        onCompleted(data: Internal.QuestProgressEventData_<any>): void;
        static getID(object: Internal.QuestObjectBase_): number;
        isVisible(data: Internal.TeamData_): boolean;
        formatMaxProgress(): string;
        onEditButtonClicked(gui: Internal.Runnable_): void;
        getChildren(): Internal.Collection<Internal.QuestObject>;
        addMouseOverText(list: Internal.TooltipList_, teamData: Internal.TeamData_): void;
        onStarted(data: Internal.QuestProgressEventData_<any>): void;
        getIngredient(): any;
        getAltTitle(): Internal.Component;
        getType(): Internal.TaskType;
        onButtonClicked(button: Internal.Button_, canClick: boolean): void;
        getMaxProgress(): number;
        consumesResources(): boolean;
        deleteSelf(): void;
        cacheProgress(): boolean;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        addTitleInMouseOverText(): boolean;
        readNetData(buffer: Internal.FriendlyByteBuf_): void;
        deleteChildren(): void;
        notifyAll(): void;
        notify(): void;
        drawGUI(teamData: Internal.TeamData_, matrixStack: Internal.PoseStack_, x: number, y: number, w: number, h: number): void;
        getRelativeProgressFromChildren(data: Internal.TeamData_): number;
        static getRelativeProgressFromChildren(progressSum: number, count: number): number;
        hashCode(): number;
        getAltIcon(): Internal.Icon;
        getObjectType(): Internal.QuestObjectType;
        hasUnclaimedRewardsRaw(teamData: Internal.TeamData_, player: Internal.UUID_): boolean;
        getParentID(): number;
        getProgressColor(data: Internal.TeamData_, dim: boolean): Internal.Color4I;
        getProgressColor(data: Internal.TeamData_): Internal.Color4I;
        refreshJEI(): number;
        getQuestChapter(): Internal.Chapter;
        getButtonText(): Internal.MutableComponent;
        getQuestFile(): Internal.QuestFile;
        formatProgress(teamData: Internal.TeamData_, progress: number): string;
        checkOnLogin(): boolean;
        writeNetData(buffer: Internal.FriendlyByteBuf_): void;
        getConfig(config: Internal.ConfigGroup_): void;
        getIcon(): Internal.Icon;
        forceProgressRaw(teamData: Internal.TeamData_, progressChange: Internal.ProgressChange_): void;
        static isNull(object: Internal.QuestObjectBase_): boolean;
        equals(object: any): boolean;
        toString(): string;
        static titleToID(s: string): Internal.Optional<string>;
        onCreated(): void;
        canInsertItem(): boolean;
        hideProgressNumbers(): boolean;
        disableToast : boolean;
        invalid : boolean;
        icon : Internal.ItemStack;
        static sendNotifications : Internal.Tristate;
        id : number;
        title : string;
        readonly quest : Internal.Quest;
        get buttonText(): Internal.MutableComponent;
        get ingredient(): any;
        get codeString(): string;
        get maxProgress(): number;
        get questFile(): Internal.QuestFile;
        get type(): Internal.TaskType;
        get parentID(): number;
        get mutableTitle(): Internal.MutableComponent;
        get tags(): Internal.Set<string>;
        get altIcon(): Internal.Icon;
        get objectType(): Internal.QuestObjectType;
        get path(): string;
        get children(): Internal.Collection<Internal.QuestObject>;
        get altTitle(): Internal.Component;
        get class(): Internal.Class<any>;
        get questChapter(): Internal.Chapter;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    type Task_ = Task;
    class ShapelessRecipeJS extends Internal.RecipeJS {
        parseResultItemList(o: any): Internal.List<Internal.ItemStackJS>;
        getClass(): Internal.Class<any>;
        ingredientAction(filter: Internal.IngredientActionFilter_, action: Internal.IngredientAction_): Internal.RecipeJS;
        convertReplacedInput(index: number, oldIngredient: Internal.IngredientJS_, newIngredient: Internal.IngredientJS_): Internal.IngredientJS;
        getUniqueId(): string;
        replaceOutput(i: Internal.IngredientJS_, with_: Internal.ItemStackJS_, exact: boolean): boolean;
        replaceOutput(i: Internal.IngredientJS_, with_: Internal.ItemStackJS_, exact: boolean, func: Internal.BiFunction_<Internal.ItemStackJS_, Internal.ItemStackJS_, Internal.ItemStackJS_>): boolean;
        parseIngredientItemList(o: any): Internal.List<Internal.IngredientJS>;
        merge(data: any): Internal.RecipeJS;
        getPath(): string;
        create(args: Internal.ListJS_): void;
        parseIngredientItemStackList(o: any): Internal.List<Internal.IngredientStackJS>;
        id(_id: ResourceLocation_): Internal.RecipeJS;
        parseIngredientItem(o: any, key: string): Internal.IngredientJS;
        parseIngredientItem(o: any): Internal.IngredientJS;
        group(g: string): Internal.RecipeJS;
        getOriginalRecipeResult(): Internal.ItemStackJS;
        getOriginalRecipeIngredients(): Internal.List<Internal.IngredientJS>;
        getInputIndex(ingredient: Internal.IngredientJS_, exact: boolean): number;
        setGroup(g: string): void;
        serialize(): void;
        replaceInput(i: Internal.IngredientJS_, with_: Internal.IngredientJS_, exact: boolean, func: Internal.BiFunction_<Internal.IngredientJS_, Internal.IngredientJS_, Internal.IngredientJS_>): boolean;
        replaceInput(i: Internal.IngredientJS_, with_: Internal.IngredientJS_, exact: boolean): boolean;
        getType(): string;
        getGroup(): string;
        hasOutput(ingredient: Internal.IngredientJS_, exact: boolean): boolean;
        keepIngredient(filter: Internal.IngredientActionFilter_): Internal.RecipeJS;
        customIngredientAction(filter: Internal.IngredientActionFilter_, id: string): Internal.RecipeJS;
        modifyResult(callback: Internal.ModifyRecipeResultCallback_): Internal.RecipeJS;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        getMod(): string;
        notifyAll(): void;
        convertReplacedOutput(index: number, oldStack: Internal.ItemStackJS_, newStack: Internal.ItemStackJS_): Internal.ItemStackJS;
        save(): void;
        damageIngredient(filter: Internal.IngredientActionFilter_): Internal.RecipeJS;
        damageIngredient(filter: Internal.IngredientActionFilter_, damage: number): Internal.RecipeJS;
        getId(): string;
        dontAdd(): void;
        notify(): void;
        serializeJson(): void;
        createRecipe(): Internal.Recipe<any>;
        getFromToString(): string;
        hashCode(): number;
        deserializeJson(): void;
        getOrCreateId(): ResourceLocation;
        deserialize(): void;
        serializeNBTAsJson(): boolean;
        getOutputIndex(ingredient: Internal.IngredientJS_, exact: boolean): number;
        serializeIngredientStack(in_: Internal.IngredientStackJS_): Internal.JsonElement;
        resultFromRecipeJson(json: Internal.JsonObject_): Internal.ItemStackJS;
        stage(s: string): Internal.RecipeJS;
        equals(arg0: any): boolean;
        serializeItemStack(stack: Internal.ItemStackJS_): Internal.JsonElement;
        toString(): string;
        hasInput(ingredient: Internal.IngredientJS_, exact: boolean): boolean;
        parseResultItem(o: any): Internal.ItemStackJS;
        replaceIngredient(filter: Internal.IngredientActionFilter_, item: Internal.ItemStackJS_): Internal.RecipeJS;
        static currentRecipe : Internal.RecipeJS;
        originalJson : Internal.JsonObject;
        serializeOutputs : boolean;
        originalRecipe : Internal.Recipe<any>;
        readonly inputItems : Internal.List<((arg0: Internal.ItemStackJS) => boolean)>;
        static itemErrors : false;
        json : Internal.JsonObject;
        readonly outputItems : Internal.List<Internal.ItemStackJS>;
        type : Internal.RecipeTypeJS;
        serializeInputs : boolean;
        get path(): string;
        get originalRecipeIngredients(): Internal.List<Internal.IngredientJS>;
        get mod(): string;
        get originalRecipeResult(): Internal.ItemStackJS;
        get orCreateId(): ResourceLocation;
        get class(): Internal.Class<any>;
        get fromToString(): string;
        get uniqueId(): string;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    type ShapelessRecipeJS_ = ShapelessRecipeJS;
    class FilterOutputStream extends Internal.OutputStream {
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        flush(): void;
        hashCode(): number;
        notifyAll(): void;
        equals(arg0: any): boolean;
        toString(): string;
        static nullOutputStream(): Internal.OutputStream;
        close(): void;
        write(arg0: number[], arg1: number, arg2: number): void;
        write(arg0: number[]): void;
        write(arg0: number): void;
        notify(): void;
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    type FilterOutputStream_ = FilterOutputStream;
    class ServerPlayerDataJS extends Internal.PlayerDataJS<Internal.ServerPlayer, Internal.ServerPlayerJS> {
        getServer(): Internal.ServerJS;
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        getPlayer(): Internal.ServerPlayerJS;
        getName(): string;
        notifyAll(): void;
        getProfile(): Internal.GameProfile;
        getId(): Internal.UUID;
        getOverworld(): Internal.LevelJS;
        notify(): void;
        getMinecraftPlayer(): Internal.ServerPlayer;
        hashCode(): number;
        equals(arg0: any): boolean;
        hasClientMod(): boolean;
        toString(): string;
        getData(): Internal.AttachedData;
        get server(): Internal.ServerJS;
        get data(): Internal.AttachedData;
        get minecraftPlayer(): Internal.ServerPlayer;
        get profile(): Internal.GameProfile;
        get name(): string;
        get id(): Internal.UUID;
        get overworld(): Internal.LevelJS;
        get class(): Internal.Class<any>;
        get player(): Internal.ServerPlayerJS;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    type ServerPlayerDataJS_ = ServerPlayerDataJS;
    abstract class MethodHandle implements Internal.Constable {
        asCollector(arg0: number, arg1: Internal.Class_<any>, arg2: number): Internal.MethodHandle;
        asCollector(arg0: Internal.Class_<any>, arg1: number): Internal.MethodHandle;
        asSpreader(arg0: Internal.Class_<any>, arg1: number): Internal.MethodHandle;
        asSpreader(arg0: number, arg1: Internal.Class_<any>, arg2: number): Internal.MethodHandle;
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        withVarargs(arg0: boolean): Internal.MethodHandle;
        invokeExact(arg0: any[]): any;
        notifyAll(): void;
        invoke(arg0: any[]): any;
        type(): Internal.MethodType;
        describeConstable(): Internal.Optional<Internal.MethodHandleDesc>;
        notify(): void;
        bindTo(arg0: any): Internal.MethodHandle;
        asVarargsCollector(arg0: Internal.Class_<any>): Internal.MethodHandle;
        asType(arg0: Internal.MethodType_): Internal.MethodHandle;
        invokeWithArguments(arg0: any[]): any;
        invokeWithArguments(arg0: Internal.List_<any>): any;
        hashCode(): number;
        equals(arg0: any): boolean;
        isVarargsCollector(): boolean;
        asFixedArity(): Internal.MethodHandle;
        toString(): string;
        get varargsCollector(): boolean;
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    type MethodHandle_ = MethodHandle;
    class Vector3d {
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        hashCode(): number;
        notifyAll(): void;
        equals(arg0: any): boolean;
        toString(): string;
        notify(): void;
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    type Vector3d_ = Vector3d;
    abstract class Record {
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        hashCode(): number;
        notifyAll(): void;
        equals(arg0: any): boolean;
        toString(): string;
        notify(): void;
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    type Record_ = Record;
    class ItemColors implements Internal.ItemColorsExtended {
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        getColorProvider(stack: Internal.ItemStack_): Internal.ItemColor;
        hashCode(): number;
        notifyAll(): void;
        equals(arg0: any): boolean;
        toString(): string;
        notify(): void;
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    type ItemColors_ = ItemColors;
    interface Long2FloatFunction extends Internal.Function<number, number>, Internal.LongToDoubleFunction {
        getOrDefault(arg0: any, arg1: number): number;
        getOrDefault(arg0: number, arg1: number): number;
        applyAsDouble(arg0: number): number;
        andThenShort(arg0: Internal.Float2ShortFunction_): Internal.Long2ShortFunction;
        composeByte(arg0: Internal.Byte2LongFunction_): Internal.Byte2FloatFunction;
        andThenInt(arg0: Internal.Float2IntFunction_): Internal.Long2IntFunction;
        composeReference<T_>(arg0: Internal.Reference2LongFunction_<T_>): Internal.Reference2FloatFunction<T_>;
        andThen<T_>(arg0: java_.util.function_.Function_<number, T_>): java_.util.function_.Function<number, T_>;
        put(arg0: number, arg1: number): number;
        remove(arg0: number): number;
        remove(arg0: any): number;
        defaultReturnValue(): number;
        defaultReturnValue(arg0: number): void;
        andThenDouble(arg0: Internal.Float2DoubleFunction_): Internal.Long2DoubleFunction;
        andThenObject<T_>(arg0: Internal.Float2ObjectFunction_<T_>): Internal.Long2ObjectFunction<T_>;
        get(arg0: any): number;
        get(arg0: number): number;
        andThenLong(arg0: Internal.Float2LongFunction_): Internal.Long2LongFunction;
        composeLong(arg0: Internal.Long2LongFunction_): Internal.Long2FloatFunction;
        andThenByte(arg0: Internal.Float2ByteFunction_): Internal.Long2ByteFunction;
        andThenFloat(arg0: Internal.Float2FloatFunction_): Internal.Long2FloatFunction;
        apply(arg0: number): number;
        containsKey(arg0: any): boolean;
        containsKey(arg0: number): boolean;
        composeInt(arg0: Internal.Int2LongFunction_): Internal.Int2FloatFunction;
        clear(): void;
        composeFloat(arg0: Internal.Float2LongFunction_): Internal.Float2FloatFunction;
        andThenChar(arg0: Internal.Float2CharFunction_): Internal.Long2CharFunction;
        composeObject<T_>(arg0: Internal.Object2LongFunction_<T_>): Internal.Object2FloatFunction<T_>;
        size(): number;
        compose<T_>(arg0: java_.util.function_.Function_<T_, number>): java_.util.function_.Function<T_, number>;
        composeShort(arg0: Internal.Short2LongFunction_): Internal.Short2FloatFunction;
        andThenReference<T_>(arg0: Internal.Float2ReferenceFunction_<T_>): Internal.Long2ReferenceFunction<T_>;
        composeChar(arg0: Internal.Char2LongFunction_): Internal.Char2FloatFunction;
        composeDouble(arg0: Internal.Double2LongFunction_): Internal.Double2FloatFunction;
    }
    type Long2FloatFunction_ = ((arg0: number) => number) | Long2FloatFunction;
    class ServerSettings {
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        hashCode(): number;
        notifyAll(): void;
        equals(arg0: any): boolean;
        toString(): string;
        notify(): void;
        static exportData(): void;
        logInvalidRecipeHandlers : boolean;
        useOriginalRecipeForFilters : boolean;
        dataPackOutput : boolean;
        logSkippedRecipes : boolean;
        static instance : Internal.ServerSettings;
        logOverrides : boolean;
        logErroringRecipes : boolean;
        logAddedRecipes : boolean;
        logRemovedRecipes : boolean;
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    type ServerSettings_ = ServerSettings;
    abstract class SimpleJsonResourceReloadListener extends Internal.SimplePreparableReloadListener<Internal.Map<ResourceLocation, Internal.JsonElement>> implements Internal.JsonReloadListenerAccess {
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        hashCode(): number;
        notifyAll(): void;
        equals(arg0: any): boolean;
        toString(): string;
        notify(): void;
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    type SimpleJsonResourceReloadListener_ = SimpleJsonResourceReloadListener;
    interface INBTSerializable <T> {
        serializeNBT(): T;
        deserializeNBT(arg0: T): void;
    }
    type INBTSerializable_<T> = INBTSerializable<T>;
    interface ChannelProgressivePromise extends Internal.ProgressivePromise<void>, Internal.ChannelProgressiveFuture, Internal.ChannelPromise {
        cancel(arg0: boolean): boolean;
        unvoid(): Internal.ChannelProgressivePromise;
        unvoid(): Internal.ChannelPromise;
        channel(): io.netty.channel.Channel;
        setProgress(arg0: number, arg1: number): Internal.ChannelProgressivePromise;
        setProgress(arg0: number, arg1: number): Internal.ProgressivePromise<void>;
        cause(): Internal.Throwable;
        awaitUninterruptibly(): Internal.ChannelProgressivePromise;
        awaitUninterruptibly(): Internal.ProgressivePromise<void>;
        awaitUninterruptibly(): Internal.Promise<void>;
        awaitUninterruptibly(): io.netty.util.concurrent.Future<void>;
        awaitUninterruptibly(): Internal.ProgressiveFuture<void>;
        awaitUninterruptibly(): Internal.ChannelProgressiveFuture;
        awaitUninterruptibly(): Internal.ChannelFuture;
        awaitUninterruptibly(): Internal.ChannelPromise;
        awaitUninterruptibly(arg0: number, arg1: Internal.TimeUnit_): boolean;
        awaitUninterruptibly(arg0: number): boolean;
        trySuccess(arg0: void): boolean;
        trySuccess(): boolean;
        tryProgress(arg0: number, arg1: number): boolean;
        syncUninterruptibly(): Internal.ChannelProgressivePromise;
        syncUninterruptibly(): Internal.ProgressivePromise<void>;
        syncUninterruptibly(): Internal.Promise<void>;
        syncUninterruptibly(): io.netty.util.concurrent.Future<void>;
        syncUninterruptibly(): Internal.ProgressiveFuture<void>;
        syncUninterruptibly(): Internal.ChannelProgressiveFuture;
        syncUninterruptibly(): Internal.ChannelFuture;
        syncUninterruptibly(): Internal.ChannelPromise;
        get(arg0: number, arg1: Internal.TimeUnit_): void;
        get(): void;
        await(): Internal.ChannelProgressivePromise;
        await(): Internal.ProgressivePromise<void>;
        await(): Internal.Promise<void>;
        await(): io.netty.util.concurrent.Future<void>;
        await(): Internal.ProgressiveFuture<void>;
        await(): Internal.ChannelProgressiveFuture;
        await(): Internal.ChannelFuture;
        await(): Internal.ChannelPromise;
        await(arg0: number, arg1: Internal.TimeUnit_): boolean;
        await(arg0: number): boolean;
        isSuccess(): boolean;
        addListener(arg0: Internal.GenericFutureListener_<io.netty.util.concurrent.Future_<void>>): Internal.ChannelProgressivePromise;
        addListener(arg0: Internal.GenericFutureListener_<io.netty.util.concurrent.Future_<void>>): Internal.ProgressivePromise<void>;
        addListener(arg0: Internal.GenericFutureListener_<io.netty.util.concurrent.Future_<void>>): Internal.Promise<void>;
        addListener(arg0: Internal.GenericFutureListener_<io.netty.util.concurrent.Future_<void>>): io.netty.util.concurrent.Future<void>;
        addListener(arg0: Internal.GenericFutureListener_<io.netty.util.concurrent.Future_<void>>): Internal.ProgressiveFuture<void>;
        addListener(arg0: Internal.GenericFutureListener_<io.netty.util.concurrent.Future_<void>>): Internal.ChannelProgressiveFuture;
        addListener(arg0: Internal.GenericFutureListener_<io.netty.util.concurrent.Future_<void>>): Internal.ChannelFuture;
        addListener(arg0: Internal.GenericFutureListener_<io.netty.util.concurrent.Future_<void>>): Internal.ChannelPromise;
        isCancelled(): boolean;
        removeListeners(arg0: Internal.GenericFutureListener_<io.netty.util.concurrent.Future_<void>>[]): Internal.ChannelProgressivePromise;
        removeListeners(arg0: Internal.GenericFutureListener_<io.netty.util.concurrent.Future_<void>>[]): Internal.ProgressivePromise<void>;
        removeListeners(arg0: Internal.GenericFutureListener_<io.netty.util.concurrent.Future_<void>>[]): Internal.Promise<void>;
        removeListeners(arg0: Internal.GenericFutureListener_<io.netty.util.concurrent.Future_<void>>[]): io.netty.util.concurrent.Future<void>;
        removeListeners(arg0: Internal.GenericFutureListener_<io.netty.util.concurrent.Future_<void>>[]): Internal.ProgressiveFuture<void>;
        removeListeners(arg0: Internal.GenericFutureListener_<io.netty.util.concurrent.Future_<void>>[]): Internal.ChannelProgressiveFuture;
        removeListeners(arg0: Internal.GenericFutureListener_<io.netty.util.concurrent.Future_<void>>[]): Internal.ChannelFuture;
        removeListeners(arg0: Internal.GenericFutureListener_<io.netty.util.concurrent.Future_<void>>[]): Internal.ChannelPromise;
        getNow(): void;
        removeListener(arg0: Internal.GenericFutureListener_<io.netty.util.concurrent.Future_<void>>): Internal.ChannelProgressivePromise;
        removeListener(arg0: Internal.GenericFutureListener_<io.netty.util.concurrent.Future_<void>>): Internal.ProgressivePromise<void>;
        removeListener(arg0: Internal.GenericFutureListener_<io.netty.util.concurrent.Future_<void>>): Internal.Promise<void>;
        removeListener(arg0: Internal.GenericFutureListener_<io.netty.util.concurrent.Future_<void>>): io.netty.util.concurrent.Future<void>;
        removeListener(arg0: Internal.GenericFutureListener_<io.netty.util.concurrent.Future_<void>>): Internal.ProgressiveFuture<void>;
        removeListener(arg0: Internal.GenericFutureListener_<io.netty.util.concurrent.Future_<void>>): Internal.ChannelProgressiveFuture;
        removeListener(arg0: Internal.GenericFutureListener_<io.netty.util.concurrent.Future_<void>>): Internal.ChannelFuture;
        removeListener(arg0: Internal.GenericFutureListener_<io.netty.util.concurrent.Future_<void>>): Internal.ChannelPromise;
        tryFailure(arg0: Internal.Throwable_): boolean;
        isDone(): boolean;
        sync(): Internal.ChannelProgressivePromise;
        sync(): Internal.ProgressivePromise<void>;
        sync(): Internal.Promise<void>;
        sync(): io.netty.util.concurrent.Future<void>;
        sync(): Internal.ProgressiveFuture<void>;
        sync(): Internal.ChannelProgressiveFuture;
        sync(): Internal.ChannelFuture;
        sync(): Internal.ChannelPromise;
        setSuccess(arg0: void): Internal.ChannelProgressivePromise;
        setSuccess(arg0: void): Internal.ChannelPromise;
        setSuccess(): Internal.ChannelProgressivePromise;
        setSuccess(): Internal.ChannelPromise;
        setSuccess(arg0: void): Internal.ProgressivePromise<void>;
        setSuccess(arg0: void): Internal.Promise<void>;
        setFailure(arg0: Internal.Throwable_): Internal.ChannelProgressivePromise;
        setFailure(arg0: Internal.Throwable_): Internal.ProgressivePromise<void>;
        setFailure(arg0: Internal.Throwable_): Internal.Promise<void>;
        setFailure(arg0: Internal.Throwable_): Internal.ChannelPromise;
        isVoid(): boolean;
        isCancellable(): boolean;
        addListeners(arg0: Internal.GenericFutureListener_<io.netty.util.concurrent.Future_<void>>[]): Internal.ChannelProgressivePromise;
        addListeners(arg0: Internal.GenericFutureListener_<io.netty.util.concurrent.Future_<void>>[]): Internal.ProgressivePromise<void>;
        addListeners(arg0: Internal.GenericFutureListener_<io.netty.util.concurrent.Future_<void>>[]): Internal.Promise<void>;
        addListeners(arg0: Internal.GenericFutureListener_<io.netty.util.concurrent.Future_<void>>[]): io.netty.util.concurrent.Future<void>;
        addListeners(arg0: Internal.GenericFutureListener_<io.netty.util.concurrent.Future_<void>>[]): Internal.ProgressiveFuture<void>;
        addListeners(arg0: Internal.GenericFutureListener_<io.netty.util.concurrent.Future_<void>>[]): Internal.ChannelProgressiveFuture;
        addListeners(arg0: Internal.GenericFutureListener_<io.netty.util.concurrent.Future_<void>>[]): Internal.ChannelFuture;
        addListeners(arg0: Internal.GenericFutureListener_<io.netty.util.concurrent.Future_<void>>[]): Internal.ChannelPromise;
        setUncancellable(): boolean;
    }
    type ChannelProgressivePromise_ = ChannelProgressivePromise;
    class FixedUnit extends dev.latvian.mods.rhino.util.unit.Unit {
        getClass(): Internal.Class<any>;
        mod(with_: dev.latvian.mods.rhino.util.unit.Unit_): dev.latvian.mods.rhino.util.unit.Unit;
        log1p(): dev.latvian.mods.rhino.util.unit.Unit;
        cos(): dev.latvian.mods.rhino.util.unit.Unit;
        deg(): dev.latvian.mods.rhino.util.unit.Unit;
        lt(with_: dev.latvian.mods.rhino.util.unit.Unit_): dev.latvian.mods.rhino.util.unit.Unit;
        atan(): dev.latvian.mods.rhino.util.unit.Unit;
        getAsInt(): number;
        div(with_: dev.latvian.mods.rhino.util.unit.Unit_): dev.latvian.mods.rhino.util.unit.Unit;
        neg(): dev.latvian.mods.rhino.util.unit.Unit;
        shiftLeft(with_: dev.latvian.mods.rhino.util.unit.Unit_): dev.latvian.mods.rhino.util.unit.Unit;
        rad(): dev.latvian.mods.rhino.util.unit.Unit;
        sqrt(): dev.latvian.mods.rhino.util.unit.Unit;
        gte(with_: dev.latvian.mods.rhino.util.unit.Unit_): dev.latvian.mods.rhino.util.unit.Unit;
        neq(with_: dev.latvian.mods.rhino.util.unit.Unit_): dev.latvian.mods.rhino.util.unit.Unit;
        atan2(with_: dev.latvian.mods.rhino.util.unit.Unit_): dev.latvian.mods.rhino.util.unit.Unit;
        tan(): dev.latvian.mods.rhino.util.unit.Unit;
        add(with_: dev.latvian.mods.rhino.util.unit.Unit_): dev.latvian.mods.rhino.util.unit.Unit;
        newValue(v: number): dev.latvian.mods.rhino.util.unit.Unit;
        toBool(): dev.latvian.mods.rhino.util.unit.Unit;
        ceil(): dev.latvian.mods.rhino.util.unit.Unit;
        eq(with_: dev.latvian.mods.rhino.util.unit.Unit_): dev.latvian.mods.rhino.util.unit.Unit;
        shiftRight(with_: dev.latvian.mods.rhino.util.unit.Unit_): dev.latvian.mods.rhino.util.unit.Unit;
        sub(with_: dev.latvian.mods.rhino.util.unit.Unit_): dev.latvian.mods.rhino.util.unit.Unit;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        mul(with_: dev.latvian.mods.rhino.util.unit.Unit_): dev.latvian.mods.rhino.util.unit.Unit;
        log(): dev.latvian.mods.rhino.util.unit.Unit;
        log10(): dev.latvian.mods.rhino.util.unit.Unit;
        notifyAll(): void;
        notify(): void;
        not(): dev.latvian.mods.rhino.util.unit.Unit;
        min(with_: dev.latvian.mods.rhino.util.unit.Unit_): dev.latvian.mods.rhino.util.unit.Unit;
        hashCode(): number;
        and(with_: dev.latvian.mods.rhino.util.unit.Unit_): dev.latvian.mods.rhino.util.unit.Unit;
        static of(value: number): Internal.FixedUnit;
        get(): number;
        pow(with_: dev.latvian.mods.rhino.util.unit.Unit_): dev.latvian.mods.rhino.util.unit.Unit;
        sin(): dev.latvian.mods.rhino.util.unit.Unit;
        xor(with_: dev.latvian.mods.rhino.util.unit.Unit_): dev.latvian.mods.rhino.util.unit.Unit;
        lte(with_: dev.latvian.mods.rhino.util.unit.Unit_): dev.latvian.mods.rhino.util.unit.Unit;
        floor(): dev.latvian.mods.rhino.util.unit.Unit;
        isFixed(): boolean;
        sq(): dev.latvian.mods.rhino.util.unit.Unit;
        or(with_: dev.latvian.mods.rhino.util.unit.Unit_): dev.latvian.mods.rhino.util.unit.Unit;
        max(with_: dev.latvian.mods.rhino.util.unit.Unit_): dev.latvian.mods.rhino.util.unit.Unit;
        gt(with_: dev.latvian.mods.rhino.util.unit.Unit_): dev.latvian.mods.rhino.util.unit.Unit;
        abs(): dev.latvian.mods.rhino.util.unit.Unit;
        getAsBoolean(): boolean;
        equals(arg0: any): boolean;
        toString(): string;
        append(sb: Internal.StringBuilder_): void;
        static readonly ZERO : Internal.FixedUnit;
        static readonly ONE : Internal.FixedUnit;
        static readonly POS_INFINITY : Internal.FixedUnit;
        static readonly NEG_INFINITY : Internal.FixedUnit;
        static readonly NAN : Internal.FixedUnit;
        get asInt(): number;
        get fixed(): boolean;
        get class(): Internal.Class<any>;
        get asBoolean(): boolean;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    type FixedUnit_ = FixedUnit;
    class DayOfWeek extends Internal.Enum<Internal.DayOfWeek> implements Internal.TemporalAccessor, Internal.TemporalAdjuster {
        getClass(): Internal.Class<any>;
        minus(arg0: number): Internal.DayOfWeek;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        notifyAll(): void;
        static values(): Internal.DayOfWeek[];
        adjustInto(arg0: Internal.Temporal_): Internal.Temporal;
        range(arg0: Internal.TemporalField_): Internal.ValueRange;
        compareTo(arg0: Internal.DayOfWeek_): number;
        describeConstable(): Internal.Optional<Internal.Enum$EnumDesc<Internal.DayOfWeek>>;
        notify(): void;
        getDeclaringClass(): Internal.Class<Internal.DayOfWeek>;
        hashCode(): number;
        static of(arg0: number): Internal.DayOfWeek;
        get(arg0: Internal.TemporalField_): number;
        static from(arg0: Internal.TemporalAccessor_): Internal.DayOfWeek;
        static valueOf(arg0: string): Internal.DayOfWeek;
        static valueOf<T_>(arg0: Internal.Class_<T_>, arg1: string): T_;
        query<R_>(arg0: Internal.TemporalQuery_<R_>): R_;
        isSupported(arg0: Internal.TemporalField_): boolean;
        plus(arg0: number): Internal.DayOfWeek;
        getLong(arg0: Internal.TemporalField_): number;
        getValue(): number;
        getDisplayName(arg0: Internal.TextStyle_, arg1: Internal.Locale_): string;
        equals(arg0: any): boolean;
        name(): string;
        toString(): string;
        ordinal(): number;
        static readonly WEDNESDAY : Internal.DayOfWeek;
        static readonly MONDAY : Internal.DayOfWeek;
        static readonly THURSDAY : Internal.DayOfWeek;
        static readonly SUNDAY : Internal.DayOfWeek;
        static readonly TUESDAY : Internal.DayOfWeek;
        static readonly FRIDAY : Internal.DayOfWeek;
        static readonly SATURDAY : Internal.DayOfWeek;
        get class(): Internal.Class<any>;
        get value(): number;
        get declaringClass(): Internal.Class<Internal.DayOfWeek>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    type DayOfWeek_ = "sunday" | "saturday" | "tuesday" | "wednesday" | "thursday" | "friday" | "monday" | DayOfWeek;
    interface EntityGetter {
    }
    type EntityGetter_ = EntityGetter;
    interface Future <V> {
        cancel(arg0: boolean): boolean;
        isCancelled(): boolean;
        get(arg0: number, arg1: Internal.TimeUnit_): V;
        get(): V;
        isDone(): boolean;
    }
    type Future_<V> = Future<V>;
    class Locale$FilteringMode extends Internal.Enum<Internal.Locale$FilteringMode> {
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        static valueOf(arg0: string): Internal.Locale$FilteringMode;
        static valueOf<T_>(arg0: Internal.Class_<T_>, arg1: string): T_;
        notifyAll(): void;
        static values(): Internal.Locale$FilteringMode[];
        compareTo(arg0: Internal.Locale$FilteringMode_): number;
        describeConstable(): Internal.Optional<Internal.Enum$EnumDesc<Internal.Locale$FilteringMode>>;
        notify(): void;
        getDeclaringClass(): Internal.Class<Internal.Locale$FilteringMode>;
        hashCode(): number;
        equals(arg0: any): boolean;
        name(): string;
        toString(): string;
        ordinal(): number;
        static readonly IGNORE_EXTENDED_RANGES : Internal.Locale$FilteringMode;
        static readonly MAP_EXTENDED_RANGES : Internal.Locale$FilteringMode;
        static readonly AUTOSELECT_FILTERING : Internal.Locale$FilteringMode;
        static readonly REJECT_EXTENDED_RANGES : Internal.Locale$FilteringMode;
        static readonly EXTENDED_FILTERING : Internal.Locale$FilteringMode;
        get class(): Internal.Class<any>;
        get declaringClass(): Internal.Class<Internal.Locale$FilteringMode>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    type Locale$FilteringMode_ = "extended_filtering" | "reject_extended_ranges" | "map_extended_ranges" | "ignore_extended_ranges" | "autoselect_filtering" | Locale$FilteringMode;
    interface WatchService extends Internal.Closeable {
        take(): Internal.WatchKey;
        poll(arg0: number, arg1: Internal.TimeUnit_): Internal.WatchKey;
        poll(): Internal.WatchKey;
        close(): void;
    }
    type WatchService_ = WatchService;
    class FlowingFluidBuilder extends Internal.BuilderBase<Internal.Fluid> {
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        clientRegistry(minecraft: Internal.Minecraft_): void;
        generateAssetJsons(generator: Internal.AssetJsonGenerator_): void;
        transformObject(obj: Internal.Fluid_): Internal.Fluid;
        translationKey(key: string): Internal.BuilderBase<Internal.Fluid>;
        getTranslationKeyGroup(): string;
        newID(pre: string, post: string): ResourceLocation;
        displayName(name: string): Internal.BuilderBase<Internal.Fluid>;
        notifyAll(): void;
        generateLang(lang: Internal.Map_<string, string>): void;
        type(type: string): Internal.BuilderBase<Internal.Fluid>;
        notify(): void;
        createAdditionalObjects(): void;
        createObject(): Internal.Fluid;
        addResourcePackLocations(path: string, list: Internal.List_<ResourceLocation_>, packType: Internal.PackType_): void;
        hashCode(): number;
        equals(arg0: any): boolean;
        get(): Internal.Fluid;
        getRegistryType(): Internal.RegistryObjectBuilderTypes<Internal.Fluid>;
        toString(): string;
        tag(tag: ResourceLocation_): Internal.BuilderBase<Internal.Fluid>;
        generateDataJsons(generator: Internal.DataJsonGenerator_): void;
        readonly fluidBuilder : Internal.FluidBuilder;
        readonly id : ResourceLocation;
        get registryType(): Internal.RegistryObjectBuilderTypes<Internal.Fluid>;
        get class(): Internal.Class<any>;
        get translationKeyGroup(): string;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    type FlowingFluidBuilder_ = FlowingFluidBuilder;
    class LootContext$EntityTarget extends Internal.Enum<Internal.LootContext$EntityTarget> implements Internal.EntityTargetKJS {
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        static valueOf(arg0: string): Internal.LootContext$EntityTarget;
        static valueOf<T_>(arg0: Internal.Class_<T_>, arg1: string): T_;
        notifyAll(): void;
        static values(): Internal.LootContext$EntityTarget[];
        compareTo(arg0: Internal.LootContext$EntityTarget_): number;
        describeConstable(): Internal.Optional<Internal.Enum$EnumDesc<Internal.LootContext$EntityTarget>>;
        notify(): void;
        getDeclaringClass(): Internal.Class<Internal.LootContext$EntityTarget>;
        hashCode(): number;
        equals(arg0: any): boolean;
        name(): string;
        toString(): string;
        ordinal(): number;
        static readonly DIRECT_KILLER : Internal.LootContext$EntityTarget;
        static readonly KILLER_PLAYER : Internal.LootContext$EntityTarget;
        static readonly KILLER : Internal.LootContext$EntityTarget;
        static readonly THIS : Internal.LootContext$EntityTarget;
        get class(): Internal.Class<any>;
        get declaringClass(): Internal.Class<Internal.LootContext$EntityTarget>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    type LootContext$EntityTarget_ = "this" | "killer_player" | "killer" | "direct_killer" | LootContext$EntityTarget;
    interface NBTSerializable {
        toNBT(): net.minecraft.nbt.Tag;
    }
    type NBTSerializable_ = NBTSerializable;
    interface WindowFocusListener extends Internal.EventListener {
        windowLostFocus(arg0: Internal.WindowEvent_): void;
        windowGainedFocus(arg0: Internal.WindowEvent_): void;
    }
    type WindowFocusListener_ = WindowFocusListener;
    interface BlockSensitiveBufferBuilder {
        beginBlock(arg0: number, arg1: number): void;
        endBlock(): void;
    }
    type BlockSensitiveBufferBuilder_ = BlockSensitiveBufferBuilder;
    class DirectMethodHandleDesc$Kind extends Internal.Enum<Internal.DirectMethodHandleDesc$Kind> {
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        static valueOf(arg0: number, arg1: boolean): Internal.DirectMethodHandleDesc$Kind;
        static valueOf(arg0: string): Internal.DirectMethodHandleDesc$Kind;
        static valueOf(arg0: number): Internal.DirectMethodHandleDesc$Kind;
        static valueOf<T_>(arg0: Internal.Class_<T_>, arg1: string): T_;
        notifyAll(): void;
        static values(): Internal.DirectMethodHandleDesc$Kind[];
        compareTo(arg0: Internal.DirectMethodHandleDesc$Kind_): number;
        describeConstable(): Internal.Optional<Internal.Enum$EnumDesc<Internal.DirectMethodHandleDesc$Kind>>;
        notify(): void;
        getDeclaringClass(): Internal.Class<Internal.DirectMethodHandleDesc$Kind>;
        hashCode(): number;
        equals(arg0: any): boolean;
        name(): string;
        toString(): string;
        ordinal(): number;
        static readonly INTERFACE_SPECIAL : Internal.DirectMethodHandleDesc$Kind;
        readonly refKind : number;
        static readonly SETTER : Internal.DirectMethodHandleDesc$Kind;
        static readonly SPECIAL : Internal.DirectMethodHandleDesc$Kind;
        static readonly STATIC : Internal.DirectMethodHandleDesc$Kind;
        static readonly GETTER : Internal.DirectMethodHandleDesc$Kind;
        static readonly STATIC_GETTER : Internal.DirectMethodHandleDesc$Kind;
        static readonly INTERFACE_VIRTUAL : Internal.DirectMethodHandleDesc$Kind;
        static readonly STATIC_SETTER : Internal.DirectMethodHandleDesc$Kind;
        static readonly CONSTRUCTOR : Internal.DirectMethodHandleDesc$Kind;
        readonly isInterface : boolean;
        static readonly INTERFACE_STATIC : Internal.DirectMethodHandleDesc$Kind;
        static readonly VIRTUAL : Internal.DirectMethodHandleDesc$Kind;
        get class(): Internal.Class<any>;
        get declaringClass(): Internal.Class<Internal.DirectMethodHandleDesc$Kind>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    type DirectMethodHandleDesc$Kind_ = "special" | "interface_static" | "virtual" | "static_setter" | "static" | "getter" | "static_getter" | "interface_virtual" | "constructor" | "setter" | "interface_special" | DirectMethodHandleDesc$Kind;
    interface MobFilter extends Internal.BiPredicate<Internal.MobCategory, Internal.MobSpawnSettings$SpawnerData> {
        or(arg0: Internal.BiPredicate_<Internal.MobCategory_, Internal.MobSpawnSettings$SpawnerData_>): Internal.BiPredicate<Internal.MobCategory, Internal.MobSpawnSettings$SpawnerData>;
        test(arg0: Internal.MobCategory_, arg1: Internal.MobSpawnSettings$SpawnerData_): boolean;
        and(arg0: Internal.BiPredicate_<Internal.MobCategory_, Internal.MobSpawnSettings$SpawnerData_>): Internal.BiPredicate<Internal.MobCategory, Internal.MobSpawnSettings$SpawnerData>;
        negate(): Internal.BiPredicate<Internal.MobCategory, Internal.MobSpawnSettings$SpawnerData>;
    }
    type MobFilter_ = ((arg0: Internal.MobCategory, arg1: Internal.MobSpawnSettings$SpawnerData) => boolean) | MobFilter;
    interface Function13 <T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, R> {
        curry12(): Internal.Function12<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, java_.util.function_.Function<T13, R>>;
        curry9(): Internal.Function9<T1, T2, T3, T4, T5, T6, T7, T8, T9, Internal.Function4<T10, T11, T12, T13, R>>;
        apply(arg0: T1, arg1: T2, arg2: T3, arg3: T4, arg4: T5, arg5: T6, arg6: T7, arg7: T8, arg8: T9, arg9: T10, arg10: T11, arg11: T12, arg12: T13): R;
        curry7(): Internal.Function7<T1, T2, T3, T4, T5, T6, T7, Internal.Function6<T8, T9, T10, T11, T12, T13, R>>;
        curry8(): Internal.Function8<T1, T2, T3, T4, T5, T6, T7, T8, Internal.Function5<T9, T10, T11, T12, T13, R>>;
        curry5(): Internal.Function5<T1, T2, T3, T4, T5, Internal.Function8<T6, T7, T8, T9, T10, T11, T12, T13, R>>;
        curry6(): Internal.Function6<T1, T2, T3, T4, T5, T6, Internal.Function7<T7, T8, T9, T10, T11, T12, T13, R>>;
        curry3(): Internal.Function3<T1, T2, T3, Internal.Function10<T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, R>>;
        curry10(): Internal.Function10<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, Internal.Function3<T11, T12, T13, R>>;
        curry4(): Internal.Function4<T1, T2, T3, T4, Internal.Function9<T5, T6, T7, T8, T9, T10, T11, T12, T13, R>>;
        curry11(): Internal.Function11<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, Internal.BiFunction<T12, T13, R>>;
        curry2(): Internal.BiFunction<T1, T2, Internal.Function11<T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, R>>;
        curry(): java_.util.function_.Function<T1, Internal.Function12<T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, R>>;
    }
    type Function13_<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, R> = Function13<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, R>;
    interface LycheeCounter {
        lychee$setRecipeId(arg0: ResourceLocation_): void;
        lychee$update(arg0: ResourceLocation_, arg1: Internal.Recipe_<any>): void;
        lychee$getRecipeId(): ResourceLocation;
        lychee$setCount(arg0: number): void;
        lychee$getCount(): number;
    }
    type LycheeCounter_ = LycheeCounter;
    abstract class AsynchronousFileChannel implements Internal.AsynchronousChannel {
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        read(arg0: Internal.ByteBuffer_, arg1: number): Internal.Future<number>;
        read<A_>(arg0: Internal.ByteBuffer_, arg1: number, arg2: A_, arg3: Internal.CompletionHandler_<number, A_>): void;
        notifyAll(): void;
        notify(): void;
        tryLock(): Internal.FileLock;
        tryLock(arg0: number, arg1: number, arg2: boolean): Internal.FileLock;
        isOpen(): boolean;
        truncate(arg0: number): Internal.AsynchronousFileChannel;
        size(): number;
        hashCode(): number;
        equals(arg0: any): boolean;
        lock(arg0: number, arg1: number, arg2: boolean): Internal.Future<Internal.FileLock>;
        lock<A_>(arg0: A_, arg1: Internal.CompletionHandler_<Internal.FileLock_, A_>): void;
        lock<A_>(arg0: number, arg1: number, arg2: boolean, arg3: A_, arg4: Internal.CompletionHandler_<Internal.FileLock_, A_>): void;
        lock(): Internal.Future<Internal.FileLock>;
        toString(): string;
        force(arg0: boolean): void;
        close(): void;
        write(arg0: Internal.ByteBuffer_, arg1: number): Internal.Future<number>;
        write<A_>(arg0: Internal.ByteBuffer_, arg1: number, arg2: A_, arg3: Internal.CompletionHandler_<number, A_>): void;
        static open(arg0: Internal.Path_, arg1: Internal.Set_<Internal.OpenOption_>, arg2: Internal.ExecutorService_, arg3: any_<any>[]): Internal.AsynchronousFileChannel;
        static open(arg0: Internal.Path_, arg1: Internal.OpenOption_[]): Internal.AsynchronousFileChannel;
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    type AsynchronousFileChannel_ = AsynchronousFileChannel;
    class FluidBuilder extends Internal.BuilderBase<Internal.FlowingFluid> {
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        clientRegistry(minecraft: Internal.Minecraft_): void;
        thinTexture(color: Internal.Color_): Internal.FluidBuilder;
        transformObject(obj: Internal.FlowingFluid_): Internal.FlowingFluid;
        translationKey(key: string): Internal.BuilderBase<Internal.FlowingFluid>;
        bucketColor(c: Internal.Color_): Internal.FluidBuilder;
        color(c: Internal.Color_): Internal.FluidBuilder;
        newID(pre: string, post: string): ResourceLocation;
        displayName(name: string): Internal.BuilderBase<Internal.FlowingFluid>;
        notifyAll(): void;
        type(type: string): Internal.BuilderBase<Internal.FlowingFluid>;
        gaseous(): Internal.FluidBuilder;
        notify(): void;
        createAttributes(): Internal.ArchitecturyFluidAttributes;
        createAdditionalObjects(): void;
        hashCode(): number;
        flowingTexture(id: ResourceLocation_): Internal.FluidBuilder;
        get(): Internal.FlowingFluid;
        temperature(temperature: number): Internal.FluidBuilder;
        luminosity(luminosity: number): Internal.FluidBuilder;
        tag(tag: ResourceLocation_): Internal.BuilderBase<Internal.FlowingFluid>;
        generateDataJsons(generator: Internal.DataJsonGenerator_): void;
        noBucket(): Internal.FluidBuilder;
        noBlock(): Internal.FluidBuilder;
        generateAssetJsons(generator: Internal.AssetJsonGenerator_): void;
        density(density: number): Internal.FluidBuilder;
        getTranslationKeyGroup(): string;
        generateLang(lang: Internal.Map_<string, string>): void;
        thickTexture(color: Internal.Color_): Internal.FluidBuilder;
        createObject(): Internal.FlowingFluid;
        builtinTextures(): Internal.FluidBuilder;
        addResourcePackLocations(path: string, list: Internal.List_<ResourceLocation_>, packType: Internal.PackType_): void;
        stillTexture(id: ResourceLocation_): Internal.FluidBuilder;
        viscosity(viscosity: number): Internal.FluidBuilder;
        equals(arg0: any): boolean;
        getRegistryType(): Internal.RegistryObjectBuilderTypes<Internal.Fluid>;
        toString(): string;
        rarity(rarity: Rarity_): Internal.FluidBuilder;
        flowingFluid : Internal.FlowingFluidBuilder;
        attributes : Internal.ArchitecturyFluidAttributes;
        block : Internal.FluidBlockBuilder;
        readonly id : ResourceLocation;
        bucketItem : Internal.FluidBucketItemBuilder;
        get registryType(): Internal.RegistryObjectBuilderTypes<Internal.Fluid>;
        get class(): Internal.Class<any>;
        get translationKeyGroup(): string;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    type FluidBuilder_ = FluidBuilder;
    interface Byte2ObjectMap <V> extends Internal.Byte2ObjectFunction<V>, Internal.Map<number, V> {
        getOrDefault(arg0: number, arg1: V): V;
        getOrDefault(arg0: any, arg1: V): V;
        computeIfAbsent(arg0: number, arg1: Internal.Byte2ObjectFunction_<V>): V;
        computeIfAbsent(arg0: number, arg1: Internal.IntFunction_<V>): V;
        computeIfAbsent(arg0: number, arg1: java_.util.function_.Function_<number, V>): V;
        values(): Internal.ObjectCollection<V>;
        andThenShort(arg0: Internal.Object2ShortFunction_<V>): Internal.Byte2ShortFunction;
        replace(arg0: number, arg1: V, arg2: V): boolean;
        replace(arg0: number, arg1: V): V;
        composeByte(arg0: Internal.Byte2ByteFunction_): Internal.Byte2ObjectFunction<V>;
        computeIfAbsentPartial(arg0: number, arg1: Internal.Byte2ObjectFunction_<V>): V;
        replaceAll(arg0: Internal.BiFunction_<number, V, V>): void;
        andThenInt(arg0: Internal.Object2IntFunction_<V>): Internal.Byte2IntFunction;
        containsValue(arg0: any): boolean;
        andThen<V_>(arg0: java_.util.function_.Function_<V, V_>): java_.util.function_.Function<number, V_>;
        composeReference<T_>(arg0: Internal.Reference2ByteFunction_<T_>): Internal.Reference2ObjectFunction<T_, V>;
        put(arg0: number, arg1: V): V;
        remove(arg0: any): V;
        remove(arg0: number, arg1: any): boolean;
        remove(arg0: number): V;
        remove(arg0: any, arg1: any): boolean;
        compute(arg0: number, arg1: Internal.BiFunction_<number, V, V>): V;
        byte2ObjectEntrySet(): Internal.ObjectSet<Internal.Byte2ObjectMap$Entry<V>>;
        defaultReturnValue(arg0: V): void;
        defaultReturnValue(): V;
        andThenDouble(arg0: Internal.Object2DoubleFunction_<V>): Internal.Byte2DoubleFunction;
        andThenObject<T_>(arg0: Internal.Object2ObjectFunction_<V, T_>): Internal.Byte2ObjectFunction<T_>;
        hashCode(): number;
        putAll(arg0: Internal.Map_<number, V>): void;
        merge(arg0: number, arg1: V, arg2: Internal.BiFunction_<V, V, V>): V;
        get(arg0: any): V;
        get(arg0: number): V;
        andThenLong(arg0: Internal.Object2LongFunction_<V>): Internal.Byte2LongFunction;
        composeLong(arg0: Internal.Long2ByteFunction_): Internal.Long2ObjectFunction<V>;
        keySet(): Internal.ByteSet;
        andThenByte(arg0: Internal.Object2ByteFunction_<V>): Internal.Byte2ByteFunction;
        andThenFloat(arg0: Internal.Object2FloatFunction_<V>): Internal.Byte2FloatFunction;
        apply(arg0: number): V;
        entrySet(): Internal.ObjectSet<Internal.Map$Entry<number, V>>;
        containsKey(arg0: number): boolean;
        containsKey(arg0: any): boolean;
        forEach(arg0: Internal.BiConsumer_<number, V>): void;
        composeInt(arg0: Internal.Int2ByteFunction_): Internal.Int2ObjectFunction<V>;
        isEmpty(): boolean;
        clear(): void;
        composeFloat(arg0: Internal.Float2ByteFunction_): Internal.Float2ObjectFunction<V>;
        andThenChar(arg0: Internal.Object2CharFunction_<V>): Internal.Byte2CharFunction;
        composeObject<T_>(arg0: Internal.Object2ByteFunction_<T_>): Internal.Object2ObjectFunction<T_, V>;
        computeIfPresent(arg0: number, arg1: Internal.BiFunction_<number, V, V>): V;
        size(): number;
        compose<T_>(arg0: java_.util.function_.Function_<T_, number>): java_.util.function_.Function<T_, V>;
        equals(arg0: any): boolean;
        composeShort(arg0: Internal.Short2ByteFunction_): Internal.Short2ObjectFunction<V>;
        andThenReference<T_>(arg0: Internal.Object2ReferenceFunction_<V, T_>): Internal.Byte2ReferenceFunction<T_>;
        composeChar(arg0: Internal.Char2ByteFunction_): Internal.Char2ObjectFunction<V>;
        composeDouble(arg0: Internal.Double2ByteFunction_): Internal.Double2ObjectFunction<V>;
        putIfAbsent(arg0: number, arg1: V): V;
    }
    type Byte2ObjectMap_<V> = Byte2ObjectMap<V>;
    /**
    * Fired when you need to remove worldgen.
    */
    class WorldgenAddEventJS extends Internal.StartupEventJS {
        cancel(): void;
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        isCancelled(): boolean;
        notifyAll(): void;
        notify(): void;
        static getUniqueId<T_>(feature: T_, codec: Internal.Codec_<T_>): string;
        addSpawn(category: Internal.MobCategory_, spawn: string): void;
        addSpawn(p: Internal.Consumer_<Internal.AddSpawnProperties_>): void;
        addSpawn(filter: Internal.BiomeFilter_, category: Internal.MobCategory_, spawn: string): void;
        post(id: string): boolean;
        post(id: string, sub: string): boolean;
        post(t: Internal.ScriptType_, id: string, sub: string): boolean;
        post(t: Internal.ScriptType_, id: string): boolean;
        addFeatureJson(filter: Internal.BiomeFilter_, json: Internal.JsonObject_): void;
        addFeatureJson(filter: Internal.BiomeFilter_, id: ResourceLocation_, json: Internal.JsonObject_): void;
        addOre(p: Internal.Consumer_<Internal.AddOreProperties_>): void;
        hashCode(): number;
        addLake(p: Internal.Consumer_<Internal.AddLakeProperties_>): void;
        equals(arg0: any): boolean;
        toString(): string;
        canCancel(): boolean;
        get cancelled(): boolean;
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    /**
    * Fired when you need to remove worldgen.
    */
    type WorldgenAddEventJS_ = WorldgenAddEventJS;
    class FireworksJS$Explosion {
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        hashCode(): number;
        notifyAll(): void;
        equals(arg0: any): boolean;
        toString(): string;
        notify(): void;
        trail : boolean;
        readonly fadeColors : Internal.IntOpenHashSet;
        shape : Internal.FireworksJS$Shape;
        flicker : boolean;
        readonly colors : Internal.IntOpenHashSet;
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    type FireworksJS$Explosion_ = FireworksJS$Explosion;
    interface AmbiguityConsumer <S> {
        ambiguous(arg0: Internal.CommandNode_<S>, arg1: Internal.CommandNode_<S>, arg2: Internal.CommandNode_<S>, arg3: Internal.Collection_<string>): void;
    }
    type AmbiguityConsumer_<S> = ((arg0: Internal.CommandNode<S>, arg1: Internal.CommandNode<S>, arg2: Internal.CommandNode<S>, arg3: Internal.Collection<string>) => void) | AmbiguityConsumer<S>;
    interface ChannelInboundInvoker {
        fireChannelRead(arg0: any): Internal.ChannelInboundInvoker;
        fireChannelInactive(): Internal.ChannelInboundInvoker;
        fireChannelReadComplete(): Internal.ChannelInboundInvoker;
        fireChannelWritabilityChanged(): Internal.ChannelInboundInvoker;
        fireExceptionCaught(arg0: Internal.Throwable_): Internal.ChannelInboundInvoker;
        fireUserEventTriggered(arg0: any): Internal.ChannelInboundInvoker;
        fireChannelActive(): Internal.ChannelInboundInvoker;
        fireChannelUnregistered(): Internal.ChannelInboundInvoker;
        fireChannelRegistered(): Internal.ChannelInboundInvoker;
    }
    type ChannelInboundInvoker_ = ChannelInboundInvoker;
    interface IForgeBlock {
        rotate(arg0: Internal.BlockState_, arg1: Internal.LevelAccessor_, arg2: BlockPos_, arg3: Internal.Rotation_): Internal.BlockState;
        getStateAtViewpoint(arg0: Internal.BlockState_, arg1: Internal.BlockGetter_, arg2: BlockPos_, arg3: Vec3_): Internal.BlockState;
        onBlockExploded(arg0: Internal.BlockState_, arg1: Internal.Level_, arg2: BlockPos_, arg3: Internal.Explosion_): void;
        getBedDirection(arg0: Internal.BlockState_, arg1: Internal.LevelReader_, arg2: BlockPos_): Internal.Direction;
        getExpDrop(arg0: Internal.BlockState_, arg1: Internal.LevelReader_, arg2: BlockPos_, arg3: number, arg4: number): number;
        isConduitFrame(arg0: Internal.BlockState_, arg1: Internal.LevelReader_, arg2: BlockPos_, arg3: BlockPos_): boolean;
        getLightEmission(arg0: Internal.BlockState_, arg1: Internal.BlockGetter_, arg2: BlockPos_): number;
        onDestroyedByPlayer(arg0: Internal.BlockState_, arg1: Internal.Level_, arg2: BlockPos_, arg3: Internal.Player_, arg4: boolean, arg5: Internal.FluidState_): boolean;
        isBed(arg0: Internal.BlockState_, arg1: Internal.BlockGetter_, arg2: BlockPos_, arg3: Internal.Entity_): boolean;
        canHarvestBlock(arg0: Internal.BlockState_, arg1: Internal.BlockGetter_, arg2: BlockPos_, arg3: Internal.Player_): boolean;
        makesOpenTrapdoorAboveClimbable(arg0: Internal.BlockState_, arg1: Internal.LevelReader_, arg2: BlockPos_, arg3: Internal.BlockState_): boolean;
        shouldCheckWeakPower(arg0: Internal.BlockState_, arg1: Internal.LevelReader_, arg2: BlockPos_, arg3: Internal.Direction_): boolean;
        collisionExtendsVertically(arg0: Internal.BlockState_, arg1: Internal.BlockGetter_, arg2: BlockPos_, arg3: Internal.Entity_): boolean;
        supportsExternalFaceHiding(arg0: Internal.BlockState_): boolean;
        isLadder(arg0: Internal.BlockState_, arg1: Internal.LevelReader_, arg2: BlockPos_, arg3: Internal.LivingEntity_): boolean;
        addLandingEffects(arg0: Internal.BlockState_, arg1: Internal.ServerLevel_, arg2: BlockPos_, arg3: Internal.BlockState_, arg4: Internal.LivingEntity_, arg5: number): boolean;
        shouldDisplayFluidOverlay(arg0: Internal.BlockState_, arg1: Internal.BlockAndTintGetter_, arg2: BlockPos_, arg3: Internal.FluidState_): boolean;
        getSoundType(arg0: Internal.BlockState_, arg1: Internal.LevelReader_, arg2: BlockPos_, arg3: Internal.Entity_): Internal.SoundType;
        canStickTo(arg0: Internal.BlockState_, arg1: Internal.BlockState_): boolean;
        addRunningEffects(arg0: Internal.BlockState_, arg1: Internal.Level_, arg2: BlockPos_, arg3: Internal.Entity_): boolean;
        onNeighborChange(arg0: Internal.BlockState_, arg1: Internal.LevelReader_, arg2: BlockPos_, arg3: BlockPos_): void;
        hidesNeighborFace(arg0: Internal.BlockGetter_, arg1: BlockPos_, arg2: Internal.BlockState_, arg3: Internal.BlockState_, arg4: Internal.Direction_): boolean;
        getWeakChanges(arg0: Internal.BlockState_, arg1: Internal.LevelReader_, arg2: BlockPos_): boolean;
        canEntityDestroy(arg0: Internal.BlockState_, arg1: Internal.BlockGetter_, arg2: BlockPos_, arg3: Internal.Entity_): boolean;
        isBurning(arg0: Internal.BlockState_, arg1: Internal.BlockGetter_, arg2: BlockPos_): boolean;
        getCloneItemStack(arg0: Internal.BlockState_, arg1: Internal.HitResult_, arg2: Internal.BlockGetter_, arg3: BlockPos_, arg4: Internal.Player_): Internal.ItemStack;
        getFriction(arg0: Internal.BlockState_, arg1: Internal.LevelReader_, arg2: BlockPos_, arg3: Internal.Entity_): number;
        isFlammable(arg0: Internal.BlockState_, arg1: Internal.BlockGetter_, arg2: BlockPos_, arg3: Internal.Direction_): boolean;
        isValidSpawn(arg0: Internal.BlockState_, arg1: Internal.BlockGetter_, arg2: BlockPos_, arg3: Internal.SpawnPlacements$Type_, arg4: Internal.EntityType_<any>): boolean;
        isPortalFrame(arg0: Internal.BlockState_, arg1: Internal.BlockGetter_, arg2: BlockPos_): boolean;
        getExplosionResistance(arg0: Internal.BlockState_, arg1: Internal.BlockGetter_, arg2: BlockPos_, arg3: Internal.Explosion_): number;
        canSustainPlant(arg0: Internal.BlockState_, arg1: Internal.BlockGetter_, arg2: BlockPos_, arg3: Internal.Direction_, arg4: Internal.IPlantable_): boolean;
        isScaffolding(arg0: Internal.BlockState_, arg1: Internal.LevelReader_, arg2: BlockPos_, arg3: Internal.LivingEntity_): boolean;
        onCaughtFire(arg0: Internal.BlockState_, arg1: Internal.Level_, arg2: BlockPos_, arg3: Internal.Direction_, arg4: Internal.LivingEntity_): void;
        getEnchantPowerBonus(arg0: Internal.BlockState_, arg1: Internal.LevelReader_, arg2: BlockPos_): number;
        setBedOccupied(arg0: Internal.BlockState_, arg1: Internal.Level_, arg2: BlockPos_, arg3: Internal.LivingEntity_, arg4: boolean): void;
        isFireSource(arg0: Internal.BlockState_, arg1: Internal.LevelReader_, arg2: BlockPos_, arg3: Internal.Direction_): boolean;
        canDropFromExplosion(arg0: Internal.BlockState_, arg1: Internal.BlockGetter_, arg2: BlockPos_, arg3: Internal.Explosion_): boolean;
        getRespawnPosition(arg0: Internal.BlockState_, arg1: Internal.EntityType_<any>, arg2: Internal.LevelReader_, arg3: BlockPos_, arg4: number, arg5: Internal.LivingEntity_): Internal.Optional<Vec3>;
        isStickyBlock(arg0: Internal.BlockState_): boolean;
        isFertile(arg0: Internal.BlockState_, arg1: Internal.BlockGetter_, arg2: BlockPos_): boolean;
        getAiPathNodeType(arg0: Internal.BlockState_, arg1: Internal.BlockGetter_, arg2: BlockPos_, arg3: Internal.Mob_): Internal.BlockPathTypes;
        isSlimeBlock(arg0: Internal.BlockState_): boolean;
        canConnectRedstone(arg0: Internal.BlockState_, arg1: Internal.BlockGetter_, arg2: BlockPos_, arg3: Internal.Direction_): boolean;
        getFireSpreadSpeed(arg0: Internal.BlockState_, arg1: Internal.BlockGetter_, arg2: BlockPos_, arg3: Internal.Direction_): number;
        getFlammability(arg0: Internal.BlockState_, arg1: Internal.BlockGetter_, arg2: BlockPos_, arg3: Internal.Direction_): number;
        getToolModifiedState(arg0: Internal.BlockState_, arg1: Internal.Level_, arg2: BlockPos_, arg3: Internal.Player_, arg4: Internal.ItemStack_, arg5: Internal.ToolAction_): Internal.BlockState;
        getToolModifiedState(arg0: Internal.BlockState_, arg1: Internal.UseOnContext_, arg2: Internal.ToolAction_, arg3: boolean): Internal.BlockState;
        getBeaconColorMultiplier(arg0: Internal.BlockState_, arg1: Internal.LevelReader_, arg2: BlockPos_, arg3: BlockPos_): number[];
    }
    type IForgeBlock_ = IForgeBlock;
    class Theme {
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        drawCheckboxBackground(matrixStack: Internal.PoseStack_, x: number, y: number, w: number, h: number, radioButton: boolean): void;
        trimStringToWidth(text: Internal.FormattedText_, width: number): Internal.FormattedText;
        trimStringToWidth(text: string, width: number): string;
        drawWidget(matrixStack: Internal.PoseStack_, x: number, y: number, w: number, h: number, type: Internal.WidgetType_): void;
        listFormattedStringToWidth(text: Internal.FormattedText_, width: number): Internal.List<Internal.FormattedText>;
        notifyAll(): void;
        drawScrollBar(matrixStack: Internal.PoseStack_, x: number, y: number, w: number, h: number, type: Internal.WidgetType_, vertical: boolean): void;
        notify(): void;
        drawString(matrixStack: Internal.PoseStack_, text: any, x: number, y: number, color: Internal.Color4I_, flags: number): number;
        drawString(matrixStack: Internal.PoseStack_, text: any, x: number, y: number, flags: number): number;
        drawString(matrixStack: Internal.PoseStack_, text: any, x: number, y: number): number;
        drawGui(matrixStack: Internal.PoseStack_, x: number, y: number, w: number, h: number, type: Internal.WidgetType_): void;
        drawScrollBarBackground(matrixStack: Internal.PoseStack_, x: number, y: number, w: number, h: number, type: Internal.WidgetType_): void;
        drawSlot(matrixStack: Internal.PoseStack_, x: number, y: number, w: number, h: number, type: Internal.WidgetType_): void;
        hashCode(): number;
        getContentColor(type: Internal.WidgetType_): Internal.Color4I;
        drawContainerSlot(matrixStack: Internal.PoseStack_, x: number, y: number, w: number, h: number): void;
        drawButton(matrixStack: Internal.PoseStack_, x: number, y: number, w: number, h: number, type: Internal.WidgetType_): void;
        drawContextMenuBackground(matrixStack: Internal.PoseStack_, x: number, y: number, w: number, h: number): void;
        drawTextBox(matrixStack: Internal.PoseStack_, x: number, y: number, w: number, h: number): void;
        getStringWidth(text: Internal.FormattedCharSequence_): number;
        getStringWidth(text: Internal.FormattedText_): number;
        getStringWidth(text: string): number;
        drawHorizontalTab(matrixStack: Internal.PoseStack_, x: number, y: number, w: number, h: number, selected: boolean): void;
        getFontHeight(): number;
        drawCheckbox(matrixStack: Internal.PoseStack_, x: number, y: number, w: number, h: number, type: Internal.WidgetType_, selected: boolean, radioButton: boolean): void;
        trimStringToWidthReverse(text: string, width: number): string;
        equals(arg0: any): boolean;
        toString(): string;
        getFont(): net.minecraft.client.gui.Font;
        drawPanelBackground(matrixStack: Internal.PoseStack_, x: number, y: number, w: number, h: number): void;
        getInvertedContentColor(): Internal.Color4I;
        static readonly MOUSE_OVER : 16;
        static readonly BACKGROUND_SQUARES : Internal.ImageIcon;
        static readonly CENTERED : 4;
        static readonly SHADOW : 2;
        static readonly CENTERED_V : 32;
        static readonly DARK : 1;
        static renderDebugBoxes : false;
        static readonly UNICODE : 8;
        static readonly DEFAULT : Internal.Theme;
        get invertedContentColor(): Internal.Color4I;
        get fontHeight(): number;
        get class(): Internal.Class<any>;
        get font(): net.minecraft.client.gui.Font;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    type Theme_ = Theme;
    class CapabilityDispatcher implements Internal.INBTSerializable<Internal.CompoundTag>, Internal.ICapabilityProvider {
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        serializeNBT(): Internal.CompoundTag;
        getCapability<T_>(arg0: Internal.Capability_<T_>, arg1: Internal.Direction_): Internal.LazyOptional<T_>;
        getCapability<T_>(arg0: Internal.Capability_<T_>): Internal.LazyOptional<T_>;
        hashCode(): number;
        notifyAll(): void;
        equals(arg0: any): boolean;
        deserializeNBT(arg0: Internal.CompoundTag_): void;
        toString(): string;
        invalidate(): void;
        areCompatible(arg0: Internal.CapabilityDispatcher_): boolean;
        notify(): void;
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    type CapabilityDispatcher_ = CapabilityDispatcher;
    interface FireworkRocketEntityKJS {
        setLifetimeKJS(arg0: number): void;
    }
    type FireworkRocketEntityKJS_ = FireworkRocketEntityKJS;
    interface StringRepresentable {
    }
    type StringRepresentable_ = StringRepresentable;
    class UpdateFormedEvent extends Internal.EventJS {
        cancel(): void;
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        isCancelled(): boolean;
        post(t: Internal.ScriptType_, id: string, sub: string): boolean;
        post(t: Internal.ScriptType_, id: string): boolean;
        hashCode(): number;
        notifyAll(): void;
        equals(arg0: any): boolean;
        toString(): string;
        getController(): Internal.ControllerTileEntity;
        notify(): void;
        canCancel(): boolean;
        static readonly ID : "mbd.update_formed";
        get controller(): Internal.ControllerTileEntity;
        get cancelled(): boolean;
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    type UpdateFormedEvent_ = UpdateFormedEvent;
    class Rotation extends Internal.Enum<Internal.Rotation> {
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        static valueOf(arg0: string): Internal.Rotation;
        static valueOf<T_>(arg0: Internal.Class_<T_>, arg1: string): T_;
        notifyAll(): void;
        static values(): Internal.Rotation[];
        compareTo(arg0: Internal.Rotation_): number;
        describeConstable(): Internal.Optional<Internal.Enum$EnumDesc<Internal.Rotation>>;
        notify(): void;
        getDeclaringClass(): Internal.Class<Internal.Rotation>;
        hashCode(): number;
        equals(arg0: any): boolean;
        name(): string;
        toString(): string;
        ordinal(): number;
        static readonly COUNTERCLOCKWISE_90 : Internal.Rotation;
        static readonly CLOCKWISE_90 : Internal.Rotation;
        static readonly CLOCKWISE_180 : Internal.Rotation;
        static readonly NONE : Internal.Rotation;
        get class(): Internal.Class<any>;
        get declaringClass(): Internal.Class<Internal.Rotation>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    type Rotation_ = "clockwise_90" | "clockwise_180" | "none" | "counterclockwise_90" | Rotation;
    abstract class Permission implements Internal.Guard, Internal.Serializable {
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        getName(): string;
        checkGuard(arg0: any): void;
        newPermissionCollection(): Internal.PermissionCollection;
        hashCode(): number;
        notifyAll(): void;
        equals(arg0: any): boolean;
        getActions(): string;
        toString(): string;
        implies(arg0: Internal.Permission_): boolean;
        notify(): void;
        get name(): string;
        get class(): Internal.Class<any>;
        get actions(): string;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    type Permission_ = Permission;
    interface InputMethodListener extends Internal.EventListener {
        inputMethodTextChanged(arg0: Internal.InputMethodEvent_): void;
        caretPositionChanged(arg0: Internal.InputMethodEvent_): void;
    }
    type InputMethodListener_ = InputMethodListener;
    class JobAttributes$MultipleDocumentHandlingType extends Internal.AttributeValue {
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        notifyAll(): void;
        equals(arg0: any): boolean;
        notify(): void;
        static readonly SEPARATE_DOCUMENTS_COLLATED_COPIES : Internal.JobAttributes$MultipleDocumentHandlingType;
        static readonly SEPARATE_DOCUMENTS_UNCOLLATED_COPIES : Internal.JobAttributes$MultipleDocumentHandlingType;
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    type JobAttributes$MultipleDocumentHandlingType_ = JobAttributes$MultipleDocumentHandlingType;
    class URL implements Internal.Serializable {
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        static setURLStreamHandlerFactory(arg0: Internal.URLStreamHandlerFactory_): void;
        getDefaultPort(): number;
        openConnection(): Internal.URLConnection;
        openConnection(arg0: Internal.Proxy_): Internal.URLConnection;
        notifyAll(): void;
        toURI(): Internal.URI;
        getContent(): any;
        getContent(arg0: Internal.Class_<any>[]): any;
        getProtocol(): string;
        getAuthority(): string;
        getFile(): string;
        openStream(): Internal.InputStream;
        notify(): void;
        toExternalForm(): string;
        getPort(): number;
        getRef(): string;
        sameFile(arg0: Internal.URL_): boolean;
        hashCode(): number;
        equals(arg0: any): boolean;
        getPath(): string;
        toString(): string;
        getUserInfo(): string;
        getQuery(): string;
        getHost(): string;
        get defaultPort(): number;
        get path(): string;
        get userInfo(): string;
        get protocol(): string;
        get ref(): string;
        get file(): string;
        get port(): number;
        get authority(): string;
        get query(): string;
        get host(): string;
        get class(): Internal.Class<any>;
        get content(): any;
        set uRLStreamHandlerFactory(arg0: Internal.URLStreamHandlerFactory_);
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    type URL_ = URL;
    interface Thread$UncaughtExceptionHandler {
        uncaughtException(arg0: Internal.Thread_, arg1: Internal.Throwable_): void;
    }
    type Thread$UncaughtExceptionHandler_ = ((arg0: Internal.Thread, arg1: Internal.Throwable) => void) | Thread$UncaughtExceptionHandler;
    interface IntStream$IntMapMultiConsumer {
        accept(arg0: number, arg1: java_.util.function_.IntConsumer_): void;
    }
    type IntStream$IntMapMultiConsumer_ = ((arg0: number, arg1: java_.util.function_.IntConsumer) => void) | IntStream$IntMapMultiConsumer;
    /**
    */
    abstract class MobEffectBuilder extends Internal.BuilderBase<Internal.MobEffect> {
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        clientRegistry(minecraft: Internal.Minecraft_): void;
        transformObject(obj: Internal.MobEffect_): Internal.MobEffect;
        translationKey(key: string): Internal.BuilderBase<Internal.MobEffect>;
        color(col: Internal.Color_): Internal.MobEffectBuilder;
        newID(pre: string, post: string): ResourceLocation;
        displayName(name: string): Internal.BuilderBase<Internal.MobEffect>;
        notifyAll(): void;
        effectTick(effectTick: Internal.MobEffectBuilder$EffectTickCallback_): Internal.MobEffectBuilder;
        type(type: string): Internal.BuilderBase<Internal.MobEffect>;
        notify(): void;
        createAdditionalObjects(): void;
        harmful(): Internal.MobEffectBuilder;
        hashCode(): number;
        get(): Internal.MobEffect;
        tag(tag: ResourceLocation_): Internal.BuilderBase<Internal.MobEffect>;
        generateDataJsons(generator: Internal.DataJsonGenerator_): void;
        generateAssetJsons(generator: Internal.AssetJsonGenerator_): void;
        getTranslationKeyGroup(): string;
        generateLang(lang: Internal.Map_<string, string>): void;
        createObject(): Internal.MobEffect;
        addResourcePackLocations(path: string, list: Internal.List_<ResourceLocation_>, packType: Internal.PackType_): void;
        /**
        */
        modifyAttribute(attribute: net.minecraft.world.entity.ai.attributes.Attribute_, identifier: string, d: number, operation: Internal.AttributeModifier$Operation_): Internal.MobEffectBuilder;
        beneficial(): Internal.MobEffectBuilder;
        equals(arg0: any): boolean;
        getRegistryType(): Internal.RegistryObjectBuilderTypes<Internal.MobEffect>;
        toString(): string;
        category(c: Internal.MobEffectCategory_): Internal.MobEffectBuilder;
        readonly id : ResourceLocation;
        get registryType(): Internal.RegistryObjectBuilderTypes<Internal.MobEffect>;
        get class(): Internal.Class<any>;
        get translationKeyGroup(): string;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    /**
    */
    type MobEffectBuilder_ = MobEffectBuilder;
    class InputConstants$Key implements Internal.AccessInputConstantsKey {
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        hashCode(): number;
        notifyAll(): void;
        equals(arg0: any): boolean;
        toString(): string;
        notify(): void;
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    type InputConstants$Key_ = InputConstants$Key;
    interface CollisionGetter extends Internal.BlockGetter {
        getExistingBlockEntity(arg0: BlockPos_): Internal.BlockEntity;
    }
    type CollisionGetter_ = CollisionGetter;
    class Connection extends Internal.SimpleChannelInboundHandler<Internal.Packet<any>> {
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        channelReadComplete(arg0: Internal.ChannelHandlerContext_): void;
        getDirection(): Internal.PacketFlow;
        notifyAll(): void;
        channel(): io.netty.channel.Channel;
        exceptionCaught(arg0: Internal.ChannelHandlerContext_, arg1: Internal.Throwable_): void;
        channelActive(arg0: Internal.ChannelHandlerContext_): void;
        handlerAdded(arg0: Internal.ChannelHandlerContext_): void;
        isSharable(): boolean;
        notify(): void;
        handlerRemoved(arg0: Internal.ChannelHandlerContext_): void;
        channelWritabilityChanged(arg0: Internal.ChannelHandlerContext_): void;
        channelRead(arg0: Internal.ChannelHandlerContext_, arg1: any): void;
        channelInactive(arg0: Internal.ChannelHandlerContext_): void;
        channelUnregistered(arg0: Internal.ChannelHandlerContext_): void;
        hashCode(): number;
        equals(arg0: any): boolean;
        toString(): string;
        userEventTriggered(arg0: Internal.ChannelHandlerContext_, arg1: any): void;
        channelRegistered(arg0: Internal.ChannelHandlerContext_): void;
        acceptInboundMessage(arg0: any): boolean;
        get sharable(): boolean;
        get class(): Internal.Class<any>;
        get direction(): Internal.PacketFlow;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    type Connection_ = Connection;
    abstract class DataBuffer {
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        getNumBanks(): number;
        getElemDouble(arg0: number, arg1: number): number;
        getElemDouble(arg0: number): number;
        static getDataTypeSize(arg0: number): number;
        notifyAll(): void;
        getDataType(): number;
        getOffset(): number;
        getOffsets(): number[];
        setElemFloat(arg0: number, arg1: number, arg2: number): void;
        setElemFloat(arg0: number, arg1: number): void;
        notify(): void;
        getSize(): number;
        setElemDouble(arg0: number, arg1: number): void;
        setElemDouble(arg0: number, arg1: number, arg2: number): void;
        hashCode(): number;
        equals(arg0: any): boolean;
        setElem(arg0: number, arg1: number, arg2: number): void;
        setElem(arg0: number, arg1: number): void;
        getElemFloat(arg0: number, arg1: number): number;
        getElemFloat(arg0: number): number;
        toString(): string;
        getElem(arg0: number): number;
        getElem(arg0: number, arg1: number): number;
        static readonly TYPE_INT : 3;
        static readonly TYPE_DOUBLE : 5;
        static readonly TYPE_SHORT : 2;
        static readonly TYPE_UNDEFINED : 32;
        static readonly TYPE_BYTE : 0;
        static readonly TYPE_USHORT : 1;
        static readonly TYPE_FLOAT : 4;
        get offset(): number;
        get size(): number;
        get offsets(): number[];
        get dataType(): number;
        get numBanks(): number;
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    type DataBuffer_ = DataBuffer;
    interface ICapabilityProxyHolder {
        hasProxy(arg0: Internal.IO_, arg1: Internal.MultiblockCapability_<any>): boolean;
        mergeWith(arg0: Internal.ICapabilityProxyHolder_): Internal.ICapabilityProxyHolder;
        hasProxies(): boolean;
        getCapabilitiesProxy(): Internal.Table<Internal.IO, Internal.MultiblockCapability<any>, Internal.Long2ObjectOpenHashMap<Internal.CapabilityProxy<any>>>;
    }
    type ICapabilityProxyHolder_ = ICapabilityProxyHolder;
    interface Spliterator$OfDouble extends Internal.Spliterator$OfPrimitive<number, java_.util.function_.DoubleConsumer, Internal.Spliterator$OfDouble> {
        trySplit(): Internal.Spliterator$OfDouble;
        characteristics(): number;
        tryAdvance(arg0: Internal.Consumer_<number>): boolean;
        tryAdvance(arg0: java_.util.function_.DoubleConsumer_): boolean;
        getComparator(): Internal.Comparator<number>;
        getExactSizeIfKnown(): number;
        estimateSize(): number;
        hasCharacteristics(arg0: number): boolean;
        forEachRemaining(arg0: java_.util.function_.DoubleConsumer_): void;
        forEachRemaining(arg0: Internal.Consumer_<number>): void;
    }
    type Spliterator$OfDouble_ = Spliterator$OfDouble;
    interface SpriteExtended {
        setActive(arg0: boolean): void;
        isActive(): boolean;
    }
    type SpriteExtended_ = SpriteExtended;
    class ChannelInboundHandlerAdapter extends Internal.ChannelHandlerAdapter implements Internal.ChannelInboundHandler {
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        channelReadComplete(arg0: Internal.ChannelHandlerContext_): void;
        notifyAll(): void;
        exceptionCaught(arg0: Internal.ChannelHandlerContext_, arg1: Internal.Throwable_): void;
        channelActive(arg0: Internal.ChannelHandlerContext_): void;
        handlerAdded(arg0: Internal.ChannelHandlerContext_): void;
        isSharable(): boolean;
        notify(): void;
        handlerRemoved(arg0: Internal.ChannelHandlerContext_): void;
        channelWritabilityChanged(arg0: Internal.ChannelHandlerContext_): void;
        channelRead(arg0: Internal.ChannelHandlerContext_, arg1: any): void;
        channelInactive(arg0: Internal.ChannelHandlerContext_): void;
        channelUnregistered(arg0: Internal.ChannelHandlerContext_): void;
        hashCode(): number;
        equals(arg0: any): boolean;
        toString(): string;
        userEventTriggered(arg0: Internal.ChannelHandlerContext_, arg1: any): void;
        channelRegistered(arg0: Internal.ChannelHandlerContext_): void;
        get sharable(): boolean;
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    type ChannelInboundHandlerAdapter_ = ChannelInboundHandlerAdapter;
    interface NumberProvider extends Internal.LootContextUser {
    }
    type NumberProvider_ = NumberProvider;
    abstract class GraphicsConfiguration {
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        getColorModel(): Internal.ColorModel;
        getColorModel(arg0: number): Internal.ColorModel;
        getNormalizingTransform(): Internal.AffineTransform;
        notifyAll(): void;
        getDefaultTransform(): Internal.AffineTransform;
        isTranslucencyCapable(): boolean;
        notify(): void;
        getDevice(): Internal.GraphicsDevice;
        getBounds(): Internal.Rectangle;
        createCompatibleVolatileImage(arg0: number, arg1: number, arg2: Internal.ImageCapabilities_, arg3: number): Internal.VolatileImage;
        createCompatibleVolatileImage(arg0: number, arg1: number, arg2: Internal.ImageCapabilities_): Internal.VolatileImage;
        createCompatibleVolatileImage(arg0: number, arg1: number, arg2: number): Internal.VolatileImage;
        createCompatibleVolatileImage(arg0: number, arg1: number): Internal.VolatileImage;
        hashCode(): number;
        getImageCapabilities(): Internal.ImageCapabilities;
        equals(arg0: any): boolean;
        getBufferCapabilities(): Internal.BufferCapabilities;
        createCompatibleImage(arg0: number, arg1: number): Internal.BufferedImage;
        createCompatibleImage(arg0: number, arg1: number, arg2: number): Internal.BufferedImage;
        toString(): string;
        get normalizingTransform(): Internal.AffineTransform;
        get translucencyCapable(): boolean;
        get defaultTransform(): Internal.AffineTransform;
        get bounds(): Internal.Rectangle;
        get colorModel(): Internal.ColorModel;
        get imageCapabilities(): Internal.ImageCapabilities;
        get bufferCapabilities(): Internal.BufferCapabilities;
        get class(): Internal.Class<any>;
        get device(): Internal.GraphicsDevice;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    type GraphicsConfiguration_ = GraphicsConfiguration;
    class CodingErrorAction {
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        hashCode(): number;
        notifyAll(): void;
        equals(arg0: any): boolean;
        toString(): string;
        notify(): void;
        static readonly REPORT : Internal.CodingErrorAction;
        static readonly IGNORE : Internal.CodingErrorAction;
        static readonly REPLACE : Internal.CodingErrorAction;
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    type CodingErrorAction_ = CodingErrorAction;
    interface IntsAccess {
    }
    type IntsAccess_ = IntsAccess;
    interface Target extends Internal.Consumer<any> {
        andThen(arg0: Internal.Consumer_<any>): Internal.Consumer<any>;
        getArea(): Internal.Rect2i;
        accept(arg0: any): void;
    }
    type Target_ = Target;
    interface ComponentListener extends Internal.EventListener {
        componentHidden(arg0: Internal.ComponentEvent_): void;
        componentResized(arg0: Internal.ComponentEvent_): void;
        componentShown(arg0: Internal.ComponentEvent_): void;
        componentMoved(arg0: Internal.ComponentEvent_): void;
    }
    type ComponentListener_ = ComponentListener;
    class StructureFormedEvent extends Internal.EventJS {
        cancel(): void;
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        isCancelled(): boolean;
        post(t: Internal.ScriptType_, id: string, sub: string): boolean;
        post(t: Internal.ScriptType_, id: string): boolean;
        hashCode(): number;
        notifyAll(): void;
        equals(arg0: any): boolean;
        toString(): string;
        getController(): Internal.ControllerTileEntity;
        notify(): void;
        canCancel(): boolean;
        static readonly ID : "mbd.structure_formed";
        get controller(): Internal.ControllerTileEntity;
        get cancelled(): boolean;
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    type StructureFormedEvent_ = StructureFormedEvent;
    class ArmorItemBuilder extends Internal.ItemBuilder {
        barWidth(barWidth: Internal.ToIntFunction_<Internal.ItemStackJS_>): Internal.ItemBuilder;
        getClass(): Internal.Class<any>;
        maxStackSize(v: number): Internal.ItemBuilder;
        translationKey(key: string): Internal.BuilderBase<Internal.Item>;
        newID(pre: string, post: string): ResourceLocation;
        use(use: Internal.ItemBuilder$UseCallback_): Internal.ItemBuilder;
        maxDamage(v: number): Internal.ItemBuilder;
        textureJson(json: Internal.JsonObject_): Internal.ItemBuilder;
        tooltip(text: Internal.Component_): Internal.ItemBuilder;
        modifyTier(callback: Internal.Consumer_<Internal.MutableArmorTier_>): Internal.ArmorItemBuilder;
        type(type: string): Internal.BuilderBase<Internal.Item>;
        containerItem(id: string): Internal.ItemBuilder;
        subtypes(fn: java_.util.function_.Function_<Internal.ItemStackJS_, Internal.Collection_<Internal.ItemStackJS_>>): Internal.ItemBuilder;
        modelJson(json: Internal.JsonObject_): Internal.ItemBuilder;
        burnTime(v: number): Internal.ItemBuilder;
        useDuration(useDuration: Internal.ToIntFunction_<Internal.ItemStackJS_>): Internal.ItemBuilder;
        tag(tag: ResourceLocation_): Internal.BuilderBase<Internal.Item>;
        parentModel(m: string): Internal.ItemBuilder;
        generateDataJsons(generator: Internal.DataJsonGenerator_): void;
        group(g: string): Internal.ItemBuilder;
        static ofArmorMaterial(o: any): Internal.ArmorMaterial;
        modifyAttribute(attribute: ResourceLocation_, identifier: string, d: number, operation: Internal.AttributeModifier$Operation_): Internal.ItemBuilder;
        getRegistryType(): Internal.RegistryObjectBuilderTypes<Internal.Item>;
        glow(v: boolean): Internal.ItemBuilder;
        useAnimation(animation: Internal.UseAnim_): Internal.ItemBuilder;
        rarity(v: Rarity_): Internal.ItemBuilder;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        clientRegistry(minecraft: Internal.Minecraft_): void;
        transformObject(obj: Internal.Item_): Internal.Item;
        color(callback: Internal.ItemBuilder$ItemColorJS_): Internal.ItemBuilder;
        color(index: number, c: Internal.Color_): Internal.ItemBuilder;
        displayName(name: string): Internal.BuilderBase<Internal.Item>;
        notifyAll(): void;
        barColor(barColor: java_.util.function_.Function_<Internal.ItemStackJS_, Internal.Color_>): Internal.ItemBuilder;
        notify(): void;
        createAdditionalObjects(): void;
        tier(t: Internal.ArmorMaterial_): Internal.ArmorItemBuilder;
        hashCode(): number;
        get(): Internal.Item;
        generateAssetJsons(generator: Internal.AssetJsonGenerator_): void;
        getTranslationKeyGroup(): string;
        texture(key: string, tex: string): Internal.ItemBuilder;
        texture(tex: string): Internal.ItemBuilder;
        generateLang(lang: Internal.Map_<string, string>): void;
        food(b: Internal.Consumer_<Internal.FoodBuilder_>): Internal.ItemBuilder;
        createObject(): Internal.Item;
        releaseUsing(releaseUsing: Internal.ItemBuilder$ReleaseUsingCallback_): Internal.ItemBuilder;
        unstackable(): Internal.ItemBuilder;
        addResourcePackLocations(path: string, list: Internal.List_<ResourceLocation_>, packType: Internal.PackType_): void;
        equals(arg0: any): boolean;
        toString(): string;
        finishUsing(finishUsing: Internal.ItemBuilder$FinishUsingCallback_): Internal.ItemBuilder;
        createItemProperties(): Internal.Item$Properties;
        armorTier : Internal.MutableArmorTier;
        static readonly TOOL_TIERS : {"gold":any,"diamond":any,"iron":any,"wood":any,"stone":any,"netherite":any};
        static readonly ARMOR_TIERS : {"gold":any,"chain":any,"diamond":any,"turtle":any,"iron":any,"leather":any,"netherite":any};
        readonly equipmentSlot : EquipmentSlot;
        readonly id : ResourceLocation;
        get registryType(): Internal.RegistryObjectBuilderTypes<Internal.Item>;
        get class(): Internal.Class<any>;
        get translationKeyGroup(): string;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    type ArmorItemBuilder_ = ArmorItemBuilder;
    class PotionBuilder extends Internal.BuilderBase<Internal.Potion> {
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        clientRegistry(minecraft: Internal.Minecraft_): void;
        generateAssetJsons(generator: Internal.AssetJsonGenerator_): void;
        transformObject(obj: Internal.Potion_): Internal.Potion;
        translationKey(key: string): Internal.BuilderBase<Internal.Potion>;
        getTranslationKeyGroup(): string;
        newID(pre: string, post: string): ResourceLocation;
        displayName(name: string): Internal.BuilderBase<Internal.Potion>;
        notifyAll(): void;
        generateLang(lang: Internal.Map_<string, string>): void;
        type(type: string): Internal.BuilderBase<Internal.Potion>;
        addEffect(effect: Internal.MobEffectInstance_): Internal.PotionBuilder;
        notify(): void;
        createAdditionalObjects(): void;
        createObject(): Internal.Potion;
        addResourcePackLocations(path: string, list: Internal.List_<ResourceLocation_>, packType: Internal.PackType_): void;
        hashCode(): number;
        equals(arg0: any): boolean;
        get(): Internal.Potion;
        getRegistryType(): Internal.RegistryObjectBuilderTypes<Internal.Potion>;
        effect(effect: Internal.MobEffect_, duration: number, amplifier: number, ambient: boolean, visible: boolean): Internal.PotionBuilder;
        effect(effect: Internal.MobEffect_, duration: number, amplifier: number, ambient: boolean, visible: boolean, showIcon: boolean): Internal.PotionBuilder;
        effect(effect: Internal.MobEffect_, duration: number, amplifier: number, ambient: boolean, visible: boolean, showIcon: boolean, hiddenEffect: Internal.MobEffectInstance_): Internal.PotionBuilder;
        effect(effect: Internal.MobEffect_, duration: number): Internal.PotionBuilder;
        effect(effect: Internal.MobEffect_, duration: number, amplifier: number): Internal.PotionBuilder;
        effect(effect: Internal.MobEffect_): Internal.PotionBuilder;
        toString(): string;
        tag(tag: ResourceLocation_): Internal.BuilderBase<Internal.Potion>;
        generateDataJsons(generator: Internal.DataJsonGenerator_): void;
        readonly id : ResourceLocation;
        get registryType(): Internal.RegistryObjectBuilderTypes<Internal.Potion>;
        get class(): Internal.Class<any>;
        get translationKeyGroup(): string;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    type PotionBuilder_ = PotionBuilder;
    interface IForgeFluidState {
        getExplosionResistance(arg0: Internal.BlockGetter_, arg1: BlockPos_, arg2: Internal.Explosion_): number;
        isEntityInside(arg0: Internal.LevelReader_, arg1: BlockPos_, arg2: Internal.Entity_, arg3: number, arg4: Internal.HolderSet_<Internal.Fluid_>, arg5: boolean): boolean;
    }
    type IForgeFluidState_ = IForgeFluidState;
    interface Clearable {
    }
    type Clearable_ = Clearable;
    interface RegistryObjectBuilderTypes$BuilderFactory <T> {
        createBuilder(arg0: ResourceLocation_): Internal.BuilderBase<T>;
    }
    type RegistryObjectBuilderTypes$BuilderFactory_<T> = RegistryObjectBuilderTypes$BuilderFactory<T>;
    interface UnmodifiableConfig$Entry {
        getShortOrElse(arg0: number): number;
        getKey(): string;
        getByte(): number;
        getShort(): number;
        getOptionalInt(): Internal.OptionalInt;
        getRawValue<T>(): T;
        getCharOrElse(arg0: string): string;
        getLongOrElse(arg0: number): number;
        getByteOrElse(arg0: number): number;
        getLong(): number;
        getValue<T>(): T;
        getInt(): number;
        getChar(): string;
        getOptional<T>(): Internal.Optional<T>;
        isNull(): boolean;
        getOrElse<T>(arg0: T): T;
        getIntOrElse(arg0: number): number;
        getOptionalLong(): Internal.OptionalLong;
    }
    type UnmodifiableConfig$Entry_ = UnmodifiableConfig$Entry;
    interface SpecialEquality {
        specialEquals(o: any, shallow: boolean): boolean;
    }
    type SpecialEquality_ = SpecialEquality;
    interface IntStream extends Internal.BaseStream<number, Internal.IntStream> {
        average(): Internal.OptionalDouble;
        sequential(): Internal.IntStream;
        takeWhile(arg0: java_.util.function_.IntPredicate_): Internal.IntStream;
        distinct(): Internal.IntStream;
        findFirst(): Internal.OptionalInt;
        sum(): number;
        skip(arg0: number): Internal.IntStream;
        asLongStream(): Internal.LongStream;
        allMatch(arg0: java_.util.function_.IntPredicate_): boolean;
        mapToObj<U_>(arg0: Internal.IntFunction_<U_>): Internal.Stream<U_>;
        mapMulti(arg0: Internal.IntStream$IntMapMultiConsumer_): Internal.IntStream;
        iterator(): Internal.PrimitiveIterator$OfInt;
        asDoubleStream(): Internal.DoubleStream;
        min(): Internal.OptionalInt;
        mapToLong(arg0: Internal.IntToLongFunction_): Internal.LongStream;
        parallel(): Internal.IntStream;
        noneMatch(arg0: java_.util.function_.IntPredicate_): boolean;
        findAny(): Internal.OptionalInt;
        isParallel(): boolean;
        limit(arg0: number): Internal.IntStream;
        toArray(): number[];
        forEachOrdered(arg0: java_.util.function_.IntConsumer_): void;
        close(): void;
        anyMatch(arg0: java_.util.function_.IntPredicate_): boolean;
        map(arg0: Internal.IntUnaryOperator_): Internal.IntStream;
        mapToDouble(arg0: Internal.IntToDoubleFunction_): Internal.DoubleStream;
        unordered(): Internal.IntStream;
        reduce(arg0: number, arg1: Internal.IntBinaryOperator_): number;
        reduce(arg0: Internal.IntBinaryOperator_): Internal.OptionalInt;
        spliterator(): Internal.Spliterator$OfInt;
        max(): Internal.OptionalInt;
        forEach(arg0: java_.util.function_.IntConsumer_): void;
        count(): number;
        dropWhile(arg0: java_.util.function_.IntPredicate_): Internal.IntStream;
        peek(arg0: java_.util.function_.IntConsumer_): Internal.IntStream;
        flatMap(arg0: Internal.IntFunction_<Internal.IntStream_>): Internal.IntStream;
        filter(arg0: java_.util.function_.IntPredicate_): Internal.IntStream;
        onClose(arg0: Internal.Runnable_): Internal.IntStream;
        sorted(): Internal.IntStream;
        boxed(): Internal.Stream<number>;
        summaryStatistics(): Internal.IntSummaryStatistics;
        collect<R_>(arg0: Internal.Supplier_<R_>, arg1: Internal.ObjIntConsumer_<R_>, arg2: Internal.BiConsumer_<R_, R_>): R_;
    }
    type IntStream_ = IntStream;
    class MobSpawnType extends Internal.Enum<Internal.MobSpawnType> {
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        static valueOf(arg0: string): Internal.MobSpawnType;
        static valueOf<T_>(arg0: Internal.Class_<T_>, arg1: string): T_;
        notifyAll(): void;
        static values(): Internal.MobSpawnType[];
        compareTo(arg0: Internal.MobSpawnType_): number;
        describeConstable(): Internal.Optional<Internal.Enum$EnumDesc<Internal.MobSpawnType>>;
        notify(): void;
        getDeclaringClass(): Internal.Class<Internal.MobSpawnType>;
        hashCode(): number;
        equals(arg0: any): boolean;
        name(): string;
        toString(): string;
        ordinal(): number;
        static readonly CONVERSION : Internal.MobSpawnType;
        static readonly STRUCTURE : Internal.MobSpawnType;
        static readonly BUCKET : Internal.MobSpawnType;
        static readonly DISPENSER : Internal.MobSpawnType;
        static readonly SPAWNER : Internal.MobSpawnType;
        static readonly EVENT : Internal.MobSpawnType;
        static readonly MOB_SUMMONED : Internal.MobSpawnType;
        static readonly NATURAL : Internal.MobSpawnType;
        static readonly SPAWN_EGG : Internal.MobSpawnType;
        static readonly PATROL : Internal.MobSpawnType;
        static readonly CHUNK_GENERATION : Internal.MobSpawnType;
        static readonly BREEDING : Internal.MobSpawnType;
        static readonly REINFORCEMENT : Internal.MobSpawnType;
        static readonly COMMAND : Internal.MobSpawnType;
        static readonly TRIGGERED : Internal.MobSpawnType;
        static readonly JOCKEY : Internal.MobSpawnType;
        get class(): Internal.Class<any>;
        get declaringClass(): Internal.Class<Internal.MobSpawnType>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    type MobSpawnType_ = "patrol" | "triggered" | "natural" | "chunk_generation" | "spawn_egg" | "jockey" | "structure" | "command" | "bucket" | "dispenser" | "spawner" | "mob_summoned" | "reinforcement" | "event" | "breeding" | "conversion" | MobSpawnType;
    class WrapFactory {
        getClass(): Internal.Class<any>;
        wrapAsJavaObject(cx: Internal.Context_, scope: Internal.Scriptable_, javaObject: any, staticType: Internal.Class_<any>): Internal.Scriptable;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        wrapJavaClass(cx: Internal.Context_, scope: Internal.Scriptable_, javaClass: Internal.Class_<any>): Internal.Scriptable;
        setJavaPrimitiveWrap(value: boolean): void;
        hashCode(): number;
        notifyAll(): void;
        equals(arg0: any): boolean;
        isJavaPrimitiveWrap(): boolean;
        toString(): string;
        wrapNewObject(cx: Internal.Context_, scope: Internal.Scriptable_, obj: any): Internal.Scriptable;
        wrap(cx: Internal.Context_, scope: Internal.Scriptable_, obj: any, staticType: Internal.Class_<any>): any;
        notify(): void;
        get javaPrimitiveWrap(): boolean;
        get class(): Internal.Class<any>;
        set javaPrimitiveWrap(value: boolean);
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    type WrapFactory_ = WrapFactory;
    interface CommandExceptionType {
    }
    type CommandExceptionType_ = CommandExceptionType;
    class OptionalDynamic <T> extends Internal.DynamicLike<T> {
        createIntList(arg0: Internal.IntStream_): Internal.Dynamic<any>;
        createLong(arg0: number): Internal.Dynamic<T>;
        getClass(): Internal.Class<any>;
        getElementGeneric(arg0: T): Internal.DataResult<T>;
        getElementGeneric(arg0: T, arg1: T): T;
        createLongList(arg0: Internal.LongStream_): Internal.Dynamic<any>;
        readMap<K_, V_>(arg0: Internal.Decoder_<K_>, arg1: Internal.Decoder_<V_>): Internal.DataResult<Internal.List<Internal.Pair<K_, V_>>>;
        readMap<R_>(arg0: Internal.DataResult_<R_>, arg1: Internal.Function3_<R_, Internal.Dynamic_<T>, Internal.Dynamic_<T>, Internal.DataResult_<R_>>): Internal.DataResult<R_>;
        readMap<K_, V_>(arg0: Internal.Decoder_<K_>, arg1: java_.util.function_.Function_<K_, Internal.Decoder_<V_>>): Internal.DataResult<Internal.List<Internal.Pair<K_, V_>>>;
        asListOpt<U_>(arg0: java_.util.function_.Function_<Internal.Dynamic_<T>, U_>): Internal.DataResult<Internal.List<U_>>;
        orElseEmptyList(): Internal.Dynamic<T>;
        createShort(arg0: number): Internal.Dynamic<T>;
        decode<A_>(arg0: Internal.Decoder_<A_>): Internal.DataResult<Internal.Pair<A_, T>>;
        asIntStreamOpt(): Internal.DataResult<Internal.IntStream>;
        asList<U_>(arg0: java_.util.function_.Function_<Internal.Dynamic_<T>, U_>): Internal.List<U_>;
        readList<E_>(arg0: Internal.Decoder_<E_>): Internal.DataResult<Internal.List<E_>>;
        readList<E_>(arg0: java_.util.function_.Function_<Internal.Dynamic_<any>, Internal.DataResult_<E_>>): Internal.DataResult<Internal.List<E_>>;
        asString(): Internal.DataResult<string>;
        asString(arg0: string): string;
        asByte(arg0: number): number;
        createList(arg0: Internal.Stream_<Internal.Dynamic_<any>>): Internal.Dynamic<T>;
        read<A_>(arg0: Internal.Decoder_<A_>): Internal.DataResult<A_>;
        asByteBufferOpt(): Internal.DataResult<Internal.ByteBuffer>;
        createString(arg0: string): Internal.Dynamic<T>;
        asMapOpt(): Internal.DataResult<Internal.Stream<Internal.Pair<Internal.Dynamic<T>, Internal.Dynamic<T>>>>;
        asMapOpt<K_, V_>(arg0: java_.util.function_.Function_<Internal.Dynamic_<T>, K_>, arg1: java_.util.function_.Function_<Internal.Dynamic_<T>, V_>): Internal.DataResult<Internal.Map<K_, V_>>;
        getGeneric(arg0: T): Internal.DataResult<T>;
        asStream(): Internal.Stream<Internal.Dynamic<T>>;
        asLong(arg0: number): number;
        createByte(arg0: number): Internal.Dynamic<T>;
        flatMap<U_>(arg0: java_.util.function_.Function_<Internal.Dynamic_<T>, Internal.DataResult_<U_>>): Internal.DataResult<U_>;
        asDouble(arg0: number): number;
        asBoolean(arg0: boolean): boolean;
        createDouble(arg0: number): Internal.Dynamic<T>;
        asLongStreamOpt(): Internal.DataResult<Internal.LongStream>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        asMap<K_, V_>(arg0: java_.util.function_.Function_<Internal.Dynamic_<T>, K_>, arg1: java_.util.function_.Function_<Internal.Dynamic_<T>, V_>): Internal.Map<K_, V_>;
        asStreamOpt(): Internal.DataResult<Internal.Stream<Internal.Dynamic<T>>>;
        notifyAll(): void;
        asIntStream(): Internal.IntStream;
        createByteList(arg0: Internal.ByteBuffer_): Internal.Dynamic<any>;
        asByteBuffer(): Internal.ByteBuffer;
        asFloat(arg0: number): number;
        asLongStream(): Internal.LongStream;
        notify(): void;
        createBoolean(arg0: boolean): Internal.Dynamic<T>;
        result(): Internal.Optional<Internal.Dynamic<T>>;
        asInt(arg0: number): number;
        into<V_>(arg0: java_.util.function_.Function_<Internal.Dynamic_<T>, V_>): Internal.DataResult<V_>;
        emptyList(): Internal.Dynamic<T>;
        hashCode(): number;
        asShort(arg0: number): number;
        get(arg0: string): Internal.OptionalDynamic<T>;
        get(): Internal.DataResult<Internal.Dynamic<T>>;
        emptyMap(): Internal.Dynamic<T>;
        createNumeric(arg0: Internal.Number_): Internal.Dynamic<T>;
        map<U_>(arg0: java_.util.function_.Function_<Internal.Dynamic_<T>, U_>): Internal.DataResult<U_>;
        orElseEmptyMap(): Internal.Dynamic<T>;
        asNumber(): Internal.DataResult<Internal.Number>;
        asNumber(arg0: Internal.Number_): Internal.Number;
        createMap(arg0: Internal.Map_<Internal.Dynamic_<any>, Internal.Dynamic_<any>>): Internal.Dynamic<T>;
        createFloat(arg0: number): Internal.Dynamic<T>;
        getOps(): Internal.DynamicOps<T>;
        getElement(arg0: string): Internal.DataResult<T>;
        getElement(arg0: string, arg1: T): T;
        equals(arg0: any): boolean;
        createInt(arg0: number): Internal.Dynamic<T>;
        toString(): string;
        get ops(): Internal.DynamicOps<T>;
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    type OptionalDynamic_<T> = OptionalDynamic<T>;
    abstract class BufferStrategy {
        getClass(): Internal.Class<any>;
        contentsRestored(): boolean;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        contentsLost(): boolean;
        hashCode(): number;
        notifyAll(): void;
        equals(arg0: any): boolean;
        getDrawGraphics(): Internal.Graphics;
        show(): void;
        toString(): string;
        dispose(): void;
        getCapabilities(): Internal.BufferCapabilities;
        notify(): void;
        get capabilities(): Internal.BufferCapabilities;
        get drawGraphics(): Internal.Graphics;
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    type BufferStrategy_ = BufferStrategy;
    abstract class CharsetEncoder {
        encode(arg0: Internal.CharBuffer_, arg1: Internal.ByteBuffer_, arg2: boolean): Internal.CoderResult;
        encode(arg0: Internal.CharBuffer_): Internal.ByteBuffer;
        getClass(): Internal.Class<any>;
        charset(): Internal.Charset;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        onUnmappableCharacter(arg0: Internal.CodingErrorAction_): Internal.CharsetEncoder;
        notifyAll(): void;
        maxBytesPerChar(): number;
        isLegalReplacement(arg0: number[]): boolean;
        notify(): void;
        unmappableCharacterAction(): Internal.CodingErrorAction;
        malformedInputAction(): Internal.CodingErrorAction;
        flush(arg0: Internal.ByteBuffer_): Internal.CoderResult;
        hashCode(): number;
        equals(arg0: any): boolean;
        canEncode(arg0: Internal.CharSequence_): boolean;
        canEncode(arg0: string): boolean;
        averageBytesPerChar(): number;
        onMalformedInput(arg0: Internal.CodingErrorAction_): Internal.CharsetEncoder;
        reset(): Internal.CharsetEncoder;
        toString(): string;
        replacement(): number[];
        replaceWith(arg0: number[]): Internal.CharsetEncoder;
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    type CharsetEncoder_ = CharsetEncoder;
    interface AccessorPlayer {
        darkutils$setEnchantmentSeed(arg0: number): void;
        darkutils$setSleepTimer(arg0: number): void;
    }
    type AccessorPlayer_ = AccessorPlayer;
    interface Logger {
        warn(arg0: Internal.Marker_, arg1: string, arg2: Internal.Throwable_): void;
        warn(arg0: Internal.Marker_, arg1: string, arg2: any[]): void;
        warn(arg0: Internal.Marker_, arg1: string, arg2: any, arg3: any): void;
        warn(arg0: string, arg1: any): void;
        warn(arg0: string): void;
        warn(arg0: string, arg1: any[]): void;
        warn(arg0: string, arg1: any, arg2: any): void;
        warn(arg0: string, arg1: Internal.Throwable_): void;
        warn(arg0: Internal.Marker_, arg1: string, arg2: any): void;
        warn(arg0: Internal.Marker_, arg1: string): void;
        trace(arg0: Internal.Marker_, arg1: string): void;
        trace(arg0: Internal.Marker_, arg1: string, arg2: any): void;
        trace(arg0: Internal.Marker_, arg1: string, arg2: any, arg3: any): void;
        trace(arg0: string, arg1: any): void;
        trace(arg0: string, arg1: any, arg2: any): void;
        trace(arg0: string, arg1: any[]): void;
        trace(arg0: string): void;
        trace(arg0: string, arg1: Internal.Throwable_): void;
        trace(arg0: Internal.Marker_, arg1: string, arg2: any[]): void;
        trace(arg0: Internal.Marker_, arg1: string, arg2: Internal.Throwable_): void;
        debug(arg0: Internal.Marker_, arg1: string, arg2: any[]): void;
        debug(arg0: string, arg1: any[]): void;
        debug(arg0: string, arg1: any): void;
        debug(arg0: string): void;
        debug(arg0: Internal.Marker_, arg1: string): void;
        debug(arg0: string, arg1: any, arg2: any): void;
        debug(arg0: Internal.Marker_, arg1: string, arg2: any, arg3: any): void;
        debug(arg0: Internal.Marker_, arg1: string, arg2: any): void;
        debug(arg0: Internal.Marker_, arg1: string, arg2: Internal.Throwable_): void;
        debug(arg0: string, arg1: Internal.Throwable_): void;
        getName(): string;
        isInfoEnabled(arg0: Internal.Marker_): boolean;
        isInfoEnabled(): boolean;
        isErrorEnabled(): boolean;
        isErrorEnabled(arg0: Internal.Marker_): boolean;
        isTraceEnabled(arg0: Internal.Marker_): boolean;
        isTraceEnabled(): boolean;
        isWarnEnabled(): boolean;
        isWarnEnabled(arg0: Internal.Marker_): boolean;
        isDebugEnabled(arg0: Internal.Marker_): boolean;
        isDebugEnabled(): boolean;
        error(arg0: string, arg1: any): void;
        error(arg0: string): void;
        error(arg0: string, arg1: any, arg2: any): void;
        error(arg0: string, arg1: any[]): void;
        error(arg0: Internal.Marker_, arg1: string, arg2: any[]): void;
        error(arg0: Internal.Marker_, arg1: string, arg2: any, arg3: any): void;
        error(arg0: Internal.Marker_, arg1: string, arg2: any): void;
        error(arg0: Internal.Marker_, arg1: string): void;
        error(arg0: string, arg1: Internal.Throwable_): void;
        error(arg0: Internal.Marker_, arg1: string, arg2: Internal.Throwable_): void;
        info(arg0: string, arg1: any, arg2: any): void;
        info(arg0: string, arg1: any[]): void;
        info(arg0: string, arg1: Internal.Throwable_): void;
        info(arg0: string, arg1: any): void;
        info(arg0: string): void;
        info(arg0: Internal.Marker_, arg1: string, arg2: Internal.Throwable_): void;
        info(arg0: Internal.Marker_, arg1: string, arg2: any[]): void;
        info(arg0: Internal.Marker_, arg1: string, arg2: any, arg3: any): void;
        info(arg0: Internal.Marker_, arg1: string, arg2: any): void;
        info(arg0: Internal.Marker_, arg1: string): void;
    }
    type Logger_ = Logger;
    abstract class AbstractContainerScreen <T> extends Internal.Screen implements Internal.MenuAccess<T>, net.blay09.mods.balm.mixin.AbstractContainerScreenAccessor, Internal.AccessorAbstractContainerScreen, Internal.AbstractContainerScreenAccessor {
        renderComponentTooltip(arg0: Internal.PoseStack_, arg1: Internal.List_<Internal.FormattedText_>, arg2: number, arg3: number, arg4: net.minecraft.client.gui.Font_): void;
        renderComponentTooltip(arg0: Internal.PoseStack_, arg1: Internal.List_<Internal.FormattedText_>, arg2: number, arg3: number, arg4: Internal.ItemStack_): void;
        renderComponentTooltip(arg0: Internal.PoseStack_, arg1: Internal.List_<Internal.FormattedText_>, arg2: number, arg3: number, arg4: net.minecraft.client.gui.Font_, arg5: Internal.ItemStack_): void;
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        renderTooltip(arg0: Internal.PoseStack_, arg1: Internal.List_<Internal.Component_>, arg2: Internal.Optional_<Internal.TooltipComponent_>, arg3: number, arg4: number, arg5: Internal.ItemStack_): void;
        renderTooltip(arg0: Internal.PoseStack_, arg1: Internal.List_<Internal.Component_>, arg2: Internal.Optional_<Internal.TooltipComponent_>, arg3: number, arg4: number, arg5: net.minecraft.client.gui.Font_): void;
        renderTooltip(arg0: Internal.PoseStack_, arg1: Internal.List_<Internal.Component_>, arg2: Internal.Optional_<Internal.TooltipComponent_>, arg3: number, arg4: number, arg5: net.minecraft.client.gui.Font_, arg6: Internal.ItemStack_): void;
        renderTooltip(arg0: Internal.PoseStack_, arg1: Internal.List_<Internal.FormattedCharSequence_>, arg2: number, arg3: number, arg4: net.minecraft.client.gui.Font_): void;
        notifyAll(): void;
        handler$bmc000$renderSlot(arg0: Internal.PoseStack_, arg1: Internal.Slot_, arg2: Internal.CallbackInfo_): void;
        getYSize(): number;
        getMinecraft(): Internal.Minecraft;
        getGuiTop(): number;
        getGuiLeft(): number;
        notify(): void;
        static renderSlotHighlight(arg0: Internal.PoseStack_, arg1: number, arg2: number, arg3: number, arg4: number): void;
        hashCode(): number;
        equals(arg0: any): boolean;
        getSlotUnderMouse(): Internal.Slot;
        toString(): string;
        getSlotColor(arg0: number): number;
        getXSize(): number;
        tooltipFont : net.minecraft.client.gui.Font;
        get minecraft(): Internal.Minecraft;
        get slotUnderMouse(): Internal.Slot;
        get guiLeft(): number;
        get ySize(): number;
        get xSize(): number;
        get class(): Internal.Class<any>;
        get guiTop(): number;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    type AbstractContainerScreen_<T> = AbstractContainerScreen<T>;
    abstract class SimpleChannelInboundHandler <I> extends Internal.ChannelInboundHandlerAdapter {
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        channelReadComplete(arg0: Internal.ChannelHandlerContext_): void;
        notifyAll(): void;
        exceptionCaught(arg0: Internal.ChannelHandlerContext_, arg1: Internal.Throwable_): void;
        channelActive(arg0: Internal.ChannelHandlerContext_): void;
        handlerAdded(arg0: Internal.ChannelHandlerContext_): void;
        isSharable(): boolean;
        notify(): void;
        handlerRemoved(arg0: Internal.ChannelHandlerContext_): void;
        channelWritabilityChanged(arg0: Internal.ChannelHandlerContext_): void;
        channelRead(arg0: Internal.ChannelHandlerContext_, arg1: any): void;
        channelInactive(arg0: Internal.ChannelHandlerContext_): void;
        channelUnregistered(arg0: Internal.ChannelHandlerContext_): void;
        hashCode(): number;
        equals(arg0: any): boolean;
        toString(): string;
        userEventTriggered(arg0: Internal.ChannelHandlerContext_, arg1: any): void;
        channelRegistered(arg0: Internal.ChannelHandlerContext_): void;
        acceptInboundMessage(arg0: any): boolean;
        get sharable(): boolean;
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    type SimpleChannelInboundHandler_<I> = SimpleChannelInboundHandler<I>;
    class CommandEventJS extends Internal.ServerEventJS {
        cancel(): void;
        getServer(): Internal.ServerJS;
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        isCancelled(): boolean;
        getException(): Internal.Throwable;
        getParseResults(): Internal.ParseResults<Internal.CommandSourceStack>;
        notifyAll(): void;
        setParseResults(parse: Internal.ParseResults_<Internal.CommandSourceStack_>): void;
        notify(): void;
        post(t: Internal.ScriptType_, id: string, sub: string): boolean;
        post(t: Internal.ScriptType_, id: string): boolean;
        hashCode(): number;
        equals(arg0: any): boolean;
        toString(): string;
        setException(exception: Internal.Throwable_): void;
        canCancel(): boolean;
        get exception(): Internal.Throwable;
        get server(): Internal.ServerJS;
        get cancelled(): boolean;
        get class(): Internal.Class<any>;
        get parseResults(): Internal.ParseResults<Internal.CommandSourceStack>;
        set exception(exception: Internal.Throwable_);
        set parseResults(parse: Internal.ParseResults_<Internal.CommandSourceStack_>);
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    type CommandEventJS_ = CommandEventJS;
    class TeamManager {
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        getInternalPlayerTeam(uuid: Internal.UUID_): Internal.PlayerTeam;
        getName(id: Internal.UUID_): Internal.Component;
        notifyAll(): void;
        getKnownPlayers(): Internal.Map<Internal.UUID, Internal.PlayerTeam>;
        save(): void;
        getTeamMap(): Internal.Map<Internal.UUID, Internal.Team>;
        getId(): Internal.UUID;
        notify(): void;
        serializeNBT(): Internal.SNBTCompoundTag;
        load(): void;
        hashCode(): number;
        getServer(): Internal.MinecraftServer;
        getTeamNameMap(): Internal.Map<string, Internal.Team>;
        createServerTeam(player: Internal.ServerPlayer_, name: string): Internal.ServerTeam;
        syncAll(): void;
        getExtraData(): Internal.CompoundTag;
        arePlayersInSameTeam(player1: Internal.ServerPlayer_, player2: Internal.ServerPlayer_): boolean;
        createServer(source: Internal.CommandSourceStack_, name: string): org.apache.commons.lang3.tuple.Pair<number, Internal.ServerTeam>;
        getPlayerTeamID(id: Internal.UUID_): Internal.UUID;
        sync(player: Internal.ServerPlayer_, self: Internal.Team_): void;
        sync(player: Internal.ServerPlayer_): void;
        getTeams(): Internal.Collection<Internal.Team>;
        createClientTeamManager(): Internal.ClientTeamManager;
        createPartyTeam(player: Internal.ServerPlayer_, name: string): Internal.PartyTeam;
        createParty(player: Internal.ServerPlayer_, name: string): org.apache.commons.lang3.tuple.Pair<number, Internal.PartyTeam>;
        equals(arg0: any): boolean;
        getTeamByID(uuid: Internal.UUID_): Internal.Team;
        getPlayerTeam(uuid: Internal.UUID_): Internal.Team;
        getPlayerTeam(player: Internal.ServerPlayer_): Internal.Team;
        saveNow(): void;
        toString(): string;
        playerLoggedOut(player: Internal.ServerPlayer_): void;
        playerLoggedIn(player: Internal.ServerPlayer_, id: Internal.UUID_, name: string): void;
        readonly server : Internal.MinecraftServer;
        static readonly FOLDER_NAME : Internal.LevelResource;
        static INSTANCE : Internal.TeamManager;
        get teamNameMap(): Internal.Map<string, Internal.Team>;
        get knownPlayers(): Internal.Map<Internal.UUID, Internal.PlayerTeam>;
        get teams(): Internal.Collection<Internal.Team>;
        get extraData(): Internal.CompoundTag;
        get teamMap(): Internal.Map<Internal.UUID, Internal.Team>;
        get id(): Internal.UUID;
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    type TeamManager_ = TeamManager;
    interface ByteSet extends Internal.ByteCollection, Internal.Set<number> {
        intIterator(): Internal.IntIterator;
        intSpliterator(): Internal.IntSpliterator;
        remove(arg0: number): boolean;
        remove(arg0: any): boolean;
        intStream(): Internal.IntStream;
        removeAll(arg0: Internal.ByteCollection_): boolean;
        removeAll(arg0: Internal.Collection_<any>): boolean;
        iterator(): Internal.ByteIterator;
        stream(): Internal.Stream<number>;
        hashCode(): number;
        toArray(arg0: number[]): number[];
        toArray<T_>(arg0: T_[]): T_[];
        toArray<T_>(arg0: Internal.IntFunction_<T_[]>): T_[];
        toArray(): any[];
        parallelStream(): Internal.Stream<number>;
        rem(arg0: number): boolean;
        add(arg0: number): boolean;
        spliterator(): Internal.ByteSpliterator;
        forEach(arg0: Internal.Consumer_<number>): void;
        forEach(arg0: Internal.ByteConsumer_): void;
        forEach(arg0: java_.util.function_.IntConsumer_): void;
        containsAll(arg0: Internal.ByteCollection_): boolean;
        containsAll(arg0: Internal.Collection_<any>): boolean;
        isEmpty(): boolean;
        clear(): void;
        removeIf(arg0: Internal.Predicate_<number>): boolean;
        removeIf(arg0: Internal.BytePredicate_): boolean;
        removeIf(arg0: java_.util.function_.IntPredicate_): boolean;
        contains(arg0: any): boolean;
        contains(arg0: number): boolean;
        size(): number;
        addAll(arg0: Internal.ByteCollection_): boolean;
        addAll(arg0: Internal.Collection_<number>): boolean;
        equals(arg0: any): boolean;
        toByteArray(): number[];
        toByteArray(arg0: number[]): number[];
        intParallelStream(): Internal.IntStream;
        retainAll(arg0: Internal.ByteCollection_): boolean;
        retainAll(arg0: Internal.Collection_<any>): boolean;
    }
    type ByteSet_ = ByteSet;
    class Content {
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        hashCode(): number;
        notifyAll(): void;
        equals(arg0: any): boolean;
        getContent(): any;
        toString(): string;
        notify(): void;
        slotName : string;
        chance : number;
        get class(): Internal.Class<any>;
        get content(): any;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    type Content_ = Content;
    interface ItemTooltipEventJS$StaticTooltipHandlerFromJS {
        accept(arg0: Internal.ItemStackJS_, arg1: boolean, arg2: Internal.List_<any>): void;
    }
    type ItemTooltipEventJS$StaticTooltipHandlerFromJS_ = ((arg0: Internal.ItemStackJS, arg1: boolean, arg2: Internal.List<any>) => void) | ItemTooltipEventJS$StaticTooltipHandlerFromJS;
    interface UnaryOperator <T> extends java_.util.function_.Function<T, T> {
        compose<V_>(arg0: java_.util.function_.Function_<V_, T>): java_.util.function_.Function<V_, T>;
        apply(arg0: T): T;
        andThen<V_>(arg0: java_.util.function_.Function_<T, V_>): java_.util.function_.Function<T, V_>;
    }
    type UnaryOperator_<T> = ((arg0: T) => T) | UnaryOperator<T>;
    class RemoveJEIRecipesEvent extends Internal.EventJS {
        cancel(): void;
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        isCancelled(): boolean;
        yeet(category: ResourceLocation_, recipesToYeet: ResourceLocation_[]): void;
        notifyAll(): void;
        notify(): void;
        remove(category: ResourceLocation_, recipesToRemove: ResourceLocation_[]): void;
        post(t: Internal.ScriptType_, id: string, sub: string): boolean;
        post(t: Internal.ScriptType_, id: string): boolean;
        getCategories(): Internal.Collection<Internal.IRecipeCategory<any>>;
        hashCode(): number;
        equals(arg0: any): boolean;
        toString(): string;
        getCategoryIds(): Internal.Collection<ResourceLocation>;
        canCancel(): boolean;
        get categoryIds(): Internal.Collection<ResourceLocation>;
        get cancelled(): boolean;
        get categories(): Internal.Collection<Internal.IRecipeCategory<any>>;
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    type RemoveJEIRecipesEvent_ = RemoveJEIRecipesEvent;
    class Products$P5 <F, T1, T2, T3, T4, T5> {
        t4(): Internal.App<F, T4>;
        getClass(): Internal.Class<any>;
        t5(): Internal.App<F, T5>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        apply<R>(arg0: Internal.Applicative_<F, any>, arg1: Internal.Function5_<T1, T2, T3, T4, T5, R>): Internal.App<F, R>;
        apply<R>(arg0: Internal.Applicative_<F, any>, arg1: Internal.App_<F, Internal.Function5_<T1, T2, T3, T4, T5, R>>): Internal.App<F, R>;
        notifyAll(): void;
        notify(): void;
        hashCode(): number;
        and<T6, T7>(arg0: Internal.Products$P2_<F, T6, T7>): Internal.Products$P7<F, T1, T2, T3, T4, T5, T6, T7>;
        and<T6, T7, T8>(arg0: Internal.Products$P3_<F, T6, T7, T8>): Internal.Products$P8<F, T1, T2, T3, T4, T5, T6, T7, T8>;
        and<T6>(arg0: Internal.App_<F, T6>): Internal.Products$P6<F, T1, T2, T3, T4, T5, T6>;
        equals(arg0: any): boolean;
        toString(): string;
        t1(): Internal.App<F, T1>;
        t2(): Internal.App<F, T2>;
        t3(): Internal.App<F, T3>;
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    type Products$P5_<F, T1, T2, T3, T4, T5> = Products$P5<F, T1, T2, T3, T4, T5>;
    interface ListIterator <E> extends Internal.Iterator<E> {
        next(): E;
        add(arg0: E): void;
        set(arg0: E): void;
        previous(): E;
        hasPrevious(): boolean;
        hasNext(): boolean;
        forEachRemaining(arg0: Internal.Consumer_<E>): void;
        nextIndex(): number;
        previousIndex(): number;
        remove(): void;
    }
    type ListIterator_<E> = ListIterator<E>;
    interface K1 {
    }
    type K1_ = K1;
    class Optional <T> {
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        or(arg0: Internal.Supplier_<Internal.Optional_<T>>): Internal.Optional<T>;
        static ofNullable<T>(arg0: T): Internal.Optional<T>;
        notifyAll(): void;
        isEmpty(): boolean;
        isPresent(): boolean;
        orElse(arg0: T): T;
        notify(): void;
        orElseThrow<X>(arg0: Internal.Supplier_<X>): T;
        orElseThrow(): T;
        static empty<T>(): Internal.Optional<T>;
        flatMap<U>(arg0: java_.util.function_.Function_<T, Internal.Optional_<U>>): Internal.Optional<U>;
        filter(arg0: Internal.Predicate_<T>): Internal.Optional<T>;
        orElseGet(arg0: Internal.Supplier_<T>): T;
        stream(): Internal.Stream<T>;
        hashCode(): number;
        ifPresentOrElse(arg0: Internal.Consumer_<T>, arg1: Internal.Runnable_): void;
        ifPresent(arg0: Internal.Consumer_<T>): void;
        static of<T>(arg0: T): Internal.Optional<T>;
        equals(arg0: any): boolean;
        get(): T;
        toString(): string;
        map<U>(arg0: java_.util.function_.Function_<T, U>): Internal.Optional<U>;
        get present(): boolean;
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    type Optional_<T> = Optional<T>;
    class BlockItem extends Internal.Item implements Internal.IPlaceableItem {
        getClass(): Internal.Class<any>;
        canElytraFly(arg0: Internal.ItemStack_, arg1: Internal.LivingEntity_): boolean;
        setBurnTime(i: number): void;
        setDamage(arg0: Internal.ItemStack_, arg1: number): void;
        canPerformAction(arg0: Internal.ItemStack_, arg1: Internal.ToolAction_): boolean;
        damageItem<T_>(arg0: Internal.ItemStack_, arg1: number, arg2: T_, arg3: Internal.Consumer_<T_>): number;
        shouldCauseBlockBreakReset(arg0: Internal.ItemStack_, arg1: Internal.ItemStack_): boolean;
        getItemEnchantability(arg0: Internal.ItemStack_): number;
        getPlacer(): Internal.BlockPlacerItem;
        shouldCauseReequipAnimation(arg0: Internal.ItemStack_, arg1: Internal.ItemStack_, arg2: boolean): boolean;
        getXpRepairRatio(arg0: Internal.ItemStack_): number;
        readShareTag(arg0: Internal.ItemStack_, arg1: Internal.CompoundTag_): void;
        handler$bcn000$overrideOtherStackedOnMe(arg0: Internal.ItemStack_, arg1: Internal.ItemStack_, arg2: Internal.Slot_, arg3: Internal.ClickAction_, arg4: Internal.Player_, arg5: Internal.SlotAccess_, arg6: Internal.CallbackInfoReturnable_<any>): void;
        onEntityItemUpdate(arg0: Internal.ItemStack_, arg1: Internal.ItemEntity_): boolean;
        getDamage(arg0: Internal.ItemStack_): number;
        isBookEnchantable(arg0: Internal.ItemStack_, arg1: Internal.ItemStack_): boolean;
        canDisableShield(arg0: Internal.ItemStack_, arg1: Internal.ItemStack_, arg2: Internal.LivingEntity_, arg3: Internal.LivingEntity_): boolean;
        onUsingTick(arg0: Internal.ItemStack_, arg1: Internal.LivingEntity_, arg2: number): void;
        isPiglinCurrency(arg0: Internal.ItemStack_): boolean;
        getCreativeTabs(): Internal.Collection<Internal.CreativeModeTab>;
        createEntity(arg0: Internal.Level_, arg1: Internal.Entity_, arg2: Internal.ItemStack_): Internal.Entity;
        getSweepHitBox(arg0: Internal.ItemStack_, arg1: Internal.Player_, arg2: Internal.Entity_): Internal.AABB;
        isRepairable(arg0: Internal.ItemStack_): boolean;
        getPlaceableBlock(): Internal.Block;
        removeFromBlockToItemMap(arg0: Internal.Map_<Internal.Block_, Internal.Item_>, arg1: Internal.Item_): void;
        getShareTag(arg0: Internal.ItemStack_): Internal.CompoundTag;
        getBurnTime(arg0: Internal.ItemStack_, arg1: Internal.RecipeType_<any>): number;
        onDroppedByPlayer(arg0: Internal.ItemStack_, arg1: Internal.Player_): boolean;
        isDamageable(arg0: Internal.ItemStack_): boolean;
        onEntitySwing(arg0: Internal.ItemStack_, arg1: Internal.LivingEntity_): boolean;
        getRegistryType(): Internal.Class<Internal.Item>;
        setItemBuilderKJS(b: Internal.ItemBuilder_): void;
        elytraFlightTick(arg0: Internal.ItemStack_, arg1: Internal.LivingEntity_, arg2: number): boolean;
        getItemBuilderKJS(): Internal.ItemBuilder;
        handler$bcn000$overrideStackedOnOther(arg0: Internal.ItemStack_, arg1: Internal.Slot_, arg2: Internal.ClickAction_, arg3: Internal.Player_, arg4: Internal.CallbackInfoReturnable_<any>): void;
        getAttributeModifiers(arg0: EquipmentSlot_, arg1: Internal.ItemStack_): Internal.Multimap<Internal.Attribute, Internal.AttributeModifier>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        onLeftClickEntity(arg0: Internal.ItemStack_, arg1: Internal.Player_, arg2: Internal.Entity_): boolean;
        canEquip(arg0: Internal.ItemStack_, arg1: EquipmentSlot_, arg2: Internal.Entity_): boolean;
        notifyAll(): void;
        getId(): string;
        notify(): void;
        onBlockStartBreak(arg0: Internal.ItemStack_, arg1: BlockPos_, arg2: Internal.Player_): boolean;
        onHorseArmorTick(arg0: Internal.ItemStack_, arg1: Internal.Level_, arg2: Internal.Mob_): void;
        canContinueUsing(arg0: Internal.ItemStack_, arg1: Internal.ItemStack_): boolean;
        getEntityLifespan(arg0: Internal.ItemStack_, arg1: Internal.Level_): number;
        getRenderPropertiesInternal(): any;
        getArmorTexture(arg0: Internal.ItemStack_, arg1: Internal.Entity_, arg2: EquipmentSlot_, arg3: string): string;
        getDefaultTooltipHideFlags(arg0: Internal.ItemStack_): number;
        hashCode(): number;
        hasCustomEntity(arg0: Internal.ItemStack_): boolean;
        getHighlightTip(arg0: Internal.ItemStack_, arg1: Internal.Component_): Internal.Component;
        canWalkOnPowderedSnow(arg0: Internal.ItemStack_, arg1: Internal.LivingEntity_): boolean;
        initializeClient(arg0: Internal.Consumer_<Internal.IItemRenderProperties_>): void;
        getMaxDamage(arg0: Internal.ItemStack_): number;
        getCreatorModId(arg0: Internal.ItemStack_): string;
        isDamaged(arg0: Internal.ItemStack_): boolean;
        onArmorTick(arg0: Internal.ItemStack_, arg1: Internal.Level_, arg2: Internal.Player_): void;
        hasContainerItem(arg0: Internal.ItemStack_): boolean;
        getFoodProperties(arg0: Internal.ItemStack_, arg1: Internal.LivingEntity_): Internal.FoodProperties;
        doesSneakBypassUse(arg0: Internal.ItemStack_, arg1: Internal.LevelReader_, arg2: BlockPos_, arg3: Internal.Player_): boolean;
        makePlaceable(arg0: Internal.Block_): void;
        onItemUseFirst(arg0: Internal.ItemStack_, arg1: Internal.UseOnContext_): Internal.InteractionResult;
        getContainerItem(arg0: Internal.ItemStack_): Internal.ItemStack;
        getRegistryName(): ResourceLocation;
        setRegistryName(arg0: ResourceLocation_): Internal.Item;
        setRegistryName(arg0: string): Internal.Item;
        setRegistryName(arg0: string, arg1: string): Internal.Item;
        onDestroyed(arg0: Internal.ItemEntity_, arg1: Internal.DamageSource_): void;
        isCorrectToolForDrops(arg0: Internal.ItemStack_, arg1: Internal.BlockState_): boolean;
        getEquipmentSlot(arg0: Internal.ItemStack_): EquipmentSlot;
        getItemStackLimit(arg0: Internal.ItemStack_): number;
        initCapabilities(arg0: Internal.ItemStack_, arg1: Internal.CompoundTag_): Internal.ICapabilityProvider;
        equals(arg0: any): boolean;
        makesPiglinsNeutral(arg0: Internal.ItemStack_, arg1: Internal.LivingEntity_): boolean;
        getTypeData(): Internal.CompoundTag;
        toString(): string;
        isEnderMask(arg0: Internal.ItemStack_, arg1: Internal.Player_, arg2: Internal.EnderMan_): boolean;
        canApplyAtEnchantingTable(arg0: Internal.ItemStack_, arg1: Internal.Enchantment_): boolean;
        readonly delegate : Internal.IRegistryDelegate<Internal.Item>;
        renderProperties : any;
        get registryType(): Internal.Class<Internal.Item>;
        get itemBuilderKJS(): Internal.ItemBuilder;
        get renderPropertiesInternal(): any;
        get placer(): Internal.BlockPlacerItem;
        get placeableBlock(): Internal.Block;
        get creativeTabs(): Internal.Collection<Internal.CreativeModeTab>;
        get id(): string;
        get registryName(): ResourceLocation;
        get typeData(): Internal.CompoundTag;
        get class(): Internal.Class<any>;
        set itemBuilderKJS(b: Internal.ItemBuilder_);
        set burnTime(i: number);
        set registryName(arg0: ResourceLocation_);
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    type BlockItem_ = BlockItem;
    class FireworksJS {
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        hashCode(): number;
        notifyAll(): void;
        equals(arg0: any): boolean;
        static of(o: any): Internal.FireworksJS;
        toString(): string;
        createFireworkRocket(w: Internal.Level_, x: number, y: number, z: number): Internal.FireworkRocketEntity;
        notify(): void;
        flight : number;
        lifetime : number;
        readonly explosions : Internal.List<Internal.FireworksJS$Explosion>;
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    type FireworksJS_ = FireworksJS;
    /**
    * Fired when the generic loot table is registering.
    * Note that this is unused.
    */
    class GenericLootEventJS extends Internal.LootEventJS {
        cancel(): void;
        addGeneric(id: ResourceLocation_, b: Internal.Consumer_<Internal.LootBuilder_>): void;
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        isCancelled(): boolean;
        notifyAll(): void;
        addJson(id: ResourceLocation_, json: Internal.JsonObject_): void;
        notify(): void;
        modify(id: ResourceLocation_, b: Internal.Consumer_<Internal.LootBuilder_>): void;
        removeAll(): void;
        post(t: Internal.ScriptType_, id: string, sub: string): boolean;
        post(t: Internal.ScriptType_, id: string): boolean;
        getType(): string;
        hashCode(): number;
        equals(arg0: any): boolean;
        toString(): string;
        getDirectory(): string;
        canCancel(): boolean;
        get cancelled(): boolean;
        get type(): string;
        get class(): Internal.Class<any>;
        get directory(): string;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    /**
    * Fired when the generic loot table is registering.
    * Note that this is unused.
    */
    type GenericLootEventJS_ = GenericLootEventJS;
    interface BaseStream <T, S> extends Internal.AutoCloseable {
        unordered(): S;
        onClose(arg0: Internal.Runnable_): S;
        iterator(): Internal.Iterator<T>;
        parallel(): S;
        spliterator(): Internal.Spliterator<T>;
        sequential(): S;
        isParallel(): boolean;
        close(): void;
    }
    type BaseStream_<T, S> = BaseStream<T, S>;
    class ModuleLayer$Controller {
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        addReads(arg0: Internal.Module_, arg1: Internal.Module_): Internal.ModuleLayer$Controller;
        hashCode(): number;
        notifyAll(): void;
        equals(arg0: any): boolean;
        addExports(arg0: Internal.Module_, arg1: string, arg2: Internal.Module_): Internal.ModuleLayer$Controller;
        toString(): string;
        addOpens(arg0: Internal.Module_, arg1: string, arg2: Internal.Module_): Internal.ModuleLayer$Controller;
        notify(): void;
        layer(): Internal.ModuleLayer;
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    type ModuleLayer$Controller_ = ModuleLayer$Controller;
    interface BlockAndTintGetter extends Internal.BlockGetter {
        getExistingBlockEntity(arg0: BlockPos_): Internal.BlockEntity;
    }
    type BlockAndTintGetter_ = BlockAndTintGetter;
    class Ingredient implements Internal.Predicate<Internal.ItemStack>, Internal.AccessorIngredient, Internal.IngredientKJS {
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        or(arg0: Internal.Predicate_<Internal.ItemStack_>): Internal.Predicate<Internal.ItemStack>;
        test(arg0: Internal.ItemStack_): boolean;
        checkInvalidation(): boolean;
        notifyAll(): void;
        isVanilla(): boolean;
        asKJS(): any;
        notify(): void;
        static invalidateAll(): void;
        getSerializer(): Internal.IIngredientSerializer<Internal.Ingredient>;
        and(arg0: Internal.Predicate_<Internal.ItemStack_>): Internal.Predicate<Internal.ItemStack>;
        negate(): Internal.Predicate<Internal.ItemStack>;
        hashCode(): number;
        equals(arg0: any): boolean;
        static merge(arg0: Internal.Collection_<Internal.Ingredient_>): Internal.Ingredient;
        isSimple(): boolean;
        toString(): string;
        getItemsKJS(): Internal.ItemStack[];
        static readonly INVALIDATION_COUNTER : Internal.AtomicInteger;
        invalidationCounter : number;
        get serializer(): Internal.IIngredientSerializer<Internal.Ingredient>;
        get itemsKJS(): Internal.ItemStack[];
        get simple(): boolean;
        get class(): Internal.Class<any>;
        get vanilla(): boolean;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    type Ingredient_ = Ingredient;
    interface MessageSender {
        setStatusMessage(message: Internal.Component_): void;
        getName(): Internal.Text;
        getDisplayName(): Internal.Text;
        tell(arg0: Internal.Component_): void;
        runCommand(arg0: string): number;
        runCommandSilent(command: string): number;
    }
    type MessageSender_ = MessageSender;
    interface InputMethodRequests {
        getCommittedTextLength(): number;
        getSelectedText(arg0: Internal.AttributedCharacterIterator$Attribute_[]): Internal.AttributedCharacterIterator;
        getInsertPositionOffset(): number;
        getCommittedText(arg0: number, arg1: number, arg2: Internal.AttributedCharacterIterator$Attribute_[]): Internal.AttributedCharacterIterator;
        getLocationOffset(arg0: number, arg1: number): Internal.TextHitInfo;
        cancelLatestCommittedText(arg0: Internal.AttributedCharacterIterator$Attribute_[]): Internal.AttributedCharacterIterator;
        getTextLocation(arg0: Internal.TextHitInfo_): Internal.Rectangle;
    }
    type InputMethodRequests_ = InputMethodRequests;
    abstract class QuestFile extends Internal.QuestObject {
        getClass(): Internal.Class<any>;
        clearCachedProgress(): void;
        getAllTasks(): Internal.List<Internal.Task>;
        newID(): number;
        getMutableTitle(): Internal.MutableComponent;
        getTags(): Internal.Set<string>;
        static getCodeString(object: Internal.QuestObjectBase_): string;
        getCodeString(): string;
        static getCodeString(id: number): string;
        writeData(nbt: Internal.CompoundTag_): void;
        createSubGroup(group: Internal.ConfigGroup_): Internal.ConfigGroup;
        editedFromGUIOnServer(): void;
        forceProgress(teamData: Internal.TeamData_, progressChange: Internal.ProgressChange_): void;
        getFolder(): Internal.Path;
        isServerSide(): boolean;
        isCompletedRaw(data: Internal.TeamData_): boolean;
        getTitle(): Internal.Component;
        getAllObjects(): Internal.Collection<Internal.QuestObjectBase>;
        deleteObject(arg0: number): void;
        getPath(): string;
        create(type: Internal.QuestObjectType_, parent: number, extra: Internal.CompoundTag_): Internal.QuestObjectBase;
        clearCachedData(): void;
        getRandomLootCrate(entity: Internal.Entity_, random: Internal.Random_): Internal.LootCrate;
        getQuest(id: number): Internal.Quest;
        editedFromGUI(): void;
        static parseCodeString(id: string): number;
        readData(nbt: Internal.CompoundTag_): void;
        hasTag(tag: string): boolean;
        writeNetDataFull(buffer: Internal.FriendlyByteBuf_): void;
        onCompleted(data: Internal.QuestProgressEventData_<any>): void;
        getID(o: any): number;
        static getID(object: Internal.QuestObjectBase_): number;
        isVisible(data: Internal.TeamData_): boolean;
        onEditButtonClicked(gui: Internal.Runnable_): void;
        refreshGui(): void;
        isLoading(): boolean;
        getChildren(): Internal.Collection<Internal.QuestObject>;
        onStarted(data: Internal.QuestProgressEventData_<any>): void;
        refreshIDMap(): void;
        getAltTitle(): Internal.MutableComponent;
        getVisibleChapters(data: Internal.TeamData_): Internal.List<Internal.Chapter>;
        getBase(id: number): Internal.QuestObjectBase;
        deleteSelf(): void;
        collect<T_>(clazz: Internal.Class_<T_>): Internal.List<T_>;
        collect<T_>(filter: Internal.Predicate_<Internal.QuestObjectBase_>): Internal.List<T_>;
        cacheProgress(): boolean;
        readNetDataFull(buffer: Internal.FriendlyByteBuf_): void;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        getSubmitTasks(): Internal.List<Internal.Task>;
        getReward(id: number): Internal.Reward;
        getNullableTeamData(id: Internal.UUID_): Internal.TeamData;
        deleteChildren(): void;
        readNetData(buffer: Internal.FriendlyByteBuf_): void;
        notifyAll(): void;
        canEdit(): boolean;
        getSide(): Internal.Env;
        save(): void;
        getDefaultQuestShape(): string;
        notify(): void;
        getChapter(id: number): Internal.Chapter;
        remove(id: number): Internal.QuestObjectBase;
        getAllData(): Internal.Collection<Internal.TeamData>;
        readDataFull(folder: Internal.Path_): void;
        getRelativeProgressFromChildren(data: Internal.TeamData_): number;
        static getRelativeProgressFromChildren(progressSum: number, count: number): number;
        load(): void;
        hashCode(): number;
        getAltIcon(): Internal.Icon;
        writeDataFull(folder: Internal.Path_): void;
        get(id: number): Internal.QuestObject;
        getObjectType(): Internal.QuestObjectType;
        hasUnclaimedRewardsRaw(teamData: Internal.TeamData_, player: Internal.UUID_): boolean;
        getParentID(): number;
        getData(player: Internal.Entity_): Internal.TeamData;
        getData(teamId: Internal.UUID_): Internal.TeamData;
        getData(team: Internal.TeamBase_): Internal.TeamData;
        getLootCrate(id: string): Internal.LootCrate;
        getProgressColor(data: Internal.TeamData_, dim: boolean): Internal.Color4I;
        getProgressColor(data: Internal.TeamData_): Internal.Color4I;
        updateLootCrates(): void;
        refreshJEI(): number;
        getQuestChapter(): Internal.Chapter;
        getAllChapters(): Internal.List<Internal.Chapter>;
        getFirstVisibleChapter(data: Internal.TeamData_): Internal.Chapter;
        getRewardTable(id: number): Internal.RewardTable;
        addData(data: Internal.TeamData_, override: boolean): void;
        getQuestFile(): Internal.QuestFile;
        writeNetData(buffer: Internal.FriendlyByteBuf_): void;
        getConfig(config: Internal.ConfigGroup_): void;
        getIcon(): Internal.Icon;
        forceProgressRaw(teamData: Internal.TeamData_, progressChange: Internal.ProgressChange_): void;
        readID(tag: net.minecraft.nbt.Tag_): number;
        readID(id: number): number;
        static isNull(object: Internal.QuestObjectBase_): boolean;
        equals(object: any): boolean;
        toString(): string;
        onCreated(): void;
        static titleToID(s: string): Internal.Optional<string>;
        getChapterGroup(id: number): Internal.ChapterGroup;
        getTask(id: number): Internal.Task;
        disableToast : boolean;
        defaultTeamConsumeItems : boolean;
        gridScale : number;
        icon : Internal.ItemStack;
        defaultQuestDisableJEI : boolean;
        title : string;
        readonly rewardTables : Internal.List<Internal.RewardTable>;
        defaultQuestShape : string;
        readonly rewardTypeIds : Internal.Int2ObjectOpenHashMap<Internal.RewardType>;
        readonly lootCrateNoDrop : Internal.EntityWeight;
        lockMessage : string;
        id : number;
        fileVersion : number;
        pauseGame : boolean;
        defaultRewardAutoClaim : Internal.RewardAutoClaim;
        readonly chapterGroups : Internal.List<Internal.ChapterGroup>;
        readonly defaultChapterGroup : Internal.DefaultChapterGroup;
        readonly emergencyItems : Internal.List<Internal.ItemStack>;
        emergencyItemsCooldown : number;
        dropLootCrates : boolean;
        disableGui : boolean;
        readonly taskTypeIds : Internal.Int2ObjectOpenHashMap<Internal.TaskType>;
        static VERSION : 13;
        invalid : boolean;
        static sendNotifications : Internal.Tristate;
        defaultRewardTeam : boolean;
        get side(): Internal.Env;
        get allTasks(): Internal.List<Internal.Task>;
        get codeString(): string;
        get questFile(): Internal.QuestFile;
        get loading(): boolean;
        get allObjects(): Internal.Collection<Internal.QuestObjectBase>;
        get parentID(): number;
        get mutableTitle(): Internal.MutableComponent;
        get tags(): Internal.Set<string>;
        get altIcon(): Internal.Icon;
        get objectType(): Internal.QuestObjectType;
        get serverSide(): boolean;
        get path(): string;
        get allData(): Internal.Collection<Internal.TeamData>;
        get folder(): Internal.Path;
        get children(): Internal.Collection<Internal.QuestObject>;
        get allChapters(): Internal.List<Internal.Chapter>;
        get altTitle(): Internal.MutableComponent;
        get submitTasks(): Internal.List<Internal.Task>;
        get class(): Internal.Class<any>;
        get questChapter(): Internal.Chapter;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    type QuestFile_ = QuestFile;
    interface PlayerAccess {
        botania$setCritTarget(arg0: Internal.LivingEntity_): void;
    }
    type PlayerAccess_ = PlayerAccess;
    class Dialog$ModalExclusionType extends Internal.Enum<Internal.Dialog$ModalExclusionType> {
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        static valueOf(arg0: string): Internal.Dialog$ModalExclusionType;
        static valueOf<T_>(arg0: Internal.Class_<T_>, arg1: string): T_;
        notifyAll(): void;
        static values(): Internal.Dialog$ModalExclusionType[];
        compareTo(arg0: Internal.Dialog$ModalExclusionType_): number;
        describeConstable(): Internal.Optional<Internal.Enum$EnumDesc<Internal.Dialog$ModalExclusionType>>;
        notify(): void;
        getDeclaringClass(): Internal.Class<Internal.Dialog$ModalExclusionType>;
        hashCode(): number;
        equals(arg0: any): boolean;
        name(): string;
        toString(): string;
        ordinal(): number;
        static readonly APPLICATION_EXCLUDE : Internal.Dialog$ModalExclusionType;
        static readonly NO_EXCLUDE : Internal.Dialog$ModalExclusionType;
        static readonly TOOLKIT_EXCLUDE : Internal.Dialog$ModalExclusionType;
        get class(): Internal.Class<any>;
        get declaringClass(): Internal.Class<Internal.Dialog$ModalExclusionType>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    type Dialog$ModalExclusionType_ = "no_exclude" | "toolkit_exclude" | "application_exclude" | Dialog$ModalExclusionType;
    interface LongSet extends Internal.LongCollection, Internal.Set<number> {
        longIterator(): Internal.LongIterator;
        remove(arg0: number): boolean;
        remove(arg0: any): boolean;
        removeAll(arg0: Internal.LongCollection_): boolean;
        removeAll(arg0: Internal.Collection_<any>): boolean;
        iterator(): Internal.LongIterator;
        stream(): Internal.Stream<number>;
        hashCode(): number;
        toArray(arg0: number[]): number[];
        toArray<T_>(arg0: T_[]): T_[];
        toArray<T_>(arg0: Internal.IntFunction_<T_[]>): T_[];
        toArray(): any[];
        longStream(): Internal.LongStream;
        parallelStream(): Internal.Stream<number>;
        rem(arg0: number): boolean;
        add(arg0: number): boolean;
        longSpliterator(): Internal.LongSpliterator;
        toLongArray(arg0: number[]): number[];
        toLongArray(): number[];
        spliterator(): Internal.LongSpliterator;
        forEach(arg0: Internal.Consumer_<number>): void;
        forEach(arg0: java_.util.function_.LongConsumer_): void;
        forEach(arg0: Internal.LongConsumer_): void;
        containsAll(arg0: Internal.LongCollection_): boolean;
        containsAll(arg0: Internal.Collection_<any>): boolean;
        isEmpty(): boolean;
        clear(): void;
        longParallelStream(): Internal.LongStream;
        removeIf(arg0: Internal.LongPredicate_): boolean;
        removeIf(arg0: Internal.Predicate_<number>): boolean;
        removeIf(arg0: it.unimi.dsi.fastutil.longs.LongPredicate_): boolean;
        contains(arg0: any): boolean;
        contains(arg0: number): boolean;
        size(): number;
        addAll(arg0: Internal.LongCollection_): boolean;
        addAll(arg0: Internal.Collection_<number>): boolean;
        equals(arg0: any): boolean;
        retainAll(arg0: Internal.LongCollection_): boolean;
        retainAll(arg0: Internal.Collection_<any>): boolean;
    }
    type LongSet_ = LongSet;
    class WallBlockBuilder extends Internal.ShapedBlockBuilder {
        noItem(): Internal.BlockBuilder;
        suffocating(b: boolean): Internal.BlockBuilder;
        getClass(): Internal.Class<any>;
        translationKey(key: string): Internal.BuilderBase<Internal.Block>;
        newID(pre: string, post: string): ResourceLocation;
        type(type: string): Internal.BuilderBase<Internal.Block>;
        unbreakable(): Internal.BlockBuilder;
        model(m: string): Internal.BlockBuilder;
        tag(tag: ResourceLocation_): Internal.BlockBuilder;
        generateDataJsons(generator: Internal.DataJsonGenerator_): void;
        tagBoth(tag: ResourceLocation_): Internal.BlockBuilder;
        defaultCutout(): Internal.BlockBuilder;
        item(i: Internal.Consumer_<Internal.BlockItemBuilder_>): Internal.BlockBuilder;
        resistance(r: number): Internal.BlockBuilder;
        hardness(h: number): Internal.BlockBuilder;
        slipperiness(f: number): Internal.BlockBuilder;
        getRegistryType(): Internal.RegistryObjectBuilderTypes<Internal.Block>;
        textureSide(direction: Internal.Direction_, tex: string): Internal.BlockBuilder;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        clientRegistry(minecraft: Internal.Minecraft_): void;
        waterlogged(): Internal.BlockBuilder;
        transformObject(obj: Internal.Block_): Internal.Block;
        color(index: number, c: Internal.Color_): Internal.BlockBuilder;
        textureAll(tex: string): Internal.BlockBuilder;
        displayName(name: string): Internal.BuilderBase<Internal.Block>;
        notifyAll(): void;
        box(x0: number, y0: number, z0: number, x1: number, y1: number, z1: number): Internal.BlockBuilder;
        box(x0: number, y0: number, z0: number, x1: number, y1: number, z1: number, scale16: boolean): Internal.BlockBuilder;
        viewBlocking(b: boolean): Internal.BlockBuilder;
        notify(): void;
        transparent(b: boolean): Internal.BlockBuilder;
        createAdditionalObjects(): void;
        tagBlock(tag: ResourceLocation_): Internal.BlockBuilder;
        fullBlock(f: boolean): Internal.BlockBuilder;
        createProperties(): Internal.BlockBehaviour$Properties;
        notSolid(): Internal.BlockBuilder;
        generateBlockModels(builder: Internal.BlockBuilder_): Internal.Map<ResourceLocation, Internal.JsonObject>;
        hashCode(): number;
        noCollission(): Internal.BlockBuilder;
        get(): Internal.Block;
        requiresTool(f: boolean): Internal.BlockBuilder;
        renderType(l: string): Internal.BlockBuilder;
        jumpFactor(f: number): Internal.BlockBuilder;
        createShape(): Internal.VoxelShape;
        generateAssetJsons(generator: Internal.AssetJsonGenerator_): void;
        noCollision(): Internal.BlockBuilder;
        opaque(o: boolean): Internal.BlockBuilder;
        randomTick(randomTickCallback: Internal.Consumer_<Internal.RandomTickCallbackJS_>): Internal.BlockBuilder;
        getTranslationKeyGroup(): string;
        texture(id: string, tex: string): Internal.BlockBuilder;
        noDrops(): Internal.BlockBuilder;
        generateLang(lang: Internal.Map_<string, string>): void;
        tagItem(tag: ResourceLocation_): Internal.BlockBuilder;
        speedFactor(f: number): Internal.BlockBuilder;
        noValidSpawns(b: boolean): Internal.BlockBuilder;
        createObject(): Internal.Block;
        lightLevel(light: number): Internal.BlockBuilder;
        addResourcePackLocations(path: string, list: Internal.List_<ResourceLocation_>, packType: Internal.PackType_): void;
        defaultTranslucent(): Internal.BlockBuilder;
        material(m: Internal.MaterialJS_): Internal.BlockBuilder;
        equals(arg0: any): boolean;
        toString(): string;
        redstoneConductor(b: boolean): Internal.BlockBuilder;
        lootTable : ((arg0: Internal.LootBuilder) => void);
        modelJson : Internal.JsonObject;
        blockstateJson : Internal.JsonObject;
        readonly id : ResourceLocation;
        randomTickCallback : ((arg0: Internal.RandomTickCallbackJS) => void);
        get registryType(): Internal.RegistryObjectBuilderTypes<Internal.Block>;
        get class(): Internal.Class<any>;
        get translationKeyGroup(): string;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    type WallBlockBuilder_ = WallBlockBuilder;
    interface Int2BooleanFunction extends Internal.Function<number, boolean>, java_.util.function_.IntPredicate {
        getOrDefault(arg0: any, arg1: boolean): boolean;
        getOrDefault(arg0: number, arg1: boolean): boolean;
        andThenShort(arg0: Internal.Boolean2ShortFunction_): Internal.Int2ShortFunction;
        composeByte(arg0: Internal.Byte2IntFunction_): Internal.Byte2BooleanFunction;
        andThenInt(arg0: Internal.Boolean2IntFunction_): Internal.Int2IntFunction;
        composeReference<T_>(arg0: Internal.Reference2IntFunction_<T_>): Internal.Reference2BooleanFunction<T_>;
        andThen<T_>(arg0: java_.util.function_.Function_<boolean, T_>): java_.util.function_.Function<number, T_>;
        put(arg0: number, arg1: boolean): boolean;
        remove(arg0: number): boolean;
        remove(arg0: any): boolean;
        defaultReturnValue(): boolean;
        defaultReturnValue(arg0: boolean): void;
        andThenDouble(arg0: Internal.Boolean2DoubleFunction_): Internal.Int2DoubleFunction;
        andThenObject<T_>(arg0: Internal.Boolean2ObjectFunction_<T_>): Internal.Int2ObjectFunction<T_>;
        and(arg0: java_.util.function_.IntPredicate_): java_.util.function_.IntPredicate;
        get(arg0: any): boolean;
        get(arg0: number): boolean;
        andThenLong(arg0: Internal.Boolean2LongFunction_): Internal.Int2LongFunction;
        composeLong(arg0: Internal.Long2IntFunction_): Internal.Long2BooleanFunction;
        andThenByte(arg0: Internal.Boolean2ByteFunction_): Internal.Int2ByteFunction;
        andThenFloat(arg0: Internal.Boolean2FloatFunction_): Internal.Int2FloatFunction;
        or(arg0: java_.util.function_.IntPredicate_): java_.util.function_.IntPredicate;
        test(arg0: number): boolean;
        apply(arg0: number): boolean;
        containsKey(arg0: number): boolean;
        containsKey(arg0: any): boolean;
        composeInt(arg0: Internal.Int2IntFunction_): Internal.Int2BooleanFunction;
        clear(): void;
        composeFloat(arg0: Internal.Float2IntFunction_): Internal.Float2BooleanFunction;
        andThenChar(arg0: Internal.Boolean2CharFunction_): Internal.Int2CharFunction;
        composeObject<T_>(arg0: Internal.Object2IntFunction_<T_>): Internal.Object2BooleanFunction<T_>;
        size(): number;
        compose<T_>(arg0: java_.util.function_.Function_<T_, number>): java_.util.function_.Function<T_, boolean>;
        negate(): java_.util.function_.IntPredicate;
        composeShort(arg0: Internal.Short2IntFunction_): Internal.Short2BooleanFunction;
        andThenReference<T_>(arg0: Internal.Boolean2ReferenceFunction_<T_>): Internal.Int2ReferenceFunction<T_>;
        composeChar(arg0: Internal.Char2IntFunction_): Internal.Char2BooleanFunction;
        composeDouble(arg0: Internal.Double2IntFunction_): Internal.Double2BooleanFunction;
    }
    type Int2BooleanFunction_ = ((arg0: number) => boolean) | Int2BooleanFunction;
    abstract class PlacementModifier {
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        hashCode(): number;
        notifyAll(): void;
        equals(arg0: any): boolean;
        toString(): string;
        notify(): void;
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    type PlacementModifier_ = PlacementModifier;
    interface MapCodec$ResultFunction <A> {
        apply<T>(arg0: Internal.DynamicOps_<T>, arg1: Internal.MapLike_<T>, arg2: Internal.DataResult_<A>): Internal.DataResult<A>;
        coApply<T>(arg0: Internal.DynamicOps_<T>, arg1: A, arg2: Internal.RecordBuilder_<T>): Internal.RecordBuilder<T>;
    }
    type MapCodec$ResultFunction_<A> = MapCodec$ResultFunction<A>;
    class PainterUpdatedEventJS extends Internal.ClientEventJS {
        cancel(): void;
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        isCancelled(): boolean;
        getPlayer(): Internal.ClientPlayerJS;
        notifyAll(): void;
        getEntity(): Internal.EntityJS;
        notify(): void;
        getLevel(): Internal.ClientLevelJS;
        post(id: string): boolean;
        post(id: string, sub: string): boolean;
        post(t: Internal.ScriptType_, id: string, sub: string): boolean;
        post(t: Internal.ScriptType_, id: string): boolean;
        hashCode(): number;
        equals(arg0: any): boolean;
        toString(): string;
        canCancel(): boolean;
        get level(): Internal.ClientLevelJS;
        get cancelled(): boolean;
        get class(): Internal.Class<any>;
        get entity(): Internal.EntityJS;
        get player(): Internal.ClientPlayerJS;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    type PainterUpdatedEventJS_ = PainterUpdatedEventJS;
    class ModelGenerator {
        getClass(): Internal.Class<any>;
        parent(s: string): void;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        toJson(): Internal.JsonObject;
        textures(json: Internal.JsonObject_): void;
        hashCode(): number;
        texture(name: string, texture: string): void;
        notifyAll(): void;
        equals(arg0: any): boolean;
        toString(): string;
        notify(): void;
        element(consumer: Internal.Consumer_<Internal.ModelGenerator$Element_>): void;
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    type ModelGenerator_ = ModelGenerator;
    interface ImageConsumer {
        imageComplete(arg0: number): void;
        setPixels(arg0: number, arg1: number, arg2: number, arg3: number, arg4: Internal.ColorModel_, arg5: number[], arg6: number, arg7: number): void;
        setProperties(arg0: Internal.Hashtable_<any, any>): void;
        setDimensions(arg0: number, arg1: number): void;
        setHints(arg0: number): void;
        setColorModel(arg0: Internal.ColorModel_): void;
    }
    type ImageConsumer_ = ImageConsumer;
    interface MouseListener extends Internal.EventListener {
        mouseReleased(arg0: Internal.MouseEvent_): void;
        mouseExited(arg0: Internal.MouseEvent_): void;
        mouseEntered(arg0: Internal.MouseEvent_): void;
        mouseClicked(arg0: Internal.MouseEvent_): void;
        mousePressed(arg0: Internal.MouseEvent_): void;
    }
    type MouseListener_ = MouseListener;
    class UnboundedMapCodec <K, V> implements Internal.BaseMapCodec<K, V>, Internal.Codec<Internal.Map<K, V>> {
        encode<T_>(arg0: Internal.Map_<K, V>, arg1: Internal.DynamicOps_<T_>, arg2: T_): Internal.DataResult<T_>;
        encode<T_>(arg0: Internal.Map_<K, V>, arg1: Internal.DynamicOps_<T_>, arg2: Internal.RecordBuilder_<T_>): Internal.RecordBuilder<T_>;
        getClass(): Internal.Class<any>;
        flatComapMap<S_>(arg0: java_.util.function_.Function_<Internal.Map_<K, V>, S_>, arg1: java_.util.function_.Function_<S_, Internal.DataResult_<Internal.Map_<K, V>>>): Internal.Codec<S_>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        dispatch<E_>(arg0: java_.util.function_.Function_<E_, Internal.Map_<K, V>>, arg1: java_.util.function_.Function_<Internal.Map_<K, V>, Internal.Codec_<E_>>): Internal.Codec<E_>;
        dispatch<E_>(arg0: string, arg1: java_.util.function_.Function_<E_, Internal.Map_<K, V>>, arg2: java_.util.function_.Function_<Internal.Map_<K, V>, Internal.Codec_<E_>>): Internal.Codec<E_>;
        deprecated(arg0: number): Internal.Codec<Internal.Map<K, V>>;
        notifyAll(): void;
        simple(): Internal.Decoder$Simple<Internal.Map<K, V>>;
        dispatchMap<E_>(arg0: string, arg1: java_.util.function_.Function_<E_, Internal.Map_<K, V>>, arg2: java_.util.function_.Function_<Internal.Map_<K, V>, Internal.Codec_<E_>>): Internal.MapCodec<E_>;
        dispatchMap<E_>(arg0: java_.util.function_.Function_<E_, Internal.Map_<K, V>>, arg1: java_.util.function_.Function_<Internal.Map_<K, V>, Internal.Codec_<E_>>): Internal.MapCodec<E_>;
        comapFlatMap<S_>(arg0: java_.util.function_.Function_<Internal.Map_<K, V>, Internal.DataResult_<S_>>, arg1: java_.util.function_.Function_<S_, Internal.Map_<K, V>>): Internal.Codec<S_>;
        decode<T_>(arg0: Internal.DynamicOps_<T_>, arg1: T_): Internal.DataResult<Internal.Pair<Internal.Map<K, V>, T_>>;
        decode<T_>(arg0: Internal.DynamicOps_<T_>, arg1: Internal.MapLike_<T_>): Internal.DataResult<Internal.Map<K, V>>;
        decode<T_>(arg0: Internal.Dynamic_<T_>): Internal.DataResult<Internal.Pair<Internal.Map<K, V>, T_>>;
        notify(): void;
        promotePartial(arg0: Internal.Consumer_<string>): Internal.Codec<Internal.Map<K, V>>;
        flatXmap<S_>(arg0: java_.util.function_.Function_<Internal.Map_<K, V>, Internal.DataResult_<S_>>, arg1: java_.util.function_.Function_<S_, Internal.DataResult_<Internal.Map_<K, V>>>): Internal.Codec<S_>;
        hashCode(): number;
        comap<B_>(arg0: java_.util.function_.Function_<B_, Internal.Map_<K, V>>): Internal.Encoder<B_>;
        fieldOf(arg0: string): Internal.MapCodec<Internal.Map<K, V>>;
        xmap<S_>(arg0: java_.util.function_.Function_<Internal.Map_<K, V>, S_>, arg1: java_.util.function_.Function_<S_, Internal.Map_<K, V>>): Internal.Codec<S_>;
        listOf(): Internal.Codec<Internal.List<Internal.Map<K, V>>>;
        map<B_>(arg0: java_.util.function_.Function_<Internal.Map_<K, V>, B_>): Internal.Decoder<B_>;
        encodeStart<T_>(arg0: Internal.DynamicOps_<T_>, arg1: Internal.Map_<K, V>): Internal.DataResult<T_>;
        optionalFieldOf(arg0: string, arg1: Internal.Map_<K, V>, arg2: Internal.Lifecycle_): Internal.MapCodec<Internal.Map<K, V>>;
        optionalFieldOf(arg0: string, arg1: Internal.Map_<K, V>): Internal.MapCodec<Internal.Map<K, V>>;
        optionalFieldOf(arg0: string): Internal.MapCodec<Internal.Optional<Internal.Map<K, V>>>;
        optionalFieldOf(arg0: string, arg1: Internal.Lifecycle_, arg2: Internal.Map_<K, V>, arg3: Internal.Lifecycle_): Internal.MapCodec<Internal.Map<K, V>>;
        flatComap<B_>(arg0: java_.util.function_.Function_<B_, Internal.DataResult_<Internal.Map_<K, V>>>): Internal.Encoder<B_>;
        keyCodec(): Internal.Codec<K>;
        partialDispatch<E_>(arg0: string, arg1: java_.util.function_.Function_<E_, Internal.DataResult_<Internal.Map_<K, V>>>, arg2: java_.util.function_.Function_<Internal.Map_<K, V>, Internal.DataResult_<Internal.Codec_<E_>>>): Internal.Codec<E_>;
        terminal(): Internal.Decoder$Terminal<Internal.Map<K, V>>;
        parse<T_>(arg0: Internal.DynamicOps_<T_>, arg1: T_): Internal.DataResult<Internal.Map<K, V>>;
        parse<T_>(arg0: Internal.Dynamic_<T_>): Internal.DataResult<Internal.Map<K, V>>;
        withLifecycle(arg0: Internal.Lifecycle_): Internal.Codec<Internal.Map<K, V>>;
        orElse(arg0: Internal.Map_<K, V>): Internal.Codec<Internal.Map<K, V>>;
        orElse(arg0: Internal.Consumer_<string>, arg1: Internal.Map_<K, V>): Internal.Codec<Internal.Map<K, V>>;
        orElse(arg0: Internal.UnaryOperator_<string>, arg1: Internal.Map_<K, V>): Internal.Codec<Internal.Map<K, V>>;
        flatMap<B_>(arg0: java_.util.function_.Function_<Internal.Map_<K, V>, Internal.DataResult_<B_>>): Internal.Decoder<B_>;
        elementCodec(): Internal.Codec<V>;
        boxed(): Internal.Decoder$Boxed<Internal.Map<K, V>>;
        dispatchStable<E_>(arg0: java_.util.function_.Function_<E_, Internal.Map_<K, V>>, arg1: java_.util.function_.Function_<Internal.Map_<K, V>, Internal.Codec_<E_>>): Internal.Codec<E_>;
        orElseGet(arg0: Internal.Consumer_<string>, arg1: Internal.Supplier_<Internal.Map_<K, V>>): Internal.Codec<Internal.Map<K, V>>;
        orElseGet(arg0: Internal.Supplier_<Internal.Map_<K, V>>): Internal.Codec<Internal.Map<K, V>>;
        orElseGet(arg0: Internal.UnaryOperator_<string>, arg1: Internal.Supplier_<Internal.Map_<K, V>>): Internal.Codec<Internal.Map<K, V>>;
        stable(): Internal.Codec<Internal.Map<K, V>>;
        equals(arg0: any): boolean;
        mapResult(arg0: Internal.Codec$ResultFunction_<Internal.Map_<K, V>>): Internal.Codec<Internal.Map<K, V>>;
        toString(): string;
        static readonly FLOAT : Internal.PrimitiveCodec<number>;
        static readonly INT : Internal.PrimitiveCodec<number>;
        static readonly SHORT : Internal.PrimitiveCodec<number>;
        static readonly PASSTHROUGH : Internal.Codec<Internal.Dynamic<any>>;
        static readonly BOOL : Internal.PrimitiveCodec<boolean>;
        static readonly BYTE_BUFFER : Internal.PrimitiveCodec<Internal.ByteBuffer>;
        static readonly INT_STREAM : Internal.PrimitiveCodec<Internal.IntStream>;
        static readonly BYTE : Internal.PrimitiveCodec<number>;
        static readonly LONG_STREAM : Internal.PrimitiveCodec<Internal.LongStream>;
        static readonly STRING : Internal.PrimitiveCodec<string>;
        static readonly DOUBLE : Internal.PrimitiveCodec<number>;
        static readonly EMPTY : Internal.MapCodec<Internal.Unit>;
        static readonly LONG : Internal.PrimitiveCodec<number>;
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    type UnboundedMapCodec_<K, V> = UnboundedMapCodec<K, V>;
    interface Compressable extends Internal.Keyable {
        keys<T_>(arg0: Internal.DynamicOps_<T_>): Internal.Stream<T_>;
        compressor<T_>(arg0: Internal.DynamicOps_<T_>): Internal.KeyCompressor<T_>;
    }
    type Compressable_ = Compressable;
    class InteractionResult extends Internal.Enum<Internal.InteractionResult> {
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        static valueOf(arg0: string): Internal.InteractionResult;
        static valueOf<T_>(arg0: Internal.Class_<T_>, arg1: string): T_;
        notifyAll(): void;
        static values(): Internal.InteractionResult[];
        compareTo(arg0: Internal.InteractionResult_): number;
        describeConstable(): Internal.Optional<Internal.Enum$EnumDesc<Internal.InteractionResult>>;
        notify(): void;
        getDeclaringClass(): Internal.Class<Internal.InteractionResult>;
        hashCode(): number;
        equals(arg0: any): boolean;
        name(): string;
        toString(): string;
        ordinal(): number;
        static readonly SUCCESS : Internal.InteractionResult;
        static readonly PASS : Internal.InteractionResult;
        static readonly CONSUME_PARTIAL : Internal.InteractionResult;
        static readonly CONSUME : Internal.InteractionResult;
        static readonly FAIL : Internal.InteractionResult;
        get class(): Internal.Class<any>;
        get declaringClass(): Internal.Class<Internal.InteractionResult>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    type InteractionResult_ = "fail" | "pass" | "success" | "consume" | "consume_partial" | InteractionResult;
    abstract class InputStream implements Internal.Closeable {
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        read(arg0: number[], arg1: number, arg2: number): number;
        read(arg0: number[]): number;
        read(): number;
        markSupported(): boolean;
        notifyAll(): void;
        available(): number;
        static nullInputStream(): Internal.InputStream;
        skip(arg0: number): number;
        transferTo(arg0: Internal.OutputStream_): number;
        notify(): void;
        hashCode(): number;
        equals(arg0: any): boolean;
        readAllBytes(): number[];
        reset(): void;
        readNBytes(arg0: number): number[];
        readNBytes(arg0: number[], arg1: number, arg2: number): number;
        toString(): string;
        close(): void;
        skipNBytes(arg0: number): void;
        mark(arg0: number): void;
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    type InputStream_ = InputStream;
    class IngredientWithCustomPredicateJS implements Internal.IngredientJS {
        anyStackMatches(ingredient: Internal.IngredientJS_): boolean;
        getItemIds(): Internal.Set<string>;
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        getStacks(): Internal.Set<Internal.ItemStackJS>;
        getVanillaItems(): Internal.Set<Internal.Item>;
        notifyAll(): void;
        isInvalidRecipeIngredient(): boolean;
        notify(): void;
        not(): Internal.IngredientJS;
        hashCode(): number;
        getFirst(): Internal.ItemStackJS;
        copy(): Internal.IngredientJS;
        getCount(): number;
        testVanillaItem(i: Internal.Item_): boolean;
        test(stack: Internal.ItemStackJS_): boolean;
        isEmpty(): boolean;
        asIngredientStack(): Internal.IngredientStackJS;
        getVanillaPredicate(): Internal.Predicate<Internal.ItemStack>;
        filter(filter: Internal.IngredientJS_): Internal.IngredientJS;
        createVanillaIngredient(): Internal.Ingredient;
        toJson(): Internal.JsonElement;
        withCount(count: number): Internal.IngredientJS;
        unwrapStackIngredient(): Internal.List<Internal.IngredientJS>;
        equals(arg0: any): boolean;
        testVanilla(stack: Internal.ItemStack_): boolean;
        x(c: number): Internal.IngredientJS;
        toString(): string;
        readonly predicate : ((arg0: Internal.ItemStack) => boolean);
        readonly ingredient : ((arg0: Internal.ItemStackJS) => boolean);
        readonly uuid : Internal.UUID;
        get invalidRecipeIngredient(): boolean;
        get stacks(): Internal.Set<Internal.ItemStackJS>;
        get itemIds(): Internal.Set<string>;
        get count(): number;
        get class(): Internal.Class<any>;
        get vanillaItems(): Internal.Set<Internal.Item>;
        get first(): Internal.ItemStackJS;
        get empty(): boolean;
        get vanillaPredicate(): Internal.Predicate<Internal.ItemStack>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    type IngredientWithCustomPredicateJS_ = IngredientWithCustomPredicateJS;
    class CodeSource implements Internal.Serializable {
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        getLocation(): Internal.URL;
        getCodeSigners(): any[];
        hashCode(): number;
        notifyAll(): void;
        equals(arg0: any): boolean;
        getCertificates(): any[];
        toString(): string;
        implies(arg0: Internal.CodeSource_): boolean;
        notify(): void;
        get codeSigners(): any[];
        get certificates(): any[];
        get location(): Internal.URL;
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    type CodeSource_ = CodeSource;
    class VariantBlockStateGenerator {
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        toJson(): Internal.JsonObject;
        hashCode(): number;
        notifyAll(): void;
        equals(arg0: any): boolean;
        variant(key: string, model: string): void;
        variant(key: string, consumer: Internal.Consumer_<Internal.VariantBlockStateGenerator$Variant_>): void;
        toString(): string;
        notify(): void;
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    type VariantBlockStateGenerator_ = VariantBlockStateGenerator;
    class RenderContext implements Internal.Cloneable {
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        preConcetenateTransform(arg0: Internal.AffineTransform_): void;
        getAreaOfInterest(): Internal.Shape;
        concetenateTransform(arg0: Internal.AffineTransform_): void;
        setAreaOfInterest(arg0: Internal.Shape_): void;
        notifyAll(): void;
        getRenderingHints(): Internal.RenderingHints;
        notify(): void;
        setTransform(arg0: Internal.AffineTransform_): void;
        hashCode(): number;
        equals(arg0: any): boolean;
        preConcatenateTransform(arg0: Internal.AffineTransform_): void;
        setRenderingHints(arg0: Internal.RenderingHints_): void;
        concatenateTransform(arg0: Internal.AffineTransform_): void;
        clone(): any;
        toString(): string;
        getTransform(): Internal.AffineTransform;
        get transform(): Internal.AffineTransform;
        get areaOfInterest(): Internal.Shape;
        get renderingHints(): Internal.RenderingHints;
        get class(): Internal.Class<any>;
        set transform(arg0: Internal.AffineTransform_);
        set areaOfInterest(arg0: Internal.Shape_);
        set renderingHints(arg0: Internal.RenderingHints_);
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    type RenderContext_ = RenderContext;
    class Throwable implements Internal.Serializable {
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        printStackTrace(): void;
        printStackTrace(arg0: Internal.PrintWriter_): void;
        printStackTrace(arg0: Internal.PrintStream_): void;
        getLocalizedMessage(): string;
        notifyAll(): void;
        initCause(arg0: Internal.Throwable_): Internal.Throwable;
        getMessage(): string;
        getCause(): Internal.Throwable;
        notify(): void;
        addSuppressed(arg0: Internal.Throwable_): void;
        setStackTrace(arg0: any_[]): void;
        getStackTrace(): any[];
        hashCode(): number;
        equals(arg0: any): boolean;
        getSuppressed(): Internal.Throwable[];
        toString(): string;
        fillInStackTrace(): Internal.Throwable;
        get localizedMessage(): string;
        get cause(): Internal.Throwable;
        get stackTrace(): any[];
        get suppressed(): Internal.Throwable[];
        get message(): string;
        get class(): Internal.Class<any>;
        set stackTrace(arg0: any_[]);
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    type Throwable_ = Throwable;
    class JobAttributes$DefaultSelectionType extends Internal.AttributeValue {
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        notifyAll(): void;
        equals(arg0: any): boolean;
        notify(): void;
        static readonly ALL : Internal.JobAttributes$DefaultSelectionType;
        static readonly SELECTION : Internal.JobAttributes$DefaultSelectionType;
        static readonly RANGE : Internal.JobAttributes$DefaultSelectionType;
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    type JobAttributes$DefaultSelectionType_ = JobAttributes$DefaultSelectionType;
    interface Runnable {
        run(): void;
    }
    type Runnable_ = (() => void) | Runnable;
    interface ChannelFuture extends io.netty.util.concurrent.Future<void> {
        cancel(arg0: boolean): boolean;
        isCancelled(): boolean;
        removeListeners(arg0: Internal.GenericFutureListener_<io.netty.util.concurrent.Future_<void>>[]): Internal.ChannelFuture;
        removeListeners(arg0: Internal.GenericFutureListener_<io.netty.util.concurrent.Future_<void>>[]): io.netty.util.concurrent.Future<void>;
        getNow(): void;
        channel(): io.netty.channel.Channel;
        cause(): Internal.Throwable;
        awaitUninterruptibly(): Internal.ChannelFuture;
        awaitUninterruptibly(): io.netty.util.concurrent.Future<void>;
        awaitUninterruptibly(arg0: number, arg1: Internal.TimeUnit_): boolean;
        awaitUninterruptibly(arg0: number): boolean;
        removeListener(arg0: Internal.GenericFutureListener_<io.netty.util.concurrent.Future_<void>>): Internal.ChannelFuture;
        removeListener(arg0: Internal.GenericFutureListener_<io.netty.util.concurrent.Future_<void>>): io.netty.util.concurrent.Future<void>;
        isDone(): boolean;
        sync(): Internal.ChannelFuture;
        sync(): io.netty.util.concurrent.Future<void>;
        isVoid(): boolean;
        syncUninterruptibly(): Internal.ChannelFuture;
        syncUninterruptibly(): io.netty.util.concurrent.Future<void>;
        get(arg0: number, arg1: Internal.TimeUnit_): void;
        get(): void;
        isCancellable(): boolean;
        await(): Internal.ChannelFuture;
        await(): io.netty.util.concurrent.Future<void>;
        await(arg0: number, arg1: Internal.TimeUnit_): boolean;
        await(arg0: number): boolean;
        addListeners(arg0: Internal.GenericFutureListener_<io.netty.util.concurrent.Future_<void>>[]): Internal.ChannelFuture;
        addListeners(arg0: Internal.GenericFutureListener_<io.netty.util.concurrent.Future_<void>>[]): io.netty.util.concurrent.Future<void>;
        isSuccess(): boolean;
        addListener(arg0: Internal.GenericFutureListener_<io.netty.util.concurrent.Future_<void>>): Internal.ChannelFuture;
        addListener(arg0: Internal.GenericFutureListener_<io.netty.util.concurrent.Future_<void>>): io.netty.util.concurrent.Future<void>;
    }
    type ChannelFuture_ = ChannelFuture;
    class RandomTickCallbackJS {
        getServer(): Internal.ServerJS;
        getClass(): Internal.Class<any>;
        getLevel(): Internal.LevelJS;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        hashCode(): number;
        notifyAll(): void;
        equals(arg0: any): boolean;
        toString(): string;
        notify(): void;
        random : Internal.Random;
        block : Internal.BlockContainerJS;
        get server(): Internal.ServerJS;
        get level(): Internal.LevelJS;
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    type RandomTickCallbackJS_ = RandomTickCallbackJS;
    class PageAttributes implements Internal.Cloneable {
        setOrientationRequestedToDefault(): void;
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        getOrientationRequested(): Internal.PageAttributes$OrientationRequestedType;
        getMedia(): Internal.PageAttributes$MediaType;
        set(arg0: Internal.PageAttributes_): void;
        getOrigin(): Internal.PageAttributes$OriginType;
        setOrigin(arg0: Internal.PageAttributes$OriginType_): void;
        notifyAll(): void;
        setPrintQualityToDefault(): void;
        getColor(): Internal.PageAttributes$ColorType;
        setOrientationRequested(arg0: number): void;
        setOrientationRequested(arg0: Internal.PageAttributes$OrientationRequestedType_): void;
        setPrinterResolutionToDefault(): void;
        notify(): void;
        setPrintQuality(arg0: number): void;
        setPrintQuality(arg0: Internal.PageAttributes$PrintQualityType_): void;
        getPrintQuality(): Internal.PageAttributes$PrintQualityType;
        setMediaToDefault(): void;
        setColor(arg0: Internal.PageAttributes$ColorType_): void;
        getPrinterResolution(): number[];
        hashCode(): number;
        equals(arg0: any): boolean;
        clone(): any;
        setMedia(arg0: Internal.PageAttributes$MediaType_): void;
        toString(): string;
        setPrinterResolution(arg0: number): void;
        setPrinterResolution(arg0: number[]): void;
        get color(): Internal.PageAttributes$ColorType;
        get orientationRequested(): Internal.PageAttributes$OrientationRequestedType;
        get origin(): Internal.PageAttributes$OriginType;
        get printerResolution(): number[];
        get printQuality(): Internal.PageAttributes$PrintQualityType;
        get media(): Internal.PageAttributes$MediaType;
        get class(): Internal.Class<any>;
        set color(arg0: Internal.PageAttributes$ColorType_);
        set orientationRequested(arg0: Internal.PageAttributes$OrientationRequestedType_);
        set printerResolution(arg0: number[]);
        set origin(arg0: Internal.PageAttributes$OriginType_);
        set printQuality(arg0: Internal.PageAttributes$PrintQualityType_);
        set media(arg0: Internal.PageAttributes$MediaType_);
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    type PageAttributes_ = PageAttributes;
    class ModuleDescriptor$Exports$Modifier extends Internal.Enum<Internal.ModuleDescriptor$Exports$Modifier> {
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        static valueOf(arg0: string): Internal.ModuleDescriptor$Exports$Modifier;
        static valueOf<T_>(arg0: Internal.Class_<T_>, arg1: string): T_;
        notifyAll(): void;
        static values(): Internal.ModuleDescriptor$Exports$Modifier[];
        compareTo(arg0: Internal.ModuleDescriptor$Exports$Modifier_): number;
        describeConstable(): Internal.Optional<Internal.Enum$EnumDesc<Internal.ModuleDescriptor$Exports$Modifier>>;
        notify(): void;
        getDeclaringClass(): Internal.Class<Internal.ModuleDescriptor$Exports$Modifier>;
        hashCode(): number;
        equals(arg0: any): boolean;
        name(): string;
        toString(): string;
        ordinal(): number;
        static readonly SYNTHETIC : Internal.ModuleDescriptor$Exports$Modifier;
        static readonly MANDATED : Internal.ModuleDescriptor$Exports$Modifier;
        get class(): Internal.Class<any>;
        get declaringClass(): Internal.Class<Internal.ModuleDescriptor$Exports$Modifier>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    type ModuleDescriptor$Exports$Modifier_ = "synthetic" | "mandated" | ModuleDescriptor$Exports$Modifier;
    abstract class CommandNode <S> implements Internal.Comparable<Internal.CommandNode<S>> {
        getClass(): Internal.Class<any>;
        getRedirectModifier(): Internal.RedirectModifier<S>;
        getRelevantNodes(arg0: Internal.StringReader_): Internal.Collection<Internal.CommandNode<S>>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        getName(): string;
        getRedirect(): Internal.CommandNode<S>;
        getCommand(): Internal.Command<S>;
        notifyAll(): void;
        getChild(arg0: string): Internal.CommandNode<S>;
        getExamples(): Internal.Collection<string>;
        getUsageText(): string;
        parse(arg0: Internal.StringReader_, arg1: Internal.CommandContextBuilder_<S>): void;
        compareTo(arg0: Internal.CommandNode_<S>): number;
        notify(): void;
        isFork(): boolean;
        canUse(arg0: S): boolean;
        getChildren(): Internal.Collection<Internal.CommandNode<S>>;
        getRequirement(): Internal.Predicate<S>;
        findAmbiguities(arg0: Internal.AmbiguityConsumer_<S>): void;
        listSuggestions(arg0: Internal.CommandContext_<S>, arg1: Internal.SuggestionsBuilder_): Internal.CompletableFuture<Internal.Suggestions>;
        createBuilder(): Internal.ArgumentBuilder<S, any>;
        hashCode(): number;
        equals(arg0: any): boolean;
        toString(): string;
        addChild(arg0: Internal.CommandNode_<S>): void;
        get redirect(): Internal.CommandNode<S>;
        get fork(): boolean;
        get examples(): Internal.Collection<string>;
        get children(): Internal.Collection<Internal.CommandNode<S>>;
        get name(): string;
        get usageText(): string;
        get requirement(): Internal.Predicate<S>;
        get redirectModifier(): Internal.RedirectModifier<S>;
        get class(): Internal.Class<any>;
        get command(): Internal.Command<S>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    type CommandNode_<S> = CommandNode<S>;
    interface Double2LongFunction extends Internal.Function<number, number>, Internal.DoubleToLongFunction {
        getOrDefault(arg0: any, arg1: number): number;
        getOrDefault(arg0: number, arg1: number): number;
        andThenShort(arg0: Internal.Long2ShortFunction_): Internal.Double2ShortFunction;
        composeByte(arg0: Internal.Byte2DoubleFunction_): Internal.Byte2LongFunction;
        andThenInt(arg0: Internal.Long2IntFunction_): Internal.Double2IntFunction;
        composeReference<T_>(arg0: Internal.Reference2DoubleFunction_<T_>): Internal.Reference2LongFunction<T_>;
        andThen<T_>(arg0: java_.util.function_.Function_<number, T_>): java_.util.function_.Function<number, T_>;
        put(arg0: number, arg1: number): number;
        remove(arg0: number): number;
        remove(arg0: any): number;
        defaultReturnValue(): number;
        defaultReturnValue(arg0: number): void;
        andThenDouble(arg0: Internal.Long2DoubleFunction_): Internal.Double2DoubleFunction;
        andThenObject<T_>(arg0: Internal.Long2ObjectFunction_<T_>): Internal.Double2ObjectFunction<T_>;
        get(arg0: any): number;
        get(arg0: number): number;
        andThenLong(arg0: Internal.Long2LongFunction_): Internal.Double2LongFunction;
        composeLong(arg0: Internal.Long2DoubleFunction_): Internal.Long2LongFunction;
        andThenByte(arg0: Internal.Long2ByteFunction_): Internal.Double2ByteFunction;
        andThenFloat(arg0: Internal.Long2FloatFunction_): Internal.Double2FloatFunction;
        apply(arg0: number): number;
        containsKey(arg0: any): boolean;
        containsKey(arg0: number): boolean;
        composeInt(arg0: Internal.Int2DoubleFunction_): Internal.Int2LongFunction;
        clear(): void;
        composeFloat(arg0: Internal.Float2DoubleFunction_): Internal.Float2LongFunction;
        andThenChar(arg0: Internal.Long2CharFunction_): Internal.Double2CharFunction;
        applyAsLong(arg0: number): number;
        composeObject<T_>(arg0: Internal.Object2DoubleFunction_<T_>): Internal.Object2LongFunction<T_>;
        size(): number;
        compose<T_>(arg0: java_.util.function_.Function_<T_, number>): java_.util.function_.Function<T_, number>;
        composeShort(arg0: Internal.Short2DoubleFunction_): Internal.Short2LongFunction;
        andThenReference<T_>(arg0: Internal.Long2ReferenceFunction_<T_>): Internal.Double2ReferenceFunction<T_>;
        composeChar(arg0: Internal.Char2DoubleFunction_): Internal.Char2LongFunction;
        composeDouble(arg0: Internal.Double2DoubleFunction_): Internal.Double2LongFunction;
    }
    type Double2LongFunction_ = ((arg0: number) => number) | Double2LongFunction;
    abstract class Goal {
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        hashCode(): number;
        notifyAll(): void;
        equals(arg0: any): boolean;
        toString(): string;
        notify(): void;
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    type Goal_ = Goal;
    interface CropBlockBuilder$SurviveCallback {
        survive(arg0: Internal.BlockState_, arg1: Internal.LevelReader_, arg2: BlockPos_): boolean;
    }
    type CropBlockBuilder$SurviveCallback_ = ((arg0: Internal.BlockState, arg1: Internal.LevelReader, arg2: BlockPos) => boolean) | CropBlockBuilder$SurviveCallback;
    class JsonGenerator {
        getClass(): Internal.Class<any>;
        getAllJsons(): Internal.Map<ResourceLocation, Internal.JsonElement>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        hashCode(): number;
        notifyAll(): void;
        equals(arg0: any): boolean;
        json(id: ResourceLocation_, json: Internal.JsonElement_): void;
        toString(): string;
        notify(): void;
        get class(): Internal.Class<any>;
        get allJsons(): Internal.Map<ResourceLocation, Internal.JsonElement>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    type JsonGenerator_ = JsonGenerator;
    interface ObjectSet <K> extends Internal.ObjectCollection<K>, Internal.Set<K> {
        add(arg0: K): boolean;
        spliterator(): Internal.ObjectSpliterator<K>;
        forEach(arg0: Internal.Consumer_<K>): void;
        containsAll(arg0: Internal.Collection_<any>): boolean;
        isEmpty(): boolean;
        clear(): void;
        remove(arg0: any): boolean;
        removeIf(arg0: Internal.Predicate_<K>): boolean;
        removeAll(arg0: Internal.Collection_<any>): boolean;
        contains(arg0: any): boolean;
        iterator(): Internal.ObjectIterator<K>;
        size(): number;
        addAll(arg0: Internal.Collection_<K>): boolean;
        stream(): Internal.Stream<K>;
        hashCode(): number;
        equals(arg0: any): boolean;
        toArray<T_>(arg0: T_[]): T_[];
        toArray<T_>(arg0: Internal.IntFunction_<T_[]>): T_[];
        toArray(): any[];
        parallelStream(): Internal.Stream<K>;
        retainAll(arg0: Internal.Collection_<any>): boolean;
    }
    type ObjectSet_<K> = ObjectSet<K>;
    interface ChannelHandlerContext extends Internal.AttributeMap, Internal.ChannelInboundInvoker, Internal.ChannelOutboundInvoker {
        disconnect(): Internal.ChannelFuture;
        disconnect(arg0: Internal.ChannelPromise_): Internal.ChannelFuture;
        handler(): Internal.ChannelHandler;
        newProgressivePromise(): Internal.ChannelProgressivePromise;
        fireChannelWritabilityChanged(): Internal.ChannelHandlerContext;
        fireChannelWritabilityChanged(): Internal.ChannelInboundInvoker;
        channel(): io.netty.channel.Channel;
        fireExceptionCaught(arg0: Internal.Throwable_): Internal.ChannelHandlerContext;
        fireExceptionCaught(arg0: Internal.Throwable_): Internal.ChannelInboundInvoker;
        fireChannelActive(): Internal.ChannelHandlerContext;
        fireChannelActive(): Internal.ChannelInboundInvoker;
        writeAndFlush(arg0: any, arg1: Internal.ChannelPromise_): Internal.ChannelFuture;
        writeAndFlush(arg0: any): Internal.ChannelFuture;
        bind(arg0: Internal.SocketAddress_): Internal.ChannelFuture;
        bind(arg0: Internal.SocketAddress_, arg1: Internal.ChannelPromise_): Internal.ChannelFuture;
        isRemoved(): boolean;
        flush(): Internal.ChannelHandlerContext;
        flush(): Internal.ChannelOutboundInvoker;
        executor(): Internal.EventExecutor;
        attr<T_>(arg0: Internal.AttributeKey_<T_>): io.netty.util.Attribute<T_>;
        close(arg0: Internal.ChannelPromise_): Internal.ChannelFuture;
        close(): Internal.ChannelFuture;
        write(arg0: any): Internal.ChannelFuture;
        write(arg0: any, arg1: Internal.ChannelPromise_): Internal.ChannelFuture;
        connect(arg0: Internal.SocketAddress_, arg1: Internal.SocketAddress_, arg2: Internal.ChannelPromise_): Internal.ChannelFuture;
        connect(arg0: Internal.SocketAddress_, arg1: Internal.ChannelPromise_): Internal.ChannelFuture;
        connect(arg0: Internal.SocketAddress_): Internal.ChannelFuture;
        connect(arg0: Internal.SocketAddress_, arg1: Internal.SocketAddress_): Internal.ChannelFuture;
        newPromise(): Internal.ChannelPromise;
        fireChannelInactive(): Internal.ChannelHandlerContext;
        fireChannelInactive(): Internal.ChannelInboundInvoker;
        read(): Internal.ChannelHandlerContext;
        read(): Internal.ChannelOutboundInvoker;
        fireChannelReadComplete(): Internal.ChannelHandlerContext;
        fireChannelReadComplete(): Internal.ChannelInboundInvoker;
        deregister(arg0: Internal.ChannelPromise_): Internal.ChannelFuture;
        deregister(): Internal.ChannelFuture;
        newFailedFuture(arg0: Internal.Throwable_): Internal.ChannelFuture;
        hasAttr<T_>(arg0: Internal.AttributeKey_<T_>): boolean;
        fireChannelRegistered(): Internal.ChannelHandlerContext;
        fireChannelRegistered(): Internal.ChannelInboundInvoker;
        pipeline(): Internal.ChannelPipeline;
        fireChannelRead(arg0: any): Internal.ChannelHandlerContext;
        fireChannelRead(arg0: any): Internal.ChannelInboundInvoker;
        voidPromise(): Internal.ChannelPromise;
        newSucceededFuture(): Internal.ChannelFuture;
        name(): string;
        fireUserEventTriggered(arg0: any): Internal.ChannelHandlerContext;
        fireUserEventTriggered(arg0: any): Internal.ChannelInboundInvoker;
        fireChannelUnregistered(): Internal.ChannelHandlerContext;
        fireChannelUnregistered(): Internal.ChannelInboundInvoker;
        alloc(): Internal.ByteBufAllocator;
    }
    type ChannelHandlerContext_ = ChannelHandlerContext;
    class PageAttributes$MediaType extends Internal.AttributeValue {
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        notifyAll(): void;
        equals(arg0: any): boolean;
        notify(): void;
        static readonly ISO_B0 : Internal.PageAttributes$MediaType;
        static readonly ISO_B1 : Internal.PageAttributes$MediaType;
        static readonly ISO_B2 : Internal.PageAttributes$MediaType;
        static readonly NA_10X13_ENVELOPE : Internal.PageAttributes$MediaType;
        static readonly ISO_B3 : Internal.PageAttributes$MediaType;
        static readonly NA_NUMBER_14_ENVELOPE : Internal.PageAttributes$MediaType;
        static readonly ISO_B4 : Internal.PageAttributes$MediaType;
        static readonly ENV_INVITE : Internal.PageAttributes$MediaType;
        static readonly ISO_B5 : Internal.PageAttributes$MediaType;
        static readonly ISO_B6 : Internal.PageAttributes$MediaType;
        static readonly ISO_C10 : Internal.PageAttributes$MediaType;
        static readonly ISO_B7 : Internal.PageAttributes$MediaType;
        static readonly INVITE : Internal.PageAttributes$MediaType;
        static readonly ISO_C8_ENVELOPE : Internal.PageAttributes$MediaType;
        static readonly A0 : Internal.PageAttributes$MediaType;
        static readonly JIS_B9 : Internal.PageAttributes$MediaType;
        static readonly A1 : Internal.PageAttributes$MediaType;
        static readonly A2 : Internal.PageAttributes$MediaType;
        static readonly JIS_B7 : Internal.PageAttributes$MediaType;
        static readonly A3 : Internal.PageAttributes$MediaType;
        static readonly JIS_B8 : Internal.PageAttributes$MediaType;
        static readonly A4 : Internal.PageAttributes$MediaType;
        static readonly ISO_C2_ENVELOPE : Internal.PageAttributes$MediaType;
        static readonly A5 : Internal.PageAttributes$MediaType;
        static readonly A6 : Internal.PageAttributes$MediaType;
        static readonly A7 : Internal.PageAttributes$MediaType;
        static readonly A8 : Internal.PageAttributes$MediaType;
        static readonly ISO_B8 : Internal.PageAttributes$MediaType;
        static readonly A9 : Internal.PageAttributes$MediaType;
        static readonly ISO_B9 : Internal.PageAttributes$MediaType;
        static readonly PERSONAL_ENVELOPE : Internal.PageAttributes$MediaType;
        static readonly ISO_C1 : Internal.PageAttributes$MediaType;
        static readonly A10 : Internal.PageAttributes$MediaType;
        static readonly ISO_C2 : Internal.PageAttributes$MediaType;
        static readonly ISO_C3 : Internal.PageAttributes$MediaType;
        static readonly ISO_C4 : Internal.PageAttributes$MediaType;
        static readonly ISO_C5 : Internal.PageAttributes$MediaType;
        static readonly ISO_C6 : Internal.PageAttributes$MediaType;
        static readonly ISO_C7 : Internal.PageAttributes$MediaType;
        static readonly ISO_C8 : Internal.PageAttributes$MediaType;
        static readonly JIS_B1 : Internal.PageAttributes$MediaType;
        static readonly NA_LETTER : Internal.PageAttributes$MediaType;
        static readonly ISO_2A0 : Internal.PageAttributes$MediaType;
        static readonly JIS_B2 : Internal.PageAttributes$MediaType;
        static readonly ENV_6X9 : Internal.PageAttributes$MediaType;
        static readonly JIS_B0 : Internal.PageAttributes$MediaType;
        static readonly JIS_B5 : Internal.PageAttributes$MediaType;
        static readonly JIS_B6 : Internal.PageAttributes$MediaType;
        static readonly JIS_B3 : Internal.PageAttributes$MediaType;
        static readonly B0 : Internal.PageAttributes$MediaType;
        static readonly JIS_B4 : Internal.PageAttributes$MediaType;
        static readonly ISO_C0 : Internal.PageAttributes$MediaType;
        static readonly NA_NUMBER_9_ENVELOPE : Internal.PageAttributes$MediaType;
        static readonly B1 : Internal.PageAttributes$MediaType;
        static readonly B2 : Internal.PageAttributes$MediaType;
        static readonly B3 : Internal.PageAttributes$MediaType;
        static readonly B4 : Internal.PageAttributes$MediaType;
        static readonly B5 : Internal.PageAttributes$MediaType;
        static readonly B6 : Internal.PageAttributes$MediaType;
        static readonly B7 : Internal.PageAttributes$MediaType;
        static readonly B8 : Internal.PageAttributes$MediaType;
        static readonly B9 : Internal.PageAttributes$MediaType;
        static readonly ISO_C9 : Internal.PageAttributes$MediaType;
        static readonly NA_7X9_ENVELOPE : Internal.PageAttributes$MediaType;
        static readonly MONARCH : Internal.PageAttributes$MediaType;
        static readonly ISO_C3_ENVELOPE : Internal.PageAttributes$MediaType;
        static readonly ENV_9X11 : Internal.PageAttributes$MediaType;
        static readonly ENV_ITALY : Internal.PageAttributes$MediaType;
        static readonly ENV_9X12 : Internal.PageAttributes$MediaType;
        static readonly ENV_10X15 : Internal.PageAttributes$MediaType;
        static readonly A : Internal.PageAttributes$MediaType;
        static readonly ENV_10X14 : Internal.PageAttributes$MediaType;
        static readonly B : Internal.PageAttributes$MediaType;
        static readonly ENV_10X13 : Internal.PageAttributes$MediaType;
        static readonly C : Internal.PageAttributes$MediaType;
        static readonly D : Internal.PageAttributes$MediaType;
        static readonly E : Internal.PageAttributes$MediaType;
        static readonly ISO_C9_ENVELOPE : Internal.PageAttributes$MediaType;
        static readonly C0 : Internal.PageAttributes$MediaType;
        static readonly C1 : Internal.PageAttributes$MediaType;
        static readonly C2 : Internal.PageAttributes$MediaType;
        static readonly C3 : Internal.PageAttributes$MediaType;
        static readonly ISO_DESIGNATED_LONG_ENVELOPE : Internal.PageAttributes$MediaType;
        static readonly PERSONAL : Internal.PageAttributes$MediaType;
        static readonly C4 : Internal.PageAttributes$MediaType;
        static readonly C5 : Internal.PageAttributes$MediaType;
        static readonly C6 : Internal.PageAttributes$MediaType;
        static readonly NA_10X14_ENVELOPE : Internal.PageAttributes$MediaType;
        static readonly C7 : Internal.PageAttributes$MediaType;
        static readonly C8 : Internal.PageAttributes$MediaType;
        static readonly C9 : Internal.PageAttributes$MediaType;
        static readonly NA_NUMBER_10_ENVELOPE : Internal.PageAttributes$MediaType;
        static readonly ISO_A0 : Internal.PageAttributes$MediaType;
        static readonly ISO_A1 : Internal.PageAttributes$MediaType;
        static readonly ISO_A2 : Internal.PageAttributes$MediaType;
        static readonly ISO_A3 : Internal.PageAttributes$MediaType;
        static readonly ISO_A4 : Internal.PageAttributes$MediaType;
        static readonly ISO_A5 : Internal.PageAttributes$MediaType;
        static readonly ISO_A6 : Internal.PageAttributes$MediaType;
        static readonly ISO_C1_ENVELOPE : Internal.PageAttributes$MediaType;
        static readonly ISO_B5_ENVELOPE : Internal.PageAttributes$MediaType;
        static readonly NA_LEGAL : Internal.PageAttributes$MediaType;
        static readonly ISO_A7 : Internal.PageAttributes$MediaType;
        static readonly ISO_C6_ENVELOPE : Internal.PageAttributes$MediaType;
        static readonly ISO_A8 : Internal.PageAttributes$MediaType;
        static readonly ISO_A9 : Internal.PageAttributes$MediaType;
        static readonly NA_NUMBER_11_ENVELOPE : Internal.PageAttributes$MediaType;
        static readonly STATEMENT : Internal.PageAttributes$MediaType;
        static readonly LETTER : Internal.PageAttributes$MediaType;
        static readonly ISO_A10 : Internal.PageAttributes$MediaType;
        static readonly NA_9X11_ENVELOPE : Internal.PageAttributes$MediaType;
        static readonly ISO_C5_ENVELOPE : Internal.PageAttributes$MediaType;
        static readonly QUARTO : Internal.PageAttributes$MediaType;
        static readonly ISO_DESIGNATED_LONG : Internal.PageAttributes$MediaType;
        static readonly NA_6X9_ENVELOPE : Internal.PageAttributes$MediaType;
        static readonly ISO_C4_ENVELOPE : Internal.PageAttributes$MediaType;
        static readonly C10 : Internal.PageAttributes$MediaType;
        static readonly ISO_C10_ENVELOPE : Internal.PageAttributes$MediaType;
        static readonly ISO_4A0 : Internal.PageAttributes$MediaType;
        static readonly ITALY : Internal.PageAttributes$MediaType;
        static readonly NA_NUMBER_12_ENVELOPE : Internal.PageAttributes$MediaType;
        static readonly INVOICE : Internal.PageAttributes$MediaType;
        static readonly ENV_9 : Internal.PageAttributes$MediaType;
        static readonly NA_9X12_ENVELOPE : Internal.PageAttributes$MediaType;
        static readonly ITALY_ENVELOPE : Internal.PageAttributes$MediaType;
        static readonly ISO_B4_ENVELOPE : Internal.PageAttributes$MediaType;
        static readonly ENV_PERSONAL : Internal.PageAttributes$MediaType;
        static readonly ISO_B10 : Internal.PageAttributes$MediaType;
        static readonly JIS_B10 : Internal.PageAttributes$MediaType;
        static readonly ISO_C0_ENVELOPE : Internal.PageAttributes$MediaType;
        static readonly INVITE_ENVELOPE : Internal.PageAttributes$MediaType;
        static readonly NOTE : Internal.PageAttributes$MediaType;
        static readonly LEGAL : Internal.PageAttributes$MediaType;
        static readonly EXECUTIVE : Internal.PageAttributes$MediaType;
        static readonly ENV_MONARCH : Internal.PageAttributes$MediaType;
        static readonly ENV_11 : Internal.PageAttributes$MediaType;
        static readonly B10 : Internal.PageAttributes$MediaType;
        static readonly ENV_12 : Internal.PageAttributes$MediaType;
        static readonly ENV_10 : Internal.PageAttributes$MediaType;
        static readonly ISO_C7_ENVELOPE : Internal.PageAttributes$MediaType;
        static readonly ENV_14 : Internal.PageAttributes$MediaType;
        static readonly MONARCH_ENVELOPE : Internal.PageAttributes$MediaType;
        static readonly ENV_7X9 : Internal.PageAttributes$MediaType;
        static readonly NA_10X15_ENVELOPE : Internal.PageAttributes$MediaType;
        static readonly TABLOID : Internal.PageAttributes$MediaType;
        static readonly LEDGER : Internal.PageAttributes$MediaType;
        static readonly FOLIO : Internal.PageAttributes$MediaType;
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    type PageAttributes$MediaType_ = PageAttributes$MediaType;
    class TeamType extends Internal.Enum<Internal.TeamType> implements Internal.StringRepresentable {
        isPlayer(): boolean;
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        isServer(): boolean;
        static valueOf(name: string): Internal.TeamType;
        static valueOf<T_>(arg0: Internal.Class_<T_>, arg1: string): T_;
        notifyAll(): void;
        static values(): Internal.TeamType[];
        compareTo(arg0: Internal.TeamType_): number;
        describeConstable(): Internal.Optional<Internal.Enum$EnumDesc<Internal.TeamType>>;
        notify(): void;
        getDeclaringClass(): Internal.Class<Internal.TeamType>;
        hashCode(): number;
        equals(arg0: any): boolean;
        name(): string;
        toString(): string;
        isParty(): boolean;
        ordinal(): number;
        static readonly PLAYER : Internal.TeamType;
        static readonly PARTY : Internal.TeamType;
        readonly factory : ((arg0: Internal.TeamManager) => Internal.Team);
        static readonly SERVER : Internal.TeamType;
        static readonly VALUES : Internal.TeamType[];
        static readonly MAP : {"server":Internal.TeamType,"party":Internal.TeamType,"player":Internal.TeamType};
        get server(): boolean;
        get class(): Internal.Class<any>;
        get party(): boolean;
        get player(): boolean;
        get declaringClass(): Internal.Class<Internal.TeamType>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    type TeamType_ = "server" | "party" | "player" | TeamType;
    interface BooleanConsumer {
        accept(arg0: boolean): void;
    }
    type BooleanConsumer_ = ((arg0: boolean) => void) | BooleanConsumer;
    interface RenderedImage {
        getTileHeight(): number;
        getMinTileX(): number;
        getTile(arg0: number, arg1: number): Internal.Raster;
        getMinTileY(): number;
        getTileWidth(): number;
        getColorModel(): Internal.ColorModel;
        getProperty(arg0: string): any;
        getNumYTiles(): number;
        getSources(): Internal.Vector<Internal.RenderedImage>;
        getWidth(): number;
        getTileGridXOffset(): number;
        copyData(arg0: Internal.WritableRaster_): Internal.WritableRaster;
        getTileGridYOffset(): number;
        getSampleModel(): Internal.SampleModel;
        getHeight(): number;
        getPropertyNames(): string[];
        getNumXTiles(): number;
        getMinX(): number;
        getData(): Internal.Raster;
        getData(arg0: Internal.Rectangle_): Internal.Raster;
        getMinY(): number;
    }
    type RenderedImage_ = RenderedImage;
    class RewardTable extends Internal.QuestObjectBase {
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        deleteChildren(): void;
        readNetData(buffer: Internal.FriendlyByteBuf_): void;
        notifyAll(): void;
        getMutableTitle(): Internal.MutableComponent;
        getTags(): Internal.Set<string>;
        static getCodeString(object: Internal.QuestObjectBase_): string;
        getCodeString(): string;
        static getCodeString(id: number): string;
        writeData(nbt: Internal.CompoundTag_): void;
        createSubGroup(group: Internal.ConfigGroup_): Internal.ConfigGroup;
        editedFromGUIOnServer(): void;
        notify(): void;
        forceProgress(teamData: Internal.TeamData_, progressChange: Internal.ProgressChange_): void;
        getTitle(): Internal.Component;
        hashCode(): number;
        getAltIcon(): Internal.Icon;
        getObjectType(): Internal.QuestObjectType;
        getPath(): string;
        clearCachedData(): void;
        getTotalWeight(includeEmpty: boolean): number;
        getParentID(): number;
        static parseCodeString(id: string): number;
        readData(nbt: Internal.CompoundTag_): void;
        editedFromGUI(): void;
        refreshJEI(): number;
        hasTag(tag: string): boolean;
        getQuestChapter(): Internal.Chapter;
        static getID(object: Internal.QuestObjectBase_): number;
        getQuestFile(): Internal.QuestFile;
        writeNetData(buffer: Internal.FriendlyByteBuf_): void;
        onEditButtonClicked(gui: Internal.Runnable_): void;
        getConfig(config: Internal.ConfigGroup_): void;
        getIcon(): Internal.Icon;
        addMouseOverText(list: Internal.TooltipList_, includeWeight: boolean, includeEmpty: boolean): void;
        forceProgressRaw(teamData: Internal.TeamData_, progressChange: Internal.ProgressChange_): void;
        getFilename(): string;
        getAltTitle(): Internal.Component;
        static isNull(object: Internal.QuestObjectBase_): boolean;
        equals(object: any): boolean;
        toString(): string;
        deleteSelf(): void;
        static titleToID(s: string): Internal.Optional<string>;
        onCreated(): void;
        emptyWeight : number;
        icon : Internal.ItemStack;
        title : string;
        lootSize : number;
        lootTableId : ResourceLocation;
        useTitle : boolean;
        readonly file : Internal.QuestFile;
        filename : string;
        lootCrate : Internal.LootCrate;
        invalid : boolean;
        readonly fakeQuest : Internal.Quest;
        static sendNotifications : Internal.Tristate;
        id : number;
        readonly rewards : Internal.List<Internal.WeightedReward>;
        hideTooltip : boolean;
        get path(): string;
        get codeString(): string;
        get altTitle(): Internal.Component;
        get questFile(): Internal.QuestFile;
        get class(): Internal.Class<any>;
        get parentID(): number;
        get mutableTitle(): Internal.MutableComponent;
        get tags(): Internal.Set<string>;
        get altIcon(): Internal.Icon;
        get objectType(): Internal.QuestObjectType;
        get questChapter(): Internal.Chapter;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    type RewardTable_ = RewardTable;
    interface IntComparator extends Internal.Comparator<number> {
        compare(arg0: number, arg1: number): number;
        thenComparingLong(arg0: Internal.ToLongFunction_<number>): Internal.Comparator<number>;
        thenComparingInt(arg0: Internal.ToIntFunction_<number>): Internal.Comparator<number>;
        thenComparing(arg0: Internal.Comparator_<number>): Internal.Comparator<number>;
        thenComparing(arg0: Internal.IntComparator_): Internal.IntComparator;
        thenComparing<U_>(arg0: java_.util.function_.Function_<number, U_>, arg1: Internal.Comparator_<U_>): Internal.Comparator<number>;
        thenComparing<U_>(arg0: java_.util.function_.Function_<number, U_>): Internal.Comparator<number>;
        thenComparingDouble(arg0: Internal.ToDoubleFunction_<number>): Internal.Comparator<number>;
        equals(arg0: any): boolean;
        reversed(): Internal.IntComparator;
    }
    type IntComparator_ = ((arg0: number, arg1: number) => number) | IntComparator;
    interface BiomeFTBC {
        getFTBCBiomeColorIndex(): number;
        setFTBCBiomeColorIndex(arg0: number): void;
    }
    type BiomeFTBC_ = BiomeFTBC;
    class LazyOptional <T> {
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        resolve(): Internal.Optional<T>;
        notifyAll(): void;
        isPresent(): boolean;
        invalidate(): void;
        orElse(arg0: T): T;
        notify(): void;
        orElseThrow<X>(arg0: Internal.NonNullSupplier_<X>): T;
        static empty<T>(): Internal.LazyOptional<T>;
        filter(arg0: Internal.NonNullPredicate_<T>): Internal.Optional<T>;
        cast<X>(): Internal.LazyOptional<X>;
        orElseGet(arg0: Internal.NonNullSupplier_<T>): T;
        hashCode(): number;
        equals(arg0: any): boolean;
        ifPresent(arg0: Internal.NonNullConsumer_<T>): void;
        static of<T>(arg0: Internal.NonNullSupplier_<T>): Internal.LazyOptional<T>;
        toString(): string;
        map<U>(arg0: Internal.NonNullFunction_<T, U>): Internal.Optional<U>;
        lazyMap<U>(arg0: Internal.NonNullFunction_<T, U>): Internal.LazyOptional<U>;
        addListener(arg0: Internal.NonNullConsumer_<Internal.LazyOptional_<T>>): void;
        get present(): boolean;
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    type LazyOptional_<T> = LazyOptional<T>;
    class Tesselator {
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        hashCode(): number;
        notifyAll(): void;
        equals(arg0: any): boolean;
        toString(): string;
        notify(): void;
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    type Tesselator_ = Tesselator;
    class MinMaxBounds$Ints extends Internal.MinMaxBounds<number> implements Internal.IntsAccess {
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        hashCode(): number;
        notifyAll(): void;
        equals(arg0: any): boolean;
        toString(): string;
        notify(): void;
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    type MinMaxBounds$Ints_ = MinMaxBounds$Ints;
    class BlockHitResult extends Internal.HitResult {
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        hashCode(): number;
        notifyAll(): void;
        equals(arg0: any): boolean;
        toString(): string;
        notify(): void;
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    type BlockHitResult_ = BlockHitResult;
    interface VertexDrain {
        createSink<T>(arg0: Internal.VertexType_<T>): T;
    }
    type VertexDrain_ = VertexDrain;
    abstract class Registry <T> implements Internal.Keyable, Internal.IdMap<T>, Internal.RegistryAccess, Internal.ForgeAccessorRegistry {
        getClass(): Internal.Class<any>;
        iterator(): Internal.Iterator<T>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        spliterator(): Internal.Spliterator<T>;
        forEach(arg0: Internal.Consumer_<T>): void;
        hashCode(): number;
        keys<U_>(arg0: Internal.DynamicOps_<U_>): Internal.Stream<U_>;
        notifyAll(): void;
        equals(arg0: any): boolean;
        toString(): string;
        notify(): void;
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    type Registry_<T> = Registry<T>;
    abstract class ScriptableObject implements Internal.Scriptable, Internal.SymbolScriptable, Internal.Serializable, Internal.ConstProperties {
        getClass(): Internal.Class<any>;
        isSealed(): boolean;
        setParentScope(m: Internal.Scriptable_): void;
        static redefineProperty(obj: Internal.Scriptable_, name: string, isConst: boolean): void;
        putConst(name: string, start: Internal.Scriptable_, value: any): void;
        static getTypedProperty<T_>(s: Internal.Scriptable_, name: string, type: Internal.Class_<T_>): T_;
        static getTypedProperty<T_>(s: Internal.Scriptable_, index: number, type: Internal.Class_<T_>): T_;
        getIds(): any[];
        static getArrayPrototype(scope: Internal.Scriptable_): Internal.Scriptable;
        getAllIds(): any[];
        put(index: number, start: Internal.Scriptable_, value: any): void;
        put(key: Internal.Symbol_, start: Internal.Scriptable_, value: any): void;
        put(name: string, start: Internal.Scriptable_, value: any): void;
        static getDefaultValue(object: Internal.Scriptable_, typeHint: Internal.Class_<any>): any;
        getDefaultValue(typeHint: Internal.Class_<any>): any;
        defineOwnProperties(cx: Internal.Context_, props: Internal.ScriptableObject_): void;
        defineProperty(key: Internal.Symbol_, value: any, attributes: number): void;
        defineProperty(propertyName: string, clazz: Internal.Class_<any>, attributes: number): void;
        defineProperty(propertyName: string, delegateTo: any, getter: Internal.Method_, setter: Internal.Method_, attributes: number): void;
        defineProperty(propertyName: string, value: any, attributes: number): void;
        static defineProperty(destination: Internal.Scriptable_, propertyName: string, value: any, attributes: number): void;
        setGetterOrSetter(name: string, index: number, getterOrSetter: Internal.Callable_, isSetter: boolean): void;
        avoidObjectDetection(): boolean;
        has(index: number, start: Internal.Scriptable_): boolean;
        has(name: string, start: Internal.Scriptable_): boolean;
        has(key: Internal.Symbol_, start: Internal.Scriptable_): boolean;
        getExternalArrayLength(): any;
        getAttributes(sym: Internal.Symbol_): number;
        getAttributes(name: string): number;
        getAttributes(index: number): number;
        hasInstance(instance: Internal.Scriptable_): boolean;
        getAssociatedValue(key: any): any;
        static getPropertyIds(obj: Internal.Scriptable_): any[];
        static hasProperty(obj: Internal.Scriptable_, name: string): boolean;
        static hasProperty(obj: Internal.Scriptable_, key: Internal.Symbol_): boolean;
        static hasProperty(obj: Internal.Scriptable_, index: number): boolean;
        getExternalArrayData(): Internal.ExternalArrayData;
        size(): number;
        defineOwnProperty(cx: Internal.Context_, id: any, desc: Internal.ScriptableObject_): void;
        static getFunctionPrototype(scope: Internal.Scriptable_): Internal.Scriptable;
        getClassName(): string;
        getParentScope(): Internal.Scriptable;
        preventExtensions(): void;
        setExternalArrayData(array: Internal.ExternalArrayData_): void;
        static callMethod(cx: Internal.Context_, obj: Internal.Scriptable_, methodName: string, args: any[]): any;
        static callMethod(obj: Internal.Scriptable_, methodName: string, args: any[]): any;
        enumerationIteratorNext(cx: Internal.Context_, currentId: Internal.Consumer_<any>): boolean;
        getTypeOf(): string;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        static getTopScopeValue(scope: Internal.Scriptable_, key: any): any;
        notifyAll(): void;
        sealObject(): void;
        setAttributes(key: Internal.Symbol_, attributes: number): void;
        setAttributes(index: number, attributes: number): void;
        setAttributes(name: string, attributes: number): void;
        static putProperty(obj: Internal.Scriptable_, name: string, value: any): void;
        static putProperty(obj: Internal.Scriptable_, index: number, value: any): void;
        static putProperty(obj: Internal.Scriptable_, key: Internal.Symbol_, value: any): void;
        delete(name: string): void;
        delete(key: Internal.Symbol_): void;
        delete(index: number): void;
        notify(): void;
        associateValue(key: any, value: any): any;
        static deleteProperty(obj: Internal.Scriptable_, name: string): boolean;
        static deleteProperty(obj: Internal.Scriptable_, index: number): boolean;
        getPrototype(): Internal.Scriptable;
        static getObjectPrototype(scope: Internal.Scriptable_): Internal.Scriptable;
        isExtensible(): boolean;
        hashCode(): number;
        isConst(name: string): boolean;
        get(index: number, start: Internal.Scriptable_): any;
        get(key: Internal.Symbol_, start: Internal.Scriptable_): any;
        get(name: string, start: Internal.Scriptable_): any;
        get(key: any): any;
        static putConstProperty(obj: Internal.Scriptable_, name: string, value: any): void;
        getGetterOrSetter(name: string, index: number, isSetter: boolean): any;
        static getTopLevelScope(obj: Internal.Scriptable_): Internal.Scriptable;
        static getProperty(obj: Internal.Scriptable_, name: string): any;
        static getProperty(obj: Internal.Scriptable_, key: Internal.Symbol_): any;
        static getProperty(obj: Internal.Scriptable_, index: number): any;
        static defineClass<T_>(scope: Internal.Scriptable_, clazz: Internal.Class_<T_>, sealed: boolean): void;
        static defineClass<T_>(scope: Internal.Scriptable_, clazz: Internal.Class_<T_>): void;
        static defineClass<T_>(scope: Internal.Scriptable_, clazz: Internal.Class_<T_>, sealed: boolean, mapInheritance: boolean): string;
        isEmpty(): boolean;
        defineFunctionProperties(names: string[], clazz: Internal.Class_<any>, attributes: number): void;
        static getClassPrototype(scope: Internal.Scriptable_, className: string): Internal.Scriptable;
        setPrototype(m: Internal.Scriptable_): void;
        defineConst(name: string, start: Internal.Scriptable_): void;
        equals(arg0: any): boolean;
        static defineConstProperty(destination: Internal.Scriptable_, propertyName: string): void;
        toString(): string;
        enumerationIteratorHasNext(cx: Internal.Context_, currentId: Internal.Consumer_<any>): boolean;
        static getGeneratorFunctionPrototype(scope: Internal.Scriptable_): Internal.Scriptable;
        static readonly DONTENUM : 2;
        static readonly CONST : 13;
        static readonly NOT_FOUND : any;
        static readonly UNINITIALIZED_CONST : 8;
        static readonly EMPTY : 0;
        static readonly READONLY : 1;
        static readonly PERMANENT : 4;
        get sealed(): boolean;
        get externalArrayData(): Internal.ExternalArrayData;
        get parentScope(): Internal.Scriptable;
        get ids(): any[];
        get className(): string;
        get externalArrayLength(): any;
        get class(): Internal.Class<any>;
        get allIds(): any[];
        get prototype(): Internal.Scriptable;
        get extensible(): boolean;
        get typeOf(): string;
        get empty(): boolean;
        set externalArrayData(array: Internal.ExternalArrayData_);
        set parentScope(m: Internal.Scriptable_);
        set prototype(m: Internal.Scriptable_);
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    type ScriptableObject_ = ScriptableObject;
    interface Script {
        exec(arg0: Internal.Context_, arg1: Internal.Scriptable_): any;
    }
    type Script_ = Script;
    class ChunkRenderData {
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        getOcclusionData(): Internal.VisibilitySet;
        hashCode(): number;
        getAnimatedSprites(): Internal.List<Internal.TextureAtlasSprite>;
        notifyAll(): void;
        equals(arg0: any): boolean;
        getGlobalBlockEntities(): Internal.Collection<Internal.BlockEntity>;
        isEmpty(): boolean;
        toString(): string;
        getBlockEntities(): Internal.Collection<Internal.BlockEntity>;
        notify(): void;
        getBounds(): Internal.ChunkRenderBounds;
        static readonly ABSENT : Internal.ChunkRenderData;
        static readonly EMPTY : Internal.ChunkRenderData;
        get occlusionData(): Internal.VisibilitySet;
        get globalBlockEntities(): Internal.Collection<Internal.BlockEntity>;
        get bounds(): Internal.ChunkRenderBounds;
        get animatedSprites(): Internal.List<Internal.TextureAtlasSprite>;
        get class(): Internal.Class<any>;
        get blockEntities(): Internal.Collection<Internal.BlockEntity>;
        get empty(): boolean;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    type ChunkRenderData_ = ChunkRenderData;
    class LootContext implements Internal.LootContextAccessor {
        getClass(): Internal.Class<any>;
        getLootingModifier(): number;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        setQueriedLootTableId(arg0: ResourceLocation_): void;
        hashCode(): number;
        notifyAll(): void;
        equals(arg0: any): boolean;
        toString(): string;
        notify(): void;
        getQueriedLootTableId(): ResourceLocation;
        get lootingModifier(): number;
        get queriedLootTableId(): ResourceLocation;
        get class(): Internal.Class<any>;
        set queriedLootTableId(arg0: ResourceLocation_);
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    type LootContext_ = LootContext;
    class ChronoField extends Internal.Enum<Internal.ChronoField> implements Internal.TemporalField {
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        resolve(arg0: Internal.Map_<Internal.TemporalField_, number>, arg1: Internal.TemporalAccessor_, arg2: Internal.ResolverStyle_): Internal.TemporalAccessor;
        notifyAll(): void;
        static values(): Internal.ChronoField[];
        adjustInto<R_>(arg0: R_, arg1: number): R_;
        range(): Internal.ValueRange;
        getRangeUnit(): Internal.TemporalUnit;
        compareTo(arg0: Internal.ChronoField_): number;
        describeConstable(): Internal.Optional<Internal.Enum$EnumDesc<Internal.ChronoField>>;
        notify(): void;
        getDeclaringClass(): Internal.Class<Internal.ChronoField>;
        getBaseUnit(): Internal.TemporalUnit;
        hashCode(): number;
        isTimeBased(): boolean;
        checkValidIntValue(arg0: number): number;
        isDateBased(): boolean;
        getFrom(arg0: Internal.TemporalAccessor_): number;
        static valueOf(arg0: string): Internal.ChronoField;
        static valueOf<T_>(arg0: Internal.Class_<T_>, arg1: string): T_;
        rangeRefinedBy(arg0: Internal.TemporalAccessor_): Internal.ValueRange;
        getDisplayName(arg0: Internal.Locale_): string;
        equals(arg0: any): boolean;
        name(): string;
        checkValidValue(arg0: number): number;
        toString(): string;
        ordinal(): number;
        isSupportedBy(arg0: Internal.TemporalAccessor_): boolean;
        static readonly CLOCK_HOUR_OF_AMPM : Internal.ChronoField;
        static readonly DAY_OF_YEAR : Internal.ChronoField;
        static readonly MICRO_OF_DAY : Internal.ChronoField;
        static readonly ALIGNED_DAY_OF_WEEK_IN_MONTH : Internal.ChronoField;
        static readonly DAY_OF_MONTH : Internal.ChronoField;
        static readonly SECOND_OF_MINUTE : Internal.ChronoField;
        static readonly PROLEPTIC_MONTH : Internal.ChronoField;
        static readonly MILLI_OF_SECOND : Internal.ChronoField;
        static readonly NANO_OF_DAY : Internal.ChronoField;
        static readonly CLOCK_HOUR_OF_DAY : Internal.ChronoField;
        static readonly MINUTE_OF_DAY : Internal.ChronoField;
        static readonly ALIGNED_WEEK_OF_MONTH : Internal.ChronoField;
        static readonly YEAR : Internal.ChronoField;
        static readonly HOUR_OF_DAY : Internal.ChronoField;
        static readonly MILLI_OF_DAY : Internal.ChronoField;
        static readonly ALIGNED_DAY_OF_WEEK_IN_YEAR : Internal.ChronoField;
        static readonly YEAR_OF_ERA : Internal.ChronoField;
        static readonly AMPM_OF_DAY : Internal.ChronoField;
        static readonly NANO_OF_SECOND : Internal.ChronoField;
        static readonly SECOND_OF_DAY : Internal.ChronoField;
        static readonly MICRO_OF_SECOND : Internal.ChronoField;
        static readonly MONTH_OF_YEAR : Internal.ChronoField;
        static readonly EPOCH_DAY : Internal.ChronoField;
        static readonly ERA : Internal.ChronoField;
        static readonly OFFSET_SECONDS : Internal.ChronoField;
        static readonly HOUR_OF_AMPM : Internal.ChronoField;
        static readonly MINUTE_OF_HOUR : Internal.ChronoField;
        static readonly INSTANT_SECONDS : Internal.ChronoField;
        static readonly ALIGNED_WEEK_OF_YEAR : Internal.ChronoField;
        static readonly DAY_OF_WEEK : Internal.ChronoField;
        get baseUnit(): Internal.TemporalUnit;
        get rangeUnit(): Internal.TemporalUnit;
        get timeBased(): boolean;
        get dateBased(): boolean;
        get class(): Internal.Class<any>;
        get declaringClass(): Internal.Class<Internal.ChronoField>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    type ChronoField_ = "year_of_era" | "micro_of_second" | "year" | "minute_of_day" | "minute_of_hour" | "epoch_day" | "day_of_month" | "hour_of_ampm" | "offset_seconds" | "milli_of_second" | "nano_of_second" | "proleptic_month" | "era" | "second_of_minute" | "aligned_day_of_week_in_year" | "micro_of_day" | "nano_of_day" | "hour_of_day" | "day_of_week" | "second_of_day" | "day_of_year" | "month_of_year" | "ampm_of_day" | "milli_of_day" | "aligned_week_of_month" | "instant_seconds" | "aligned_day_of_week_in_month" | "aligned_week_of_year" | "clock_hour_of_day" | "clock_hour_of_ampm" | ChronoField;
    class PoseStack {
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        hashCode(): number;
        notifyAll(): void;
        equals(arg0: any): boolean;
        toString(): string;
        notify(): void;
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    type PoseStack_ = PoseStack;
    class CustomProperties {
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        hashCode(): number;
        notifyAll(): void;
        equals(arg0: any): boolean;
        createItem(): Internal.Item$Properties;
        createBlock(): Internal.BlockBehaviour$Properties;
        toString(): string;
        notify(): void;
        destroyTime : number;
        explosionResistance : number;
        lightEmissive : number;
        stackSize : number;
        isOpaque : boolean;
        tabGroup : string;
        speedFactor : number;
        friction : number;
        hasCollision : boolean;
        jumpFactor : number;
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    type CustomProperties_ = CustomProperties;
    class CookingRecipeJS extends Internal.RecipeJS {
        parseResultItemList(o: any): Internal.List<Internal.ItemStackJS>;
        getClass(): Internal.Class<any>;
        ingredientAction(filter: Internal.IngredientActionFilter_, action: Internal.IngredientAction_): Internal.RecipeJS;
        convertReplacedInput(index: number, oldIngredient: Internal.IngredientJS_, newIngredient: Internal.IngredientJS_): Internal.IngredientJS;
        cookingTime(time: number): Internal.CookingRecipeJS;
        getUniqueId(): string;
        replaceOutput(i: Internal.IngredientJS_, with_: Internal.ItemStackJS_, exact: boolean): boolean;
        replaceOutput(i: Internal.IngredientJS_, with_: Internal.ItemStackJS_, exact: boolean, func: Internal.BiFunction_<Internal.ItemStackJS_, Internal.ItemStackJS_, Internal.ItemStackJS_>): boolean;
        parseIngredientItemList(o: any): Internal.List<Internal.IngredientJS>;
        merge(data: any): Internal.RecipeJS;
        getPath(): string;
        create(args: Internal.ListJS_): void;
        parseIngredientItemStackList(o: any): Internal.List<Internal.IngredientStackJS>;
        id(_id: ResourceLocation_): Internal.RecipeJS;
        parseIngredientItem(o: any, key: string): Internal.IngredientJS;
        parseIngredientItem(o: any): Internal.IngredientJS;
        group(g: string): Internal.RecipeJS;
        getOriginalRecipeResult(): Internal.ItemStackJS;
        getOriginalRecipeIngredients(): Internal.List<Internal.IngredientJS>;
        getInputIndex(ingredient: Internal.IngredientJS_, exact: boolean): number;
        setGroup(g: string): void;
        serialize(): void;
        replaceInput(i: Internal.IngredientJS_, with_: Internal.IngredientJS_, exact: boolean, func: Internal.BiFunction_<Internal.IngredientJS_, Internal.IngredientJS_, Internal.IngredientJS_>): boolean;
        replaceInput(i: Internal.IngredientJS_, with_: Internal.IngredientJS_, exact: boolean): boolean;
        getType(): string;
        getGroup(): string;
        hasOutput(ingredient: Internal.IngredientJS_, exact: boolean): boolean;
        keepIngredient(filter: Internal.IngredientActionFilter_): Internal.RecipeJS;
        customIngredientAction(filter: Internal.IngredientActionFilter_, id: string): Internal.RecipeJS;
        modifyResult(callback: Internal.ModifyRecipeResultCallback_): Internal.RecipeJS;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        getMod(): string;
        notifyAll(): void;
        convertReplacedOutput(index: number, oldStack: Internal.ItemStackJS_, newStack: Internal.ItemStackJS_): Internal.ItemStackJS;
        save(): void;
        damageIngredient(filter: Internal.IngredientActionFilter_): Internal.RecipeJS;
        damageIngredient(filter: Internal.IngredientActionFilter_, damage: number): Internal.RecipeJS;
        getId(): string;
        dontAdd(): void;
        notify(): void;
        serializeJson(): void;
        createRecipe(): Internal.Recipe<any>;
        getFromToString(): string;
        hashCode(): number;
        deserializeJson(): void;
        getOrCreateId(): ResourceLocation;
        deserialize(): void;
        serializeNBTAsJson(): boolean;
        getOutputIndex(ingredient: Internal.IngredientJS_, exact: boolean): number;
        serializeIngredientStack(in_: Internal.IngredientStackJS_): Internal.JsonElement;
        resultFromRecipeJson(json: Internal.JsonObject_): Internal.ItemStackJS;
        stage(s: string): Internal.RecipeJS;
        equals(arg0: any): boolean;
        serializeItemStack(stack: Internal.ItemStackJS_): Internal.JsonElement;
        xp(xp: number): Internal.CookingRecipeJS;
        toString(): string;
        hasInput(ingredient: Internal.IngredientJS_, exact: boolean): boolean;
        parseResultItem(o: any): Internal.ItemStackJS;
        replaceIngredient(filter: Internal.IngredientActionFilter_, item: Internal.ItemStackJS_): Internal.RecipeJS;
        static currentRecipe : Internal.RecipeJS;
        originalJson : Internal.JsonObject;
        serializeOutputs : boolean;
        originalRecipe : Internal.Recipe<any>;
        readonly inputItems : Internal.List<((arg0: Internal.ItemStackJS) => boolean)>;
        static itemErrors : false;
        json : Internal.JsonObject;
        readonly outputItems : Internal.List<Internal.ItemStackJS>;
        type : Internal.RecipeTypeJS;
        serializeInputs : boolean;
        get path(): string;
        get originalRecipeIngredients(): Internal.List<Internal.IngredientJS>;
        get mod(): string;
        get originalRecipeResult(): Internal.ItemStackJS;
        get orCreateId(): ResourceLocation;
        get class(): Internal.Class<any>;
        get fromToString(): string;
        get uniqueId(): string;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    type CookingRecipeJS_ = CookingRecipeJS;
    class Size {
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        getHeight(): number;
        hashCode(): number;
        notifyAll(): void;
        equals(arg0: any): boolean;
        toString(): string;
        getWidth(): number;
        notify(): void;
        static readonly ZERO : Internal.Size;
        readonly width : number;
        readonly height : number;
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    type Size_ = Size;
    class LocalTime implements Internal.Temporal, Internal.TemporalAdjuster, Internal.Comparable<Internal.LocalTime>, Internal.Serializable {
        getClass(): Internal.Class<any>;
        plusHours(arg0: number): Internal.LocalTime;
        atDate(arg0: Internal.LocalDate_): Internal.LocalDateTime;
        compareTo(arg0: Internal.LocalTime_): number;
        toSecondOfDay(): number;
        plusSeconds(arg0: number): Internal.LocalTime;
        getMinute(): number;
        static from(arg0: Internal.TemporalAccessor_): Internal.LocalTime;
        plusNanos(arg0: number): Internal.LocalTime;
        withHour(arg0: number): Internal.LocalTime;
        static ofNanoOfDay(arg0: number): Internal.LocalTime;
        truncatedTo(arg0: Internal.TemporalUnit_): Internal.LocalTime;
        query<R_>(arg0: Internal.TemporalQuery_<R_>): R_;
        minusNanos(arg0: number): Internal.LocalTime;
        getNano(): number;
        format(arg0: Internal.DateTimeFormatter_): string;
        isSupported(arg0: Internal.TemporalUnit_): boolean;
        isSupported(arg0: Internal.TemporalField_): boolean;
        plus(arg0: Internal.TemporalAmount_): Internal.LocalTime;
        plus(arg0: number, arg1: Internal.TemporalUnit_): Internal.LocalTime;
        static ofSecondOfDay(arg0: number): Internal.LocalTime;
        toNanoOfDay(): number;
        toEpochSecond(arg0: Internal.LocalDate_, arg1: Internal.ZoneOffset_): number;
        isAfter(arg0: Internal.LocalTime_): boolean;
        static ofInstant(arg0: Internal.Instant_, arg1: Internal.ZoneId_): Internal.LocalTime;
        minus(arg0: Internal.TemporalAmount_): Internal.LocalTime;
        minus(arg0: number, arg1: Internal.TemporalUnit_): Internal.LocalTime;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        minusHours(arg0: number): Internal.LocalTime;
        notifyAll(): void;
        adjustInto(arg0: Internal.Temporal_): Internal.Temporal;
        range(arg0: Internal.TemporalField_): Internal.ValueRange;
        plusMinutes(arg0: number): Internal.LocalTime;
        notify(): void;
        minusMinutes(arg0: number): Internal.LocalTime;
        hashCode(): number;
        static now(): Internal.LocalTime;
        static now(arg0: Internal.Clock_): Internal.LocalTime;
        static now(arg0: Internal.ZoneId_): Internal.LocalTime;
        static of(arg0: number, arg1: number): Internal.LocalTime;
        static of(arg0: number, arg1: number, arg2: number, arg3: number): Internal.LocalTime;
        static of(arg0: number, arg1: number, arg2: number): Internal.LocalTime;
        get(arg0: Internal.TemporalField_): number;
        getHour(): number;
        withMinute(arg0: number): Internal.LocalTime;
        atOffset(arg0: Internal.ZoneOffset_): Internal.OffsetTime;
        static parse(arg0: Internal.CharSequence_): Internal.LocalTime;
        static parse(arg0: Internal.CharSequence_, arg1: Internal.DateTimeFormatter_): Internal.LocalTime;
        isBefore(arg0: Internal.LocalTime_): boolean;
        withNano(arg0: number): Internal.LocalTime;
        getLong(arg0: Internal.TemporalField_): number;
        with(arg0: Internal.TemporalAdjuster_): Internal.LocalTime;
        with(arg0: Internal.TemporalField_, arg1: number): Internal.LocalTime;
        equals(arg0: any): boolean;
        getSecond(): number;
        until(arg0: Internal.Temporal_, arg1: Internal.TemporalUnit_): number;
        toString(): string;
        minusSeconds(arg0: number): Internal.LocalTime;
        withSecond(arg0: number): Internal.LocalTime;
        static readonly MIN : Internal.LocalTime;
        static readonly NOON : Internal.LocalTime;
        static readonly MAX : Internal.LocalTime;
        static readonly MIDNIGHT : Internal.LocalTime;
        get hour(): number;
        get nano(): number;
        get class(): Internal.Class<any>;
        get minute(): number;
        get second(): number;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    type LocalTime_ = LocalTime;
    class LootPoolAction extends Internal.CompositeLootAction {
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        hashCode(): number;
        notifyAll(): void;
        equals(arg0: any): boolean;
        toString(): string;
        applyLootHandler(arg0: Internal.LootContext_, arg1: Internal.List_<Internal.ItemStack_>): boolean;
        notify(): void;
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    type LootPoolAction_ = LootPoolAction;
    /**
    * Fired when the fishing loot table is registering.
    */
    class FishingLootEventJS extends Internal.LootEventJS {
        cancel(): void;
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        isCancelled(): boolean;
        addFishing(id: ResourceLocation_, b: Internal.Consumer_<Internal.LootBuilder_>): void;
        notifyAll(): void;
        addJson(id: ResourceLocation_, json: Internal.JsonObject_): void;
        notify(): void;
        modify(id: ResourceLocation_, b: Internal.Consumer_<Internal.LootBuilder_>): void;
        removeAll(): void;
        post(t: Internal.ScriptType_, id: string, sub: string): boolean;
        post(t: Internal.ScriptType_, id: string): boolean;
        getType(): string;
        hashCode(): number;
        equals(arg0: any): boolean;
        toString(): string;
        getDirectory(): string;
        canCancel(): boolean;
        get cancelled(): boolean;
        get type(): string;
        get class(): Internal.Class<any>;
        get directory(): string;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    /**
    * Fired when the fishing loot table is registering.
    */
    type FishingLootEventJS_ = FishingLootEventJS;
    class NetworkEvent$PacketDispatcher {
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        hashCode(): number;
        notifyAll(): void;
        equals(arg0: any): boolean;
        sendPacket(arg0: ResourceLocation_, arg1: Internal.FriendlyByteBuf_): void;
        toString(): string;
        notify(): void;
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    type NetworkEvent$PacketDispatcher_ = NetworkEvent$PacketDispatcher;
    abstract class TypeAdapter <T> {
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        read(arg0: Internal.JsonReader_): T;
        notifyAll(): void;
        nullSafe(): Internal.TypeAdapter<T>;
        notify(): void;
        fromJsonTree(arg0: Internal.JsonElement_): T;
        toJson(arg0: Internal.Writer_, arg1: T): void;
        toJson(arg0: T): string;
        hashCode(): number;
        equals(arg0: any): boolean;
        toJsonTree(arg0: T): Internal.JsonElement;
        fromJson(arg0: Internal.Reader_): T;
        fromJson(arg0: string): T;
        toString(): string;
        write(arg0: Internal.JsonWriter_, arg1: T): void;
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    type TypeAdapter_<T> = TypeAdapter<T>;
    interface ArmorMaterial {
    }
    type ArmorMaterial_ = ArmorMaterial;
    interface IEventListener {
        listenerName(): string;
        invoke(arg0: Internal.Event_): void;
    }
    type IEventListener_ = IEventListener;
    class DropTarget implements Internal.DropTargetListener, Internal.Serializable {
        removeDropTargetListener(arg0: Internal.DropTargetListener_): void;
        getDropTargetContext(): Internal.DropTargetContext;
        drop(arg0: Internal.DropTargetDropEvent_): void;
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        dragEnter(arg0: Internal.DropTargetDragEvent_): void;
        notifyAll(): void;
        dropActionChanged(arg0: Internal.DropTargetDragEvent_): void;
        setComponent(arg0: java_.awt.Component_): void;
        isActive(): boolean;
        notify(): void;
        addDropTargetListener(arg0: Internal.DropTargetListener_): void;
        setFlavorMap(arg0: Internal.FlavorMap_): void;
        getFlavorMap(): Internal.FlavorMap;
        setActive(arg0: boolean): void;
        addNotify(): void;
        hashCode(): number;
        equals(arg0: any): boolean;
        removeNotify(): void;
        toString(): string;
        dragOver(arg0: Internal.DropTargetDragEvent_): void;
        getComponent(): java_.awt.Component;
        dragExit(arg0: Internal.DropTargetEvent_): void;
        setDefaultActions(arg0: number): void;
        getDefaultActions(): number;
        get flavorMap(): Internal.FlavorMap;
        get component(): java_.awt.Component;
        get defaultActions(): number;
        get active(): boolean;
        get dropTargetContext(): Internal.DropTargetContext;
        get class(): Internal.Class<any>;
        set flavorMap(arg0: Internal.FlavorMap_);
        set component(arg0: java_.awt.Component_);
        set defaultActions(arg0: number);
        set active(arg0: boolean);
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    type DropTarget_ = DropTarget;
    class ListenerList {
        getListeners(arg0: number): Internal.IEventListener[];
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        static clearBusID(arg0: number): void;
        hashCode(): number;
        notifyAll(): void;
        equals(arg0: any): boolean;
        unregister(arg0: number, arg1: Internal.IEventListener_): void;
        toString(): string;
        static unregisterAll(arg0: number, arg1: Internal.IEventListener_): void;
        notify(): void;
        register(arg0: number, arg1: Internal.EventPriority_, arg2: Internal.IEventListener_): void;
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    type ListenerList_ = ListenerList;
    interface IVertexProducer {
        pipe(arg0: Internal.IVertexConsumer_): void;
    }
    type IVertexProducer_ = IVertexProducer;
    class CheckLivingEntitySpawnEventJS extends Internal.LivingEntityEventJS {
        cancel(): void;
        getServer(): Internal.ServerJS;
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        isCancelled(): boolean;
        getBlock(): Internal.BlockContainerJS;
        notifyAll(): void;
        getEntity(): Internal.EntityJS;
        notify(): void;
        getLevel(): Internal.LevelJS;
        post(id: string): boolean;
        post(id: string, sub: string): boolean;
        post(t: Internal.ScriptType_, id: string, sub: string): boolean;
        post(t: Internal.ScriptType_, id: string): boolean;
        getType(): Internal.MobSpawnType;
        hashCode(): number;
        equals(arg0: any): boolean;
        toString(): string;
        canCancel(): boolean;
        readonly x : number;
        readonly y : number;
        readonly z : number;
        readonly type : Internal.MobSpawnType;
        get server(): Internal.ServerJS;
        get level(): Internal.LevelJS;
        get cancelled(): boolean;
        get block(): Internal.BlockContainerJS;
        get class(): Internal.Class<any>;
        get entity(): Internal.EntityJS;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    type CheckLivingEntitySpawnEventJS_ = CheckLivingEntitySpawnEventJS;
    class CompositeLootAction implements Internal.ILootAction {
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        hashCode(): number;
        notifyAll(): void;
        equals(arg0: any): boolean;
        toString(): string;
        applyLootHandler(arg0: Internal.LootContext_, arg1: Internal.List_<Internal.ItemStack_>): boolean;
        notify(): void;
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    type CompositeLootAction_ = CompositeLootAction;
    class AddLakeProperties {
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        setInner(p: BlockStatePredicate_): void;
        hashCode(): number;
        notifyAll(): void;
        equals(arg0: any): boolean;
        setOuter(p: BlockStatePredicate_): void;
        toString(): string;
        notify(): void;
        barrier : BlockStatePredicate;
        chance : number;
        biomes : ((arg0: Internal.BiomeModifications$BiomeContext) => boolean);
        retrogen : number;
        fluid : BlockStatePredicate;
        id : ResourceLocation;
        worldgenLayer : DecorationGenerationStep;
        get class(): Internal.Class<any>;
        set outer(p: BlockStatePredicate_);
        set inner(p: BlockStatePredicate_);
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    type AddLakeProperties_ = AddLakeProperties;
    interface JEISubtypesEventJS$Interpreter extends java_.util.function_.Function<Internal.ItemStackJS, any> {
        compose<V_>(arg0: java_.util.function_.Function_<V_, Internal.ItemStackJS_>): java_.util.function_.Function<V_, any>;
        apply(arg0: Internal.ItemStackJS_): any;
        andThen<V_>(arg0: java_.util.function_.Function_<any, V_>): java_.util.function_.Function<Internal.ItemStackJS, V_>;
    }
    type JEISubtypesEventJS$Interpreter_ = ((arg0: Internal.ItemStackJS) => any) | JEISubtypesEventJS$Interpreter;
    interface Int2CharFunction extends Internal.Function<number, string>, Internal.IntUnaryOperator {
        getOrDefault(arg0: any, arg1: string): string;
        getOrDefault(arg0: number, arg1: string): string;
        andThenShort(arg0: Internal.Char2ShortFunction_): Internal.Int2ShortFunction;
        composeByte(arg0: Internal.Byte2IntFunction_): Internal.Byte2CharFunction;
        andThenInt(arg0: Internal.Char2IntFunction_): Internal.Int2IntFunction;
        composeReference<T_>(arg0: Internal.Reference2IntFunction_<T_>): Internal.Reference2CharFunction<T_>;
        andThen<T_>(arg0: java_.util.function_.Function_<string, T_>): java_.util.function_.Function<number, T_>;
        andThen(arg0: Internal.IntUnaryOperator_): Internal.IntUnaryOperator;
        put(arg0: number, arg1: string): string;
        remove(arg0: number): string;
        remove(arg0: any): string;
        defaultReturnValue(): string;
        defaultReturnValue(arg0: string): void;
        andThenDouble(arg0: Internal.Char2DoubleFunction_): Internal.Int2DoubleFunction;
        andThenObject<T_>(arg0: Internal.Char2ObjectFunction_<T_>): Internal.Int2ObjectFunction<T_>;
        get(arg0: any): string;
        get(arg0: number): string;
        andThenLong(arg0: Internal.Char2LongFunction_): Internal.Int2LongFunction;
        composeLong(arg0: Internal.Long2IntFunction_): Internal.Long2CharFunction;
        andThenByte(arg0: Internal.Char2ByteFunction_): Internal.Int2ByteFunction;
        andThenFloat(arg0: Internal.Char2FloatFunction_): Internal.Int2FloatFunction;
        applyAsInt(arg0: number): number;
        apply(arg0: number): string;
        containsKey(arg0: any): boolean;
        containsKey(arg0: number): boolean;
        composeInt(arg0: Internal.Int2IntFunction_): Internal.Int2CharFunction;
        clear(): void;
        composeFloat(arg0: Internal.Float2IntFunction_): Internal.Float2CharFunction;
        andThenChar(arg0: Internal.Char2CharFunction_): Internal.Int2CharFunction;
        composeObject<T_>(arg0: Internal.Object2IntFunction_<T_>): Internal.Object2CharFunction<T_>;
        size(): number;
        compose<T_>(arg0: java_.util.function_.Function_<T_, number>): java_.util.function_.Function<T_, string>;
        compose(arg0: Internal.IntUnaryOperator_): Internal.IntUnaryOperator;
        composeShort(arg0: Internal.Short2IntFunction_): Internal.Short2CharFunction;
        andThenReference<T_>(arg0: Internal.Char2ReferenceFunction_<T_>): Internal.Int2ReferenceFunction<T_>;
        composeChar(arg0: Internal.Char2IntFunction_): Internal.Char2CharFunction;
        composeDouble(arg0: Internal.Double2IntFunction_): Internal.Double2CharFunction;
    }
    type Int2CharFunction_ = ((arg0: number) => string) | Int2CharFunction;
    class IsoEra extends Internal.Enum<Internal.IsoEra> implements Internal.Era {
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        static valueOf(arg0: string): Internal.IsoEra;
        static valueOf<T_>(arg0: Internal.Class_<T_>, arg1: string): T_;
        query<R_>(arg0: Internal.TemporalQuery_<R_>): R_;
        notifyAll(): void;
        static values(): Internal.IsoEra[];
        adjustInto(arg0: Internal.Temporal_): Internal.Temporal;
        range(arg0: Internal.TemporalField_): Internal.ValueRange;
        isSupported(arg0: Internal.TemporalField_): boolean;
        compareTo(arg0: Internal.IsoEra_): number;
        describeConstable(): Internal.Optional<Internal.Enum$EnumDesc<Internal.IsoEra>>;
        notify(): void;
        getLong(arg0: Internal.TemporalField_): number;
        getDeclaringClass(): Internal.Class<Internal.IsoEra>;
        getValue(): number;
        getDisplayName(arg0: Internal.TextStyle_, arg1: Internal.Locale_): string;
        hashCode(): number;
        get(arg0: Internal.TemporalField_): number;
        equals(arg0: any): boolean;
        static of(arg0: number): Internal.IsoEra;
        name(): string;
        toString(): string;
        ordinal(): number;
        static readonly CE : Internal.IsoEra;
        static readonly BCE : Internal.IsoEra;
        get class(): Internal.Class<any>;
        get value(): number;
        get declaringClass(): Internal.Class<Internal.IsoEra>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    type IsoEra_ = "ce" | "bce" | IsoEra;
    abstract class DoubleBuffer extends Internal.Buffer implements Internal.Comparable<Internal.DoubleBuffer> {
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        compact(): Internal.DoubleBuffer;
        notifyAll(): void;
        compareTo(arg0: Internal.DoubleBuffer_): number;
        notify(): void;
        asReadOnlyBuffer(): Internal.DoubleBuffer;
        put(arg0: number[]): Internal.DoubleBuffer;
        put(arg0: number, arg1: number[], arg2: number, arg3: number): Internal.DoubleBuffer;
        put(arg0: number, arg1: number[]): Internal.DoubleBuffer;
        put(arg0: number[], arg1: number, arg2: number): Internal.DoubleBuffer;
        put(arg0: number, arg1: Internal.DoubleBuffer_, arg2: number, arg3: number): Internal.DoubleBuffer;
        put(arg0: Internal.DoubleBuffer_): Internal.DoubleBuffer;
        put(arg0: number, arg1: number): Internal.DoubleBuffer;
        put(arg0: number): Internal.DoubleBuffer;
        capacity(): number;
        isReadOnly(): boolean;
        slice(arg0: number, arg1: number): Internal.DoubleBuffer;
        slice(): Internal.DoubleBuffer;
        array(): number[];
        hashCode(): number;
        get(): number;
        get(arg0: number, arg1: number[]): Internal.DoubleBuffer;
        get(arg0: number): number;
        get(arg0: number, arg1: number[], arg2: number, arg3: number): Internal.DoubleBuffer;
        get(arg0: number[], arg1: number, arg2: number): Internal.DoubleBuffer;
        get(arg0: number[]): Internal.DoubleBuffer;
        limit(arg0: number): Internal.DoubleBuffer;
        limit(): number;
        arrayOffset(): number;
        flip(): Internal.DoubleBuffer;
        order(): Internal.ByteOrder;
        hasArray(): boolean;
        hasRemaining(): boolean;
        clear(): Internal.DoubleBuffer;
        duplicate(): Internal.DoubleBuffer;
        remaining(): number;
        static allocate(arg0: number): Internal.DoubleBuffer;
        rewind(): Internal.DoubleBuffer;
        mismatch(arg0: Internal.DoubleBuffer_): number;
        equals(arg0: any): boolean;
        reset(): Internal.DoubleBuffer;
        toString(): string;
        position(arg0: number): Internal.DoubleBuffer;
        position(): number;
        isDirect(): boolean;
        static wrap(arg0: number[]): Internal.DoubleBuffer;
        static wrap(arg0: number[], arg1: number, arg2: number): Internal.DoubleBuffer;
        mark(): Internal.DoubleBuffer;
        get direct(): boolean;
        get readOnly(): boolean;
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    type DoubleBuffer_ = DoubleBuffer;
    interface LootContextBuilderAccess {
        getRandom(): Internal.Random;
        getParams(): Internal.Map<Internal.LootContextParam<any>, any>;
    }
    type LootContextBuilderAccess_ = LootContextBuilderAccess;
    class TextureAtlas extends Internal.AbstractTexture implements Internal.Tickable, Internal.TextureAtlasInterface {
        restoreLastBlurMipmap(): void;
        getAtlasSize(): Internal.Vec2;
        setAtlasSize(arg0: number, arg1: number): void;
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        setBlurMipmap(arg0: boolean, arg1: boolean): void;
        hashCode(): number;
        notifyAll(): void;
        equals(arg0: any): boolean;
        toString(): string;
        close(): void;
        notify(): void;
        get atlasSize(): Internal.Vec2;
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    type TextureAtlas_ = TextureAtlas;
    class JobAttributes$DestinationType extends Internal.AttributeValue {
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        notifyAll(): void;
        equals(arg0: any): boolean;
        notify(): void;
        static readonly PRINTER : Internal.JobAttributes$DestinationType;
        static readonly FILE : Internal.JobAttributes$DestinationType;
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    type JobAttributes$DestinationType_ = JobAttributes$DestinationType;
    class ForgeConfigSpec$LongValue extends Internal.ForgeConfigSpec$ConfigValue<number> {
        next(): Internal.ForgeConfigSpec$Builder;
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        set(arg0: number): void;
        hashCode(): number;
        notifyAll(): void;
        equals(arg0: any): boolean;
        get(): number;
        getPath(): Internal.List<string>;
        save(): void;
        toString(): string;
        clearCache(): void;
        notify(): void;
        get path(): Internal.List<string>;
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    type ForgeConfigSpec$LongValue_ = ForgeConfigSpec$LongValue;
    class ComponentEvent extends Internal.AWTEvent {
        getClass(): Internal.Class<any>;
        setSource(arg0: any): void;
        paramString(): string;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        hashCode(): number;
        getSource(): any;
        notifyAll(): void;
        equals(arg0: any): boolean;
        getID(): number;
        toString(): string;
        getComponent(): java_.awt.Component;
        notify(): void;
        static readonly ADJUSTMENT_EVENT_MASK : 256;
        static readonly MOUSE_EVENT_MASK : 16;
        static readonly COMPONENT_EVENT_MASK : 1;
        static readonly PAINT_EVENT_MASK : 8192;
        static readonly COMPONENT_HIDDEN : 103;
        static readonly INPUT_METHOD_EVENT_MASK : 2048;
        static readonly HIERARCHY_BOUNDS_EVENT_MASK : 65536;
        static readonly COMPONENT_LAST : 103;
        static readonly FOCUS_EVENT_MASK : 4;
        static readonly INVOCATION_EVENT_MASK : 16384;
        static readonly KEY_EVENT_MASK : 8;
        static readonly RESERVED_ID_MAX : 1999;
        static readonly CONTAINER_EVENT_MASK : 2;
        static readonly WINDOW_EVENT_MASK : 64;
        static readonly MOUSE_WHEEL_EVENT_MASK : 131072;
        static readonly MOUSE_MOTION_EVENT_MASK : 32;
        static readonly COMPONENT_FIRST : 100;
        static readonly WINDOW_FOCUS_EVENT_MASK : 524288;
        static readonly COMPONENT_MOVED : 100;
        static readonly COMPONENT_SHOWN : 102;
        static readonly TEXT_EVENT_MASK : 1024;
        static readonly ACTION_EVENT_MASK : 128;
        static readonly ITEM_EVENT_MASK : 512;
        static readonly HIERARCHY_EVENT_MASK : 32768;
        static readonly WINDOW_STATE_EVENT_MASK : 262144;
        static readonly COMPONENT_RESIZED : 101;
        get component(): java_.awt.Component;
        get source(): any;
        get iD(): number;
        get class(): Internal.Class<any>;
        set source(arg0: any);
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    type ComponentEvent_ = ComponentEvent;
    abstract class Model {
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        hashCode(): number;
        notifyAll(): void;
        equals(arg0: any): boolean;
        toString(): string;
        notify(): void;
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    type Model_ = Model;
    class TextureStitchEvent extends Internal.Event implements Internal.IModBusEvent {
        setCanceled(arg0: boolean): void;
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        isCanceled(): boolean;
        setResult(arg0: Internal.Event$Result_): void;
        notifyAll(): void;
        hasResult(): boolean;
        notify(): void;
        getListenerList(): Internal.ListenerList;
        hashCode(): number;
        equals(arg0: any): boolean;
        getResult(): Internal.Event$Result;
        toString(): string;
        isCancelable(): boolean;
        getPhase(): Internal.EventPriority;
        setPhase(arg0: Internal.EventPriority_): void;
        getAtlas(): Internal.TextureAtlas;
        get result(): Internal.Event$Result;
        get phase(): Internal.EventPriority;
        get canceled(): boolean;
        get cancelable(): boolean;
        get listenerList(): Internal.ListenerList;
        get atlas(): Internal.TextureAtlas;
        get class(): Internal.Class<any>;
        set phase(arg0: Internal.EventPriority_);
        set result(arg0: Internal.Event$Result_);
        set canceled(arg0: boolean);
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    type TextureStitchEvent_ = TextureStitchEvent;
    abstract class SampleModel {
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        createSubsetSampleModel(arg0: number[]): Internal.SampleModel;
        setPixel(arg0: number, arg1: number, arg2: number[], arg3: Internal.DataBuffer_): void;
        setPixels(arg0: number, arg1: number, arg2: number, arg3: number, arg4: number[], arg5: Internal.DataBuffer_): void;
        notifyAll(): void;
        getDataType(): number;
        getSampleFloat(arg0: number, arg1: number, arg2: number, arg3: Internal.DataBuffer_): number;
        getSampleSize(): number[];
        getSampleSize(arg0: number): number;
        getNumDataElements(): number;
        getNumBands(): number;
        getWidth(): number;
        notify(): void;
        getHeight(): number;
        createDataBuffer(): Internal.DataBuffer;
        getTransferType(): number;
        hashCode(): number;
        getPixels(arg0: number, arg1: number, arg2: number, arg3: number, arg4: number[], arg5: Internal.DataBuffer_): number[];
        createCompatibleSampleModel(arg0: number, arg1: number): Internal.SampleModel;
        setDataElements(arg0: number, arg1: number, arg2: number, arg3: number, arg4: any, arg5: Internal.DataBuffer_): void;
        setDataElements(arg0: number, arg1: number, arg2: any, arg3: Internal.DataBuffer_): void;
        getSampleDouble(arg0: number, arg1: number, arg2: number, arg3: Internal.DataBuffer_): number;
        setSamples(arg0: number, arg1: number, arg2: number, arg3: number, arg4: number, arg5: number[], arg6: Internal.DataBuffer_): void;
        getSamples(arg0: number, arg1: number, arg2: number, arg3: number, arg4: number, arg5: number[], arg6: Internal.DataBuffer_): number[];
        getPixel(arg0: number, arg1: number, arg2: number[], arg3: Internal.DataBuffer_): number[];
        equals(arg0: any): boolean;
        getDataElements(arg0: number, arg1: number, arg2: any, arg3: Internal.DataBuffer_): any;
        getDataElements(arg0: number, arg1: number, arg2: number, arg3: number, arg4: any, arg5: Internal.DataBuffer_): any;
        toString(): string;
        getSample(arg0: number, arg1: number, arg2: number, arg3: Internal.DataBuffer_): number;
        setSample(arg0: number, arg1: number, arg2: number, arg3: number, arg4: Internal.DataBuffer_): void;
        get numDataElements(): number;
        get numBands(): number;
        get dataType(): number;
        get width(): number;
        get transferType(): number;
        get sampleSize(): number[];
        get class(): Internal.Class<any>;
        get height(): number;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    type SampleModel_ = SampleModel;
    class MissingMappingEventJS <T> extends Internal.EventJS {
        cancel(): void;
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        isCancelled(): boolean;
        notifyAll(): void;
        notify(): void;
        warn(key: ResourceLocation_): void;
        fail(key: ResourceLocation_): void;
        post(t: Internal.ScriptType_, id: string, sub: string): boolean;
        post(t: Internal.ScriptType_, id: string): boolean;
        hashCode(): number;
        equals(arg0: any): boolean;
        ignore(key: ResourceLocation_): void;
        toString(): string;
        canCancel(): boolean;
        remap(key: ResourceLocation_, value: ResourceLocation_): void;
        get cancelled(): boolean;
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    type MissingMappingEventJS_<T> = MissingMappingEventJS<T>;
    interface ProgressiveFuture <V> extends io.netty.util.concurrent.Future<V> {
        cancel(arg0: boolean): boolean;
        isCancelled(): boolean;
        removeListeners(arg0: Internal.GenericFutureListener_<io.netty.util.concurrent.Future_<V>>[]): Internal.ProgressiveFuture<V>;
        removeListeners(arg0: Internal.GenericFutureListener_<io.netty.util.concurrent.Future_<V>>[]): io.netty.util.concurrent.Future<V>;
        getNow(): V;
        cause(): Internal.Throwable;
        awaitUninterruptibly(): Internal.ProgressiveFuture<V>;
        awaitUninterruptibly(): io.netty.util.concurrent.Future<V>;
        awaitUninterruptibly(arg0: number, arg1: Internal.TimeUnit_): boolean;
        awaitUninterruptibly(arg0: number): boolean;
        removeListener(arg0: Internal.GenericFutureListener_<io.netty.util.concurrent.Future_<V>>): Internal.ProgressiveFuture<V>;
        removeListener(arg0: Internal.GenericFutureListener_<io.netty.util.concurrent.Future_<V>>): io.netty.util.concurrent.Future<V>;
        isDone(): boolean;
        sync(): Internal.ProgressiveFuture<V>;
        sync(): io.netty.util.concurrent.Future<V>;
        syncUninterruptibly(): Internal.ProgressiveFuture<V>;
        syncUninterruptibly(): io.netty.util.concurrent.Future<V>;
        get(arg0: number, arg1: Internal.TimeUnit_): V;
        get(): V;
        isCancellable(): boolean;
        await(): Internal.ProgressiveFuture<V>;
        await(): io.netty.util.concurrent.Future<V>;
        await(arg0: number, arg1: Internal.TimeUnit_): boolean;
        await(arg0: number): boolean;
        addListeners(arg0: Internal.GenericFutureListener_<io.netty.util.concurrent.Future_<V>>[]): Internal.ProgressiveFuture<V>;
        addListeners(arg0: Internal.GenericFutureListener_<io.netty.util.concurrent.Future_<V>>[]): io.netty.util.concurrent.Future<V>;
        isSuccess(): boolean;
        addListener(arg0: Internal.GenericFutureListener_<io.netty.util.concurrent.Future_<V>>): Internal.ProgressiveFuture<V>;
        addListener(arg0: Internal.GenericFutureListener_<io.netty.util.concurrent.Future_<V>>): io.netty.util.concurrent.Future<V>;
    }
    type ProgressiveFuture_<V> = ProgressiveFuture<V>;
    class JsonPrimitive extends Internal.JsonElement {
        getAsFloat(): number;
        getClass(): Internal.Class<any>;
        getAsByte(): number;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        getAsBigDecimal(): Internal.BigDecimal;
        notifyAll(): void;
        getAsNumber(): Internal.Number;
        getAsCharacter(): string;
        getAsString(): string;
        isJsonArray(): boolean;
        notify(): void;
        getAsInt(): number;
        isJsonPrimitive(): boolean;
        isBoolean(): boolean;
        getAsLong(): number;
        isJsonObject(): boolean;
        isNumber(): boolean;
        hashCode(): number;
        isString(): boolean;
        getAsBigInteger(): Internal.BigInteger;
        getAsJsonObject(): Internal.JsonObject;
        getAsJsonNull(): Internal.JsonNull;
        isJsonNull(): boolean;
        getAsDouble(): number;
        deepCopy(): Internal.JsonPrimitive;
        getAsJsonArray(): Internal.JsonArray;
        getAsJsonPrimitive(): Internal.JsonPrimitive;
        getAsBoolean(): boolean;
        equals(arg0: any): boolean;
        toString(): string;
        getAsShort(): number;
        get asByte(): number;
        get asBigInteger(): Internal.BigInteger;
        get asJsonObject(): Internal.JsonObject;
        get asCharacter(): string;
        get jsonPrimitive(): boolean;
        get string(): boolean;
        get asNumber(): Internal.Number;
        get asBigDecimal(): Internal.BigDecimal;
        get jsonNull(): boolean;
        get asFloat(): number;
        get asLong(): number;
        get asInt(): number;
        get number(): boolean;
        get asJsonPrimitive(): Internal.JsonPrimitive;
        get boolean(): boolean;
        get asJsonNull(): Internal.JsonNull;
        get asShort(): number;
        get asDouble(): number;
        get asJsonArray(): Internal.JsonArray;
        get asString(): string;
        get jsonObject(): boolean;
        get class(): Internal.Class<any>;
        get jsonArray(): boolean;
        get asBoolean(): boolean;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    type JsonPrimitive_ = JsonPrimitive;
    interface Char2LongFunction extends Internal.Function<string, number>, Internal.IntToLongFunction {
        getOrDefault(arg0: any, arg1: number): number;
        getOrDefault(arg0: string, arg1: number): number;
        andThenShort(arg0: Internal.Long2ShortFunction_): Internal.Char2ShortFunction;
        composeByte(arg0: Internal.Byte2CharFunction_): Internal.Byte2LongFunction;
        andThenInt(arg0: Internal.Long2IntFunction_): Internal.Char2IntFunction;
        composeReference<T_>(arg0: Internal.Reference2CharFunction_<T_>): Internal.Reference2LongFunction<T_>;
        andThen<T_>(arg0: java_.util.function_.Function_<number, T_>): java_.util.function_.Function<string, T_>;
        put(arg0: string, arg1: number): number;
        remove(arg0: string): number;
        remove(arg0: any): number;
        defaultReturnValue(): number;
        defaultReturnValue(arg0: number): void;
        andThenDouble(arg0: Internal.Long2DoubleFunction_): Internal.Char2DoubleFunction;
        andThenObject<T_>(arg0: Internal.Long2ObjectFunction_<T_>): Internal.Char2ObjectFunction<T_>;
        get(arg0: any): number;
        get(arg0: string): number;
        andThenLong(arg0: Internal.Long2LongFunction_): Internal.Char2LongFunction;
        composeLong(arg0: Internal.Long2CharFunction_): Internal.Long2LongFunction;
        andThenByte(arg0: Internal.Long2ByteFunction_): Internal.Char2ByteFunction;
        andThenFloat(arg0: Internal.Long2FloatFunction_): Internal.Char2FloatFunction;
        apply(arg0: string): number;
        containsKey(arg0: any): boolean;
        containsKey(arg0: string): boolean;
        composeInt(arg0: Internal.Int2CharFunction_): Internal.Int2LongFunction;
        clear(): void;
        composeFloat(arg0: Internal.Float2CharFunction_): Internal.Float2LongFunction;
        andThenChar(arg0: Internal.Long2CharFunction_): Internal.Char2CharFunction;
        applyAsLong(arg0: number): number;
        composeObject<T_>(arg0: Internal.Object2CharFunction_<T_>): Internal.Object2LongFunction<T_>;
        size(): number;
        compose<T_>(arg0: java_.util.function_.Function_<T_, string>): java_.util.function_.Function<T_, number>;
        composeShort(arg0: Internal.Short2CharFunction_): Internal.Short2LongFunction;
        andThenReference<T_>(arg0: Internal.Long2ReferenceFunction_<T_>): Internal.Char2ReferenceFunction<T_>;
        composeChar(arg0: Internal.Char2CharFunction_): Internal.Char2LongFunction;
        composeDouble(arg0: Internal.Double2CharFunction_): Internal.Double2LongFunction;
    }
    type Char2LongFunction_ = ((arg0: string) => number) | Char2LongFunction;
    interface TypeDescriptor$OfField <F> extends Internal.TypeDescriptor {
        componentType(): F;
        arrayType(): F;
        descriptorString(): string;
        isArray(): boolean;
        isPrimitive(): boolean;
    }
    type TypeDescriptor$OfField_<F> = TypeDescriptor$OfField<F>;
    abstract class LivingEntity extends Internal.Entity implements net.darkhax.bookshelf.mixin.entity.AccessorLivingEntity, Internal.ICitadelDataEntity, Internal.LivingEntityAccessor, Internal.ExpInvokerMixin, Internal.AccessorLivingEntity, Internal.LivingEntityKJS, Internal.IProperShieldUser {
        getClass(): Internal.Class<any>;
        resetDynamicLight(): void;
        getCapability<T_>(arg0: Internal.Capability_<T_>, arg1: Internal.Direction_): Internal.LazyOptional<T_>;
        getCapability<T_>(arg0: Internal.Capability_<T_>): Internal.LazyOptional<T_>;
        captureDrops(arg0: Internal.Collection_<Internal.ItemEntity_>): Internal.Collection<Internal.ItemEntity>;
        captureDrops(): Internal.Collection<Internal.ItemEntity>;
        canBeRiddenInWater(arg0: Internal.Entity_): boolean;
        setCitadelEntityData(arg0: Internal.CompoundTag_): void;
        isDynamicLightEnabled(): boolean;
        changeDimension(arg0: Internal.ServerLevel_, arg1: Internal.ITeleporter_): Internal.Entity;
        serializeNBT(): Internal.CompoundTag;
        invalidateCaps(): void;
        setDynamicLightEnabled(arg0: boolean): void;
        shouldUpdateDynamicLight(): boolean;
        foodEatenKJS(is: Internal.ItemStack_): void;
        revive(): void;
        setVisualScale(arg0: number): void;
        dynamicLightTick(): void;
        getPersistentDataKJS(): Internal.CompoundTag;
        canUpdate(): boolean;
        canUpdate(arg0: boolean): void;
        getDynamicLightY(): number;
        getDynamicLightZ(): number;
        handler$zbj000$curio$canFreeze(arg0: Internal.CallbackInfoReturnable_<any>): void;
        getDynamicLightX(): number;
        areCapsCompatible(arg0: Internal.CapabilityProvider_<Internal.Entity_>): boolean;
        areCapsCompatible(arg0: Internal.CapabilityDispatcher_): boolean;
        redirect$bie002$elytraOverride(arg0: Internal.ItemStack_, arg1: Internal.LivingEntity_): boolean;
        getEyeHeightAccess(arg0: Internal.Pose_, arg1: Internal.EntityDimensions_): number;
        reviveCaps(): void;
        lambdynlights$updateDynamicLight(arg0: Internal.LevelRenderer_): boolean;
        handler$bih000$removed(arg0: Internal.CallbackInfo_): void;
        canRiderInteract(): boolean;
        lambdynlights$scheduleTrackedChunksRebuild(arg0: Internal.LevelRenderer_): void;
        handler$bih001$onTick(arg0: Internal.CallbackInfo_): void;
        onAddedToWorld(): void;
        canTrample(arg0: Internal.BlockState_, arg1: BlockPos_, arg2: number): boolean;
        getCitadelEntityData(): Internal.CompoundTag;
        getClassification(arg0: boolean): Internal.MobCategory;
        handler$bih000$onRemove(arg0: Internal.CallbackInfo_): void;
        shouldRiderSit(): boolean;
        getPickedResult(arg0: Internal.HitResult_): Internal.ItemStack;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        notifyAll(): void;
        isActuallyReallyBlocking(): boolean;
        getPersistentData(): Internal.CompoundTag;
        notify(): void;
        redirect$bie000$eytraValidOverride(arg0: Internal.ItemStack_, arg1: Internal.LivingEntity_, arg2: number): boolean;
        hashCode(): number;
        setDimension(arg0: Internal.EntityDimensions_): void;
        isAddedToWorld(): boolean;
        getParts(): any[];
        getDynamicLightWorld(): Internal.Level;
        onRemovedFromWorld(): void;
        getLuminance(): number;
        isMultipartEntity(): boolean;
        deserializeNBT(arg0: Internal.CompoundTag_): void;
        curePotionEffects(arg0: Internal.ItemStack_): boolean;
        asKJS(): any;
        shouldRiderFaceForward(arg0: Internal.Player_): boolean;
        equals(arg0: any): boolean;
        toString(): string;
        getVisualScale(): number;
        get luminance(): number;
        get dynamicLightEnabled(): boolean;
        get citadelEntityData(): Internal.CompoundTag;
        get persistentData(): Internal.CompoundTag;
        get multipartEntity(): boolean;
        get addedToWorld(): boolean;
        get dynamicLightY(): number;
        get dynamicLightZ(): number;
        get dynamicLightX(): number;
        get visualScale(): number;
        get persistentDataKJS(): Internal.CompoundTag;
        get actuallyReallyBlocking(): boolean;
        get parts(): any[];
        get class(): Internal.Class<any>;
        get dynamicLightWorld(): Internal.Level;
        set dynamicLightEnabled(arg0: boolean);
        set visualScale(arg0: number);
        set citadelEntityData(arg0: Internal.CompoundTag_);
        set dimension(arg0: Internal.EntityDimensions_);
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    type LivingEntity_ = LivingEntity;
    class RenderingHints implements Internal.Map<any, any>, Internal.Cloneable {
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        getOrDefault(arg0: any, arg1: any): any;
        computeIfAbsent(arg0: any, arg1: java_.util.function_.Function_<any, any>): any;
        notifyAll(): void;
        values(): Internal.Collection<any>;
        replace(arg0: any, arg1: any): any;
        replace(arg0: any, arg1: any, arg2: any): boolean;
        replaceAll(arg0: Internal.BiFunction_<any, any, any>): void;
        notify(): void;
        containsValue(arg0: any): boolean;
        put(arg0: any, arg1: any): any;
        remove(arg0: any): any;
        remove(arg0: any, arg1: any): boolean;
        compute(arg0: any, arg1: Internal.BiFunction_<any, any, any>): any;
        hashCode(): number;
        merge(arg0: any, arg1: any, arg2: Internal.BiFunction_<any, any, any>): any;
        putAll(arg0: Internal.Map_<any, any>): void;
        get(arg0: any): any;
        keySet(): Internal.Set<any>;
        add(arg0: Internal.RenderingHints_): void;
        entrySet(): Internal.Set<Internal.Map$Entry<any, any>>;
        forEach(arg0: Internal.BiConsumer_<any, any>): void;
        containsKey(arg0: any): boolean;
        isEmpty(): boolean;
        clear(): void;
        computeIfPresent(arg0: any, arg1: Internal.BiFunction_<any, any, any>): any;
        size(): number;
        equals(arg0: any): boolean;
        clone(): any;
        toString(): string;
        putIfAbsent(arg0: any, arg1: any): any;
        static readonly VALUE_TEXT_ANTIALIAS_LCD_VRGB : any;
        static readonly VALUE_TEXT_ANTIALIAS_LCD_VBGR : any;
        static readonly KEY_FRACTIONALMETRICS : Internal.RenderingHints$Key;
        static readonly VALUE_RESOLUTION_VARIANT_SIZE_FIT : any;
        static readonly VALUE_TEXT_ANTIALIAS_DEFAULT : any;
        static readonly VALUE_TEXT_ANTIALIAS_OFF : any;
        static readonly VALUE_ANTIALIAS_OFF : any;
        static readonly VALUE_INTERPOLATION_BICUBIC : any;
        static readonly VALUE_COLOR_RENDER_QUALITY : any;
        static readonly VALUE_COLOR_RENDER_DEFAULT : any;
        static readonly VALUE_STROKE_DEFAULT : any;
        static readonly VALUE_RENDER_DEFAULT : any;
        static readonly VALUE_RENDER_QUALITY : any;
        static readonly KEY_ALPHA_INTERPOLATION : Internal.RenderingHints$Key;
        static readonly KEY_DITHERING : Internal.RenderingHints$Key;
        static readonly VALUE_FRACTIONALMETRICS_OFF : any;
        static readonly VALUE_ANTIALIAS_DEFAULT : any;
        static readonly VALUE_ALPHA_INTERPOLATION_SPEED : any;
        static readonly KEY_TEXT_ANTIALIASING : Internal.RenderingHints$Key;
        static readonly VALUE_TEXT_ANTIALIAS_GASP : any;
        static readonly KEY_TEXT_LCD_CONTRAST : Internal.RenderingHints$Key;
        static readonly VALUE_RENDER_SPEED : any;
        static readonly VALUE_FRACTIONALMETRICS_ON : any;
        static readonly VALUE_RESOLUTION_VARIANT_DEFAULT : any;
        static readonly KEY_ANTIALIASING : Internal.RenderingHints$Key;
        static readonly VALUE_DITHER_ENABLE : any;
        static readonly KEY_STROKE_CONTROL : Internal.RenderingHints$Key;
        static readonly VALUE_STROKE_PURE : any;
        static readonly KEY_RENDERING : Internal.RenderingHints$Key;
        static readonly VALUE_DITHER_DEFAULT : any;
        static readonly KEY_RESOLUTION_VARIANT : Internal.RenderingHints$Key;
        static readonly VALUE_INTERPOLATION_BILINEAR : any;
        static readonly VALUE_ALPHA_INTERPOLATION_QUALITY : any;
        static readonly VALUE_RESOLUTION_VARIANT_BASE : any;
        static readonly KEY_COLOR_RENDERING : Internal.RenderingHints$Key;
        static readonly VALUE_RESOLUTION_VARIANT_DPI_FIT : any;
        static readonly VALUE_ANTIALIAS_ON : any;
        static readonly VALUE_STROKE_NORMALIZE : any;
        static readonly VALUE_FRACTIONALMETRICS_DEFAULT : any;
        static readonly VALUE_INTERPOLATION_NEAREST_NEIGHBOR : any;
        static readonly VALUE_DITHER_DISABLE : any;
        static readonly VALUE_TEXT_ANTIALIAS_LCD_HRGB : any;
        static readonly VALUE_TEXT_ANTIALIAS_LCD_HBGR : any;
        static readonly KEY_INTERPOLATION : Internal.RenderingHints$Key;
        static readonly VALUE_ALPHA_INTERPOLATION_DEFAULT : any;
        static readonly VALUE_TEXT_ANTIALIAS_ON : any;
        static readonly VALUE_COLOR_RENDER_SPEED : any;
        get class(): Internal.Class<any>;
        get empty(): boolean;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    type RenderingHints_ = RenderingHints;
    class StringConfig extends Internal.ConfigFromString<string> {
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        getName(): string;
        setCanEdit(e: boolean): Internal.ConfigValue<string>;
        notifyAll(): void;
        isEqual(v1: string, v2: string): boolean;
        compareTo(o: Internal.ConfigValue_<string>): number;
        notify(): void;
        getCanEdit(): boolean;
        getStringFromValue(v: string): string;
        getTooltip(): string;
        hashCode(): number;
        getStringForGUI(v: string): Internal.Component;
        getPath(): string;
        copy(value: string): string;
        static info(key: string, value: any): Internal.Component;
        init(g: Internal.ConfigGroup_, i: string, v: string, c: Internal.Consumer_<string>, def: string): Internal.ConfigValue<string>;
        getColor(v: string): Internal.Color4I;
        addInfo(list: Internal.TooltipList_): void;
        parse(callback: Internal.Consumer_<string>, string: string): boolean;
        getIcon(v: string): Internal.Icon;
        setIcon(i: Internal.Icon_): Internal.ConfigValue<string>;
        setOrder(o: number): Internal.ConfigValue<string>;
        getNameKey(): string;
        setNameKey(key: string): Internal.ConfigValue<string>;
        equals(arg0: any): boolean;
        onClicked(button: Internal.MouseButton_, callback: Internal.ConfigCallback_): void;
        toString(): string;
        setCurrentValue(v: string): boolean;
        static readonly COLOR : Internal.Color4I;
        defaultValue : string;
        readonly pattern : Internal.Pattern;
        id : string;
        static readonly NULL_TEXT : Internal.TextComponent;
        setter : ((arg0: string) => void);
        value : string;
        group : Internal.ConfigGroup;
        get path(): string;
        get nameKey(): string;
        get canEdit(): boolean;
        get name(): string;
        get tooltip(): string;
        get class(): Internal.Class<any>;
        set nameKey(key: string);
        set canEdit(e: boolean);
        set icon(i: Internal.Icon_);
        set currentValue(v: string);
        set order(o: number);
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    type StringConfig_ = StringConfig;
    abstract class ContentWidget <T> extends Internal.SelectableWidgetGroup {
        getClass(): Internal.Class<any>;
        mouseWheelMove(arg0: number, arg1: number, arg2: number): boolean;
        openConfigurator(arg0: Internal.WidgetGroup_): void;
        mouseDragged(arg0: number, arg1: number, arg2: number, arg3: number, arg4: number): boolean;
        drawInForeground(arg0: Internal.PoseStack_, arg1: number, arg2: number, arg3: number): void;
        setOnMouseClicked(arg0: Internal.Consumer_<Internal.ContentWidget_<T>>): Internal.ContentWidget<T>;
        readUpdateInfo(arg0: number, arg1: Internal.FriendlyByteBuf_): void;
        toRectangleBox(): Internal.Rect2i;
        isActive(): boolean;
        getSlotName(): string;
        getGui(): Internal.ModularUI;
        updateScreen(): void;
        clearAllWidgets(): void;
        setOnSelected(arg0: Internal.Consumer_<Internal.SelectableWidgetGroup_>): Internal.SelectableWidgetGroup;
        mouseMoved(arg0: number, arg1: number): void;
        isChild(arg0: com.lowdragmc.lowdraglib.gui.widget.Widget_): boolean;
        allowSelected(arg0: number, arg1: number, arg2: number): boolean;
        setVisible(arg0: boolean): void;
        static isMouseOver(arg0: number, arg1: number, arg2: number, arg3: number, arg4: number, arg5: number): boolean;
        addSelfPosition(arg0: number, arg1: number): Internal.Position;
        isParent(arg0: Internal.WidgetGroup_): boolean;
        keyPressed(arg0: number, arg1: number, arg2: number): boolean;
        setOnUnSelected(arg0: Internal.Consumer_<Internal.SelectableWidgetGroup_>): Internal.SelectableWidgetGroup;
        drawChance(arg0: Internal.PoseStack_): void;
        setHoverTexture(arg0: Internal.IGuiTexture_[]): com.lowdragmc.lowdraglib.gui.widget.Widget;
        isMouseOverElement(arg0: number, arg1: number): boolean;
        isVisible(): boolean;
        getSelfPosition(): Internal.Position;
        setClientSideWidget(): Internal.WidgetGroup;
        handleClientAction(arg0: number, arg1: Internal.FriendlyByteBuf_): void;
        setSelectedTexture(arg0: Internal.IGuiTexture_): Internal.SelectableWidgetGroup;
        setSelectedTexture(arg0: number, arg1: number): Internal.SelectableWidgetGroup;
        drawTick(arg0: Internal.PoseStack_): void;
        mouseClicked(arg0: number, arg1: number, arg2: number): boolean;
        charTyped(arg0: string, arg1: number): boolean;
        onSelected(): void;
        removeWidget(arg0: com.lowdragmc.lowdraglib.gui.widget.Widget_): void;
        readInitialData(arg0: Internal.FriendlyByteBuf_): void;
        getJEIContent(arg0: any): T;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        setContent(arg0: Internal.IO_, arg1: any, arg2: number, arg3: boolean): Internal.ContentWidget<T>;
        setContent(arg0: Internal.IO_, arg1: Internal.Content_, arg2: boolean): Internal.ContentWidget<T>;
        getChance(): number;
        notifyAll(): void;
        getIo(): Internal.IO;
        getContent(): T;
        isInitialized(): boolean;
        setBackground(arg0: Internal.IGuiTexture_): Internal.ContentWidget<T>;
        setBackground(arg0: Internal.IGuiTexture_[]): com.lowdragmc.lowdraglib.gui.widget.Widget;
        notify(): void;
        mouseReleased(arg0: number, arg1: number, arg2: number): boolean;
        setSize(arg0: Internal.Size_): void;
        initWidget(): void;
        hashCode(): number;
        drawHoverOverlay(arg0: Internal.PoseStack_, arg1: number, arg2: number): void;
        getNativeWidgets(): Internal.List<Internal.SlotWidget>;
        isSelected(): boolean;
        setOnPhantomUpdate(arg0: Internal.Consumer_<Internal.ContentWidget_<T>>): Internal.ContentWidget<T>;
        keyReleased(arg0: number, arg1: number, arg2: number): boolean;
        waitToRemoved(arg0: com.lowdragmc.lowdraglib.gui.widget.Widget_): void;
        detectAndSendChanges(): void;
        getPhantomTargets(arg0: any): Internal.List<Internal.Target>;
        getParent(): Internal.WidgetGroup;
        onUnSelected(): void;
        isRemote(): boolean;
        setSelfPosition(arg0: number, arg1: number): Internal.ContentWidget<T>;
        setSelfPosition(arg0: Internal.Position_): void;
        getPerTick(): boolean;
        setFocus(arg0: boolean): void;
        setUiAccess(arg0: Internal.WidgetUIAccess_): void;
        drawInBackground(arg0: Internal.PoseStack_, arg1: number, arg2: number, arg3: number): void;
        getParentPosition(): Internal.Position;
        getSize(): Internal.Size;
        setActive(arg0: boolean): void;
        getPosition(): Internal.Position;
        getIngredientOverMouse(arg0: number, arg1: number): any;
        isFocus(): boolean;
        getJEIIngredient(arg0: T): any;
        equals(arg0: any): boolean;
        onFocusChanged(arg0: com.lowdragmc.lowdraglib.gui.widget.Widget_, arg1: com.lowdragmc.lowdraglib.gui.widget.Widget_): void;
        setHoverTooltips(arg0: string[]): Internal.ContentWidget<T>;
        setHoverTooltips(arg0: Internal.List_<Internal.Component_>): com.lowdragmc.lowdraglib.gui.widget.Widget;
        setHoverTooltips(arg0: Internal.Component_[]): com.lowdragmc.lowdraglib.gui.widget.Widget;
        writeInitialData(arg0: Internal.FriendlyByteBuf_): void;
        toString(): string;
        setParentPosition(arg0: Internal.Position_): void;
        addWidget(arg0: com.lowdragmc.lowdraglib.gui.widget.Widget_): Internal.ContentWidget<T>;
        addWidget(arg0: number, arg1: com.lowdragmc.lowdraglib.gui.widget.Widget_): Internal.WidgetGroup;
        setGui(arg0: Internal.ModularUI_): void;
        getContainedWidgets(arg0: boolean): Internal.List<com.lowdragmc.lowdraglib.gui.widget.Widget>;
        readonly widgets : Internal.List<com.lowdragmc.lowdraglib.gui.widget.Widget>;
        get selfPosition(): Internal.Position;
        get parent(): Internal.WidgetGroup;
        get visible(): boolean;
        get chance(): number;
        get nativeWidgets(): Internal.List<Internal.SlotWidget>;
        get io(): Internal.IO;
        get active(): boolean;
        get focus(): boolean;
        get remote(): boolean;
        get content(): T;
        get slotName(): string;
        get parentPosition(): Internal.Position;
        get size(): Internal.Size;
        get initialized(): boolean;
        get gui(): Internal.ModularUI;
        get perTick(): boolean;
        get position(): Internal.Position;
        get class(): Internal.Class<any>;
        get selected(): boolean;
        set selfPosition(arg0: Internal.Position_);
        set onPhantomUpdate(arg0: Internal.Consumer_<Internal.ContentWidget_<T>>);
        set visible(arg0: boolean);
        set active(arg0: boolean);
        set focus(arg0: boolean);
        set hoverTooltips(arg0: string[]);
        set parentPosition(arg0: Internal.Position_);
        set selectedTexture(arg0: Internal.IGuiTexture_);
        set size(arg0: Internal.Size_);
        set hoverTexture(arg0: Internal.IGuiTexture_[]);
        set background(arg0: Internal.IGuiTexture_);
        set onMouseClicked(arg0: Internal.Consumer_<Internal.ContentWidget_<T>>);
        set gui(arg0: Internal.ModularUI_);
        set uiAccess(arg0: Internal.WidgetUIAccess_);
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    type ContentWidget_<T> = ContentWidget<T>;
    interface BlockAccess {
        getMaterial(): Internal.Material;
    }
    type BlockAccess_ = BlockAccess;
    class Commands$CommandSelection extends Internal.Enum<Internal.Commands$CommandSelection> {
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        static valueOf(arg0: string): Internal.Commands$CommandSelection;
        static valueOf<T_>(arg0: Internal.Class_<T_>, arg1: string): T_;
        notifyAll(): void;
        static values(): Internal.Commands$CommandSelection[];
        compareTo(arg0: Internal.Commands$CommandSelection_): number;
        describeConstable(): Internal.Optional<Internal.Enum$EnumDesc<Internal.Commands$CommandSelection>>;
        notify(): void;
        getDeclaringClass(): Internal.Class<Internal.Commands$CommandSelection>;
        hashCode(): number;
        equals(arg0: any): boolean;
        name(): string;
        toString(): string;
        ordinal(): number;
        static readonly ALL : Internal.Commands$CommandSelection;
        static readonly INTEGRATED : Internal.Commands$CommandSelection;
        static readonly DEDICATED : Internal.Commands$CommandSelection;
        get class(): Internal.Class<any>;
        get declaringClass(): Internal.Class<Internal.Commands$CommandSelection>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    type Commands$CommandSelection_ = "all" | "dedicated" | "integrated" | Commands$CommandSelection;
    /**
    */
    class BasicMobEffect$Builder extends Internal.MobEffectBuilder {
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        clientRegistry(minecraft: Internal.Minecraft_): void;
        transformObject(obj: Internal.MobEffect_): Internal.MobEffect;
        translationKey(key: string): Internal.BuilderBase<Internal.MobEffect>;
        color(col: Internal.Color_): Internal.MobEffectBuilder;
        newID(pre: string, post: string): ResourceLocation;
        displayName(name: string): Internal.BuilderBase<Internal.MobEffect>;
        notifyAll(): void;
        effectTick(effectTick: Internal.MobEffectBuilder$EffectTickCallback_): Internal.MobEffectBuilder;
        type(type: string): Internal.BuilderBase<Internal.MobEffect>;
        notify(): void;
        createAdditionalObjects(): void;
        harmful(): Internal.MobEffectBuilder;
        hashCode(): number;
        get(): Internal.MobEffect;
        tag(tag: ResourceLocation_): Internal.BuilderBase<Internal.MobEffect>;
        generateDataJsons(generator: Internal.DataJsonGenerator_): void;
        generateAssetJsons(generator: Internal.AssetJsonGenerator_): void;
        getTranslationKeyGroup(): string;
        generateLang(lang: Internal.Map_<string, string>): void;
        createObject(): Internal.MobEffect;
        addResourcePackLocations(path: string, list: Internal.List_<ResourceLocation_>, packType: Internal.PackType_): void;
        /**
        */
        modifyAttribute(attribute: net.minecraft.world.entity.ai.attributes.Attribute_, identifier: string, d: number, operation: Internal.AttributeModifier$Operation_): Internal.MobEffectBuilder;
        beneficial(): Internal.MobEffectBuilder;
        equals(arg0: any): boolean;
        getRegistryType(): Internal.RegistryObjectBuilderTypes<Internal.MobEffect>;
        toString(): string;
        category(c: Internal.MobEffectCategory_): Internal.MobEffectBuilder;
        readonly id : ResourceLocation;
        get registryType(): Internal.RegistryObjectBuilderTypes<Internal.MobEffect>;
        get class(): Internal.Class<any>;
        get translationKeyGroup(): string;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    /**
    */
    type BasicMobEffect$Builder_ = BasicMobEffect$Builder;
    class RecordCodecBuilder$Instance <O> implements Internal.Applicative<Internal.RecordCodecBuilder$Mu<O>, any> {
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        notifyAll(): void;
        deprecated<A_>(arg0: A_, arg1: number): Internal.App<Internal.RecordCodecBuilder$Mu<O>, A_>;
        notify(): void;
        point<A_>(arg0: A_, arg1: Internal.Lifecycle_): Internal.App<Internal.RecordCodecBuilder$Mu<O>, A_>;
        point<A_>(arg0: A_): Internal.App<Internal.RecordCodecBuilder$Mu<O>, A_>;
        hashCode(): number;
        map<T_, R_>(arg0: java_.util.function_.Function_<T_, R_>, arg1: Internal.App_<Internal.RecordCodecBuilder$Mu_<O>, T_>): Internal.App<Internal.RecordCodecBuilder$Mu<O>, R_>;
        group<T1_, T2_, T3_, T4_, T5_, T6_, T7_, T8_, T9_, T10_, T11_>(arg0: Internal.App_<Internal.RecordCodecBuilder$Mu_<O>, T1_>, arg1: Internal.App_<Internal.RecordCodecBuilder$Mu_<O>, T2_>, arg2: Internal.App_<Internal.RecordCodecBuilder$Mu_<O>, T3_>, arg3: Internal.App_<Internal.RecordCodecBuilder$Mu_<O>, T4_>, arg4: Internal.App_<Internal.RecordCodecBuilder$Mu_<O>, T5_>, arg5: Internal.App_<Internal.RecordCodecBuilder$Mu_<O>, T6_>, arg6: Internal.App_<Internal.RecordCodecBuilder$Mu_<O>, T7_>, arg7: Internal.App_<Internal.RecordCodecBuilder$Mu_<O>, T8_>, arg8: Internal.App_<Internal.RecordCodecBuilder$Mu_<O>, T9_>, arg9: Internal.App_<Internal.RecordCodecBuilder$Mu_<O>, T10_>, arg10: Internal.App_<Internal.RecordCodecBuilder$Mu_<O>, T11_>): Internal.Products$P11<Internal.RecordCodecBuilder$Mu<O>, T1_, T2_, T3_, T4_, T5_, T6_, T7_, T8_, T9_, T10_, T11_>;
        group<T1_, T2_, T3_, T4_, T5_, T6_, T7_, T8_, T9_, T10_>(arg0: Internal.App_<Internal.RecordCodecBuilder$Mu_<O>, T1_>, arg1: Internal.App_<Internal.RecordCodecBuilder$Mu_<O>, T2_>, arg2: Internal.App_<Internal.RecordCodecBuilder$Mu_<O>, T3_>, arg3: Internal.App_<Internal.RecordCodecBuilder$Mu_<O>, T4_>, arg4: Internal.App_<Internal.RecordCodecBuilder$Mu_<O>, T5_>, arg5: Internal.App_<Internal.RecordCodecBuilder$Mu_<O>, T6_>, arg6: Internal.App_<Internal.RecordCodecBuilder$Mu_<O>, T7_>, arg7: Internal.App_<Internal.RecordCodecBuilder$Mu_<O>, T8_>, arg8: Internal.App_<Internal.RecordCodecBuilder$Mu_<O>, T9_>, arg9: Internal.App_<Internal.RecordCodecBuilder$Mu_<O>, T10_>): Internal.Products$P10<Internal.RecordCodecBuilder$Mu<O>, T1_, T2_, T3_, T4_, T5_, T6_, T7_, T8_, T9_, T10_>;
        group<T1_, T2_, T3_, T4_, T5_, T6_, T7_, T8_, T9_>(arg0: Internal.App_<Internal.RecordCodecBuilder$Mu_<O>, T1_>, arg1: Internal.App_<Internal.RecordCodecBuilder$Mu_<O>, T2_>, arg2: Internal.App_<Internal.RecordCodecBuilder$Mu_<O>, T3_>, arg3: Internal.App_<Internal.RecordCodecBuilder$Mu_<O>, T4_>, arg4: Internal.App_<Internal.RecordCodecBuilder$Mu_<O>, T5_>, arg5: Internal.App_<Internal.RecordCodecBuilder$Mu_<O>, T6_>, arg6: Internal.App_<Internal.RecordCodecBuilder$Mu_<O>, T7_>, arg7: Internal.App_<Internal.RecordCodecBuilder$Mu_<O>, T8_>, arg8: Internal.App_<Internal.RecordCodecBuilder$Mu_<O>, T9_>): Internal.Products$P9<Internal.RecordCodecBuilder$Mu<O>, T1_, T2_, T3_, T4_, T5_, T6_, T7_, T8_, T9_>;
        group<T1_, T2_, T3_, T4_, T5_, T6_, T7_, T8_, T9_, T10_, T11_, T12_, T13_, T14_, T15_, T16_>(arg0: Internal.App_<Internal.RecordCodecBuilder$Mu_<O>, T1_>, arg1: Internal.App_<Internal.RecordCodecBuilder$Mu_<O>, T2_>, arg2: Internal.App_<Internal.RecordCodecBuilder$Mu_<O>, T3_>, arg3: Internal.App_<Internal.RecordCodecBuilder$Mu_<O>, T4_>, arg4: Internal.App_<Internal.RecordCodecBuilder$Mu_<O>, T5_>, arg5: Internal.App_<Internal.RecordCodecBuilder$Mu_<O>, T6_>, arg6: Internal.App_<Internal.RecordCodecBuilder$Mu_<O>, T7_>, arg7: Internal.App_<Internal.RecordCodecBuilder$Mu_<O>, T8_>, arg8: Internal.App_<Internal.RecordCodecBuilder$Mu_<O>, T9_>, arg9: Internal.App_<Internal.RecordCodecBuilder$Mu_<O>, T10_>, arg10: Internal.App_<Internal.RecordCodecBuilder$Mu_<O>, T11_>, arg11: Internal.App_<Internal.RecordCodecBuilder$Mu_<O>, T12_>, arg12: Internal.App_<Internal.RecordCodecBuilder$Mu_<O>, T13_>, arg13: Internal.App_<Internal.RecordCodecBuilder$Mu_<O>, T14_>, arg14: Internal.App_<Internal.RecordCodecBuilder$Mu_<O>, T15_>, arg15: Internal.App_<Internal.RecordCodecBuilder$Mu_<O>, T16_>): Internal.Products$P16<Internal.RecordCodecBuilder$Mu<O>, T1_, T2_, T3_, T4_, T5_, T6_, T7_, T8_, T9_, T10_, T11_, T12_, T13_, T14_, T15_, T16_>;
        group<T1_, T2_, T3_, T4_, T5_, T6_, T7_, T8_, T9_, T10_, T11_, T12_, T13_, T14_, T15_>(arg0: Internal.App_<Internal.RecordCodecBuilder$Mu_<O>, T1_>, arg1: Internal.App_<Internal.RecordCodecBuilder$Mu_<O>, T2_>, arg2: Internal.App_<Internal.RecordCodecBuilder$Mu_<O>, T3_>, arg3: Internal.App_<Internal.RecordCodecBuilder$Mu_<O>, T4_>, arg4: Internal.App_<Internal.RecordCodecBuilder$Mu_<O>, T5_>, arg5: Internal.App_<Internal.RecordCodecBuilder$Mu_<O>, T6_>, arg6: Internal.App_<Internal.RecordCodecBuilder$Mu_<O>, T7_>, arg7: Internal.App_<Internal.RecordCodecBuilder$Mu_<O>, T8_>, arg8: Internal.App_<Internal.RecordCodecBuilder$Mu_<O>, T9_>, arg9: Internal.App_<Internal.RecordCodecBuilder$Mu_<O>, T10_>, arg10: Internal.App_<Internal.RecordCodecBuilder$Mu_<O>, T11_>, arg11: Internal.App_<Internal.RecordCodecBuilder$Mu_<O>, T12_>, arg12: Internal.App_<Internal.RecordCodecBuilder$Mu_<O>, T13_>, arg13: Internal.App_<Internal.RecordCodecBuilder$Mu_<O>, T14_>, arg14: Internal.App_<Internal.RecordCodecBuilder$Mu_<O>, T15_>): Internal.Products$P15<Internal.RecordCodecBuilder$Mu<O>, T1_, T2_, T3_, T4_, T5_, T6_, T7_, T8_, T9_, T10_, T11_, T12_, T13_, T14_, T15_>;
        group<T1_, T2_, T3_, T4_, T5_, T6_, T7_, T8_, T9_, T10_, T11_, T12_, T13_, T14_>(arg0: Internal.App_<Internal.RecordCodecBuilder$Mu_<O>, T1_>, arg1: Internal.App_<Internal.RecordCodecBuilder$Mu_<O>, T2_>, arg2: Internal.App_<Internal.RecordCodecBuilder$Mu_<O>, T3_>, arg3: Internal.App_<Internal.RecordCodecBuilder$Mu_<O>, T4_>, arg4: Internal.App_<Internal.RecordCodecBuilder$Mu_<O>, T5_>, arg5: Internal.App_<Internal.RecordCodecBuilder$Mu_<O>, T6_>, arg6: Internal.App_<Internal.RecordCodecBuilder$Mu_<O>, T7_>, arg7: Internal.App_<Internal.RecordCodecBuilder$Mu_<O>, T8_>, arg8: Internal.App_<Internal.RecordCodecBuilder$Mu_<O>, T9_>, arg9: Internal.App_<Internal.RecordCodecBuilder$Mu_<O>, T10_>, arg10: Internal.App_<Internal.RecordCodecBuilder$Mu_<O>, T11_>, arg11: Internal.App_<Internal.RecordCodecBuilder$Mu_<O>, T12_>, arg12: Internal.App_<Internal.RecordCodecBuilder$Mu_<O>, T13_>, arg13: Internal.App_<Internal.RecordCodecBuilder$Mu_<O>, T14_>): Internal.Products$P14<Internal.RecordCodecBuilder$Mu<O>, T1_, T2_, T3_, T4_, T5_, T6_, T7_, T8_, T9_, T10_, T11_, T12_, T13_, T14_>;
        group<T1_, T2_, T3_, T4_, T5_, T6_, T7_, T8_, T9_, T10_, T11_, T12_, T13_>(arg0: Internal.App_<Internal.RecordCodecBuilder$Mu_<O>, T1_>, arg1: Internal.App_<Internal.RecordCodecBuilder$Mu_<O>, T2_>, arg2: Internal.App_<Internal.RecordCodecBuilder$Mu_<O>, T3_>, arg3: Internal.App_<Internal.RecordCodecBuilder$Mu_<O>, T4_>, arg4: Internal.App_<Internal.RecordCodecBuilder$Mu_<O>, T5_>, arg5: Internal.App_<Internal.RecordCodecBuilder$Mu_<O>, T6_>, arg6: Internal.App_<Internal.RecordCodecBuilder$Mu_<O>, T7_>, arg7: Internal.App_<Internal.RecordCodecBuilder$Mu_<O>, T8_>, arg8: Internal.App_<Internal.RecordCodecBuilder$Mu_<O>, T9_>, arg9: Internal.App_<Internal.RecordCodecBuilder$Mu_<O>, T10_>, arg10: Internal.App_<Internal.RecordCodecBuilder$Mu_<O>, T11_>, arg11: Internal.App_<Internal.RecordCodecBuilder$Mu_<O>, T12_>, arg12: Internal.App_<Internal.RecordCodecBuilder$Mu_<O>, T13_>): Internal.Products$P13<Internal.RecordCodecBuilder$Mu<O>, T1_, T2_, T3_, T4_, T5_, T6_, T7_, T8_, T9_, T10_, T11_, T12_, T13_>;
        group<T1_, T2_, T3_, T4_, T5_, T6_, T7_, T8_, T9_, T10_, T11_, T12_>(arg0: Internal.App_<Internal.RecordCodecBuilder$Mu_<O>, T1_>, arg1: Internal.App_<Internal.RecordCodecBuilder$Mu_<O>, T2_>, arg2: Internal.App_<Internal.RecordCodecBuilder$Mu_<O>, T3_>, arg3: Internal.App_<Internal.RecordCodecBuilder$Mu_<O>, T4_>, arg4: Internal.App_<Internal.RecordCodecBuilder$Mu_<O>, T5_>, arg5: Internal.App_<Internal.RecordCodecBuilder$Mu_<O>, T6_>, arg6: Internal.App_<Internal.RecordCodecBuilder$Mu_<O>, T7_>, arg7: Internal.App_<Internal.RecordCodecBuilder$Mu_<O>, T8_>, arg8: Internal.App_<Internal.RecordCodecBuilder$Mu_<O>, T9_>, arg9: Internal.App_<Internal.RecordCodecBuilder$Mu_<O>, T10_>, arg10: Internal.App_<Internal.RecordCodecBuilder$Mu_<O>, T11_>, arg11: Internal.App_<Internal.RecordCodecBuilder$Mu_<O>, T12_>): Internal.Products$P12<Internal.RecordCodecBuilder$Mu<O>, T1_, T2_, T3_, T4_, T5_, T6_, T7_, T8_, T9_, T10_, T11_, T12_>;
        group<T1_, T2_, T3_>(arg0: Internal.App_<Internal.RecordCodecBuilder$Mu_<O>, T1_>, arg1: Internal.App_<Internal.RecordCodecBuilder$Mu_<O>, T2_>, arg2: Internal.App_<Internal.RecordCodecBuilder$Mu_<O>, T3_>): Internal.Products$P3<Internal.RecordCodecBuilder$Mu<O>, T1_, T2_, T3_>;
        group<T1_, T2_>(arg0: Internal.App_<Internal.RecordCodecBuilder$Mu_<O>, T1_>, arg1: Internal.App_<Internal.RecordCodecBuilder$Mu_<O>, T2_>): Internal.Products$P2<Internal.RecordCodecBuilder$Mu<O>, T1_, T2_>;
        group<T1_>(arg0: Internal.App_<Internal.RecordCodecBuilder$Mu_<O>, T1_>): Internal.Products$P1<Internal.RecordCodecBuilder$Mu<O>, T1_>;
        group<T1_, T2_, T3_, T4_, T5_, T6_, T7_, T8_>(arg0: Internal.App_<Internal.RecordCodecBuilder$Mu_<O>, T1_>, arg1: Internal.App_<Internal.RecordCodecBuilder$Mu_<O>, T2_>, arg2: Internal.App_<Internal.RecordCodecBuilder$Mu_<O>, T3_>, arg3: Internal.App_<Internal.RecordCodecBuilder$Mu_<O>, T4_>, arg4: Internal.App_<Internal.RecordCodecBuilder$Mu_<O>, T5_>, arg5: Internal.App_<Internal.RecordCodecBuilder$Mu_<O>, T6_>, arg6: Internal.App_<Internal.RecordCodecBuilder$Mu_<O>, T7_>, arg7: Internal.App_<Internal.RecordCodecBuilder$Mu_<O>, T8_>): Internal.Products$P8<Internal.RecordCodecBuilder$Mu<O>, T1_, T2_, T3_, T4_, T5_, T6_, T7_, T8_>;
        group<T1_, T2_, T3_, T4_, T5_, T6_, T7_>(arg0: Internal.App_<Internal.RecordCodecBuilder$Mu_<O>, T1_>, arg1: Internal.App_<Internal.RecordCodecBuilder$Mu_<O>, T2_>, arg2: Internal.App_<Internal.RecordCodecBuilder$Mu_<O>, T3_>, arg3: Internal.App_<Internal.RecordCodecBuilder$Mu_<O>, T4_>, arg4: Internal.App_<Internal.RecordCodecBuilder$Mu_<O>, T5_>, arg5: Internal.App_<Internal.RecordCodecBuilder$Mu_<O>, T6_>, arg6: Internal.App_<Internal.RecordCodecBuilder$Mu_<O>, T7_>): Internal.Products$P7<Internal.RecordCodecBuilder$Mu<O>, T1_, T2_, T3_, T4_, T5_, T6_, T7_>;
        group<T1_, T2_, T3_, T4_, T5_, T6_>(arg0: Internal.App_<Internal.RecordCodecBuilder$Mu_<O>, T1_>, arg1: Internal.App_<Internal.RecordCodecBuilder$Mu_<O>, T2_>, arg2: Internal.App_<Internal.RecordCodecBuilder$Mu_<O>, T3_>, arg3: Internal.App_<Internal.RecordCodecBuilder$Mu_<O>, T4_>, arg4: Internal.App_<Internal.RecordCodecBuilder$Mu_<O>, T5_>, arg5: Internal.App_<Internal.RecordCodecBuilder$Mu_<O>, T6_>): Internal.Products$P6<Internal.RecordCodecBuilder$Mu<O>, T1_, T2_, T3_, T4_, T5_, T6_>;
        group<T1_, T2_, T3_, T4_, T5_>(arg0: Internal.App_<Internal.RecordCodecBuilder$Mu_<O>, T1_>, arg1: Internal.App_<Internal.RecordCodecBuilder$Mu_<O>, T2_>, arg2: Internal.App_<Internal.RecordCodecBuilder$Mu_<O>, T3_>, arg3: Internal.App_<Internal.RecordCodecBuilder$Mu_<O>, T4_>, arg4: Internal.App_<Internal.RecordCodecBuilder$Mu_<O>, T5_>): Internal.Products$P5<Internal.RecordCodecBuilder$Mu<O>, T1_, T2_, T3_, T4_, T5_>;
        group<T1_, T2_, T3_, T4_>(arg0: Internal.App_<Internal.RecordCodecBuilder$Mu_<O>, T1_>, arg1: Internal.App_<Internal.RecordCodecBuilder$Mu_<O>, T2_>, arg2: Internal.App_<Internal.RecordCodecBuilder$Mu_<O>, T3_>, arg3: Internal.App_<Internal.RecordCodecBuilder$Mu_<O>, T4_>): Internal.Products$P4<Internal.RecordCodecBuilder$Mu<O>, T1_, T2_, T3_, T4_>;
        apply2<A_, B_, R_>(arg0: Internal.BiFunction_<A_, B_, R_>, arg1: Internal.App_<Internal.RecordCodecBuilder$Mu_<O>, A_>, arg2: Internal.App_<Internal.RecordCodecBuilder$Mu_<O>, B_>): Internal.App<Internal.RecordCodecBuilder$Mu<O>, R_>;
        apply3<T1_, T2_, T3_, R_>(arg0: Internal.Function3_<T1_, T2_, T3_, R_>, arg1: Internal.App_<Internal.RecordCodecBuilder$Mu_<O>, T1_>, arg2: Internal.App_<Internal.RecordCodecBuilder$Mu_<O>, T2_>, arg3: Internal.App_<Internal.RecordCodecBuilder$Mu_<O>, T3_>): Internal.App<Internal.RecordCodecBuilder$Mu<O>, R_>;
        ap11<T1_, T2_, T3_, T4_, T5_, T6_, T7_, T8_, T9_, T10_, T11_, R_>(arg0: Internal.App_<Internal.RecordCodecBuilder$Mu_<O>, Internal.Function11_<T1_, T2_, T3_, T4_, T5_, T6_, T7_, T8_, T9_, T10_, T11_, R_>>, arg1: Internal.App_<Internal.RecordCodecBuilder$Mu_<O>, T1_>, arg2: Internal.App_<Internal.RecordCodecBuilder$Mu_<O>, T2_>, arg3: Internal.App_<Internal.RecordCodecBuilder$Mu_<O>, T3_>, arg4: Internal.App_<Internal.RecordCodecBuilder$Mu_<O>, T4_>, arg5: Internal.App_<Internal.RecordCodecBuilder$Mu_<O>, T5_>, arg6: Internal.App_<Internal.RecordCodecBuilder$Mu_<O>, T6_>, arg7: Internal.App_<Internal.RecordCodecBuilder$Mu_<O>, T7_>, arg8: Internal.App_<Internal.RecordCodecBuilder$Mu_<O>, T8_>, arg9: Internal.App_<Internal.RecordCodecBuilder$Mu_<O>, T9_>, arg10: Internal.App_<Internal.RecordCodecBuilder$Mu_<O>, T10_>, arg11: Internal.App_<Internal.RecordCodecBuilder$Mu_<O>, T11_>): Internal.App<Internal.RecordCodecBuilder$Mu<O>, R_>;
        apply4<T1_, T2_, T3_, T4_, R_>(arg0: Internal.Function4_<T1_, T2_, T3_, T4_, R_>, arg1: Internal.App_<Internal.RecordCodecBuilder$Mu_<O>, T1_>, arg2: Internal.App_<Internal.RecordCodecBuilder$Mu_<O>, T2_>, arg3: Internal.App_<Internal.RecordCodecBuilder$Mu_<O>, T3_>, arg4: Internal.App_<Internal.RecordCodecBuilder$Mu_<O>, T4_>): Internal.App<Internal.RecordCodecBuilder$Mu<O>, R_>;
        ap2<A_, B_, R_>(arg0: Internal.App_<Internal.RecordCodecBuilder$Mu_<O>, Internal.BiFunction_<A_, B_, R_>>, arg1: Internal.App_<Internal.RecordCodecBuilder$Mu_<O>, A_>, arg2: Internal.App_<Internal.RecordCodecBuilder$Mu_<O>, B_>): Internal.App<Internal.RecordCodecBuilder$Mu<O>, R_>;
        ap10<T1_, T2_, T3_, T4_, T5_, T6_, T7_, T8_, T9_, T10_, R_>(arg0: Internal.App_<Internal.RecordCodecBuilder$Mu_<O>, Internal.Function10_<T1_, T2_, T3_, T4_, T5_, T6_, T7_, T8_, T9_, T10_, R_>>, arg1: Internal.App_<Internal.RecordCodecBuilder$Mu_<O>, T1_>, arg2: Internal.App_<Internal.RecordCodecBuilder$Mu_<O>, T2_>, arg3: Internal.App_<Internal.RecordCodecBuilder$Mu_<O>, T3_>, arg4: Internal.App_<Internal.RecordCodecBuilder$Mu_<O>, T4_>, arg5: Internal.App_<Internal.RecordCodecBuilder$Mu_<O>, T5_>, arg6: Internal.App_<Internal.RecordCodecBuilder$Mu_<O>, T6_>, arg7: Internal.App_<Internal.RecordCodecBuilder$Mu_<O>, T7_>, arg8: Internal.App_<Internal.RecordCodecBuilder$Mu_<O>, T8_>, arg9: Internal.App_<Internal.RecordCodecBuilder$Mu_<O>, T9_>, arg10: Internal.App_<Internal.RecordCodecBuilder$Mu_<O>, T10_>): Internal.App<Internal.RecordCodecBuilder$Mu<O>, R_>;
        apply5<T1_, T2_, T3_, T4_, T5_, R_>(arg0: Internal.Function5_<T1_, T2_, T3_, T4_, T5_, R_>, arg1: Internal.App_<Internal.RecordCodecBuilder$Mu_<O>, T1_>, arg2: Internal.App_<Internal.RecordCodecBuilder$Mu_<O>, T2_>, arg3: Internal.App_<Internal.RecordCodecBuilder$Mu_<O>, T3_>, arg4: Internal.App_<Internal.RecordCodecBuilder$Mu_<O>, T4_>, arg5: Internal.App_<Internal.RecordCodecBuilder$Mu_<O>, T5_>): Internal.App<Internal.RecordCodecBuilder$Mu<O>, R_>;
        lift2<A_, B_, R_>(arg0: Internal.App_<Internal.RecordCodecBuilder$Mu_<O>, Internal.BiFunction_<A_, B_, R_>>): Internal.BiFunction<Internal.App<Internal.RecordCodecBuilder$Mu<O>, A_>, Internal.App<Internal.RecordCodecBuilder$Mu<O>, B_>, Internal.App<Internal.RecordCodecBuilder$Mu<O>, R_>>;
        ap4<T1_, T2_, T3_, T4_, R_>(arg0: Internal.App_<Internal.RecordCodecBuilder$Mu_<O>, Internal.Function4_<T1_, T2_, T3_, T4_, R_>>, arg1: Internal.App_<Internal.RecordCodecBuilder$Mu_<O>, T1_>, arg2: Internal.App_<Internal.RecordCodecBuilder$Mu_<O>, T2_>, arg3: Internal.App_<Internal.RecordCodecBuilder$Mu_<O>, T3_>, arg4: Internal.App_<Internal.RecordCodecBuilder$Mu_<O>, T4_>): Internal.App<Internal.RecordCodecBuilder$Mu<O>, R_>;
        ap3<T1_, T2_, T3_, R_>(arg0: Internal.App_<Internal.RecordCodecBuilder$Mu_<O>, Internal.Function3_<T1_, T2_, T3_, R_>>, arg1: Internal.App_<Internal.RecordCodecBuilder$Mu_<O>, T1_>, arg2: Internal.App_<Internal.RecordCodecBuilder$Mu_<O>, T2_>, arg3: Internal.App_<Internal.RecordCodecBuilder$Mu_<O>, T3_>): Internal.App<Internal.RecordCodecBuilder$Mu<O>, R_>;
        lift1<A_, R_>(arg0: Internal.App_<Internal.RecordCodecBuilder$Mu_<O>, java_.util.function_.Function_<A_, R_>>): java_.util.function_.Function<Internal.App<Internal.RecordCodecBuilder$Mu<O>, A_>, Internal.App<Internal.RecordCodecBuilder$Mu<O>, R_>>;
        ap6<T1_, T2_, T3_, T4_, T5_, T6_, R_>(arg0: Internal.App_<Internal.RecordCodecBuilder$Mu_<O>, Internal.Function6_<T1_, T2_, T3_, T4_, T5_, T6_, R_>>, arg1: Internal.App_<Internal.RecordCodecBuilder$Mu_<O>, T1_>, arg2: Internal.App_<Internal.RecordCodecBuilder$Mu_<O>, T2_>, arg3: Internal.App_<Internal.RecordCodecBuilder$Mu_<O>, T3_>, arg4: Internal.App_<Internal.RecordCodecBuilder$Mu_<O>, T4_>, arg5: Internal.App_<Internal.RecordCodecBuilder$Mu_<O>, T5_>, arg6: Internal.App_<Internal.RecordCodecBuilder$Mu_<O>, T6_>): Internal.App<Internal.RecordCodecBuilder$Mu<O>, R_>;
        ap5<T1_, T2_, T3_, T4_, T5_, R_>(arg0: Internal.App_<Internal.RecordCodecBuilder$Mu_<O>, Internal.Function5_<T1_, T2_, T3_, T4_, T5_, R_>>, arg1: Internal.App_<Internal.RecordCodecBuilder$Mu_<O>, T1_>, arg2: Internal.App_<Internal.RecordCodecBuilder$Mu_<O>, T2_>, arg3: Internal.App_<Internal.RecordCodecBuilder$Mu_<O>, T3_>, arg4: Internal.App_<Internal.RecordCodecBuilder$Mu_<O>, T4_>, arg5: Internal.App_<Internal.RecordCodecBuilder$Mu_<O>, T5_>): Internal.App<Internal.RecordCodecBuilder$Mu<O>, R_>;
        ap8<T1_, T2_, T3_, T4_, T5_, T6_, T7_, T8_, R_>(arg0: Internal.App_<Internal.RecordCodecBuilder$Mu_<O>, Internal.Function8_<T1_, T2_, T3_, T4_, T5_, T6_, T7_, T8_, R_>>, arg1: Internal.App_<Internal.RecordCodecBuilder$Mu_<O>, T1_>, arg2: Internal.App_<Internal.RecordCodecBuilder$Mu_<O>, T2_>, arg3: Internal.App_<Internal.RecordCodecBuilder$Mu_<O>, T3_>, arg4: Internal.App_<Internal.RecordCodecBuilder$Mu_<O>, T4_>, arg5: Internal.App_<Internal.RecordCodecBuilder$Mu_<O>, T5_>, arg6: Internal.App_<Internal.RecordCodecBuilder$Mu_<O>, T6_>, arg7: Internal.App_<Internal.RecordCodecBuilder$Mu_<O>, T7_>, arg8: Internal.App_<Internal.RecordCodecBuilder$Mu_<O>, T8_>): Internal.App<Internal.RecordCodecBuilder$Mu<O>, R_>;
        lift6<T1_, T2_, T3_, T4_, T5_, T6_, R_>(arg0: Internal.App_<Internal.RecordCodecBuilder$Mu_<O>, Internal.Function6_<T1_, T2_, T3_, T4_, T5_, T6_, R_>>): Internal.Function6<Internal.App<Internal.RecordCodecBuilder$Mu<O>, T1_>, Internal.App<Internal.RecordCodecBuilder$Mu<O>, T2_>, Internal.App<Internal.RecordCodecBuilder$Mu<O>, T3_>, Internal.App<Internal.RecordCodecBuilder$Mu<O>, T4_>, Internal.App<Internal.RecordCodecBuilder$Mu<O>, T5_>, Internal.App<Internal.RecordCodecBuilder$Mu<O>, T6_>, Internal.App<Internal.RecordCodecBuilder$Mu<O>, R_>>;
        ap7<T1_, T2_, T3_, T4_, T5_, T6_, T7_, R_>(arg0: Internal.App_<Internal.RecordCodecBuilder$Mu_<O>, Internal.Function7_<T1_, T2_, T3_, T4_, T5_, T6_, T7_, R_>>, arg1: Internal.App_<Internal.RecordCodecBuilder$Mu_<O>, T1_>, arg2: Internal.App_<Internal.RecordCodecBuilder$Mu_<O>, T2_>, arg3: Internal.App_<Internal.RecordCodecBuilder$Mu_<O>, T3_>, arg4: Internal.App_<Internal.RecordCodecBuilder$Mu_<O>, T4_>, arg5: Internal.App_<Internal.RecordCodecBuilder$Mu_<O>, T5_>, arg6: Internal.App_<Internal.RecordCodecBuilder$Mu_<O>, T6_>, arg7: Internal.App_<Internal.RecordCodecBuilder$Mu_<O>, T7_>): Internal.App<Internal.RecordCodecBuilder$Mu<O>, R_>;
        lift5<T1_, T2_, T3_, T4_, T5_, R_>(arg0: Internal.App_<Internal.RecordCodecBuilder$Mu_<O>, Internal.Function5_<T1_, T2_, T3_, T4_, T5_, R_>>): Internal.Function5<Internal.App<Internal.RecordCodecBuilder$Mu<O>, T1_>, Internal.App<Internal.RecordCodecBuilder$Mu<O>, T2_>, Internal.App<Internal.RecordCodecBuilder$Mu<O>, T3_>, Internal.App<Internal.RecordCodecBuilder$Mu<O>, T4_>, Internal.App<Internal.RecordCodecBuilder$Mu<O>, T5_>, Internal.App<Internal.RecordCodecBuilder$Mu<O>, R_>>;
        lift4<T1_, T2_, T3_, T4_, R_>(arg0: Internal.App_<Internal.RecordCodecBuilder$Mu_<O>, Internal.Function4_<T1_, T2_, T3_, T4_, R_>>): Internal.Function4<Internal.App<Internal.RecordCodecBuilder$Mu<O>, T1_>, Internal.App<Internal.RecordCodecBuilder$Mu<O>, T2_>, Internal.App<Internal.RecordCodecBuilder$Mu<O>, T3_>, Internal.App<Internal.RecordCodecBuilder$Mu<O>, T4_>, Internal.App<Internal.RecordCodecBuilder$Mu<O>, R_>>;
        ap9<T1_, T2_, T3_, T4_, T5_, T6_, T7_, T8_, T9_, R_>(arg0: Internal.App_<Internal.RecordCodecBuilder$Mu_<O>, Internal.Function9_<T1_, T2_, T3_, T4_, T5_, T6_, T7_, T8_, T9_, R_>>, arg1: Internal.App_<Internal.RecordCodecBuilder$Mu_<O>, T1_>, arg2: Internal.App_<Internal.RecordCodecBuilder$Mu_<O>, T2_>, arg3: Internal.App_<Internal.RecordCodecBuilder$Mu_<O>, T3_>, arg4: Internal.App_<Internal.RecordCodecBuilder$Mu_<O>, T4_>, arg5: Internal.App_<Internal.RecordCodecBuilder$Mu_<O>, T5_>, arg6: Internal.App_<Internal.RecordCodecBuilder$Mu_<O>, T6_>, arg7: Internal.App_<Internal.RecordCodecBuilder$Mu_<O>, T7_>, arg8: Internal.App_<Internal.RecordCodecBuilder$Mu_<O>, T8_>, arg9: Internal.App_<Internal.RecordCodecBuilder$Mu_<O>, T9_>): Internal.App<Internal.RecordCodecBuilder$Mu<O>, R_>;
        lift3<T1_, T2_, T3_, R_>(arg0: Internal.App_<Internal.RecordCodecBuilder$Mu_<O>, Internal.Function3_<T1_, T2_, T3_, R_>>): Internal.Function3<Internal.App<Internal.RecordCodecBuilder$Mu<O>, T1_>, Internal.App<Internal.RecordCodecBuilder$Mu<O>, T2_>, Internal.App<Internal.RecordCodecBuilder$Mu<O>, T3_>, Internal.App<Internal.RecordCodecBuilder$Mu<O>, R_>>;
        apply6<T1_, T2_, T3_, T4_, T5_, T6_, R_>(arg0: Internal.Function6_<T1_, T2_, T3_, T4_, T5_, T6_, R_>, arg1: Internal.App_<Internal.RecordCodecBuilder$Mu_<O>, T1_>, arg2: Internal.App_<Internal.RecordCodecBuilder$Mu_<O>, T2_>, arg3: Internal.App_<Internal.RecordCodecBuilder$Mu_<O>, T3_>, arg4: Internal.App_<Internal.RecordCodecBuilder$Mu_<O>, T4_>, arg5: Internal.App_<Internal.RecordCodecBuilder$Mu_<O>, T5_>, arg6: Internal.App_<Internal.RecordCodecBuilder$Mu_<O>, T6_>): Internal.App<Internal.RecordCodecBuilder$Mu<O>, R_>;
        apply7<T1_, T2_, T3_, T4_, T5_, T6_, T7_, R_>(arg0: Internal.Function7_<T1_, T2_, T3_, T4_, T5_, T6_, T7_, R_>, arg1: Internal.App_<Internal.RecordCodecBuilder$Mu_<O>, T1_>, arg2: Internal.App_<Internal.RecordCodecBuilder$Mu_<O>, T2_>, arg3: Internal.App_<Internal.RecordCodecBuilder$Mu_<O>, T3_>, arg4: Internal.App_<Internal.RecordCodecBuilder$Mu_<O>, T4_>, arg5: Internal.App_<Internal.RecordCodecBuilder$Mu_<O>, T5_>, arg6: Internal.App_<Internal.RecordCodecBuilder$Mu_<O>, T6_>, arg7: Internal.App_<Internal.RecordCodecBuilder$Mu_<O>, T7_>): Internal.App<Internal.RecordCodecBuilder$Mu<O>, R_>;
        lift9<T1_, T2_, T3_, T4_, T5_, T6_, T7_, T8_, T9_, R_>(arg0: Internal.App_<Internal.RecordCodecBuilder$Mu_<O>, Internal.Function9_<T1_, T2_, T3_, T4_, T5_, T6_, T7_, T8_, T9_, R_>>): Internal.Function9<Internal.App<Internal.RecordCodecBuilder$Mu<O>, T1_>, Internal.App<Internal.RecordCodecBuilder$Mu<O>, T2_>, Internal.App<Internal.RecordCodecBuilder$Mu<O>, T3_>, Internal.App<Internal.RecordCodecBuilder$Mu<O>, T4_>, Internal.App<Internal.RecordCodecBuilder$Mu<O>, T5_>, Internal.App<Internal.RecordCodecBuilder$Mu<O>, T6_>, Internal.App<Internal.RecordCodecBuilder$Mu<O>, T7_>, Internal.App<Internal.RecordCodecBuilder$Mu<O>, T8_>, Internal.App<Internal.RecordCodecBuilder$Mu<O>, T9_>, Internal.App<Internal.RecordCodecBuilder$Mu<O>, R_>>;
        apply8<T1_, T2_, T3_, T4_, T5_, T6_, T7_, T8_, R_>(arg0: Internal.Function8_<T1_, T2_, T3_, T4_, T5_, T6_, T7_, T8_, R_>, arg1: Internal.App_<Internal.RecordCodecBuilder$Mu_<O>, T1_>, arg2: Internal.App_<Internal.RecordCodecBuilder$Mu_<O>, T2_>, arg3: Internal.App_<Internal.RecordCodecBuilder$Mu_<O>, T3_>, arg4: Internal.App_<Internal.RecordCodecBuilder$Mu_<O>, T4_>, arg5: Internal.App_<Internal.RecordCodecBuilder$Mu_<O>, T5_>, arg6: Internal.App_<Internal.RecordCodecBuilder$Mu_<O>, T6_>, arg7: Internal.App_<Internal.RecordCodecBuilder$Mu_<O>, T7_>, arg8: Internal.App_<Internal.RecordCodecBuilder$Mu_<O>, T8_>): Internal.App<Internal.RecordCodecBuilder$Mu<O>, R_>;
        lift8<T1_, T2_, T3_, T4_, T5_, T6_, T7_, T8_, R_>(arg0: Internal.App_<Internal.RecordCodecBuilder$Mu_<O>, Internal.Function8_<T1_, T2_, T3_, T4_, T5_, T6_, T7_, T8_, R_>>): Internal.Function8<Internal.App<Internal.RecordCodecBuilder$Mu<O>, T1_>, Internal.App<Internal.RecordCodecBuilder$Mu<O>, T2_>, Internal.App<Internal.RecordCodecBuilder$Mu<O>, T3_>, Internal.App<Internal.RecordCodecBuilder$Mu<O>, T4_>, Internal.App<Internal.RecordCodecBuilder$Mu<O>, T5_>, Internal.App<Internal.RecordCodecBuilder$Mu<O>, T6_>, Internal.App<Internal.RecordCodecBuilder$Mu<O>, T7_>, Internal.App<Internal.RecordCodecBuilder$Mu<O>, T8_>, Internal.App<Internal.RecordCodecBuilder$Mu<O>, R_>>;
        apply9<T1_, T2_, T3_, T4_, T5_, T6_, T7_, T8_, T9_, R_>(arg0: Internal.Function9_<T1_, T2_, T3_, T4_, T5_, T6_, T7_, T8_, T9_, R_>, arg1: Internal.App_<Internal.RecordCodecBuilder$Mu_<O>, T1_>, arg2: Internal.App_<Internal.RecordCodecBuilder$Mu_<O>, T2_>, arg3: Internal.App_<Internal.RecordCodecBuilder$Mu_<O>, T3_>, arg4: Internal.App_<Internal.RecordCodecBuilder$Mu_<O>, T4_>, arg5: Internal.App_<Internal.RecordCodecBuilder$Mu_<O>, T5_>, arg6: Internal.App_<Internal.RecordCodecBuilder$Mu_<O>, T6_>, arg7: Internal.App_<Internal.RecordCodecBuilder$Mu_<O>, T7_>, arg8: Internal.App_<Internal.RecordCodecBuilder$Mu_<O>, T8_>, arg9: Internal.App_<Internal.RecordCodecBuilder$Mu_<O>, T9_>): Internal.App<Internal.RecordCodecBuilder$Mu<O>, R_>;
        lift7<T1_, T2_, T3_, T4_, T5_, T6_, T7_, R_>(arg0: Internal.App_<Internal.RecordCodecBuilder$Mu_<O>, Internal.Function7_<T1_, T2_, T3_, T4_, T5_, T6_, T7_, R_>>): Internal.Function7<Internal.App<Internal.RecordCodecBuilder$Mu<O>, T1_>, Internal.App<Internal.RecordCodecBuilder$Mu<O>, T2_>, Internal.App<Internal.RecordCodecBuilder$Mu<O>, T3_>, Internal.App<Internal.RecordCodecBuilder$Mu<O>, T4_>, Internal.App<Internal.RecordCodecBuilder$Mu<O>, T5_>, Internal.App<Internal.RecordCodecBuilder$Mu<O>, T6_>, Internal.App<Internal.RecordCodecBuilder$Mu<O>, T7_>, Internal.App<Internal.RecordCodecBuilder$Mu<O>, R_>>;
        ap<A_, R_>(arg0: Internal.App_<Internal.RecordCodecBuilder$Mu_<O>, java_.util.function_.Function_<A_, R_>>, arg1: Internal.App_<Internal.RecordCodecBuilder$Mu_<O>, A_>): Internal.App<Internal.RecordCodecBuilder$Mu<O>, R_>;
        ap<A_, R_>(arg0: java_.util.function_.Function_<A_, R_>, arg1: Internal.App_<Internal.RecordCodecBuilder$Mu_<O>, A_>): Internal.App<Internal.RecordCodecBuilder$Mu<O>, R_>;
        stable<A_>(arg0: A_): Internal.App<Internal.RecordCodecBuilder$Mu<O>, A_>;
        equals(arg0: any): boolean;
        ap16<T1_, T2_, T3_, T4_, T5_, T6_, T7_, T8_, T9_, T10_, T11_, T12_, T13_, T14_, T15_, T16_, R_>(arg0: Internal.App_<Internal.RecordCodecBuilder$Mu_<O>, Internal.Function16_<T1_, T2_, T3_, T4_, T5_, T6_, T7_, T8_, T9_, T10_, T11_, T12_, T13_, T14_, T15_, T16_, R_>>, arg1: Internal.App_<Internal.RecordCodecBuilder$Mu_<O>, T1_>, arg2: Internal.App_<Internal.RecordCodecBuilder$Mu_<O>, T2_>, arg3: Internal.App_<Internal.RecordCodecBuilder$Mu_<O>, T3_>, arg4: Internal.App_<Internal.RecordCodecBuilder$Mu_<O>, T4_>, arg5: Internal.App_<Internal.RecordCodecBuilder$Mu_<O>, T5_>, arg6: Internal.App_<Internal.RecordCodecBuilder$Mu_<O>, T6_>, arg7: Internal.App_<Internal.RecordCodecBuilder$Mu_<O>, T7_>, arg8: Internal.App_<Internal.RecordCodecBuilder$Mu_<O>, T8_>, arg9: Internal.App_<Internal.RecordCodecBuilder$Mu_<O>, T9_>, arg10: Internal.App_<Internal.RecordCodecBuilder$Mu_<O>, T10_>, arg11: Internal.App_<Internal.RecordCodecBuilder$Mu_<O>, T11_>, arg12: Internal.App_<Internal.RecordCodecBuilder$Mu_<O>, T12_>, arg13: Internal.App_<Internal.RecordCodecBuilder$Mu_<O>, T13_>, arg14: Internal.App_<Internal.RecordCodecBuilder$Mu_<O>, T14_>, arg15: Internal.App_<Internal.RecordCodecBuilder$Mu_<O>, T15_>, arg16: Internal.App_<Internal.RecordCodecBuilder$Mu_<O>, T16_>): Internal.App<Internal.RecordCodecBuilder$Mu<O>, R_>;
        toString(): string;
        ap13<T1_, T2_, T3_, T4_, T5_, T6_, T7_, T8_, T9_, T10_, T11_, T12_, T13_, R_>(arg0: Internal.App_<Internal.RecordCodecBuilder$Mu_<O>, Internal.Function13_<T1_, T2_, T3_, T4_, T5_, T6_, T7_, T8_, T9_, T10_, T11_, T12_, T13_, R_>>, arg1: Internal.App_<Internal.RecordCodecBuilder$Mu_<O>, T1_>, arg2: Internal.App_<Internal.RecordCodecBuilder$Mu_<O>, T2_>, arg3: Internal.App_<Internal.RecordCodecBuilder$Mu_<O>, T3_>, arg4: Internal.App_<Internal.RecordCodecBuilder$Mu_<O>, T4_>, arg5: Internal.App_<Internal.RecordCodecBuilder$Mu_<O>, T5_>, arg6: Internal.App_<Internal.RecordCodecBuilder$Mu_<O>, T6_>, arg7: Internal.App_<Internal.RecordCodecBuilder$Mu_<O>, T7_>, arg8: Internal.App_<Internal.RecordCodecBuilder$Mu_<O>, T8_>, arg9: Internal.App_<Internal.RecordCodecBuilder$Mu_<O>, T9_>, arg10: Internal.App_<Internal.RecordCodecBuilder$Mu_<O>, T10_>, arg11: Internal.App_<Internal.RecordCodecBuilder$Mu_<O>, T11_>, arg12: Internal.App_<Internal.RecordCodecBuilder$Mu_<O>, T12_>, arg13: Internal.App_<Internal.RecordCodecBuilder$Mu_<O>, T13_>): Internal.App<Internal.RecordCodecBuilder$Mu<O>, R_>;
        ap12<T1_, T2_, T3_, T4_, T5_, T6_, T7_, T8_, T9_, T10_, T11_, T12_, R_>(arg0: Internal.App_<Internal.RecordCodecBuilder$Mu_<O>, Internal.Function12_<T1_, T2_, T3_, T4_, T5_, T6_, T7_, T8_, T9_, T10_, T11_, T12_, R_>>, arg1: Internal.App_<Internal.RecordCodecBuilder$Mu_<O>, T1_>, arg2: Internal.App_<Internal.RecordCodecBuilder$Mu_<O>, T2_>, arg3: Internal.App_<Internal.RecordCodecBuilder$Mu_<O>, T3_>, arg4: Internal.App_<Internal.RecordCodecBuilder$Mu_<O>, T4_>, arg5: Internal.App_<Internal.RecordCodecBuilder$Mu_<O>, T5_>, arg6: Internal.App_<Internal.RecordCodecBuilder$Mu_<O>, T6_>, arg7: Internal.App_<Internal.RecordCodecBuilder$Mu_<O>, T7_>, arg8: Internal.App_<Internal.RecordCodecBuilder$Mu_<O>, T8_>, arg9: Internal.App_<Internal.RecordCodecBuilder$Mu_<O>, T9_>, arg10: Internal.App_<Internal.RecordCodecBuilder$Mu_<O>, T10_>, arg11: Internal.App_<Internal.RecordCodecBuilder$Mu_<O>, T11_>, arg12: Internal.App_<Internal.RecordCodecBuilder$Mu_<O>, T12_>): Internal.App<Internal.RecordCodecBuilder$Mu<O>, R_>;
        ap15<T1_, T2_, T3_, T4_, T5_, T6_, T7_, T8_, T9_, T10_, T11_, T12_, T13_, T14_, T15_, R_>(arg0: Internal.App_<Internal.RecordCodecBuilder$Mu_<O>, Internal.Function15_<T1_, T2_, T3_, T4_, T5_, T6_, T7_, T8_, T9_, T10_, T11_, T12_, T13_, T14_, T15_, R_>>, arg1: Internal.App_<Internal.RecordCodecBuilder$Mu_<O>, T1_>, arg2: Internal.App_<Internal.RecordCodecBuilder$Mu_<O>, T2_>, arg3: Internal.App_<Internal.RecordCodecBuilder$Mu_<O>, T3_>, arg4: Internal.App_<Internal.RecordCodecBuilder$Mu_<O>, T4_>, arg5: Internal.App_<Internal.RecordCodecBuilder$Mu_<O>, T5_>, arg6: Internal.App_<Internal.RecordCodecBuilder$Mu_<O>, T6_>, arg7: Internal.App_<Internal.RecordCodecBuilder$Mu_<O>, T7_>, arg8: Internal.App_<Internal.RecordCodecBuilder$Mu_<O>, T8_>, arg9: Internal.App_<Internal.RecordCodecBuilder$Mu_<O>, T9_>, arg10: Internal.App_<Internal.RecordCodecBuilder$Mu_<O>, T10_>, arg11: Internal.App_<Internal.RecordCodecBuilder$Mu_<O>, T11_>, arg12: Internal.App_<Internal.RecordCodecBuilder$Mu_<O>, T12_>, arg13: Internal.App_<Internal.RecordCodecBuilder$Mu_<O>, T13_>, arg14: Internal.App_<Internal.RecordCodecBuilder$Mu_<O>, T14_>, arg15: Internal.App_<Internal.RecordCodecBuilder$Mu_<O>, T15_>): Internal.App<Internal.RecordCodecBuilder$Mu<O>, R_>;
        ap14<T1_, T2_, T3_, T4_, T5_, T6_, T7_, T8_, T9_, T10_, T11_, T12_, T13_, T14_, R_>(arg0: Internal.App_<Internal.RecordCodecBuilder$Mu_<O>, Internal.Function14_<T1_, T2_, T3_, T4_, T5_, T6_, T7_, T8_, T9_, T10_, T11_, T12_, T13_, T14_, R_>>, arg1: Internal.App_<Internal.RecordCodecBuilder$Mu_<O>, T1_>, arg2: Internal.App_<Internal.RecordCodecBuilder$Mu_<O>, T2_>, arg3: Internal.App_<Internal.RecordCodecBuilder$Mu_<O>, T3_>, arg4: Internal.App_<Internal.RecordCodecBuilder$Mu_<O>, T4_>, arg5: Internal.App_<Internal.RecordCodecBuilder$Mu_<O>, T5_>, arg6: Internal.App_<Internal.RecordCodecBuilder$Mu_<O>, T6_>, arg7: Internal.App_<Internal.RecordCodecBuilder$Mu_<O>, T7_>, arg8: Internal.App_<Internal.RecordCodecBuilder$Mu_<O>, T8_>, arg9: Internal.App_<Internal.RecordCodecBuilder$Mu_<O>, T9_>, arg10: Internal.App_<Internal.RecordCodecBuilder$Mu_<O>, T10_>, arg11: Internal.App_<Internal.RecordCodecBuilder$Mu_<O>, T11_>, arg12: Internal.App_<Internal.RecordCodecBuilder$Mu_<O>, T12_>, arg13: Internal.App_<Internal.RecordCodecBuilder$Mu_<O>, T13_>, arg14: Internal.App_<Internal.RecordCodecBuilder$Mu_<O>, T14_>): Internal.App<Internal.RecordCodecBuilder$Mu<O>, R_>;
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    type RecordCodecBuilder$Instance_<O> = RecordCodecBuilder$Instance<O>;
    /**
    * Fired by different tag when the game:
    * - is initializing
    * - is post-initializing
    */
    class StartupEventJS extends Internal.EventJS {
        cancel(): void;
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        isCancelled(): boolean;
        post(id: string): boolean;
        post(id: string, sub: string): boolean;
        post(t: Internal.ScriptType_, id: string, sub: string): boolean;
        post(t: Internal.ScriptType_, id: string): boolean;
        hashCode(): number;
        notifyAll(): void;
        equals(arg0: any): boolean;
        toString(): string;
        notify(): void;
        canCancel(): boolean;
        get cancelled(): boolean;
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    /**
    * Fired by different tag when the game:
    * - is initializing
    * - is post-initializing
    */
    type StartupEventJS_ = StartupEventJS;
    interface Long2BooleanFunction extends Internal.Function<number, boolean>, Internal.LongPredicate {
        getOrDefault(arg0: any, arg1: boolean): boolean;
        getOrDefault(arg0: number, arg1: boolean): boolean;
        andThenShort(arg0: Internal.Boolean2ShortFunction_): Internal.Long2ShortFunction;
        composeByte(arg0: Internal.Byte2LongFunction_): Internal.Byte2BooleanFunction;
        andThenInt(arg0: Internal.Boolean2IntFunction_): Internal.Long2IntFunction;
        composeReference<T_>(arg0: Internal.Reference2LongFunction_<T_>): Internal.Reference2BooleanFunction<T_>;
        andThen<T_>(arg0: java_.util.function_.Function_<boolean, T_>): java_.util.function_.Function<number, T_>;
        put(arg0: number, arg1: boolean): boolean;
        remove(arg0: number): boolean;
        remove(arg0: any): boolean;
        defaultReturnValue(): boolean;
        defaultReturnValue(arg0: boolean): void;
        andThenDouble(arg0: Internal.Boolean2DoubleFunction_): Internal.Long2DoubleFunction;
        andThenObject<T_>(arg0: Internal.Boolean2ObjectFunction_<T_>): Internal.Long2ObjectFunction<T_>;
        and(arg0: Internal.LongPredicate_): Internal.LongPredicate;
        get(arg0: any): boolean;
        get(arg0: number): boolean;
        andThenLong(arg0: Internal.Boolean2LongFunction_): Internal.Long2LongFunction;
        composeLong(arg0: Internal.Long2LongFunction_): Internal.Long2BooleanFunction;
        andThenByte(arg0: Internal.Boolean2ByteFunction_): Internal.Long2ByteFunction;
        andThenFloat(arg0: Internal.Boolean2FloatFunction_): Internal.Long2FloatFunction;
        or(arg0: Internal.LongPredicate_): Internal.LongPredicate;
        test(arg0: number): boolean;
        apply(arg0: number): boolean;
        containsKey(arg0: number): boolean;
        containsKey(arg0: any): boolean;
        composeInt(arg0: Internal.Int2LongFunction_): Internal.Int2BooleanFunction;
        clear(): void;
        composeFloat(arg0: Internal.Float2LongFunction_): Internal.Float2BooleanFunction;
        andThenChar(arg0: Internal.Boolean2CharFunction_): Internal.Long2CharFunction;
        composeObject<T_>(arg0: Internal.Object2LongFunction_<T_>): Internal.Object2BooleanFunction<T_>;
        size(): number;
        compose<T_>(arg0: java_.util.function_.Function_<T_, number>): java_.util.function_.Function<T_, boolean>;
        negate(): Internal.LongPredicate;
        composeShort(arg0: Internal.Short2LongFunction_): Internal.Short2BooleanFunction;
        andThenReference<T_>(arg0: Internal.Boolean2ReferenceFunction_<T_>): Internal.Long2ReferenceFunction<T_>;
        composeChar(arg0: Internal.Char2LongFunction_): Internal.Char2BooleanFunction;
        composeDouble(arg0: Internal.Double2LongFunction_): Internal.Double2BooleanFunction;
    }
    type Long2BooleanFunction_ = ((arg0: number) => boolean) | Long2BooleanFunction;
    interface ICapabilityProviderImpl <B> extends Internal.ICapabilityProvider {
        invalidateCaps(): void;
        getCapability<T_>(arg0: Internal.Capability_<T_>, arg1: Internal.Direction_): Internal.LazyOptional<T_>;
        getCapability<T_>(arg0: Internal.Capability_<T_>): Internal.LazyOptional<T_>;
        areCapsCompatible(arg0: Internal.CapabilityProvider_<B>): boolean;
        areCapsCompatible(arg0: Internal.CapabilityDispatcher_): boolean;
        reviveCaps(): void;
    }
    type ICapabilityProviderImpl_<B> = ICapabilityProviderImpl<B>;
    interface IGuiIngredientGroup <T> {
        init(arg0: number, arg1: boolean, arg2: number, arg3: number): void;
        init(arg0: number, arg1: boolean, arg2: Internal.IIngredientRenderer_<T>, arg3: number, arg4: number, arg5: number, arg6: number, arg7: number, arg8: number): void;
        set(arg0: number, arg1: T): void;
        set(arg0: number, arg1: Internal.List_<T>): void;
        set(arg0: Internal.IIngredients_): void;
        getGuiIngredients(): Internal.Map<number, Internal.IGuiIngredient<T>>;
        addTooltipCallback(arg0: Internal.ITooltipCallback_<T>): void;
        setOverrideDisplayFocus(arg0: Internal.IFocus_<T>): void;
        setBackground(arg0: number, arg1: Internal.IDrawable_): void;
    }
    type IGuiIngredientGroup_<T> = IGuiIngredientGroup<T>;
    interface Function5 <T1, T2, T3, T4, T5, R> {
        apply(arg0: T1, arg1: T2, arg2: T3, arg3: T4, arg4: T5): R;
        curry3(): Internal.Function3<T1, T2, T3, Internal.BiFunction<T4, T5, R>>;
        curry4(): Internal.Function4<T1, T2, T3, T4, java_.util.function_.Function<T5, R>>;
        curry2(): Internal.BiFunction<T1, T2, Internal.Function3<T3, T4, T5, R>>;
        curry(): java_.util.function_.Function<T1, Internal.Function4<T2, T3, T4, T5, R>>;
    }
    type Function5_<T1, T2, T3, T4, T5, R> = Function5<T1, T2, T3, T4, T5, R>;
    class ModuleDescriptor$Exports implements Internal.Comparable<Internal.ModuleDescriptor$Exports> {
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        hashCode(): number;
        notifyAll(): void;
        equals(arg0: any): boolean;
        isQualified(): boolean;
        toString(): string;
        source(): string;
        compareTo(arg0: Internal.ModuleDescriptor$Exports_): number;
        modifiers(): Internal.Set<Internal.ModuleDescriptor$Exports$Modifier>;
        targets(): Internal.Set<string>;
        notify(): void;
        get qualified(): boolean;
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    type ModuleDescriptor$Exports_ = ModuleDescriptor$Exports;
    interface Channel$Unsafe {
        disconnect(arg0: Internal.ChannelPromise_): void;
        deregister(arg0: Internal.ChannelPromise_): void;
        recvBufAllocHandle(): Internal.RecvByteBufAllocator$Handle;
        closeForcibly(): void;
        beginRead(): void;
        bind(arg0: Internal.SocketAddress_, arg1: Internal.ChannelPromise_): void;
        voidPromise(): Internal.ChannelPromise;
        flush(): void;
        localAddress(): Internal.SocketAddress;
        outboundBuffer(): Internal.ChannelOutboundBuffer;
        close(arg0: Internal.ChannelPromise_): void;
        write(arg0: any, arg1: Internal.ChannelPromise_): void;
        remoteAddress(): Internal.SocketAddress;
        connect(arg0: Internal.SocketAddress_, arg1: Internal.SocketAddress_, arg2: Internal.ChannelPromise_): void;
        register(arg0: Internal.EventLoop_, arg1: Internal.ChannelPromise_): void;
    }
    type Channel$Unsafe_ = Channel$Unsafe;
    class Vector <E> extends Internal.AbstractList<E> implements Internal.List<E>, Internal.RandomAccess, Internal.Cloneable, Internal.Serializable {
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        notifyAll(): void;
        firstElement(): E;
        replaceAll(arg0: Internal.UnaryOperator_<E>): void;
        notify(): void;
        remove(arg0: number): E;
        remove(arg0: any): boolean;
        capacity(): number;
        removeAll(arg0: Internal.Collection_<any>): boolean;
        iterator(): Internal.Iterator<E>;
        setSize(arg0: number): void;
        stream(): Internal.Stream<E>;
        setElementAt(arg0: E, arg1: number): void;
        hashCode(): number;
        get(arg0: number): E;
        removeElementAt(arg0: number): void;
        elementAt(arg0: number): E;
        toArray<T_>(arg0: T_[]): T_[];
        toArray(): any[];
        toArray<T_>(arg0: Internal.IntFunction_<T_[]>): T_[];
        parallelStream(): Internal.Stream<E>;
        indexOf(arg0: any): number;
        indexOf(arg0: any, arg1: number): number;
        removeAllElements(): void;
        add(arg0: E): boolean;
        add(arg0: number, arg1: E): void;
        subList(arg0: number, arg1: number): Internal.List<E>;
        trimToSize(): void;
        set(arg0: number, arg1: E): E;
        spliterator(): Internal.Spliterator<E>;
        forEach(arg0: Internal.Consumer_<E>): void;
        copyInto(arg0: any[]): void;
        containsAll(arg0: Internal.Collection_<any>): boolean;
        isEmpty(): boolean;
        clear(): void;
        sort(arg0: Internal.Comparator_<E>): void;
        removeIf(arg0: Internal.Predicate_<E>): boolean;
        lastIndexOf(arg0: any, arg1: number): number;
        lastIndexOf(arg0: any): number;
        contains(arg0: any): boolean;
        insertElementAt(arg0: E, arg1: number): void;
        size(): number;
        addAll(arg0: number, arg1: Internal.Collection_<E>): boolean;
        addAll(arg0: Internal.Collection_<E>): boolean;
        lastElement(): E;
        elements(): Internal.Enumeration<E>;
        equals(arg0: any): boolean;
        clone(): any;
        listIterator(): Internal.ListIterator<E>;
        listIterator(arg0: number): Internal.ListIterator<E>;
        toString(): string;
        addElement(arg0: E): void;
        ensureCapacity(arg0: number): void;
        removeElement(arg0: any): boolean;
        retainAll(arg0: Internal.Collection_<any>): boolean;
        get class(): Internal.Class<any>;
        get empty(): boolean;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    type Vector_<E> = Vector<E>;
    class LootCrate {
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        readData(nbt: Internal.CompoundTag_): void;
        readNetData(data: Internal.FriendlyByteBuf_): void;
        notifyAll(): void;
        createStack(): Internal.ItemStack;
        writeData(nbt: Internal.CompoundTag_): void;
        notify(): void;
        writeNetData(data: Internal.FriendlyByteBuf_): void;
        getConfig(config: Internal.ConfigGroup_): void;
        getStringID(): string;
        hashCode(): number;
        equals(arg0: any): boolean;
        toString(): string;
        static LOOT_CRATES : {};
        stringID : string;
        itemName : string;
        drops : Internal.EntityWeight;
        color : Internal.Color4I;
        glow : boolean;
        readonly table : Internal.RewardTable;
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    type LootCrate_ = LootCrate;
    abstract class InventoryFilterItem extends Internal.BaseFilterItem {
        getClass(): Internal.Class<any>;
        canElytraFly(arg0: Internal.ItemStack_, arg1: Internal.LivingEntity_): boolean;
        setBurnTime(i: number): void;
        setDamage(arg0: Internal.ItemStack_, arg1: number): void;
        canPerformAction(arg0: Internal.ItemStack_, arg1: Internal.ToolAction_): boolean;
        getItems(filter: Internal.ItemStack_, set: Internal.Set_<Internal.Item_>): void;
        damageItem<T_>(arg0: Internal.ItemStack_, arg1: number, arg2: T_, arg3: Internal.Consumer_<T_>): number;
        shouldCauseBlockBreakReset(arg0: Internal.ItemStack_, arg1: Internal.ItemStack_): boolean;
        getItemEnchantability(arg0: Internal.ItemStack_): number;
        getPlacer(): Internal.BlockPlacerItem;
        shouldCauseReequipAnimation(arg0: Internal.ItemStack_, arg1: Internal.ItemStack_, arg2: boolean): boolean;
        getXpRepairRatio(arg0: Internal.ItemStack_): number;
        readShareTag(arg0: Internal.ItemStack_, arg1: Internal.CompoundTag_): void;
        handler$bcn000$overrideOtherStackedOnMe(arg0: Internal.ItemStack_, arg1: Internal.ItemStack_, arg2: Internal.Slot_, arg3: Internal.ClickAction_, arg4: Internal.Player_, arg5: Internal.SlotAccess_, arg6: Internal.CallbackInfoReturnable_<any>): void;
        onEntityItemUpdate(arg0: Internal.ItemStack_, arg1: Internal.ItemEntity_): boolean;
        getDamage(arg0: Internal.ItemStack_): number;
        isBookEnchantable(arg0: Internal.ItemStack_, arg1: Internal.ItemStack_): boolean;
        getDisplayItemStacks(filter: Internal.ItemStack_, list: Internal.List_<Internal.ItemStack_>): void;
        canDisableShield(arg0: Internal.ItemStack_, arg1: Internal.ItemStack_, arg2: Internal.LivingEntity_, arg3: Internal.LivingEntity_): boolean;
        onUsingTick(arg0: Internal.ItemStack_, arg1: Internal.LivingEntity_, arg2: number): void;
        isPiglinCurrency(arg0: Internal.ItemStack_): boolean;
        getCreativeTabs(): Internal.Collection<Internal.CreativeModeTab>;
        createEntity(arg0: Internal.Level_, arg1: Internal.Entity_, arg2: Internal.ItemStack_): Internal.Entity;
        getSweepHitBox(arg0: Internal.ItemStack_, arg1: Internal.Player_, arg2: Internal.Entity_): Internal.AABB;
        isRepairable(arg0: Internal.ItemStack_): boolean;
        getPlaceableBlock(): Internal.Block;
        getShareTag(arg0: Internal.ItemStack_): Internal.CompoundTag;
        getInventorySize(filter: Internal.ItemStack_): number;
        getBurnTime(arg0: Internal.ItemStack_, arg1: Internal.RecipeType_<any>): number;
        onDroppedByPlayer(arg0: Internal.ItemStack_, arg1: Internal.Player_): boolean;
        isDamageable(arg0: Internal.ItemStack_): boolean;
        onEntitySwing(arg0: Internal.ItemStack_, arg1: Internal.LivingEntity_): boolean;
        getRegistryType(): Internal.Class<Internal.Item>;
        setItemBuilderKJS(b: Internal.ItemBuilder_): void;
        elytraFlightTick(arg0: Internal.ItemStack_, arg1: Internal.LivingEntity_, arg2: number): boolean;
        getItemBuilderKJS(): Internal.ItemBuilder;
        handler$bcn000$overrideStackedOnOther(arg0: Internal.ItemStack_, arg1: Internal.Slot_, arg2: Internal.ClickAction_, arg3: Internal.Player_, arg4: Internal.CallbackInfoReturnable_<any>): void;
        addSlots(filter: Internal.ItemStack_, list: Internal.List_<Internal.InventoryFilterItem$FilterSlot_>): void;
        getAttributeModifiers(arg0: EquipmentSlot_, arg1: Internal.ItemStack_): Internal.Multimap<Internal.Attribute, Internal.AttributeModifier>;
        filterItem(filter: Internal.ItemStack_, item: Internal.Item_): boolean;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        onLeftClickEntity(arg0: Internal.ItemStack_, arg1: Internal.Player_, arg2: Internal.Entity_): boolean;
        canEquip(arg0: Internal.ItemStack_, arg1: EquipmentSlot_, arg2: Internal.Entity_): boolean;
        notifyAll(): void;
        getId(): string;
        notify(): void;
        onBlockStartBreak(arg0: Internal.ItemStack_, arg1: BlockPos_, arg2: Internal.Player_): boolean;
        onHorseArmorTick(arg0: Internal.ItemStack_, arg1: Internal.Level_, arg2: Internal.Mob_): void;
        canContinueUsing(arg0: Internal.ItemStack_, arg1: Internal.ItemStack_): boolean;
        getEntityLifespan(arg0: Internal.ItemStack_, arg1: Internal.Level_): number;
        getRenderPropertiesInternal(): any;
        getArmorTexture(arg0: Internal.ItemStack_, arg1: Internal.Entity_, arg2: EquipmentSlot_, arg3: string): string;
        getDefaultTooltipHideFlags(arg0: Internal.ItemStack_): number;
        hashCode(): number;
        hasCustomEntity(arg0: Internal.ItemStack_): boolean;
        getHighlightTip(arg0: Internal.ItemStack_, arg1: Internal.Component_): Internal.Component;
        canWalkOnPowderedSnow(arg0: Internal.ItemStack_, arg1: Internal.LivingEntity_): boolean;
        initializeClient(arg0: Internal.Consumer_<Internal.IItemRenderProperties_>): void;
        clearFilterCache(filter: Internal.ItemStack_): void;
        static getInventory(stack: Internal.ItemStack_): Internal.ItemInventory;
        getMaxDamage(arg0: Internal.ItemStack_): number;
        getCreatorModId(arg0: Internal.ItemStack_): string;
        isDamaged(arg0: Internal.ItemStack_): boolean;
        onArmorTick(arg0: Internal.ItemStack_, arg1: Internal.Level_, arg2: Internal.Player_): void;
        hasContainerItem(arg0: Internal.ItemStack_): boolean;
        getFoodProperties(arg0: Internal.ItemStack_, arg1: Internal.LivingEntity_): Internal.FoodProperties;
        doesSneakBypassUse(arg0: Internal.ItemStack_, arg1: Internal.LevelReader_, arg2: BlockPos_, arg3: Internal.Player_): boolean;
        makePlaceable(arg0: Internal.Block_): void;
        onItemUseFirst(arg0: Internal.ItemStack_, arg1: Internal.UseOnContext_): Internal.InteractionResult;
        getContainerItem(arg0: Internal.ItemStack_): Internal.ItemStack;
        getRegistryName(): ResourceLocation;
        setRegistryName(arg0: ResourceLocation_): Internal.Item;
        setRegistryName(arg0: string): Internal.Item;
        setRegistryName(arg0: string, arg1: string): Internal.Item;
        addInfo(filter: Internal.ItemStack_, info: Internal.FilterInfo_, expanded: boolean): void;
        onDestroyed(arg0: Internal.ItemEntity_, arg1: Internal.DamageSource_): void;
        filter(arg0: Internal.ItemStack_, arg1: Internal.ItemStack_): boolean;
        isCorrectToolForDrops(arg0: Internal.ItemStack_, arg1: Internal.BlockState_): boolean;
        resetFilterData(filter: Internal.ItemStack_): void;
        getEquipmentSlot(arg0: Internal.ItemStack_): EquipmentSlot;
        getItemStackLimit(arg0: Internal.ItemStack_): number;
        initCapabilities(arg0: Internal.ItemStack_, arg1: Internal.CompoundTag_): Internal.ICapabilityProvider;
        equals(arg0: any): boolean;
        makesPiglinsNeutral(arg0: Internal.ItemStack_, arg1: Internal.LivingEntity_): boolean;
        getTypeData(): Internal.CompoundTag;
        toString(): string;
        isEnderMask(arg0: Internal.ItemStack_, arg1: Internal.Player_, arg2: Internal.EnderMan_): boolean;
        canApplyAtEnchantingTable(arg0: Internal.ItemStack_, arg1: Internal.Enchantment_): boolean;
        readonly delegate : Internal.IRegistryDelegate<Internal.Item>;
        renderProperties : any;
        get registryType(): Internal.Class<Internal.Item>;
        get itemBuilderKJS(): Internal.ItemBuilder;
        get renderPropertiesInternal(): any;
        get placer(): Internal.BlockPlacerItem;
        get placeableBlock(): Internal.Block;
        get creativeTabs(): Internal.Collection<Internal.CreativeModeTab>;
        get id(): string;
        get registryName(): ResourceLocation;
        get typeData(): Internal.CompoundTag;
        get class(): Internal.Class<any>;
        set itemBuilderKJS(b: Internal.ItemBuilder_);
        set burnTime(i: number);
        set registryName(arg0: ResourceLocation_);
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    type InventoryFilterItem_ = InventoryFilterItem;
    class StatusChangedEvent extends Internal.EventJS {
        cancel(): void;
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        isCancelled(): boolean;
        notifyAll(): void;
        getStatus(): string;
        notify(): void;
        setStatus(arg0: string): void;
        post(t: Internal.ScriptType_, id: string, sub: string): boolean;
        post(t: Internal.ScriptType_, id: string): boolean;
        hashCode(): number;
        equals(arg0: any): boolean;
        toString(): string;
        getComponent(): Internal.ComponentTileEntity<any>;
        canCancel(): boolean;
        static readonly ID : "mbd.status_changed";
        get component(): Internal.ComponentTileEntity<any>;
        get cancelled(): boolean;
        get class(): Internal.Class<any>;
        get status(): string;
        set status(arg0: string);
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    type StatusChangedEvent_ = StatusChangedEvent;
    interface DoubleSupplier {
        getAsDouble(): number;
    }
    type DoubleSupplier_ = (() => number) | DoubleSupplier;
    class MouseButton {
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        isRight(): boolean;
        isLeft(): boolean;
        hashCode(): number;
        notifyAll(): void;
        equals(arg0: any): boolean;
        static get(i: number): Internal.MouseButton;
        toString(): string;
        getId(): number;
        isMiddle(): boolean;
        notify(): void;
        static readonly LEFT : Internal.MouseButton;
        static readonly NEXT : Internal.MouseButton;
        static readonly RIGHT : Internal.MouseButton;
        static readonly BACK : Internal.MouseButton;
        readonly id : number;
        static readonly MIDDLE : Internal.MouseButton;
        get middle(): boolean;
        get left(): boolean;
        get right(): boolean;
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    type MouseButton_ = MouseButton;
    class StringProperty extends Internal.TeamProperty<string> {
        getClass(): Internal.Class<any>;
        readValue(buf: Internal.FriendlyByteBuf_): string;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        fromNBT(tag: net.minecraft.nbt.Tag_): Internal.Optional<string>;
        notifyAll(): void;
        notify(): void;
        toNBT(value: string): net.minecraft.nbt.Tag;
        getType(): Internal.TeamPropertyType<string>;
        hashCode(): number;
        equals(o: any): boolean;
        toString(value: string): string;
        toString(): string;
        fromString(string: string): Internal.Optional<string>;
        writeValue(buf: Internal.FriendlyByteBuf_, value: string): void;
        config(config: Internal.ConfigGroup_, value: Internal.TeamPropertyValue_<string>): void;
        write(buf: Internal.FriendlyByteBuf_): void;
        readonly defaultValue : string;
        readonly id : ResourceLocation;
        get type(): Internal.TeamPropertyType<string>;
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    type StringProperty_ = StringProperty;
    class TooltipList {
        add(component: Internal.Component_): void;
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        blankLine(): void;
        string(text: string): void;
        notifyAll(): void;
        styledString(text: string, style: Internal.Style_): void;
        styledString(text: string, color: Internal.ChatFormatting_): void;
        notify(): void;
        translate(key: string, objects: any[]): void;
        hashCode(): number;
        styledTranslate(key: string, style: Internal.Style_, objects: any[]): void;
        equals(arg0: any): boolean;
        reset(): void;
        toString(): string;
        shouldRender(): boolean;
        render(mStack: Internal.PoseStack_, mouseX: number, mouseY: number, screenWidth: number, screenHeight: number, font: net.minecraft.client.gui.Font_): void;
        backgroundColor : number;
        yOffset : number;
        zOffsetItemTooltip : number;
        xOffset : number;
        zOffset : number;
        borderColorStart : number;
        borderColorEnd : number;
        maxWidth : number;
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    type TooltipList_ = TooltipList;
    class ParsingMode extends Internal.Enum<Internal.ParsingMode> {
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        static valueOf(arg0: string): Internal.ParsingMode;
        static valueOf<T_>(arg0: Internal.Class_<T_>, arg1: string): T_;
        notifyAll(): void;
        static values(): Internal.ParsingMode[];
        compareTo(arg0: Internal.ParsingMode_): number;
        describeConstable(): Internal.Optional<Internal.Enum$EnumDesc<Internal.ParsingMode>>;
        notify(): void;
        put(arg0: Internal.Map_<string, any>, arg1: string, arg2: any): any;
        put(arg0: Internal.Config_, arg1: string, arg2: any): any;
        put(arg0: Internal.Config_, arg1: Internal.List_<string>, arg2: any): any;
        getDeclaringClass(): Internal.Class<Internal.ParsingMode>;
        hashCode(): number;
        equals(arg0: any): boolean;
        prepareParsing(arg0: Internal.Config_): void;
        name(): string;
        toString(): string;
        ordinal(): number;
        static readonly ADD : Internal.ParsingMode;
        static readonly MERGE : Internal.ParsingMode;
        static readonly REPLACE : Internal.ParsingMode;
        get class(): Internal.Class<any>;
        get declaringClass(): Internal.Class<Internal.ParsingMode>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    type ParsingMode_ = "add" | "merge" | "replace" | ParsingMode;
    interface Int2ObjectMap$FastEntrySet <V> extends Internal.ObjectSet<Internal.Int2ObjectMap$Entry<V>> {
        add(arg0: Internal.Int2ObjectMap$Entry_<V>): boolean;
        spliterator(): Internal.ObjectSpliterator<Internal.Int2ObjectMap$Entry<V>>;
        forEach(arg0: Internal.Consumer_<Internal.Int2ObjectMap$Entry_<V>>): void;
        containsAll(arg0: Internal.Collection_<any>): boolean;
        isEmpty(): boolean;
        clear(): void;
        fastIterator(): Internal.ObjectIterator<Internal.Int2ObjectMap$Entry<V>>;
        remove(arg0: any): boolean;
        removeIf(arg0: Internal.Predicate_<Internal.Int2ObjectMap$Entry_<V>>): boolean;
        fastForEach(arg0: Internal.Consumer_<Internal.Int2ObjectMap$Entry_<V>>): void;
        removeAll(arg0: Internal.Collection_<any>): boolean;
        contains(arg0: any): boolean;
        iterator(): Internal.ObjectIterator<Internal.Int2ObjectMap$Entry<V>>;
        size(): number;
        addAll(arg0: Internal.Collection_<Internal.Int2ObjectMap$Entry_<V>>): boolean;
        stream(): Internal.Stream<Internal.Int2ObjectMap$Entry<V>>;
        hashCode(): number;
        equals(arg0: any): boolean;
        toArray<T_>(arg0: T_[]): T_[];
        toArray<T_>(arg0: Internal.IntFunction_<T_[]>): T_[];
        toArray(): any[];
        parallelStream(): Internal.Stream<Internal.Int2ObjectMap$Entry<V>>;
        retainAll(arg0: Internal.Collection_<any>): boolean;
    }
    type Int2ObjectMap$FastEntrySet_<V> = Int2ObjectMap$FastEntrySet<V>;
    interface ScriptSource {
        createStream(arg0: Internal.ScriptFileInfo_): Internal.InputStream;
    }
    type ScriptSource_ = ((arg0: Internal.ScriptFileInfo) => Internal.InputStream) | ScriptSource;
    class Long2ObjectOpenHashMap <V> extends Internal.AbstractLong2ObjectMap<V> implements Internal.Serializable, Internal.Cloneable, Internal.Hash {
        getClass(): Internal.Class<any>;
        getOrDefault(arg0: number, arg1: V): V;
        getOrDefault(arg0: any, arg1: V): V;
        replace(arg0: number, arg1: V, arg2: V): boolean;
        replace(arg0: number, arg1: V): V;
        composeByte(arg0: Internal.Byte2LongFunction_): Internal.Byte2ObjectFunction<V>;
        andThen<V_>(arg0: java_.util.function_.Function_<V, V_>): java_.util.function_.Function<number, V_>;
        composeReference<T_>(arg0: Internal.Reference2LongFunction_<T_>): Internal.Reference2ObjectFunction<T_, V>;
        containsValue(arg0: any): boolean;
        put(arg0: number, arg1: V): V;
        compute(arg0: number, arg1: Internal.BiFunction_<number, V, V>): V;
        defaultReturnValue(arg0: V): void;
        defaultReturnValue(): V;
        andThenObject<T_>(arg0: Internal.Object2ObjectFunction_<V, T_>): Internal.Long2ObjectFunction<T_>;
        trim(arg0: number): boolean;
        trim(): boolean;
        merge(arg0: number, arg1: V, arg2: Internal.BiFunction_<V, V, V>): V;
        composeLong(arg0: Internal.Long2LongFunction_): Internal.Long2ObjectFunction<V>;
        entrySet(): Internal.ObjectSet<Internal.Map$Entry<number, V>>;
        containsKey(arg0: number): boolean;
        containsKey(arg0: any): boolean;
        composeObject<T_>(arg0: Internal.Object2LongFunction_<T_>): Internal.Object2ObjectFunction<T_, V>;
        size(): number;
        compose<T_>(arg0: java_.util.function_.Function_<T_, number>): java_.util.function_.Function<T_, V>;
        composeShort(arg0: Internal.Short2LongFunction_): Internal.Short2ObjectFunction<V>;
        composeChar(arg0: Internal.Char2LongFunction_): Internal.Char2ObjectFunction<V>;
        composeDouble(arg0: Internal.Double2LongFunction_): Internal.Double2ObjectFunction<V>;
        long2ObjectEntrySet(): Internal.Long2ObjectMap$FastEntrySet<V>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        notifyAll(): void;
        computeIfAbsent(arg0: number, arg1: Internal.LongFunction_<V>): V;
        computeIfAbsent(arg0: number, arg1: Internal.Long2ObjectFunction_<V>): V;
        computeIfAbsent(arg0: number, arg1: java_.util.function_.Function_<number, V>): V;
        values(): Internal.ObjectCollection<V>;
        andThenShort(arg0: Internal.Object2ShortFunction_<V>): Internal.Long2ShortFunction;
        computeIfAbsentPartial(arg0: number, arg1: Internal.Long2ObjectFunction_<V>): V;
        replaceAll(arg0: Internal.BiFunction_<number, V, V>): void;
        andThenInt(arg0: Internal.Object2IntFunction_<V>): Internal.Long2IntFunction;
        notify(): void;
        remove(arg0: number, arg1: any): boolean;
        remove(arg0: number): V;
        remove(arg0: any): V;
        remove(arg0: any, arg1: any): boolean;
        andThenDouble(arg0: Internal.Object2DoubleFunction_<V>): Internal.Long2DoubleFunction;
        hashCode(): number;
        putAll(arg0: Internal.Map_<number, V>): void;
        get(arg0: number): V;
        get(arg0: any): V;
        andThenLong(arg0: Internal.Object2LongFunction_<V>): Internal.Long2LongFunction;
        keySet(): Internal.LongSet;
        andThenByte(arg0: Internal.Object2ByteFunction_<V>): Internal.Long2ByteFunction;
        andThenFloat(arg0: Internal.Object2FloatFunction_<V>): Internal.Long2FloatFunction;
        apply(arg0: number): V;
        forEach(arg0: Internal.BiConsumer_<number, V>): void;
        composeInt(arg0: Internal.Int2LongFunction_): Internal.Int2ObjectFunction<V>;
        isEmpty(): boolean;
        clear(): void;
        composeFloat(arg0: Internal.Float2LongFunction_): Internal.Float2ObjectFunction<V>;
        andThenChar(arg0: Internal.Object2CharFunction_<V>): Internal.Long2CharFunction;
        computeIfPresent(arg0: number, arg1: Internal.BiFunction_<number, V, V>): V;
        equals(arg0: any): boolean;
        andThenReference<T_>(arg0: Internal.Object2ReferenceFunction_<V, T_>): Internal.Long2ReferenceFunction<T_>;
        clone(): Internal.Long2ObjectOpenHashMap<V>;
        toString(): string;
        putIfAbsent(arg0: number, arg1: V): V;
        static readonly DEFAULT_GROWTH_FACTOR : 16;
        static readonly FAST_LOAD_FACTOR : 0.5;
        static readonly DEFAULT_INITIAL_SIZE : 16;
        static readonly DEFAULT_LOAD_FACTOR : 0.75;
        static readonly OCCUPIED : -1;
        static readonly VERY_FAST_LOAD_FACTOR : 0.25;
        static readonly FREE : 0;
        static readonly PRIMES : number[];
        static readonly REMOVED : 1;
        get class(): Internal.Class<any>;
        get empty(): boolean;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    type Long2ObjectOpenHashMap_<V> = Long2ObjectOpenHashMap<V>;
    class UnitStorage {
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        addFunc(name: string, func: Internal.FuncSupplier_): void;
        notifyAll(): void;
        addOp(name: string, op: Internal.OpSupplier_): void;
        setVariable(key: string, unit: dev.latvian.mods.rhino.util.unit.Unit_): void;
        getVariableVersion(): number;
        parse(string: string): dev.latvian.mods.rhino.util.unit.Unit;
        getVariable(key: string): dev.latvian.mods.rhino.util.unit.Unit;
        notify(): void;
        clearVariables(): void;
        addConstant(name: string, val: number): void;
        hashCode(): number;
        createFunc(name: string, args: Internal.List_<dev.latvian.mods.rhino.util.unit.Unit_>): dev.latvian.mods.rhino.util.unit.Unit;
        equals(arg0: any): boolean;
        getConstant(name: string): Internal.ConstantUnit;
        toString(): string;
        addFunc2(name: string, func: Internal.FuncSupplier$Func2_): void;
        addFunc1(name: string, func: Internal.FuncSupplier$Func1_): void;
        createOp(name: string, unit: dev.latvian.mods.rhino.util.unit.Unit_, with_: dev.latvian.mods.rhino.util.unit.Unit_): dev.latvian.mods.rhino.util.unit.Unit;
        get variableVersion(): number;
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    type UnitStorage_ = UnitStorage;
    class BigDecimal extends Internal.Number implements Internal.Comparable<Internal.BigDecimal> {
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        longValueExact(): number;
        movePointLeft(arg0: number): Internal.BigDecimal;
        notifyAll(): void;
        precision(): number;
        byteValueExact(): number;
        toBigInteger(): Internal.BigInteger;
        scale(): number;
        toPlainString(): string;
        compareTo(arg0: Internal.BigDecimal_): number;
        shortValueExact(): number;
        notify(): void;
        longValue(): number;
        min(arg0: Internal.BigDecimal_): Internal.BigDecimal;
        unscaledValue(): Internal.BigInteger;
        sqrt(arg0: Internal.MathContext_): Internal.BigDecimal;
        scaleByPowerOfTen(arg0: number): Internal.BigDecimal;
        hashCode(): number;
        pow(arg0: number, arg1: Internal.MathContext_): Internal.BigDecimal;
        pow(arg0: number): Internal.BigDecimal;
        shortValue(): number;
        divide(arg0: Internal.BigDecimal_): Internal.BigDecimal;
        divide(arg0: Internal.BigDecimal_, arg1: number, arg2: Internal.RoundingMode_): Internal.BigDecimal;
        divide(arg0: Internal.BigDecimal_, arg1: number, arg2: number): Internal.BigDecimal;
        divide(arg0: Internal.BigDecimal_, arg1: number): Internal.BigDecimal;
        divide(arg0: Internal.BigDecimal_, arg1: Internal.RoundingMode_): Internal.BigDecimal;
        divide(arg0: Internal.BigDecimal_, arg1: Internal.MathContext_): Internal.BigDecimal;
        multiply(arg0: Internal.BigDecimal_): Internal.BigDecimal;
        multiply(arg0: Internal.BigDecimal_, arg1: Internal.MathContext_): Internal.BigDecimal;
        signum(): number;
        add(arg0: Internal.BigDecimal_, arg1: Internal.MathContext_): Internal.BigDecimal;
        add(arg0: Internal.BigDecimal_): Internal.BigDecimal;
        toBigIntegerExact(): Internal.BigInteger;
        toEngineeringString(): string;
        max(arg0: Internal.BigDecimal_): Internal.BigDecimal;
        setScale(arg0: number): Internal.BigDecimal;
        setScale(arg0: number, arg1: number): Internal.BigDecimal;
        setScale(arg0: number, arg1: Internal.RoundingMode_): Internal.BigDecimal;
        static valueOf(arg0: number): Internal.BigDecimal;
        static valueOf(arg0: number, arg1: number): Internal.BigDecimal;
        intValue(): number;
        subtract(arg0: Internal.BigDecimal_, arg1: Internal.MathContext_): Internal.BigDecimal;
        subtract(arg0: Internal.BigDecimal_): Internal.BigDecimal;
        floatValue(): number;
        doubleValue(): number;
        divideToIntegralValue(arg0: Internal.BigDecimal_, arg1: Internal.MathContext_): Internal.BigDecimal;
        divideToIntegralValue(arg0: Internal.BigDecimal_): Internal.BigDecimal;
        plus(arg0: Internal.MathContext_): Internal.BigDecimal;
        plus(): Internal.BigDecimal;
        abs(): Internal.BigDecimal;
        abs(arg0: Internal.MathContext_): Internal.BigDecimal;
        round(arg0: Internal.MathContext_): Internal.BigDecimal;
        divideAndRemainder(arg0: Internal.BigDecimal_): Internal.BigDecimal[];
        divideAndRemainder(arg0: Internal.BigDecimal_, arg1: Internal.MathContext_): Internal.BigDecimal[];
        negate(arg0: Internal.MathContext_): Internal.BigDecimal;
        negate(): Internal.BigDecimal;
        movePointRight(arg0: number): Internal.BigDecimal;
        equals(arg0: any): boolean;
        ulp(): Internal.BigDecimal;
        toString(): string;
        stripTrailingZeros(): Internal.BigDecimal;
        remainder(arg0: Internal.BigDecimal_): Internal.BigDecimal;
        remainder(arg0: Internal.BigDecimal_, arg1: Internal.MathContext_): Internal.BigDecimal;
        intValueExact(): number;
        byteValue(): number;
        static readonly ZERO : Internal.BigDecimal;
        static readonly ROUND_DOWN : 1;
        static readonly ROUND_UNNECESSARY : 7;
        static readonly ROUND_CEILING : 2;
        static readonly ROUND_HALF_DOWN : 5;
        static readonly ROUND_HALF_UP : 4;
        static readonly ONE : Internal.BigDecimal;
        static readonly ROUND_UP : 0;
        static readonly ROUND_FLOOR : 3;
        static readonly ROUND_HALF_EVEN : 6;
        static readonly TEN : Internal.BigDecimal;
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    type BigDecimal_ = BigDecimal;
    class LightTexture implements Internal.AutoCloseable {
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        hashCode(): number;
        notifyAll(): void;
        equals(arg0: any): boolean;
        toString(): string;
        close(): void;
        notify(): void;
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    type LightTexture_ = LightTexture;
    interface ItemBuilder$ReleaseUsingCallback {
        releaseUsing(arg0: Internal.ItemStackJS_, arg1: Internal.LevelJS_, arg2: Internal.LivingEntityJS_, arg3: number): void;
    }
    type ItemBuilder$ReleaseUsingCallback_ = ((arg0: Internal.ItemStackJS, arg1: Internal.LevelJS, arg2: Internal.LivingEntityJS, arg3: number) => void) | ItemBuilder$ReleaseUsingCallback;
    class WritingMode extends Internal.Enum<Internal.WritingMode> {
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        static valueOf(arg0: string): Internal.WritingMode;
        static valueOf<T_>(arg0: Internal.Class_<T_>, arg1: string): T_;
        notifyAll(): void;
        static values(): Internal.WritingMode[];
        compareTo(arg0: Internal.WritingMode_): number;
        describeConstable(): Internal.Optional<Internal.Enum$EnumDesc<Internal.WritingMode>>;
        notify(): void;
        getDeclaringClass(): Internal.Class<Internal.WritingMode>;
        hashCode(): number;
        equals(arg0: any): boolean;
        name(): string;
        toString(): string;
        ordinal(): number;
        static readonly REPLACE : Internal.WritingMode;
        static readonly APPEND : Internal.WritingMode;
        get class(): Internal.Class<any>;
        get declaringClass(): Internal.Class<Internal.WritingMode>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    type WritingMode_ = "replace" | "append" | WritingMode;
    interface WatchKey {
        cancel(): void;
        pollEvents(): Internal.List<Internal.WatchEvent<any>>;
        watchable(): Internal.Watchable;
        isValid(): boolean;
        reset(): boolean;
    }
    type WatchKey_ = WatchKey;
    class AmbientMoodSettings {
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        hashCode(): number;
        notifyAll(): void;
        equals(arg0: any): boolean;
        toString(): string;
        notify(): void;
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    type AmbientMoodSettings_ = AmbientMoodSettings;
    abstract class LivingEntityEventJS extends Internal.EntityEventJS {
        cancel(): void;
        getServer(): Internal.ServerJS;
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        isCancelled(): boolean;
        notifyAll(): void;
        getEntity(): Internal.EntityJS;
        notify(): void;
        getLevel(): Internal.LevelJS;
        post(id: string): boolean;
        post(id: string, sub: string): boolean;
        post(t: Internal.ScriptType_, id: string, sub: string): boolean;
        post(t: Internal.ScriptType_, id: string): boolean;
        hashCode(): number;
        equals(arg0: any): boolean;
        toString(): string;
        canCancel(): boolean;
        get server(): Internal.ServerJS;
        get level(): Internal.LevelJS;
        get cancelled(): boolean;
        get class(): Internal.Class<any>;
        get entity(): Internal.EntityJS;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    type LivingEntityEventJS_ = LivingEntityEventJS;
    class DecimalStyle {
        getPositiveSign(): string;
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        getDecimalSeparator(): string;
        notifyAll(): void;
        getNegativeSign(): string;
        notify(): void;
        static ofDefaultLocale(): Internal.DecimalStyle;
        getZeroDigit(): string;
        withPositiveSign(arg0: string): Internal.DecimalStyle;
        hashCode(): number;
        withDecimalSeparator(arg0: string): Internal.DecimalStyle;
        static of(arg0: Internal.Locale_): Internal.DecimalStyle;
        equals(arg0: any): boolean;
        toString(): string;
        withNegativeSign(arg0: string): Internal.DecimalStyle;
        withZeroDigit(arg0: string): Internal.DecimalStyle;
        static getAvailableLocales(): Internal.Set<Internal.Locale>;
        static readonly STANDARD : Internal.DecimalStyle;
        get negativeSign(): string;
        get decimalSeparator(): string;
        get zeroDigit(): string;
        get positiveSign(): string;
        get class(): Internal.Class<any>;
        get availableLocales(): Internal.Set<Internal.Locale>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    type DecimalStyle_ = DecimalStyle;
    class InformationJEIEventJS extends Internal.EventJS {
        cancel(): void;
        add(o: any, s: Internal.Text_[]): void;
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        isCancelled(): boolean;
        notifyAll(): void;
        notify(): void;
        addForType<T_>(type: Internal.IIngredientType_<T_>, o: any, s: Internal.Text_[]): void;
        post(t: Internal.ScriptType_, id: string, sub: string): boolean;
        post(t: Internal.ScriptType_, id: string): boolean;
        hashCode(): number;
        equals(arg0: any): boolean;
        static toComponent(s: Internal.Text_[]): Internal.Component[];
        toString(): string;
        canCancel(): boolean;
        get cancelled(): boolean;
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    type InformationJEIEventJS_ = InformationJEIEventJS;
    class JsonObject extends Internal.JsonElement {
        getAsFloat(): number;
        getClass(): Internal.Class<any>;
        getAsByte(): number;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        getAsBigDecimal(): Internal.BigDecimal;
        notifyAll(): void;
        getAsNumber(): Internal.Number;
        getAsCharacter(): string;
        getAsString(): string;
        isJsonArray(): boolean;
        notify(): void;
        getAsInt(): number;
        remove(arg0: string): Internal.JsonElement;
        isJsonPrimitive(): boolean;
        getAsLong(): number;
        isJsonObject(): boolean;
        hashCode(): number;
        get(arg0: string): Internal.JsonElement;
        has(arg0: string): boolean;
        keySet(): Internal.Set<string>;
        getAsBigInteger(): Internal.BigInteger;
        add(arg0: string, arg1: Internal.JsonElement_): void;
        getAsJsonObject(arg0: string): Internal.JsonObject;
        getAsJsonObject(): Internal.JsonObject;
        getAsJsonNull(): Internal.JsonNull;
        entrySet(): Internal.Set<Internal.Map$Entry<string, Internal.JsonElement>>;
        isJsonNull(): boolean;
        getAsDouble(): number;
        addProperty(arg0: string, arg1: string): void;
        addProperty(arg0: string, arg1: boolean): void;
        addProperty(arg0: string, arg1: Internal.Number_): void;
        deepCopy(): Internal.JsonObject;
        getAsJsonArray(arg0: string): Internal.JsonArray;
        getAsJsonArray(): Internal.JsonArray;
        size(): number;
        getAsBoolean(): boolean;
        getAsJsonPrimitive(arg0: string): Internal.JsonPrimitive;
        getAsJsonPrimitive(): Internal.JsonPrimitive;
        equals(arg0: any): boolean;
        toString(): string;
        getAsShort(): number;
        get asByte(): number;
        get asBigInteger(): Internal.BigInteger;
        get asJsonObject(): Internal.JsonObject;
        get asCharacter(): string;
        get jsonPrimitive(): boolean;
        get asNumber(): Internal.Number;
        get asBigDecimal(): Internal.BigDecimal;
        get jsonNull(): boolean;
        get asFloat(): number;
        get asLong(): number;
        get asInt(): number;
        get asJsonPrimitive(): Internal.JsonPrimitive;
        get asJsonNull(): Internal.JsonNull;
        get asShort(): number;
        get asDouble(): number;
        get asJsonArray(): Internal.JsonArray;
        get asString(): string;
        get jsonObject(): boolean;
        get class(): Internal.Class<any>;
        get jsonArray(): boolean;
        get asBoolean(): boolean;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    type JsonObject_ = JsonObject;
    class LootContext$Builder implements Internal.LootContextBuilderAccess {
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        handler$ced000$addTypeOnCreate(arg0: Internal.LootContextParamSet_, arg1: Internal.CallbackInfoReturnable_<any>): void;
        hashCode(): number;
        notifyAll(): void;
        equals(arg0: any): boolean;
        toString(): string;
        notify(): void;
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    type LootContext$Builder_ = LootContext$Builder;
    interface Function3 <T1, T2, T3, R> {
        apply(arg0: T1, arg1: T2, arg2: T3): R;
        curry2(): Internal.BiFunction<T1, T2, java_.util.function_.Function<T3, R>>;
        curry(): java_.util.function_.Function<T1, Internal.BiFunction<T2, T3, R>>;
    }
    type Function3_<T1, T2, T3, R> = Function3<T1, T2, T3, R>;
    interface SortedMap <K, V> extends Internal.Map<K, V> {
        getOrDefault(arg0: any, arg1: V): V;
        computeIfAbsent(arg0: K, arg1: java_.util.function_.Function_<K, V>): V;
        values(): Internal.Collection<V>;
        replace(arg0: K, arg1: V): V;
        replace(arg0: K, arg1: V, arg2: V): boolean;
        replaceAll(arg0: Internal.BiFunction_<K, V, V>): void;
        containsValue(arg0: any): boolean;
        put(arg0: K, arg1: V): V;
        remove(arg0: any): V;
        remove(arg0: any, arg1: any): boolean;
        compute(arg0: K, arg1: Internal.BiFunction_<K, V, V>): V;
        hashCode(): number;
        putAll(arg0: Internal.Map_<K, V>): void;
        merge(arg0: K, arg1: V, arg2: Internal.BiFunction_<V, V, V>): V;
        get(arg0: any): V;
        lastKey(): K;
        keySet(): Internal.Set<K>;
        entrySet(): Internal.Set<Internal.Map$Entry<K, V>>;
        containsKey(arg0: any): boolean;
        forEach(arg0: Internal.BiConsumer_<K, V>): void;
        subMap(arg0: K, arg1: K): Internal.SortedMap<K, V>;
        isEmpty(): boolean;
        clear(): void;
        comparator(): Internal.Comparator<K>;
        computeIfPresent(arg0: K, arg1: Internal.BiFunction_<K, V, V>): V;
        size(): number;
        firstKey(): K;
        equals(arg0: any): boolean;
        headMap(arg0: K): Internal.SortedMap<K, V>;
        putIfAbsent(arg0: K, arg1: V): V;
        tailMap(arg0: K): Internal.SortedMap<K, V>;
    }
    type SortedMap_<K, V> = SortedMap<K, V>;
    class LevelChunk extends Internal.ChunkAccess implements Internal.ICapabilityProviderImpl<Internal.LevelChunk> {
        getClass(): Internal.Class<any>;
        getWorldForge(): Internal.Level;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        localvar$zek000$modifyHeightmapType(arg0: Internal.Heightmap$Types_): Internal.Heightmap$Types;
        getCapability<T_>(arg0: Internal.Capability_<T_>, arg1: Internal.Direction_): Internal.LazyOptional<T_>;
        getCapability<T_>(arg0: Internal.Capability_<T_>): Internal.LazyOptional<T_>;
        notifyAll(): void;
        areCapsCompatible(arg0: Internal.CapabilityProvider_<Internal.LevelChunk_>): boolean;
        areCapsCompatible(arg0: Internal.CapabilityDispatcher_): boolean;
        writeCapsToNBT(): Internal.CompoundTag;
        notify(): void;
        reviveCaps(): void;
        readCapsFromNBT(arg0: Internal.CompoundTag_): void;
        getNextSaveTime(): number;
        getRandom(arg0: number): Internal.Random;
        invalidateCaps(): void;
        setSaveTimePoint(arg0: number): void;
        hashCode(): number;
        equals(arg0: any): boolean;
        getExistingBlockEntity(arg0: BlockPos_): Internal.BlockEntity;
        toString(): string;
        get nextSaveTime(): number;
        get worldForge(): Internal.Level;
        get class(): Internal.Class<any>;
        set saveTimePoint(arg0: number);
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    type LevelChunk_ = LevelChunk;
    class Thread implements Internal.Runnable {
        setName(arg0: string): void;
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        getThreadGroup(): Internal.ThreadGroup;
        getName(): string;
        static getAllStackTraces(): Internal.Map<Internal.Thread, any[]>;
        notifyAll(): void;
        static onSpinWait(): void;
        getId(): number;
        run(): void;
        notify(): void;
        setContextClassLoader(arg0: Internal.ClassLoader_): void;
        static sleep(arg0: number, arg1: number): void;
        static sleep(arg0: number): void;
        getStackTrace(): any[];
        hashCode(): number;
        isDaemon(): boolean;
        static yield(): void;
        interrupt(): void;
        static enumerate(arg0: Internal.Thread_[]): number;
        join(arg0: number): void;
        join(): void;
        join(arg0: number, arg1: number): void;
        suspend(): void;
        static activeCount(): number;
        resume(): void;
        static currentThread(): Internal.Thread;
        setUncaughtExceptionHandler(arg0: Internal.Thread$UncaughtExceptionHandler_): void;
        isInterrupted(): boolean;
        static dumpStack(): void;
        static setDefaultUncaughtExceptionHandler(arg0: Internal.Thread$UncaughtExceptionHandler_): void;
        start(): void;
        static interrupted(): boolean;
        getUncaughtExceptionHandler(): Internal.Thread$UncaughtExceptionHandler;
        checkAccess(): void;
        static getDefaultUncaughtExceptionHandler(): Internal.Thread$UncaughtExceptionHandler;
        isAlive(): boolean;
        setDaemon(arg0: boolean): void;
        static holdsLock(arg0: any): boolean;
        getState(): Internal.Thread$State;
        stop(): void;
        getContextClassLoader(): Internal.ClassLoader;
        equals(arg0: any): boolean;
        getPriority(): number;
        countStackFrames(): number;
        toString(): string;
        setPriority(arg0: number): void;
        static readonly MIN_PRIORITY : 1;
        static readonly MAX_PRIORITY : 10;
        static readonly NORM_PRIORITY : 5;
        get allStackTraces(): Internal.Map<Internal.Thread, any[]>;
        get alive(): boolean;
        get priority(): number;
        get uncaughtExceptionHandler(): Internal.Thread$UncaughtExceptionHandler;
        get daemon(): boolean;
        get defaultUncaughtExceptionHandler(): Internal.Thread$UncaughtExceptionHandler;
        get threadGroup(): Internal.ThreadGroup;
        get contextClassLoader(): Internal.ClassLoader;
        get name(): string;
        get id(): number;
        get stackTrace(): any[];
        get state(): Internal.Thread$State;
        get class(): Internal.Class<any>;
        set defaultUncaughtExceptionHandler(arg0: Internal.Thread$UncaughtExceptionHandler_);
        set contextClassLoader(arg0: Internal.ClassLoader_);
        set name(arg0: string);
        set priority(arg0: number);
        set uncaughtExceptionHandler(arg0: Internal.Thread$UncaughtExceptionHandler_);
        set daemon(arg0: boolean);
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    type Thread_ = Thread;
    class NameMap <E> implements Internal.Iterable<E> {
        getPrevious(value: E): E;
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        getName(value: E): string;
        getIndex(e: E): number;
        notifyAll(): void;
        notify(): void;
        iterator(): Internal.Iterator<E>;
        getRandom(rand: Internal.Random_): E;
        hashCode(): number;
        static of<T_>(defaultValue: T_, values: Internal.List_<T_>): Internal.NameMap$Builder<T_>;
        static of<T_>(defaultValue: T_, values: T_[]): Internal.NameMap$Builder<T_>;
        get(s: string): E;
        get(index: number): E;
        getStringIndex(s: string): number;
        write(data: Internal.FriendlyByteBuf_, object: E): void;
        read(data: Internal.FriendlyByteBuf_): E;
        offset(value: E, index: number): E;
        spliterator(): Internal.Spliterator<E>;
        forEach(arg0: Internal.Consumer_<E>): void;
        getNullable(s: string): E;
        getColor(value: E): Internal.Color4I;
        getNext(value: E): E;
        withDefault(def: E): Internal.NameMap<E>;
        getIcon(v: E): Internal.Icon;
        size(): number;
        getDisplayName(value: E): Internal.Component;
        equals(arg0: any): boolean;
        toString(): string;
        readonly defaultValue : E;
        readonly keys : Internal.List<string>;
        readonly values : Internal.List<E>;
        readonly map : Internal.Map<string, E>;
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    type NameMap_<E> = NameMap<E>;
    class PatternError {
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        getWorld(): Internal.Level;
        hashCode(): number;
        getPos(): BlockPos;
        notifyAll(): void;
        equals(arg0: any): boolean;
        getCandidates(): Internal.List<Internal.List<Internal.ItemStack>>;
        setWorldState(arg0: Internal.MultiblockState_): void;
        toString(): string;
        getErrorInfo(): string;
        notify(): void;
        get candidates(): Internal.List<Internal.List<Internal.ItemStack>>;
        get world(): Internal.Level;
        get pos(): BlockPos;
        get errorInfo(): string;
        get class(): Internal.Class<any>;
        set worldState(arg0: Internal.MultiblockState_);
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    type PatternError_ = PatternError;
    interface ActionListener extends Internal.EventListener {
        actionPerformed(arg0: Internal.ActionEvent_): void;
    }
    type ActionListener_ = ActionListener;
    interface ICondition$IContext {
        getAllTags<T>(arg0: Internal.ResourceKey_<Internal.Registry_<T>>): Internal.Map<ResourceLocation, Internal.Tag<Internal.Holder<T>>>;
        getTag<T>(arg0: Internal.TagKey_<T>): Internal.Tag<Internal.Holder<T>>;
    }
    type ICondition$IContext_ = ICondition$IContext;
    abstract class InputEvent extends Internal.ComponentEvent {
        getClass(): Internal.Class<any>;
        setSource(arg0: any): void;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        isControlDown(): boolean;
        notifyAll(): void;
        isMetaDown(): boolean;
        getID(): number;
        consume(): void;
        getModifiersEx(): number;
        notify(): void;
        isShiftDown(): boolean;
        paramString(): string;
        isConsumed(): boolean;
        static getModifiersExText(arg0: number): string;
        hashCode(): number;
        getSource(): any;
        isAltGraphDown(): boolean;
        equals(arg0: any): boolean;
        static getMaskForButton(arg0: number): number;
        getWhen(): number;
        toString(): string;
        getComponent(): java_.awt.Component;
        getModifiers(): number;
        isAltDown(): boolean;
        static readonly ADJUSTMENT_EVENT_MASK : 256;
        static readonly MOUSE_EVENT_MASK : 16;
        static readonly BUTTON1_MASK : 16;
        static readonly COMPONENT_EVENT_MASK : 1;
        static readonly PAINT_EVENT_MASK : 8192;
        static readonly SHIFT_MASK : 1;
        static readonly COMPONENT_HIDDEN : 103;
        static readonly INPUT_METHOD_EVENT_MASK : 2048;
        static readonly HIERARCHY_BOUNDS_EVENT_MASK : 65536;
        static readonly COMPONENT_LAST : 103;
        static readonly FOCUS_EVENT_MASK : 4;
        static readonly INVOCATION_EVENT_MASK : 16384;
        static readonly ALT_GRAPH_MASK : 32;
        static readonly KEY_EVENT_MASK : 8;
        static readonly RESERVED_ID_MAX : 1999;
        static readonly BUTTON2_MASK : 8;
        static readonly CONTAINER_EVENT_MASK : 2;
        static readonly WINDOW_EVENT_MASK : 64;
        static readonly CTRL_MASK : 2;
        static readonly ALT_MASK : 8;
        static readonly MOUSE_WHEEL_EVENT_MASK : 131072;
        static readonly ALT_DOWN_MASK : 512;
        static readonly MOUSE_MOTION_EVENT_MASK : 32;
        static readonly COMPONENT_FIRST : 100;
        static readonly BUTTON1_DOWN_MASK : 1024;
        static readonly WINDOW_FOCUS_EVENT_MASK : 524288;
        static readonly COMPONENT_MOVED : 100;
        static readonly COMPONENT_SHOWN : 102;
        static readonly META_DOWN_MASK : 256;
        static readonly BUTTON3_DOWN_MASK : 4096;
        static readonly SHIFT_DOWN_MASK : 64;
        static readonly CTRL_DOWN_MASK : 128;
        static readonly TEXT_EVENT_MASK : 1024;
        static readonly BUTTON2_DOWN_MASK : 2048;
        static readonly ALT_GRAPH_DOWN_MASK : 8192;
        static readonly ACTION_EVENT_MASK : 128;
        static readonly ITEM_EVENT_MASK : 512;
        static readonly BUTTON3_MASK : 4;
        static readonly HIERARCHY_EVENT_MASK : 32768;
        static readonly WINDOW_STATE_EVENT_MASK : 262144;
        static readonly META_MASK : 4;
        static readonly COMPONENT_RESIZED : 101;
        get consumed(): boolean;
        get altDown(): boolean;
        get controlDown(): boolean;
        get source(): any;
        get modifiers(): number;
        get when(): number;
        get altGraphDown(): boolean;
        get component(): java_.awt.Component;
        get modifiersEx(): number;
        get shiftDown(): boolean;
        get metaDown(): boolean;
        get iD(): number;
        get class(): Internal.Class<any>;
        set source(arg0: any);
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    type InputEvent_ = InputEvent;
    interface ReadableByteChannel extends Internal.Channel {
        isOpen(): boolean;
        read(arg0: Internal.ByteBuffer_): number;
        close(): void;
    }
    type ReadableByteChannel_ = ReadableByteChannel;
    interface LootConditionsContainer <B> {
        killerPredicate(arg0: Internal.Predicate_<Internal.Entity_>): B;
        survivesExplosion(): B;
        createConditions(arg0: Internal.Consumer_<Internal.LootConditionsContainer_<B>>): Internal.List<Internal.ILootCondition>;
        addCondition(arg0: Internal.ILootCondition_): B;
        addCondition(arg0: Internal.LootItemCondition$Builder_): B;
        matchFluid(arg0: Internal.Resolver_): B;
        customDistanceToPlayer(arg0: Internal.Consumer_<Internal.DistancePredicateBuilder_>): B;
        not(arg0: Internal.Consumer_<Internal.LootConditionsContainer_<B>>): B;
        directKillerPredicate(arg0: Internal.Predicate_<Internal.Entity_>): B;
        matchEquip(arg0: EquipmentSlot_, arg1: ItemFilter_): B;
        and(arg0: Internal.Consumer_<Internal.LootConditionsContainer_<B>>): B;
        matchLoot(arg0: ItemFilter_): B;
        matchLoot(arg0: ItemFilter_, arg1: boolean): B;
        anyBiome(arg0: Internal.Resolver_[]): B;
        distanceToKiller(arg0: Internal.MinMaxBounds$Doubles_): B;
        matchEntity(arg0: Internal.Consumer_<Internal.EntityPredicateBuilderJS_>): B;
        entityPredicate(arg0: Internal.Predicate_<Internal.Entity_>): B;
        anyDimension(arg0: ResourceLocation_[]): B;
        killedByPlayer(): B;
        or(arg0: Internal.Consumer_<Internal.LootConditionsContainer_<B>>): B;
        matchOffHand(arg0: ItemFilter_): B;
        randomChance(arg0: number): B;
        timeCheck(arg0: number, arg1: number, arg2: number): B;
        timeCheck(arg0: number, arg1: number): B;
        playerPredicate(arg0: Internal.Predicate_<Internal.ServerPlayer_>): B;
        weatherCheck(arg0: Internal.Map_<string, boolean>): B;
        matchDirectKiller(arg0: Internal.Consumer_<Internal.EntityPredicateBuilderJS_>): B;
        matchBlockState(arg0: Internal.Block_, arg1: Internal.Map_<string, string>): B;
        matchMainHand(arg0: ItemFilter_): B;
        matchPlayer(arg0: Internal.Consumer_<Internal.EntityPredicateBuilderJS_>): B;
        lightLevel(arg0: number, arg1: number): B;
        customCondition(arg0: Internal.JsonObject_): B;
        biome(arg0: Internal.Resolver_[]): B;
        matchKiller(arg0: Internal.Consumer_<Internal.EntityPredicateBuilderJS_>): B;
        randomChanceWithLooting(arg0: number, arg1: number): B;
        hasAnyStage(arg0: string[]): B;
        randomChanceWithEnchantment(arg0: Internal.Enchantment_, arg1: number[]): B;
        anyStructure(arg0: ResourceLocation_[], arg1: boolean): B;
        matchDamageSource(arg0: Internal.Consumer_<Internal.DamageSourcePredicateBuilderJS_>): B;
    }
    type LootConditionsContainer_<B> = LootConditionsContainer<B>;
    interface Long2ByteFunction extends Internal.Function<number, number>, Internal.LongToIntFunction {
        getOrDefault(arg0: any, arg1: number): number;
        getOrDefault(arg0: number, arg1: number): number;
        andThenShort(arg0: Internal.Byte2ShortFunction_): Internal.Long2ShortFunction;
        composeByte(arg0: Internal.Byte2LongFunction_): Internal.Byte2ByteFunction;
        andThenInt(arg0: Internal.Byte2IntFunction_): Internal.Long2IntFunction;
        composeReference<T_>(arg0: Internal.Reference2LongFunction_<T_>): Internal.Reference2ByteFunction<T_>;
        andThen<T_>(arg0: java_.util.function_.Function_<number, T_>): java_.util.function_.Function<number, T_>;
        put(arg0: number, arg1: number): number;
        remove(arg0: number): number;
        remove(arg0: any): number;
        defaultReturnValue(): number;
        defaultReturnValue(arg0: number): void;
        andThenDouble(arg0: Internal.Byte2DoubleFunction_): Internal.Long2DoubleFunction;
        andThenObject<T_>(arg0: Internal.Byte2ObjectFunction_<T_>): Internal.Long2ObjectFunction<T_>;
        get(arg0: any): number;
        get(arg0: number): number;
        andThenLong(arg0: Internal.Byte2LongFunction_): Internal.Long2LongFunction;
        composeLong(arg0: Internal.Long2LongFunction_): Internal.Long2ByteFunction;
        andThenByte(arg0: Internal.Byte2ByteFunction_): Internal.Long2ByteFunction;
        andThenFloat(arg0: Internal.Byte2FloatFunction_): Internal.Long2FloatFunction;
        applyAsInt(arg0: number): number;
        apply(arg0: number): number;
        containsKey(arg0: any): boolean;
        containsKey(arg0: number): boolean;
        composeInt(arg0: Internal.Int2LongFunction_): Internal.Int2ByteFunction;
        clear(): void;
        composeFloat(arg0: Internal.Float2LongFunction_): Internal.Float2ByteFunction;
        andThenChar(arg0: Internal.Byte2CharFunction_): Internal.Long2CharFunction;
        composeObject<T_>(arg0: Internal.Object2LongFunction_<T_>): Internal.Object2ByteFunction<T_>;
        size(): number;
        compose<T_>(arg0: java_.util.function_.Function_<T_, number>): java_.util.function_.Function<T_, number>;
        composeShort(arg0: Internal.Short2LongFunction_): Internal.Short2ByteFunction;
        andThenReference<T_>(arg0: Internal.Byte2ReferenceFunction_<T_>): Internal.Long2ReferenceFunction<T_>;
        composeChar(arg0: Internal.Char2LongFunction_): Internal.Char2ByteFunction;
        composeDouble(arg0: Internal.Double2LongFunction_): Internal.Double2ByteFunction;
    }
    type Long2ByteFunction_ = ((arg0: number) => number) | Long2ByteFunction;
    class ChatFormatting extends Internal.Enum<Internal.ChatFormatting> implements Internal.Color {
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        getRgbKJS(): number;
        static valueOf(arg0: string): Internal.ChatFormatting;
        static valueOf<T_>(arg0: Internal.Class_<T_>, arg1: string): T_;
        notifyAll(): void;
        static values(): Internal.ChatFormatting[];
        compareTo(arg0: Internal.ChatFormatting_): number;
        getSerializeKJS(): string;
        describeConstable(): Internal.Optional<Internal.Enum$EnumDesc<Internal.ChatFormatting>>;
        notify(): void;
        getDeclaringClass(): Internal.Class<Internal.ChatFormatting>;
        hashCode(): number;
        equals(arg0: any): boolean;
        name(): string;
        createTextColorKJS(): Internal.TextColor;
        getHexKJS(): string;
        getArgbKJS(): number;
        toString(): string;
        getFireworkColorKJS(): number;
        specialEquals(o: any, shallow: boolean): boolean;
        ordinal(): number;
        static readonly ITALIC : Internal.ChatFormatting;
        static readonly GOLD : Internal.ChatFormatting;
        static readonly GRAY : Internal.ChatFormatting;
        static readonly AQUA : Internal.ChatFormatting;
        static readonly WHITE : Internal.ChatFormatting;
        static readonly BLUE : Internal.ChatFormatting;
        static readonly OBFUSCATED : Internal.ChatFormatting;
        static readonly DARK_AQUA : Internal.ChatFormatting;
        static readonly RESET : Internal.ChatFormatting;
        static readonly DARK_BLUE : Internal.ChatFormatting;
        static readonly GREEN : Internal.ChatFormatting;
        static readonly UNDERLINE : Internal.ChatFormatting;
        static readonly RED : Internal.ChatFormatting;
        static readonly DARK_PURPLE : Internal.ChatFormatting;
        static readonly STRIKETHROUGH : Internal.ChatFormatting;
        static readonly DARK_RED : Internal.ChatFormatting;
        static readonly LIGHT_PURPLE : Internal.ChatFormatting;
        static readonly BLACK : Internal.ChatFormatting;
        static readonly BOLD : Internal.ChatFormatting;
        static readonly DARK_GREEN : Internal.ChatFormatting;
        static readonly YELLOW : Internal.ChatFormatting;
        static readonly DARK_GRAY : Internal.ChatFormatting;
        get fireworkColorKJS(): number;
        get rgbKJS(): number;
        get argbKJS(): number;
        get serializeKJS(): string;
        get hexKJS(): string;
        get class(): Internal.Class<any>;
        get declaringClass(): Internal.Class<Internal.ChatFormatting>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    type ChatFormatting_ = "dark_red" | "green" | "underline" | "dark_green" | "black" | "yellow" | "bold" | "italic" | "dark_blue" | "dark_purple" | "gold" | "red" | "aqua" | "gray" | "light_purple" | "blue" | "white" | "dark_aqua" | "dark_gray" | "reset" | "strikethrough" | "obfuscated" | ChatFormatting;
    class ConfigSpec$CorrectionAction extends Internal.Enum<Internal.ConfigSpec$CorrectionAction> {
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        static valueOf(arg0: string): Internal.ConfigSpec$CorrectionAction;
        static valueOf<T_>(arg0: Internal.Class_<T_>, arg1: string): T_;
        notifyAll(): void;
        static values(): Internal.ConfigSpec$CorrectionAction[];
        compareTo(arg0: Internal.ConfigSpec$CorrectionAction_): number;
        describeConstable(): Internal.Optional<Internal.Enum$EnumDesc<Internal.ConfigSpec$CorrectionAction>>;
        notify(): void;
        getDeclaringClass(): Internal.Class<Internal.ConfigSpec$CorrectionAction>;
        hashCode(): number;
        equals(arg0: any): boolean;
        name(): string;
        toString(): string;
        ordinal(): number;
        static readonly ADD : Internal.ConfigSpec$CorrectionAction;
        static readonly REMOVE : Internal.ConfigSpec$CorrectionAction;
        static readonly REPLACE : Internal.ConfigSpec$CorrectionAction;
        get class(): Internal.Class<any>;
        get declaringClass(): Internal.Class<Internal.ConfigSpec$CorrectionAction>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    type ConfigSpec$CorrectionAction_ = "add" | "replace" | "remove" | ConfigSpec$CorrectionAction;
    interface Short2DoubleFunction extends Internal.Function<number, number>, Internal.IntToDoubleFunction {
        getOrDefault(arg0: any, arg1: number): number;
        getOrDefault(arg0: number, arg1: number): number;
        applyAsDouble(arg0: number): number;
        andThenShort(arg0: Internal.Double2ShortFunction_): Internal.Short2ShortFunction;
        composeByte(arg0: Internal.Byte2ShortFunction_): Internal.Byte2DoubleFunction;
        andThenInt(arg0: Internal.Double2IntFunction_): Internal.Short2IntFunction;
        composeReference<T_>(arg0: Internal.Reference2ShortFunction_<T_>): Internal.Reference2DoubleFunction<T_>;
        andThen<T_>(arg0: java_.util.function_.Function_<number, T_>): java_.util.function_.Function<number, T_>;
        put(arg0: number, arg1: number): number;
        remove(arg0: number): number;
        remove(arg0: any): number;
        defaultReturnValue(): number;
        defaultReturnValue(arg0: number): void;
        andThenDouble(arg0: Internal.Double2DoubleFunction_): Internal.Short2DoubleFunction;
        andThenObject<T_>(arg0: Internal.Double2ObjectFunction_<T_>): Internal.Short2ObjectFunction<T_>;
        get(arg0: any): number;
        get(arg0: number): number;
        andThenLong(arg0: Internal.Double2LongFunction_): Internal.Short2LongFunction;
        composeLong(arg0: Internal.Long2ShortFunction_): Internal.Long2DoubleFunction;
        andThenByte(arg0: Internal.Double2ByteFunction_): Internal.Short2ByteFunction;
        andThenFloat(arg0: Internal.Double2FloatFunction_): Internal.Short2FloatFunction;
        apply(arg0: number): number;
        containsKey(arg0: any): boolean;
        containsKey(arg0: number): boolean;
        composeInt(arg0: Internal.Int2ShortFunction_): Internal.Int2DoubleFunction;
        clear(): void;
        composeFloat(arg0: Internal.Float2ShortFunction_): Internal.Float2DoubleFunction;
        andThenChar(arg0: Internal.Double2CharFunction_): Internal.Short2CharFunction;
        composeObject<T_>(arg0: Internal.Object2ShortFunction_<T_>): Internal.Object2DoubleFunction<T_>;
        size(): number;
        compose<T_>(arg0: java_.util.function_.Function_<T_, number>): java_.util.function_.Function<T_, number>;
        composeShort(arg0: Internal.Short2ShortFunction_): Internal.Short2DoubleFunction;
        andThenReference<T_>(arg0: Internal.Double2ReferenceFunction_<T_>): Internal.Short2ReferenceFunction<T_>;
        composeChar(arg0: Internal.Char2ShortFunction_): Internal.Char2DoubleFunction;
        composeDouble(arg0: Internal.Double2ShortFunction_): Internal.Double2DoubleFunction;
    }
    type Short2DoubleFunction_ = ((arg0: number) => number) | Short2DoubleFunction;
    interface IRegistryDelegate <T> extends Internal.Supplier<T> {
        get(): T;
        name(): ResourceLocation;
        type(): Internal.Class<T>;
    }
    type IRegistryDelegate_<T> = IRegistryDelegate<T>;
    interface ObjLongConsumer <T> {
        accept(arg0: T, arg1: number): void;
    }
    type ObjLongConsumer_<T> = ((arg0: T, arg1: number) => void) | ObjLongConsumer<T>;
    class GoalSelector implements Internal.AccessorGoalSelector {
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        hashCode(): number;
        notifyAll(): void;
        equals(arg0: any): boolean;
        toString(): string;
        notify(): void;
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    type GoalSelector_ = GoalSelector;
    interface IGuiFluidStackGroup extends Internal.IGuiIngredientGroup<net.minecraftforge.fluids.FluidStack> {
        init(arg0: number, arg1: boolean, arg2: number, arg3: number, arg4: number, arg5: number, arg6: number, arg7: boolean, arg8: Internal.IDrawable_): void;
        init(arg0: number, arg1: boolean, arg2: number, arg3: number): void;
        init(arg0: number, arg1: boolean, arg2: Internal.IIngredientRenderer_<net.minecraftforge.fluids.FluidStack_>, arg3: number, arg4: number, arg5: number, arg6: number, arg7: number, arg8: number): void;
        set(arg0: number, arg1: net.minecraftforge.fluids.FluidStack_): void;
        set(arg0: number, arg1: Internal.List_<net.minecraftforge.fluids.FluidStack_>): void;
        set(arg0: Internal.IIngredients_): void;
        getGuiIngredients(): Internal.Map<number, Internal.IGuiIngredient<net.minecraftforge.fluids.FluidStack>>;
        addTooltipCallback(arg0: Internal.ITooltipCallback_<net.minecraftforge.fluids.FluidStack_>): void;
        setOverrideDisplayFocus(arg0: Internal.IFocus_<net.minecraftforge.fluids.FluidStack_>): void;
        setBackground(arg0: number, arg1: Internal.IDrawable_): void;
    }
    type IGuiFluidStackGroup_ = IGuiFluidStackGroup;
    interface ExternalArrayData {
        setArrayElement(arg0: number, arg1: any): void;
        getArrayLength(): number;
        getArrayElement(arg0: number): any;
    }
    type ExternalArrayData_ = ExternalArrayData;
    class SpecialRecipeSerializerManager extends Internal.EventJS {
        cancel(): void;
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        isCancelled(): boolean;
        notifyAll(): void;
        notify(): void;
        ignoreSpecialFlag(id: ResourceLocation_): void;
        post(t: Internal.ScriptType_, id: string, sub: string): boolean;
        post(t: Internal.ScriptType_, id: string): boolean;
        isSpecial(recipe: Internal.Recipe_<any>): boolean;
        hashCode(): number;
        equals(arg0: any): boolean;
        reset(): void;
        toString(): string;
        addSpecialFlag(id: ResourceLocation_): void;
        canCancel(): boolean;
        ignoreSpecialMod(modid: string): void;
        addSpecialMod(modid: string): void;
        static readonly INSTANCE : Internal.SpecialRecipeSerializerManager;
        static readonly EVENT : dev.architectury.event.Event<(() => void)>;
        get cancelled(): boolean;
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    type SpecialRecipeSerializerManager_ = SpecialRecipeSerializerManager;
    class MenuItem extends Internal.MenuComponent implements Internal.Accessible {
        setName(arg0: string): void;
        getListeners<T_>(arg0: Internal.Class_<T_>): T_[];
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        getName(): string;
        getLabel(): string;
        notifyAll(): void;
        getShortcut(): Internal.MenuShortcut;
        notify(): void;
        paramString(): string;
        removeActionListener(arg0: Internal.ActionListener_): void;
        hashCode(): number;
        enable(arg0: boolean): void;
        enable(): void;
        setFont(arg0: Internal.Font_): void;
        setShortcut(arg0: Internal.MenuShortcut_): void;
        getParent(): Internal.MenuContainer;
        dispatchEvent(arg0: Internal.AWTEvent_): void;
        deleteShortcut(): void;
        addActionListener(arg0: Internal.ActionListener_): void;
        setActionCommand(arg0: string): void;
        getAccessibleContext(): Internal.AccessibleContext;
        postEvent(arg0: java_.awt.Event_): boolean;
        setEnabled(arg0: boolean): void;
        addNotify(): void;
        disable(): void;
        equals(arg0: any): boolean;
        isEnabled(): boolean;
        getActionListeners(): Internal.ActionListener[];
        removeNotify(): void;
        setLabel(arg0: string): void;
        getFont(): Internal.Font;
        toString(): string;
        getActionCommand(): string;
        get accessibleContext(): Internal.AccessibleContext;
        get parent(): Internal.MenuContainer;
        get actionCommand(): string;
        get shortcut(): Internal.MenuShortcut;
        get actionListeners(): Internal.ActionListener[];
        get name(): string;
        get label(): string;
        get class(): Internal.Class<any>;
        get enabled(): boolean;
        get font(): Internal.Font;
        set actionCommand(arg0: string);
        set shortcut(arg0: Internal.MenuShortcut_);
        set name(arg0: string);
        set label(arg0: string);
        set enabled(arg0: boolean);
        set font(arg0: Internal.Font_);
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    type MenuItem_ = MenuItem;
    interface MapEncoder <A> extends Internal.Keyable {
        encode<T_>(arg0: A, arg1: Internal.DynamicOps_<T_>, arg2: Internal.RecordBuilder_<T_>): Internal.RecordBuilder<T_>;
        flatComap<B_>(arg0: java_.util.function_.Function_<B_, Internal.DataResult_<A>>): Internal.MapEncoder<B_>;
        compressedBuilder<T_>(arg0: Internal.DynamicOps_<T_>): Internal.RecordBuilder<T_>;
        keys<T_>(arg0: Internal.DynamicOps_<T_>): Internal.Stream<T_>;
        comap<B_>(arg0: java_.util.function_.Function_<B_, A>): Internal.MapEncoder<B_>;
        withLifecycle(arg0: Internal.Lifecycle_): Internal.MapEncoder<A>;
        encoder(): Internal.Encoder<A>;
        compressor<T_>(arg0: Internal.DynamicOps_<T_>): Internal.KeyCompressor<T_>;
    }
    type MapEncoder_<A> = MapEncoder<A>;
    interface CullingDataCache {
        restoreState(): void;
        saveState(): void;
    }
    type CullingDataCache_ = CullingDataCache;
    abstract class GlyphVector implements Internal.Cloneable {
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        getGlyphPosition(arg0: number): Internal.Point2D;
        getGlyphPixelBounds(arg0: number, arg1: Internal.FontRenderContext_, arg2: number, arg3: number): Internal.Rectangle;
        getLogicalBounds(): Internal.Rectangle2D;
        getGlyphCharIndices(arg0: number, arg1: number, arg2: number[]): number[];
        notifyAll(): void;
        getVisualBounds(): Internal.Rectangle2D;
        notify(): void;
        getGlyphCharIndex(arg0: number): number;
        getOutline(arg0: number, arg1: number): Internal.Shape;
        getOutline(): Internal.Shape;
        getGlyphJustificationInfo(arg0: number): Internal.GlyphJustificationInfo;
        performDefaultLayout(): void;
        hashCode(): number;
        getFontRenderContext(): Internal.FontRenderContext;
        getGlyphMetrics(arg0: number): Internal.GlyphMetrics;
        getGlyphVisualBounds(arg0: number): Internal.Shape;
        getLayoutFlags(): number;
        setGlyphPosition(arg0: number, arg1: Internal.Point2D_): void;
        getGlyphCodes(arg0: number, arg1: number, arg2: number[]): number[];
        getGlyphLogicalBounds(arg0: number): Internal.Shape;
        getPixelBounds(arg0: Internal.FontRenderContext_, arg1: number, arg2: number): Internal.Rectangle;
        getNumGlyphs(): number;
        getGlyphTransform(arg0: number): Internal.AffineTransform;
        equals(arg0: Internal.GlyphVector_): boolean;
        equals(arg0: any): boolean;
        toString(): string;
        getFont(): Internal.Font;
        getGlyphPositions(arg0: number, arg1: number, arg2: number[]): number[];
        getGlyphCode(arg0: number): number;
        getGlyphOutline(arg0: number): Internal.Shape;
        getGlyphOutline(arg0: number, arg1: number, arg2: number): Internal.Shape;
        setGlyphTransform(arg0: number, arg1: Internal.AffineTransform_): void;
        static readonly FLAG_HAS_TRANSFORMS : 1;
        static readonly FLAG_HAS_POSITION_ADJUSTMENTS : 2;
        static readonly FLAG_MASK : 15;
        static readonly FLAG_COMPLEX_GLYPHS : 8;
        static readonly FLAG_RUN_RTL : 4;
        get outline(): Internal.Shape;
        get logicalBounds(): Internal.Rectangle2D;
        get numGlyphs(): number;
        get fontRenderContext(): Internal.FontRenderContext;
        get visualBounds(): Internal.Rectangle2D;
        get class(): Internal.Class<any>;
        get layoutFlags(): number;
        get font(): Internal.Font;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    type GlyphVector_ = GlyphVector;
    interface DataHolder <T> {
    }
    type DataHolder_<T> = DataHolder<T>;
    class MinecraftServer$ReloadableResources extends Internal.Record implements Internal.AutoCloseable {
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        hashCode(): number;
        notifyAll(): void;
        equals(arg0: any): boolean;
        toString(): string;
        close(): void;
        notify(): void;
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    type MinecraftServer$ReloadableResources_ = MinecraftServer$ReloadableResources;
    class Unit extends Internal.Enum<Internal.Unit> {
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        static valueOf(arg0: string): Internal.Unit;
        static valueOf<T_>(arg0: Internal.Class_<T_>, arg1: string): T_;
        notifyAll(): void;
        static values(): Internal.Unit[];
        compareTo(arg0: Internal.Unit_): number;
        describeConstable(): Internal.Optional<Internal.Enum$EnumDesc<Internal.Unit>>;
        notify(): void;
        getDeclaringClass(): Internal.Class<Internal.Unit>;
        hashCode(): number;
        equals(arg0: any): boolean;
        name(): string;
        toString(): string;
        ordinal(): number;
        static readonly INSTANCE : Internal.Unit;
        get class(): Internal.Class<any>;
        get declaringClass(): Internal.Class<Internal.Unit>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    type Unit_ = "instance" | Unit;
    interface TaskType$GuiProvider {
        openCreationGui(arg0: Internal.Runnable_, arg1: Internal.Quest_, arg2: Internal.Consumer_<Internal.Task_>): void;
    }
    type TaskType$GuiProvider_ = TaskType$GuiProvider;
    class ActionEvent extends Internal.AWTEvent {
        getClass(): Internal.Class<any>;
        setSource(arg0: any): void;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        notifyAll(): void;
        getID(): number;
        notify(): void;
        paramString(): string;
        hashCode(): number;
        getSource(): any;
        equals(arg0: any): boolean;
        getWhen(): number;
        toString(): string;
        getActionCommand(): string;
        getModifiers(): number;
        static readonly ADJUSTMENT_EVENT_MASK : 256;
        static readonly MOUSE_EVENT_MASK : 16;
        static readonly COMPONENT_EVENT_MASK : 1;
        static readonly PAINT_EVENT_MASK : 8192;
        static readonly SHIFT_MASK : 1;
        static readonly ACTION_LAST : 1001;
        static readonly INPUT_METHOD_EVENT_MASK : 2048;
        static readonly HIERARCHY_BOUNDS_EVENT_MASK : 65536;
        static readonly ACTION_FIRST : 1001;
        static readonly FOCUS_EVENT_MASK : 4;
        static readonly INVOCATION_EVENT_MASK : 16384;
        static readonly KEY_EVENT_MASK : 8;
        static readonly RESERVED_ID_MAX : 1999;
        static readonly CONTAINER_EVENT_MASK : 2;
        static readonly WINDOW_EVENT_MASK : 64;
        static readonly CTRL_MASK : 2;
        static readonly ALT_MASK : 8;
        static readonly MOUSE_WHEEL_EVENT_MASK : 131072;
        static readonly MOUSE_MOTION_EVENT_MASK : 32;
        static readonly WINDOW_FOCUS_EVENT_MASK : 524288;
        static readonly TEXT_EVENT_MASK : 1024;
        static readonly ACTION_EVENT_MASK : 128;
        static readonly ITEM_EVENT_MASK : 512;
        static readonly ACTION_PERFORMED : 1001;
        static readonly HIERARCHY_EVENT_MASK : 32768;
        static readonly WINDOW_STATE_EVENT_MASK : 262144;
        static readonly META_MASK : 4;
        get actionCommand(): string;
        get iD(): number;
        get source(): any;
        get modifiers(): number;
        get class(): Internal.Class<any>;
        get when(): number;
        set source(arg0: any);
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    type ActionEvent_ = ActionEvent;
    class TextColor implements Internal.Color {
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        getRgbKJS(): number;
        notifyAll(): void;
        getSerializeKJS(): string;
        notify(): void;
        hashCode(): number;
        equals(arg0: any): boolean;
        createTextColorKJS(): Internal.TextColor;
        getHexKJS(): string;
        getArgbKJS(): number;
        toString(): string;
        getFireworkColorKJS(): number;
        specialEquals(o: any, shallow: boolean): boolean;
        get fireworkColorKJS(): number;
        get rgbKJS(): number;
        get argbKJS(): number;
        get serializeKJS(): string;
        get hexKJS(): string;
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    type TextColor_ = TextColor;
    class Products$P1 <F, T1> {
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        apply<R>(arg0: Internal.Applicative_<F, any>, arg1: java_.util.function_.Function_<T1, R>): Internal.App<F, R>;
        apply<R>(arg0: Internal.Applicative_<F, any>, arg1: Internal.App_<F, java_.util.function_.Function_<T1, R>>): Internal.App<F, R>;
        hashCode(): number;
        and<T2, T3, T4, T5, T6, T7>(arg0: Internal.Products$P6_<F, T2, T3, T4, T5, T6, T7>): Internal.Products$P7<F, T1, T2, T3, T4, T5, T6, T7>;
        and<T2, T3, T4, T5, T6, T7, T8>(arg0: Internal.Products$P7_<F, T2, T3, T4, T5, T6, T7, T8>): Internal.Products$P8<F, T1, T2, T3, T4, T5, T6, T7, T8>;
        and<T2, T3, T4, T5>(arg0: Internal.Products$P4_<F, T2, T3, T4, T5>): Internal.Products$P5<F, T1, T2, T3, T4, T5>;
        and<T2, T3>(arg0: Internal.Products$P2_<F, T2, T3>): Internal.Products$P3<F, T1, T2, T3>;
        and<T2, T3, T4>(arg0: Internal.Products$P3_<F, T2, T3, T4>): Internal.Products$P4<F, T1, T2, T3, T4>;
        and<T2>(arg0: Internal.App_<F, T2>): Internal.Products$P2<F, T1, T2>;
        and<T2, T3, T4, T5, T6>(arg0: Internal.Products$P5_<F, T2, T3, T4, T5, T6>): Internal.Products$P6<F, T1, T2, T3, T4, T5, T6>;
        notifyAll(): void;
        equals(arg0: any): boolean;
        toString(): string;
        t1(): Internal.App<F, T1>;
        notify(): void;
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    type Products$P1_<F, T1> = Products$P1<F, T1>;
    interface NonNullFunction <T, R> {
        apply(arg0: T): R;
    }
    type NonNullFunction_<T, R> = ((arg0: T) => R) | NonNullFunction<T, R>;
    class DataResult$Instance extends Internal.Enum<Internal.DataResult$Instance> implements Internal.Applicative<Internal.DataResult$Mu, any> {
        getClass(): Internal.Class<any>;
        compareTo(arg0: Internal.DataResult$Instance_): number;
        describeConstable(): Internal.Optional<Internal.Enum$EnumDesc<Internal.DataResult$Instance>>;
        group<T1_, T2_, T3_, T4_, T5_, T6_, T7_, T8_, T9_, T10_, T11_>(arg0: Internal.App_<Internal.DataResult$Mu_, T1_>, arg1: Internal.App_<Internal.DataResult$Mu_, T2_>, arg2: Internal.App_<Internal.DataResult$Mu_, T3_>, arg3: Internal.App_<Internal.DataResult$Mu_, T4_>, arg4: Internal.App_<Internal.DataResult$Mu_, T5_>, arg5: Internal.App_<Internal.DataResult$Mu_, T6_>, arg6: Internal.App_<Internal.DataResult$Mu_, T7_>, arg7: Internal.App_<Internal.DataResult$Mu_, T8_>, arg8: Internal.App_<Internal.DataResult$Mu_, T9_>, arg9: Internal.App_<Internal.DataResult$Mu_, T10_>, arg10: Internal.App_<Internal.DataResult$Mu_, T11_>): Internal.Products$P11<Internal.DataResult$Mu, T1_, T2_, T3_, T4_, T5_, T6_, T7_, T8_, T9_, T10_, T11_>;
        group<T1_, T2_, T3_, T4_, T5_, T6_, T7_, T8_, T9_, T10_>(arg0: Internal.App_<Internal.DataResult$Mu_, T1_>, arg1: Internal.App_<Internal.DataResult$Mu_, T2_>, arg2: Internal.App_<Internal.DataResult$Mu_, T3_>, arg3: Internal.App_<Internal.DataResult$Mu_, T4_>, arg4: Internal.App_<Internal.DataResult$Mu_, T5_>, arg5: Internal.App_<Internal.DataResult$Mu_, T6_>, arg6: Internal.App_<Internal.DataResult$Mu_, T7_>, arg7: Internal.App_<Internal.DataResult$Mu_, T8_>, arg8: Internal.App_<Internal.DataResult$Mu_, T9_>, arg9: Internal.App_<Internal.DataResult$Mu_, T10_>): Internal.Products$P10<Internal.DataResult$Mu, T1_, T2_, T3_, T4_, T5_, T6_, T7_, T8_, T9_, T10_>;
        group<T1_, T2_, T3_, T4_, T5_, T6_, T7_, T8_, T9_>(arg0: Internal.App_<Internal.DataResult$Mu_, T1_>, arg1: Internal.App_<Internal.DataResult$Mu_, T2_>, arg2: Internal.App_<Internal.DataResult$Mu_, T3_>, arg3: Internal.App_<Internal.DataResult$Mu_, T4_>, arg4: Internal.App_<Internal.DataResult$Mu_, T5_>, arg5: Internal.App_<Internal.DataResult$Mu_, T6_>, arg6: Internal.App_<Internal.DataResult$Mu_, T7_>, arg7: Internal.App_<Internal.DataResult$Mu_, T8_>, arg8: Internal.App_<Internal.DataResult$Mu_, T9_>): Internal.Products$P9<Internal.DataResult$Mu, T1_, T2_, T3_, T4_, T5_, T6_, T7_, T8_, T9_>;
        group<T1_, T2_, T3_, T4_, T5_, T6_, T7_, T8_, T9_, T10_, T11_, T12_, T13_, T14_, T15_, T16_>(arg0: Internal.App_<Internal.DataResult$Mu_, T1_>, arg1: Internal.App_<Internal.DataResult$Mu_, T2_>, arg2: Internal.App_<Internal.DataResult$Mu_, T3_>, arg3: Internal.App_<Internal.DataResult$Mu_, T4_>, arg4: Internal.App_<Internal.DataResult$Mu_, T5_>, arg5: Internal.App_<Internal.DataResult$Mu_, T6_>, arg6: Internal.App_<Internal.DataResult$Mu_, T7_>, arg7: Internal.App_<Internal.DataResult$Mu_, T8_>, arg8: Internal.App_<Internal.DataResult$Mu_, T9_>, arg9: Internal.App_<Internal.DataResult$Mu_, T10_>, arg10: Internal.App_<Internal.DataResult$Mu_, T11_>, arg11: Internal.App_<Internal.DataResult$Mu_, T12_>, arg12: Internal.App_<Internal.DataResult$Mu_, T13_>, arg13: Internal.App_<Internal.DataResult$Mu_, T14_>, arg14: Internal.App_<Internal.DataResult$Mu_, T15_>, arg15: Internal.App_<Internal.DataResult$Mu_, T16_>): Internal.Products$P16<Internal.DataResult$Mu, T1_, T2_, T3_, T4_, T5_, T6_, T7_, T8_, T9_, T10_, T11_, T12_, T13_, T14_, T15_, T16_>;
        group<T1_, T2_, T3_, T4_, T5_, T6_, T7_, T8_, T9_, T10_, T11_, T12_, T13_, T14_, T15_>(arg0: Internal.App_<Internal.DataResult$Mu_, T1_>, arg1: Internal.App_<Internal.DataResult$Mu_, T2_>, arg2: Internal.App_<Internal.DataResult$Mu_, T3_>, arg3: Internal.App_<Internal.DataResult$Mu_, T4_>, arg4: Internal.App_<Internal.DataResult$Mu_, T5_>, arg5: Internal.App_<Internal.DataResult$Mu_, T6_>, arg6: Internal.App_<Internal.DataResult$Mu_, T7_>, arg7: Internal.App_<Internal.DataResult$Mu_, T8_>, arg8: Internal.App_<Internal.DataResult$Mu_, T9_>, arg9: Internal.App_<Internal.DataResult$Mu_, T10_>, arg10: Internal.App_<Internal.DataResult$Mu_, T11_>, arg11: Internal.App_<Internal.DataResult$Mu_, T12_>, arg12: Internal.App_<Internal.DataResult$Mu_, T13_>, arg13: Internal.App_<Internal.DataResult$Mu_, T14_>, arg14: Internal.App_<Internal.DataResult$Mu_, T15_>): Internal.Products$P15<Internal.DataResult$Mu, T1_, T2_, T3_, T4_, T5_, T6_, T7_, T8_, T9_, T10_, T11_, T12_, T13_, T14_, T15_>;
        group<T1_, T2_, T3_, T4_, T5_, T6_, T7_, T8_, T9_, T10_, T11_, T12_, T13_, T14_>(arg0: Internal.App_<Internal.DataResult$Mu_, T1_>, arg1: Internal.App_<Internal.DataResult$Mu_, T2_>, arg2: Internal.App_<Internal.DataResult$Mu_, T3_>, arg3: Internal.App_<Internal.DataResult$Mu_, T4_>, arg4: Internal.App_<Internal.DataResult$Mu_, T5_>, arg5: Internal.App_<Internal.DataResult$Mu_, T6_>, arg6: Internal.App_<Internal.DataResult$Mu_, T7_>, arg7: Internal.App_<Internal.DataResult$Mu_, T8_>, arg8: Internal.App_<Internal.DataResult$Mu_, T9_>, arg9: Internal.App_<Internal.DataResult$Mu_, T10_>, arg10: Internal.App_<Internal.DataResult$Mu_, T11_>, arg11: Internal.App_<Internal.DataResult$Mu_, T12_>, arg12: Internal.App_<Internal.DataResult$Mu_, T13_>, arg13: Internal.App_<Internal.DataResult$Mu_, T14_>): Internal.Products$P14<Internal.DataResult$Mu, T1_, T2_, T3_, T4_, T5_, T6_, T7_, T8_, T9_, T10_, T11_, T12_, T13_, T14_>;
        group<T1_, T2_, T3_, T4_, T5_, T6_, T7_, T8_, T9_, T10_, T11_, T12_, T13_>(arg0: Internal.App_<Internal.DataResult$Mu_, T1_>, arg1: Internal.App_<Internal.DataResult$Mu_, T2_>, arg2: Internal.App_<Internal.DataResult$Mu_, T3_>, arg3: Internal.App_<Internal.DataResult$Mu_, T4_>, arg4: Internal.App_<Internal.DataResult$Mu_, T5_>, arg5: Internal.App_<Internal.DataResult$Mu_, T6_>, arg6: Internal.App_<Internal.DataResult$Mu_, T7_>, arg7: Internal.App_<Internal.DataResult$Mu_, T8_>, arg8: Internal.App_<Internal.DataResult$Mu_, T9_>, arg9: Internal.App_<Internal.DataResult$Mu_, T10_>, arg10: Internal.App_<Internal.DataResult$Mu_, T11_>, arg11: Internal.App_<Internal.DataResult$Mu_, T12_>, arg12: Internal.App_<Internal.DataResult$Mu_, T13_>): Internal.Products$P13<Internal.DataResult$Mu, T1_, T2_, T3_, T4_, T5_, T6_, T7_, T8_, T9_, T10_, T11_, T12_, T13_>;
        group<T1_, T2_, T3_, T4_, T5_, T6_, T7_, T8_, T9_, T10_, T11_, T12_>(arg0: Internal.App_<Internal.DataResult$Mu_, T1_>, arg1: Internal.App_<Internal.DataResult$Mu_, T2_>, arg2: Internal.App_<Internal.DataResult$Mu_, T3_>, arg3: Internal.App_<Internal.DataResult$Mu_, T4_>, arg4: Internal.App_<Internal.DataResult$Mu_, T5_>, arg5: Internal.App_<Internal.DataResult$Mu_, T6_>, arg6: Internal.App_<Internal.DataResult$Mu_, T7_>, arg7: Internal.App_<Internal.DataResult$Mu_, T8_>, arg8: Internal.App_<Internal.DataResult$Mu_, T9_>, arg9: Internal.App_<Internal.DataResult$Mu_, T10_>, arg10: Internal.App_<Internal.DataResult$Mu_, T11_>, arg11: Internal.App_<Internal.DataResult$Mu_, T12_>): Internal.Products$P12<Internal.DataResult$Mu, T1_, T2_, T3_, T4_, T5_, T6_, T7_, T8_, T9_, T10_, T11_, T12_>;
        group<T1_, T2_, T3_>(arg0: Internal.App_<Internal.DataResult$Mu_, T1_>, arg1: Internal.App_<Internal.DataResult$Mu_, T2_>, arg2: Internal.App_<Internal.DataResult$Mu_, T3_>): Internal.Products$P3<Internal.DataResult$Mu, T1_, T2_, T3_>;
        group<T1_, T2_>(arg0: Internal.App_<Internal.DataResult$Mu_, T1_>, arg1: Internal.App_<Internal.DataResult$Mu_, T2_>): Internal.Products$P2<Internal.DataResult$Mu, T1_, T2_>;
        group<T1_>(arg0: Internal.App_<Internal.DataResult$Mu_, T1_>): Internal.Products$P1<Internal.DataResult$Mu, T1_>;
        group<T1_, T2_, T3_, T4_, T5_, T6_, T7_, T8_>(arg0: Internal.App_<Internal.DataResult$Mu_, T1_>, arg1: Internal.App_<Internal.DataResult$Mu_, T2_>, arg2: Internal.App_<Internal.DataResult$Mu_, T3_>, arg3: Internal.App_<Internal.DataResult$Mu_, T4_>, arg4: Internal.App_<Internal.DataResult$Mu_, T5_>, arg5: Internal.App_<Internal.DataResult$Mu_, T6_>, arg6: Internal.App_<Internal.DataResult$Mu_, T7_>, arg7: Internal.App_<Internal.DataResult$Mu_, T8_>): Internal.Products$P8<Internal.DataResult$Mu, T1_, T2_, T3_, T4_, T5_, T6_, T7_, T8_>;
        group<T1_, T2_, T3_, T4_, T5_, T6_, T7_>(arg0: Internal.App_<Internal.DataResult$Mu_, T1_>, arg1: Internal.App_<Internal.DataResult$Mu_, T2_>, arg2: Internal.App_<Internal.DataResult$Mu_, T3_>, arg3: Internal.App_<Internal.DataResult$Mu_, T4_>, arg4: Internal.App_<Internal.DataResult$Mu_, T5_>, arg5: Internal.App_<Internal.DataResult$Mu_, T6_>, arg6: Internal.App_<Internal.DataResult$Mu_, T7_>): Internal.Products$P7<Internal.DataResult$Mu, T1_, T2_, T3_, T4_, T5_, T6_, T7_>;
        group<T1_, T2_, T3_, T4_, T5_, T6_>(arg0: Internal.App_<Internal.DataResult$Mu_, T1_>, arg1: Internal.App_<Internal.DataResult$Mu_, T2_>, arg2: Internal.App_<Internal.DataResult$Mu_, T3_>, arg3: Internal.App_<Internal.DataResult$Mu_, T4_>, arg4: Internal.App_<Internal.DataResult$Mu_, T5_>, arg5: Internal.App_<Internal.DataResult$Mu_, T6_>): Internal.Products$P6<Internal.DataResult$Mu, T1_, T2_, T3_, T4_, T5_, T6_>;
        group<T1_, T2_, T3_, T4_, T5_>(arg0: Internal.App_<Internal.DataResult$Mu_, T1_>, arg1: Internal.App_<Internal.DataResult$Mu_, T2_>, arg2: Internal.App_<Internal.DataResult$Mu_, T3_>, arg3: Internal.App_<Internal.DataResult$Mu_, T4_>, arg4: Internal.App_<Internal.DataResult$Mu_, T5_>): Internal.Products$P5<Internal.DataResult$Mu, T1_, T2_, T3_, T4_, T5_>;
        group<T1_, T2_, T3_, T4_>(arg0: Internal.App_<Internal.DataResult$Mu_, T1_>, arg1: Internal.App_<Internal.DataResult$Mu_, T2_>, arg2: Internal.App_<Internal.DataResult$Mu_, T3_>, arg3: Internal.App_<Internal.DataResult$Mu_, T4_>): Internal.Products$P4<Internal.DataResult$Mu, T1_, T2_, T3_, T4_>;
        ap11<T1_, T2_, T3_, T4_, T5_, T6_, T7_, T8_, T9_, T10_, T11_, R_>(arg0: Internal.App_<Internal.DataResult$Mu_, Internal.Function11_<T1_, T2_, T3_, T4_, T5_, T6_, T7_, T8_, T9_, T10_, T11_, R_>>, arg1: Internal.App_<Internal.DataResult$Mu_, T1_>, arg2: Internal.App_<Internal.DataResult$Mu_, T2_>, arg3: Internal.App_<Internal.DataResult$Mu_, T3_>, arg4: Internal.App_<Internal.DataResult$Mu_, T4_>, arg5: Internal.App_<Internal.DataResult$Mu_, T5_>, arg6: Internal.App_<Internal.DataResult$Mu_, T6_>, arg7: Internal.App_<Internal.DataResult$Mu_, T7_>, arg8: Internal.App_<Internal.DataResult$Mu_, T8_>, arg9: Internal.App_<Internal.DataResult$Mu_, T9_>, arg10: Internal.App_<Internal.DataResult$Mu_, T10_>, arg11: Internal.App_<Internal.DataResult$Mu_, T11_>): Internal.App<Internal.DataResult$Mu, R_>;
        ap10<T1_, T2_, T3_, T4_, T5_, T6_, T7_, T8_, T9_, T10_, R_>(arg0: Internal.App_<Internal.DataResult$Mu_, Internal.Function10_<T1_, T2_, T3_, T4_, T5_, T6_, T7_, T8_, T9_, T10_, R_>>, arg1: Internal.App_<Internal.DataResult$Mu_, T1_>, arg2: Internal.App_<Internal.DataResult$Mu_, T2_>, arg3: Internal.App_<Internal.DataResult$Mu_, T3_>, arg4: Internal.App_<Internal.DataResult$Mu_, T4_>, arg5: Internal.App_<Internal.DataResult$Mu_, T5_>, arg6: Internal.App_<Internal.DataResult$Mu_, T6_>, arg7: Internal.App_<Internal.DataResult$Mu_, T7_>, arg8: Internal.App_<Internal.DataResult$Mu_, T8_>, arg9: Internal.App_<Internal.DataResult$Mu_, T9_>, arg10: Internal.App_<Internal.DataResult$Mu_, T10_>): Internal.App<Internal.DataResult$Mu, R_>;
        lift2<A_, B_, R_>(arg0: Internal.App_<Internal.DataResult$Mu_, Internal.BiFunction_<A_, B_, R_>>): Internal.BiFunction<Internal.App<Internal.DataResult$Mu, A_>, Internal.App<Internal.DataResult$Mu, B_>, Internal.App<Internal.DataResult$Mu, R_>>;
        lift1<A_, R_>(arg0: Internal.App_<Internal.DataResult$Mu_, java_.util.function_.Function_<A_, R_>>): java_.util.function_.Function<Internal.App<Internal.DataResult$Mu, A_>, Internal.App<Internal.DataResult$Mu, R_>>;
        lift6<T1_, T2_, T3_, T4_, T5_, T6_, R_>(arg0: Internal.App_<Internal.DataResult$Mu_, Internal.Function6_<T1_, T2_, T3_, T4_, T5_, T6_, R_>>): Internal.Function6<Internal.App<Internal.DataResult$Mu, T1_>, Internal.App<Internal.DataResult$Mu, T2_>, Internal.App<Internal.DataResult$Mu, T3_>, Internal.App<Internal.DataResult$Mu, T4_>, Internal.App<Internal.DataResult$Mu, T5_>, Internal.App<Internal.DataResult$Mu, T6_>, Internal.App<Internal.DataResult$Mu, R_>>;
        lift5<T1_, T2_, T3_, T4_, T5_, R_>(arg0: Internal.App_<Internal.DataResult$Mu_, Internal.Function5_<T1_, T2_, T3_, T4_, T5_, R_>>): Internal.Function5<Internal.App<Internal.DataResult$Mu, T1_>, Internal.App<Internal.DataResult$Mu, T2_>, Internal.App<Internal.DataResult$Mu, T3_>, Internal.App<Internal.DataResult$Mu, T4_>, Internal.App<Internal.DataResult$Mu, T5_>, Internal.App<Internal.DataResult$Mu, R_>>;
        lift4<T1_, T2_, T3_, T4_, R_>(arg0: Internal.App_<Internal.DataResult$Mu_, Internal.Function4_<T1_, T2_, T3_, T4_, R_>>): Internal.Function4<Internal.App<Internal.DataResult$Mu, T1_>, Internal.App<Internal.DataResult$Mu, T2_>, Internal.App<Internal.DataResult$Mu, T3_>, Internal.App<Internal.DataResult$Mu, T4_>, Internal.App<Internal.DataResult$Mu, R_>>;
        lift3<T1_, T2_, T3_, R_>(arg0: Internal.App_<Internal.DataResult$Mu_, Internal.Function3_<T1_, T2_, T3_, R_>>): Internal.Function3<Internal.App<Internal.DataResult$Mu, T1_>, Internal.App<Internal.DataResult$Mu, T2_>, Internal.App<Internal.DataResult$Mu, T3_>, Internal.App<Internal.DataResult$Mu, R_>>;
        lift9<T1_, T2_, T3_, T4_, T5_, T6_, T7_, T8_, T9_, R_>(arg0: Internal.App_<Internal.DataResult$Mu_, Internal.Function9_<T1_, T2_, T3_, T4_, T5_, T6_, T7_, T8_, T9_, R_>>): Internal.Function9<Internal.App<Internal.DataResult$Mu, T1_>, Internal.App<Internal.DataResult$Mu, T2_>, Internal.App<Internal.DataResult$Mu, T3_>, Internal.App<Internal.DataResult$Mu, T4_>, Internal.App<Internal.DataResult$Mu, T5_>, Internal.App<Internal.DataResult$Mu, T6_>, Internal.App<Internal.DataResult$Mu, T7_>, Internal.App<Internal.DataResult$Mu, T8_>, Internal.App<Internal.DataResult$Mu, T9_>, Internal.App<Internal.DataResult$Mu, R_>>;
        lift8<T1_, T2_, T3_, T4_, T5_, T6_, T7_, T8_, R_>(arg0: Internal.App_<Internal.DataResult$Mu_, Internal.Function8_<T1_, T2_, T3_, T4_, T5_, T6_, T7_, T8_, R_>>): Internal.Function8<Internal.App<Internal.DataResult$Mu, T1_>, Internal.App<Internal.DataResult$Mu, T2_>, Internal.App<Internal.DataResult$Mu, T3_>, Internal.App<Internal.DataResult$Mu, T4_>, Internal.App<Internal.DataResult$Mu, T5_>, Internal.App<Internal.DataResult$Mu, T6_>, Internal.App<Internal.DataResult$Mu, T7_>, Internal.App<Internal.DataResult$Mu, T8_>, Internal.App<Internal.DataResult$Mu, R_>>;
        lift7<T1_, T2_, T3_, T4_, T5_, T6_, T7_, R_>(arg0: Internal.App_<Internal.DataResult$Mu_, Internal.Function7_<T1_, T2_, T3_, T4_, T5_, T6_, T7_, R_>>): Internal.Function7<Internal.App<Internal.DataResult$Mu, T1_>, Internal.App<Internal.DataResult$Mu, T2_>, Internal.App<Internal.DataResult$Mu, T3_>, Internal.App<Internal.DataResult$Mu, T4_>, Internal.App<Internal.DataResult$Mu, T5_>, Internal.App<Internal.DataResult$Mu, T6_>, Internal.App<Internal.DataResult$Mu, T7_>, Internal.App<Internal.DataResult$Mu, R_>>;
        ap<A_, R_>(arg0: Internal.App_<Internal.DataResult$Mu_, java_.util.function_.Function_<A_, R_>>, arg1: Internal.App_<Internal.DataResult$Mu_, A_>): Internal.App<Internal.DataResult$Mu, R_>;
        ap<A_, R_>(arg0: java_.util.function_.Function_<A_, R_>, arg1: Internal.App_<Internal.DataResult$Mu_, A_>): Internal.App<Internal.DataResult$Mu, R_>;
        name(): string;
        ap16<T1_, T2_, T3_, T4_, T5_, T6_, T7_, T8_, T9_, T10_, T11_, T12_, T13_, T14_, T15_, T16_, R_>(arg0: Internal.App_<Internal.DataResult$Mu_, Internal.Function16_<T1_, T2_, T3_, T4_, T5_, T6_, T7_, T8_, T9_, T10_, T11_, T12_, T13_, T14_, T15_, T16_, R_>>, arg1: Internal.App_<Internal.DataResult$Mu_, T1_>, arg2: Internal.App_<Internal.DataResult$Mu_, T2_>, arg3: Internal.App_<Internal.DataResult$Mu_, T3_>, arg4: Internal.App_<Internal.DataResult$Mu_, T4_>, arg5: Internal.App_<Internal.DataResult$Mu_, T5_>, arg6: Internal.App_<Internal.DataResult$Mu_, T6_>, arg7: Internal.App_<Internal.DataResult$Mu_, T7_>, arg8: Internal.App_<Internal.DataResult$Mu_, T8_>, arg9: Internal.App_<Internal.DataResult$Mu_, T9_>, arg10: Internal.App_<Internal.DataResult$Mu_, T10_>, arg11: Internal.App_<Internal.DataResult$Mu_, T11_>, arg12: Internal.App_<Internal.DataResult$Mu_, T12_>, arg13: Internal.App_<Internal.DataResult$Mu_, T13_>, arg14: Internal.App_<Internal.DataResult$Mu_, T14_>, arg15: Internal.App_<Internal.DataResult$Mu_, T15_>, arg16: Internal.App_<Internal.DataResult$Mu_, T16_>): Internal.App<Internal.DataResult$Mu, R_>;
        ap13<T1_, T2_, T3_, T4_, T5_, T6_, T7_, T8_, T9_, T10_, T11_, T12_, T13_, R_>(arg0: Internal.App_<Internal.DataResult$Mu_, Internal.Function13_<T1_, T2_, T3_, T4_, T5_, T6_, T7_, T8_, T9_, T10_, T11_, T12_, T13_, R_>>, arg1: Internal.App_<Internal.DataResult$Mu_, T1_>, arg2: Internal.App_<Internal.DataResult$Mu_, T2_>, arg3: Internal.App_<Internal.DataResult$Mu_, T3_>, arg4: Internal.App_<Internal.DataResult$Mu_, T4_>, arg5: Internal.App_<Internal.DataResult$Mu_, T5_>, arg6: Internal.App_<Internal.DataResult$Mu_, T6_>, arg7: Internal.App_<Internal.DataResult$Mu_, T7_>, arg8: Internal.App_<Internal.DataResult$Mu_, T8_>, arg9: Internal.App_<Internal.DataResult$Mu_, T9_>, arg10: Internal.App_<Internal.DataResult$Mu_, T10_>, arg11: Internal.App_<Internal.DataResult$Mu_, T11_>, arg12: Internal.App_<Internal.DataResult$Mu_, T12_>, arg13: Internal.App_<Internal.DataResult$Mu_, T13_>): Internal.App<Internal.DataResult$Mu, R_>;
        ap12<T1_, T2_, T3_, T4_, T5_, T6_, T7_, T8_, T9_, T10_, T11_, T12_, R_>(arg0: Internal.App_<Internal.DataResult$Mu_, Internal.Function12_<T1_, T2_, T3_, T4_, T5_, T6_, T7_, T8_, T9_, T10_, T11_, T12_, R_>>, arg1: Internal.App_<Internal.DataResult$Mu_, T1_>, arg2: Internal.App_<Internal.DataResult$Mu_, T2_>, arg3: Internal.App_<Internal.DataResult$Mu_, T3_>, arg4: Internal.App_<Internal.DataResult$Mu_, T4_>, arg5: Internal.App_<Internal.DataResult$Mu_, T5_>, arg6: Internal.App_<Internal.DataResult$Mu_, T6_>, arg7: Internal.App_<Internal.DataResult$Mu_, T7_>, arg8: Internal.App_<Internal.DataResult$Mu_, T8_>, arg9: Internal.App_<Internal.DataResult$Mu_, T9_>, arg10: Internal.App_<Internal.DataResult$Mu_, T10_>, arg11: Internal.App_<Internal.DataResult$Mu_, T11_>, arg12: Internal.App_<Internal.DataResult$Mu_, T12_>): Internal.App<Internal.DataResult$Mu, R_>;
        ap15<T1_, T2_, T3_, T4_, T5_, T6_, T7_, T8_, T9_, T10_, T11_, T12_, T13_, T14_, T15_, R_>(arg0: Internal.App_<Internal.DataResult$Mu_, Internal.Function15_<T1_, T2_, T3_, T4_, T5_, T6_, T7_, T8_, T9_, T10_, T11_, T12_, T13_, T14_, T15_, R_>>, arg1: Internal.App_<Internal.DataResult$Mu_, T1_>, arg2: Internal.App_<Internal.DataResult$Mu_, T2_>, arg3: Internal.App_<Internal.DataResult$Mu_, T3_>, arg4: Internal.App_<Internal.DataResult$Mu_, T4_>, arg5: Internal.App_<Internal.DataResult$Mu_, T5_>, arg6: Internal.App_<Internal.DataResult$Mu_, T6_>, arg7: Internal.App_<Internal.DataResult$Mu_, T7_>, arg8: Internal.App_<Internal.DataResult$Mu_, T8_>, arg9: Internal.App_<Internal.DataResult$Mu_, T9_>, arg10: Internal.App_<Internal.DataResult$Mu_, T10_>, arg11: Internal.App_<Internal.DataResult$Mu_, T11_>, arg12: Internal.App_<Internal.DataResult$Mu_, T12_>, arg13: Internal.App_<Internal.DataResult$Mu_, T13_>, arg14: Internal.App_<Internal.DataResult$Mu_, T14_>, arg15: Internal.App_<Internal.DataResult$Mu_, T15_>): Internal.App<Internal.DataResult$Mu, R_>;
        ap14<T1_, T2_, T3_, T4_, T5_, T6_, T7_, T8_, T9_, T10_, T11_, T12_, T13_, T14_, R_>(arg0: Internal.App_<Internal.DataResult$Mu_, Internal.Function14_<T1_, T2_, T3_, T4_, T5_, T6_, T7_, T8_, T9_, T10_, T11_, T12_, T13_, T14_, R_>>, arg1: Internal.App_<Internal.DataResult$Mu_, T1_>, arg2: Internal.App_<Internal.DataResult$Mu_, T2_>, arg3: Internal.App_<Internal.DataResult$Mu_, T3_>, arg4: Internal.App_<Internal.DataResult$Mu_, T4_>, arg5: Internal.App_<Internal.DataResult$Mu_, T5_>, arg6: Internal.App_<Internal.DataResult$Mu_, T6_>, arg7: Internal.App_<Internal.DataResult$Mu_, T7_>, arg8: Internal.App_<Internal.DataResult$Mu_, T8_>, arg9: Internal.App_<Internal.DataResult$Mu_, T9_>, arg10: Internal.App_<Internal.DataResult$Mu_, T10_>, arg11: Internal.App_<Internal.DataResult$Mu_, T11_>, arg12: Internal.App_<Internal.DataResult$Mu_, T12_>, arg13: Internal.App_<Internal.DataResult$Mu_, T13_>, arg14: Internal.App_<Internal.DataResult$Mu_, T14_>): Internal.App<Internal.DataResult$Mu, R_>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        notifyAll(): void;
        static values(): Internal.DataResult$Instance[];
        notify(): void;
        point<A_>(arg0: A_): Internal.App<Internal.DataResult$Mu, A_>;
        getDeclaringClass(): Internal.Class<Internal.DataResult$Instance>;
        hashCode(): number;
        map<T_, R_>(arg0: java_.util.function_.Function_<T_, R_>, arg1: Internal.App_<Internal.DataResult$Mu_, T_>): Internal.App<Internal.DataResult$Mu, R_>;
        apply2<A_, B_, R_>(arg0: Internal.BiFunction_<A_, B_, R_>, arg1: Internal.App_<Internal.DataResult$Mu_, A_>, arg2: Internal.App_<Internal.DataResult$Mu_, B_>): Internal.App<Internal.DataResult$Mu, R_>;
        apply3<T1_, T2_, T3_, R_>(arg0: Internal.Function3_<T1_, T2_, T3_, R_>, arg1: Internal.App_<Internal.DataResult$Mu_, T1_>, arg2: Internal.App_<Internal.DataResult$Mu_, T2_>, arg3: Internal.App_<Internal.DataResult$Mu_, T3_>): Internal.App<Internal.DataResult$Mu, R_>;
        apply4<T1_, T2_, T3_, T4_, R_>(arg0: Internal.Function4_<T1_, T2_, T3_, T4_, R_>, arg1: Internal.App_<Internal.DataResult$Mu_, T1_>, arg2: Internal.App_<Internal.DataResult$Mu_, T2_>, arg3: Internal.App_<Internal.DataResult$Mu_, T3_>, arg4: Internal.App_<Internal.DataResult$Mu_, T4_>): Internal.App<Internal.DataResult$Mu, R_>;
        ap2<A_, B_, R_>(arg0: Internal.App_<Internal.DataResult$Mu_, Internal.BiFunction_<A_, B_, R_>>, arg1: Internal.App_<Internal.DataResult$Mu_, A_>, arg2: Internal.App_<Internal.DataResult$Mu_, B_>): Internal.App<Internal.DataResult$Mu, R_>;
        apply5<T1_, T2_, T3_, T4_, T5_, R_>(arg0: Internal.Function5_<T1_, T2_, T3_, T4_, T5_, R_>, arg1: Internal.App_<Internal.DataResult$Mu_, T1_>, arg2: Internal.App_<Internal.DataResult$Mu_, T2_>, arg3: Internal.App_<Internal.DataResult$Mu_, T3_>, arg4: Internal.App_<Internal.DataResult$Mu_, T4_>, arg5: Internal.App_<Internal.DataResult$Mu_, T5_>): Internal.App<Internal.DataResult$Mu, R_>;
        ap4<T1_, T2_, T3_, T4_, R_>(arg0: Internal.App_<Internal.DataResult$Mu_, Internal.Function4_<T1_, T2_, T3_, T4_, R_>>, arg1: Internal.App_<Internal.DataResult$Mu_, T1_>, arg2: Internal.App_<Internal.DataResult$Mu_, T2_>, arg3: Internal.App_<Internal.DataResult$Mu_, T3_>, arg4: Internal.App_<Internal.DataResult$Mu_, T4_>): Internal.App<Internal.DataResult$Mu, R_>;
        ap3<T1_, T2_, T3_, R_>(arg0: Internal.App_<Internal.DataResult$Mu_, Internal.Function3_<T1_, T2_, T3_, R_>>, arg1: Internal.App_<Internal.DataResult$Mu_, T1_>, arg2: Internal.App_<Internal.DataResult$Mu_, T2_>, arg3: Internal.App_<Internal.DataResult$Mu_, T3_>): Internal.App<Internal.DataResult$Mu, R_>;
        ap6<T1_, T2_, T3_, T4_, T5_, T6_, R_>(arg0: Internal.App_<Internal.DataResult$Mu_, Internal.Function6_<T1_, T2_, T3_, T4_, T5_, T6_, R_>>, arg1: Internal.App_<Internal.DataResult$Mu_, T1_>, arg2: Internal.App_<Internal.DataResult$Mu_, T2_>, arg3: Internal.App_<Internal.DataResult$Mu_, T3_>, arg4: Internal.App_<Internal.DataResult$Mu_, T4_>, arg5: Internal.App_<Internal.DataResult$Mu_, T5_>, arg6: Internal.App_<Internal.DataResult$Mu_, T6_>): Internal.App<Internal.DataResult$Mu, R_>;
        static valueOf(arg0: string): Internal.DataResult$Instance;
        static valueOf<T_>(arg0: Internal.Class_<T_>, arg1: string): T_;
        ap5<T1_, T2_, T3_, T4_, T5_, R_>(arg0: Internal.App_<Internal.DataResult$Mu_, Internal.Function5_<T1_, T2_, T3_, T4_, T5_, R_>>, arg1: Internal.App_<Internal.DataResult$Mu_, T1_>, arg2: Internal.App_<Internal.DataResult$Mu_, T2_>, arg3: Internal.App_<Internal.DataResult$Mu_, T3_>, arg4: Internal.App_<Internal.DataResult$Mu_, T4_>, arg5: Internal.App_<Internal.DataResult$Mu_, T5_>): Internal.App<Internal.DataResult$Mu, R_>;
        ap8<T1_, T2_, T3_, T4_, T5_, T6_, T7_, T8_, R_>(arg0: Internal.App_<Internal.DataResult$Mu_, Internal.Function8_<T1_, T2_, T3_, T4_, T5_, T6_, T7_, T8_, R_>>, arg1: Internal.App_<Internal.DataResult$Mu_, T1_>, arg2: Internal.App_<Internal.DataResult$Mu_, T2_>, arg3: Internal.App_<Internal.DataResult$Mu_, T3_>, arg4: Internal.App_<Internal.DataResult$Mu_, T4_>, arg5: Internal.App_<Internal.DataResult$Mu_, T5_>, arg6: Internal.App_<Internal.DataResult$Mu_, T6_>, arg7: Internal.App_<Internal.DataResult$Mu_, T7_>, arg8: Internal.App_<Internal.DataResult$Mu_, T8_>): Internal.App<Internal.DataResult$Mu, R_>;
        ap7<T1_, T2_, T3_, T4_, T5_, T6_, T7_, R_>(arg0: Internal.App_<Internal.DataResult$Mu_, Internal.Function7_<T1_, T2_, T3_, T4_, T5_, T6_, T7_, R_>>, arg1: Internal.App_<Internal.DataResult$Mu_, T1_>, arg2: Internal.App_<Internal.DataResult$Mu_, T2_>, arg3: Internal.App_<Internal.DataResult$Mu_, T3_>, arg4: Internal.App_<Internal.DataResult$Mu_, T4_>, arg5: Internal.App_<Internal.DataResult$Mu_, T5_>, arg6: Internal.App_<Internal.DataResult$Mu_, T6_>, arg7: Internal.App_<Internal.DataResult$Mu_, T7_>): Internal.App<Internal.DataResult$Mu, R_>;
        ap9<T1_, T2_, T3_, T4_, T5_, T6_, T7_, T8_, T9_, R_>(arg0: Internal.App_<Internal.DataResult$Mu_, Internal.Function9_<T1_, T2_, T3_, T4_, T5_, T6_, T7_, T8_, T9_, R_>>, arg1: Internal.App_<Internal.DataResult$Mu_, T1_>, arg2: Internal.App_<Internal.DataResult$Mu_, T2_>, arg3: Internal.App_<Internal.DataResult$Mu_, T3_>, arg4: Internal.App_<Internal.DataResult$Mu_, T4_>, arg5: Internal.App_<Internal.DataResult$Mu_, T5_>, arg6: Internal.App_<Internal.DataResult$Mu_, T6_>, arg7: Internal.App_<Internal.DataResult$Mu_, T7_>, arg8: Internal.App_<Internal.DataResult$Mu_, T8_>, arg9: Internal.App_<Internal.DataResult$Mu_, T9_>): Internal.App<Internal.DataResult$Mu, R_>;
        apply6<T1_, T2_, T3_, T4_, T5_, T6_, R_>(arg0: Internal.Function6_<T1_, T2_, T3_, T4_, T5_, T6_, R_>, arg1: Internal.App_<Internal.DataResult$Mu_, T1_>, arg2: Internal.App_<Internal.DataResult$Mu_, T2_>, arg3: Internal.App_<Internal.DataResult$Mu_, T3_>, arg4: Internal.App_<Internal.DataResult$Mu_, T4_>, arg5: Internal.App_<Internal.DataResult$Mu_, T5_>, arg6: Internal.App_<Internal.DataResult$Mu_, T6_>): Internal.App<Internal.DataResult$Mu, R_>;
        apply7<T1_, T2_, T3_, T4_, T5_, T6_, T7_, R_>(arg0: Internal.Function7_<T1_, T2_, T3_, T4_, T5_, T6_, T7_, R_>, arg1: Internal.App_<Internal.DataResult$Mu_, T1_>, arg2: Internal.App_<Internal.DataResult$Mu_, T2_>, arg3: Internal.App_<Internal.DataResult$Mu_, T3_>, arg4: Internal.App_<Internal.DataResult$Mu_, T4_>, arg5: Internal.App_<Internal.DataResult$Mu_, T5_>, arg6: Internal.App_<Internal.DataResult$Mu_, T6_>, arg7: Internal.App_<Internal.DataResult$Mu_, T7_>): Internal.App<Internal.DataResult$Mu, R_>;
        apply8<T1_, T2_, T3_, T4_, T5_, T6_, T7_, T8_, R_>(arg0: Internal.Function8_<T1_, T2_, T3_, T4_, T5_, T6_, T7_, T8_, R_>, arg1: Internal.App_<Internal.DataResult$Mu_, T1_>, arg2: Internal.App_<Internal.DataResult$Mu_, T2_>, arg3: Internal.App_<Internal.DataResult$Mu_, T3_>, arg4: Internal.App_<Internal.DataResult$Mu_, T4_>, arg5: Internal.App_<Internal.DataResult$Mu_, T5_>, arg6: Internal.App_<Internal.DataResult$Mu_, T6_>, arg7: Internal.App_<Internal.DataResult$Mu_, T7_>, arg8: Internal.App_<Internal.DataResult$Mu_, T8_>): Internal.App<Internal.DataResult$Mu, R_>;
        apply9<T1_, T2_, T3_, T4_, T5_, T6_, T7_, T8_, T9_, R_>(arg0: Internal.Function9_<T1_, T2_, T3_, T4_, T5_, T6_, T7_, T8_, T9_, R_>, arg1: Internal.App_<Internal.DataResult$Mu_, T1_>, arg2: Internal.App_<Internal.DataResult$Mu_, T2_>, arg3: Internal.App_<Internal.DataResult$Mu_, T3_>, arg4: Internal.App_<Internal.DataResult$Mu_, T4_>, arg5: Internal.App_<Internal.DataResult$Mu_, T5_>, arg6: Internal.App_<Internal.DataResult$Mu_, T6_>, arg7: Internal.App_<Internal.DataResult$Mu_, T7_>, arg8: Internal.App_<Internal.DataResult$Mu_, T8_>, arg9: Internal.App_<Internal.DataResult$Mu_, T9_>): Internal.App<Internal.DataResult$Mu, R_>;
        equals(arg0: any): boolean;
        toString(): string;
        ordinal(): number;
        static readonly INSTANCE : Internal.DataResult$Instance;
        get class(): Internal.Class<any>;
        get declaringClass(): Internal.Class<Internal.DataResult$Instance>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    type DataResult$Instance_ = "instance" | DataResult$Instance;
    interface SecondaryLoop {
        exit(): boolean;
        enter(): boolean;
    }
    type SecondaryLoop_ = SecondaryLoop;
    interface CompletionHandler <V, A> {
        failed(arg0: Internal.Throwable_, arg1: A): void;
        completed(arg0: V, arg1: A): void;
    }
    type CompletionHandler_<V, A> = CompletionHandler<V, A>;
    interface EntityTargetKJS {
        getNameKJS(): string;
    }
    type EntityTargetKJS_ = EntityTargetKJS;
    interface PrimitiveIterator$OfInt extends Internal.PrimitiveIterator<number, java_.util.function_.IntConsumer> {
        next(): number;
        hasNext(): boolean;
        nextInt(): number;
        forEachRemaining(arg0: java_.util.function_.IntConsumer_): void;
        forEachRemaining(arg0: Internal.Consumer_<number>): void;
        remove(): void;
    }
    type PrimitiveIterator$OfInt_ = PrimitiveIterator$OfInt;
    class ChannelMetadata {
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        hasDisconnect(): boolean;
        hashCode(): number;
        notifyAll(): void;
        equals(arg0: any): boolean;
        toString(): string;
        defaultMaxMessagesPerRead(): number;
        notify(): void;
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    type ChannelMetadata_ = ChannelMetadata;
    interface ImageProducer {
        isConsumer(arg0: Internal.ImageConsumer_): boolean;
        addConsumer(arg0: Internal.ImageConsumer_): void;
        requestTopDownLeftRightResend(arg0: Internal.ImageConsumer_): void;
        removeConsumer(arg0: Internal.ImageConsumer_): void;
        startProduction(arg0: Internal.ImageConsumer_): void;
    }
    type ImageProducer_ = ImageProducer;
    abstract class AbstractMap <K, V> implements Internal.Map<K, V> {
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        getOrDefault(arg0: any, arg1: V): V;
        computeIfAbsent(arg0: K, arg1: java_.util.function_.Function_<K, V>): V;
        notifyAll(): void;
        values(): Internal.Collection<V>;
        replace(arg0: K, arg1: V): V;
        replace(arg0: K, arg1: V, arg2: V): boolean;
        replaceAll(arg0: Internal.BiFunction_<K, V, V>): void;
        notify(): void;
        containsValue(arg0: any): boolean;
        put(arg0: K, arg1: V): V;
        remove(arg0: any): V;
        remove(arg0: any, arg1: any): boolean;
        compute(arg0: K, arg1: Internal.BiFunction_<K, V, V>): V;
        hashCode(): number;
        merge(arg0: K, arg1: V, arg2: Internal.BiFunction_<V, V, V>): V;
        putAll(arg0: Internal.Map_<K, V>): void;
        get(arg0: any): V;
        keySet(): Internal.Set<K>;
        entrySet(): Internal.Set<Internal.Map$Entry<K, V>>;
        forEach(arg0: Internal.BiConsumer_<K, V>): void;
        containsKey(arg0: any): boolean;
        isEmpty(): boolean;
        clear(): void;
        computeIfPresent(arg0: K, arg1: Internal.BiFunction_<K, V, V>): V;
        size(): number;
        equals(arg0: any): boolean;
        toString(): string;
        putIfAbsent(arg0: K, arg1: V): V;
        get class(): Internal.Class<any>;
        get empty(): boolean;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    type AbstractMap_<K, V> = AbstractMap<K, V>;
    class IngredientStackJS implements Internal.IngredientJS {
        anyStackMatches(ingredient: Internal.IngredientJS_): boolean;
        getItemIds(): Internal.Set<string>;
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        getStacks(): Internal.Set<Internal.ItemStackJS>;
        getVanillaItems(): Internal.Set<Internal.Item>;
        notifyAll(): void;
        isInvalidRecipeIngredient(): boolean;
        notify(): void;
        not(): Internal.IngredientJS;
        hashCode(): number;
        getFirst(): Internal.ItemStackJS;
        static stackOf(in_: Internal.IngredientJS_): Internal.IngredientStackJS;
        copy(): Internal.IngredientJS;
        getCount(): number;
        testVanillaItem(item: Internal.Item_): boolean;
        test(stack: Internal.ItemStackJS_): boolean;
        isEmpty(): boolean;
        asIngredientStack(): Internal.IngredientStackJS;
        getVanillaPredicate(): Internal.Predicate<Internal.ItemStack>;
        filter(filter: Internal.IngredientJS_): Internal.IngredientJS;
        createVanillaIngredient(): Internal.Ingredient;
        toJson(): Internal.JsonElement;
        withCount(count: number): Internal.IngredientJS;
        getIngredient(): Internal.IngredientJS;
        unwrapStackIngredient(): Internal.List<Internal.IngredientJS>;
        equals(arg0: any): boolean;
        testVanilla(stack: Internal.ItemStack_): boolean;
        x(c: number): Internal.IngredientJS;
        toString(): string;
        ingredientKey : string;
        ingredient : ((arg0: Internal.ItemStackJS) => boolean);
        countKey : string;
        get invalidRecipeIngredient(): boolean;
        get stacks(): Internal.Set<Internal.ItemStackJS>;
        get itemIds(): Internal.Set<string>;
        get count(): number;
        get class(): Internal.Class<any>;
        get vanillaItems(): Internal.Set<Internal.Item>;
        get first(): Internal.ItemStackJS;
        get empty(): boolean;
        get vanillaPredicate(): Internal.Predicate<Internal.ItemStack>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    type IngredientStackJS_ = IngredientStackJS;
    class TaskType extends Internal.RegistryEntry<Internal.TaskType> {
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        notifyAll(): void;
        getRegistryName(): ResourceLocation;
        setRegistryName(name: ResourceLocation_): Internal.TaskType;
        setGuiProvider(p: Internal.TaskType$GuiProvider_): Internal.TaskType;
        setDisplayName(name: Internal.Component_): Internal.TaskType;
        getGuiProvider(): Internal.TaskType$GuiProvider;
        notify(): void;
        getIcon(): Internal.Icon;
        getDisplayName(): Internal.Component;
        hashCode(): number;
        equals(arg0: any): boolean;
        getRegistryType(): Internal.Class<Internal.TaskType>;
        toString(): string;
        getTypeForNBT(): string;
        static createTask(quest: Internal.Quest_, id: string): Internal.Task;
        intId : number;
        readonly provider : ((arg0: Internal.Quest) => Internal.Task);
        readonly id : ResourceLocation;
        get registryType(): Internal.Class<Internal.TaskType>;
        get displayName(): Internal.Component;
        get guiProvider(): Internal.TaskType$GuiProvider;
        get icon(): Internal.Icon;
        get registryName(): ResourceLocation;
        get typeForNBT(): string;
        get class(): Internal.Class<any>;
        set displayName(name: Internal.Component_);
        set guiProvider(p: Internal.TaskType$GuiProvider_);
        set registryName(name: ResourceLocation_);
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    type TaskType_ = TaskType;
    interface IContentSerializer <T> {
        toJson(arg0: T): Internal.JsonElement;
        fromNetworkContent(arg0: Internal.FriendlyByteBuf_): Internal.Content;
        of(arg0: any): T;
        fromJson(arg0: Internal.JsonElement_): T;
        toJsonContent(arg0: Internal.Content_): Internal.JsonElement;
        toNetworkContent(arg0: Internal.FriendlyByteBuf_, arg1: Internal.Content_): void;
        toNetwork(arg0: Internal.FriendlyByteBuf_, arg1: T): void;
        fromNetwork(arg0: Internal.FriendlyByteBuf_): T;
        fromJsonContent(arg0: Internal.JsonElement_): Internal.Content;
    }
    type IContentSerializer_<T> = IContentSerializer<T>;
    interface JsonDeserializationContext {
        deserialize<T>(arg0: Internal.JsonElement_, arg1: java_.lang.reflect.Type_): T;
    }
    type JsonDeserializationContext_ = JsonDeserializationContext;
    abstract class Panel extends dev.ftb.mods.ftblibrary.ui.Widget {
        static isMouseButtonDown(button: Internal.MouseButton_): boolean;
        closeGui(openPrevScreen: boolean): void;
        closeGui(): void;
        getClass(): Internal.Class<any>;
        setY(v: number): void;
        collidesWith(x: number, y: number, w: number, h: number): boolean;
        setX(v: number): void;
        shouldDraw(): boolean;
        acceptGhostIngredient(ingredient: any): void;
        getContentHeight(): number;
        isGhostIngredientTarget(ingredient: any): boolean;
        run(): void;
        isDefaultScrollVertical(): boolean;
        align(layout: Internal.WidgetLayout_): number;
        getGui(): Internal.BaseScreen;
        mousePressed(button: Internal.MouseButton_): boolean;
        setPos(x: number, y: number): void;
        getTitle(): Internal.Component;
        static getClipboardString(): string;
        drawBackground(matrixStack: Internal.PoseStack_, theme: Internal.Theme_, x: number, y: number, w: number, h: number): void;
        setOffset(flag: boolean): void;
        static isCtrlKeyDown(): boolean;
        drawOffsetBackground(matrixStack: Internal.PoseStack_, theme: Internal.Theme_, x: number, y: number, w: number, h: number): void;
        updateMouseOver(mouseX: number, mouseY: number): void;
        getScrollStep(): number;
        getScreen(): Internal.Window;
        getMouseY(): number;
        add(widget: dev.ftb.mods.ftblibrary.ui.Widget_): void;
        isMouseOver(): boolean;
        onClosed(): void;
        getMouseX(): number;
        keyPressed(key: dev.ftb.mods.ftblibrary.ui.input.Key_): boolean;
        getWidget(index: number): dev.ftb.mods.ftblibrary.ui.Widget;
        openGui(): void;
        setOnlyInteractWithWidgetsInside(value: boolean): void;
        setPosAndSize(x: number, y: number, w: number, h: number): dev.ftb.mods.ftblibrary.ui.Widget;
        setOnlyRenderWidgetsInside(value: boolean): void;
        tick(): void;
        setHeight(v: number): void;
        addMouseOverText(list: Internal.TooltipList_): void;
        playClickSound(): void;
        handleClick(click: string): boolean;
        handleClick(scheme: string, path: string): boolean;
        isEnabled(): boolean;
        refreshWidgets(): void;
        isOffset(): boolean;
        alignWidgets(): void;
        charTyped(c: string, modifiers: Internal.KeyModifiers_): boolean;
        mouseDoubleClicked(button: Internal.MouseButton_): boolean;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        mouseScrolled(scroll: number): boolean;
        drawWidget(matrixStack: Internal.PoseStack_, theme: Internal.Theme_, widget: dev.ftb.mods.ftblibrary.ui.Widget_, index: number, x: number, y: number, w: number, h: number): void;
        notifyAll(): void;
        shouldAddMouseOverText(): boolean;
        openAfter(runnable: Internal.Runnable_): Internal.Runnable;
        closeContextMenu(): void;
        notify(): void;
        isMouseOverAnyWidget(): boolean;
        mouseReleased(button: Internal.MouseButton_): void;
        getScrollX(): number;
        getScrollY(): number;
        getContentWidth(): number;
        setSize(w: number, h: number): void;
        hashCode(): number;
        getPartialTicks(): number;
        openGuiLater(): void;
        static isKeyDown(key: number): boolean;
        clearWidgets(): void;
        keyReleased(key: dev.ftb.mods.ftblibrary.ui.input.Key_): void;
        static setClipboardString(string: string): void;
        static isShiftKeyDown(): boolean;
        getCursor(): Internal.CursorType;
        setScrollStep(s: number): void;
        getWidgetType(): Internal.WidgetType;
        movePanelScroll(dx: number, dy: number): boolean;
        draw(matrixStack: Internal.PoseStack_, theme: Internal.Theme_, x: number, y: number, w: number, h: number): void;
        checkMouseOver(mouseX: number, mouseY: number): boolean;
        setWidth(v: number): void;
        getOnlyRenderWidgetsInside(): boolean;
        getOnlyInteractWithWidgetsInside(): boolean;
        addWidgets(): void;
        openContextMenu(panel: Internal.Panel_): void;
        getX(): number;
        getY(): number;
        addAll(list: Internal.Iterable_<dev.ftb.mods.ftblibrary.ui.Widget_>): void;
        equals(arg0: any): boolean;
        scrollPanel(scroll: number): boolean;
        toString(): string;
        setScrollX(scroll: number): void;
        getIngredientUnderMouse(): any;
        setScrollY(scroll: number): void;
        posX : number;
        parent : Internal.Panel;
        posY : number;
        attachedScrollbar : Internal.PanelScrollBar;
        width : number;
        contentWidthExtra : number;
        readonly widgets : Internal.List<dev.ftb.mods.ftblibrary.ui.Widget>;
        contentHeightExtra : number;
        height : number;
        get mouseX(): number;
        get cursor(): Internal.CursorType;
        get ingredientUnderMouse(): any;
        get mouseY(): number;
        get shiftKeyDown(): boolean;
        get screen(): Internal.Window;
        get scrollStep(): number;
        get title(): Internal.Component;
        get enabled(): boolean;
        get contentWidth(): number;
        get mouseOverAnyWidget(): boolean;
        get class(): Internal.Class<any>;
        get defaultScrollVertical(): boolean;
        get onlyInteractWithWidgetsInside(): boolean;
        get clipboardString(): string;
        get offset(): boolean;
        get mouseOver(): boolean;
        get widgetType(): Internal.WidgetType;
        get contentHeight(): number;
        get ctrlKeyDown(): boolean;
        get onlyRenderWidgetsInside(): boolean;
        get x(): number;
        get y(): number;
        get gui(): Internal.BaseScreen;
        get scrollY(): number;
        get scrollX(): number;
        get partialTicks(): number;
        set onlyInteractWithWidgetsInside(value: boolean);
        set clipboardString(string: string);
        set offset(flag: boolean);
        set onlyRenderWidgetsInside(value: boolean);
        set x(v: number);
        set y(v: number);
        set scrollY(scroll: number);
        set scrollStep(s: number);
        set scrollX(scroll: number);
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    type Panel_ = Panel;
    interface RegistrySupplier <T> extends Internal.Supplier<T> {
        getRegistrar(): Internal.Registrar<T>;
        getRegistries(): Internal.Registries;
        toOptional(): Internal.Optional<T>;
        getRegistryKey(): Internal.ResourceKey<Internal.Registry<T>>;
        isPresent(): boolean;
        getId(): ResourceLocation;
        getOrNull(): T;
        orElse(other: T): T;
        listen(callback: Internal.Consumer_<T>): void;
        orElseGet(supplier: Internal.Supplier_<T>): T;
        stream(): Internal.Stream<T>;
        get(): T;
        ifPresentOrElse(action: Internal.Consumer_<T>, emptyAction: Internal.Runnable_): void;
        ifPresent(action: Internal.Consumer_<T>): void;
        getRegistryId(): ResourceLocation;
    }
    type RegistrySupplier_<T> = RegistrySupplier<T>;
    class Products$P7 <F, T1, T2, T3, T4, T5, T6, T7> {
        t4(): Internal.App<F, T4>;
        getClass(): Internal.Class<any>;
        t5(): Internal.App<F, T5>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        t6(): Internal.App<F, T6>;
        t7(): Internal.App<F, T7>;
        apply<R>(arg0: Internal.Applicative_<F, any>, arg1: Internal.App_<F, Internal.Function7_<T1, T2, T3, T4, T5, T6, T7, R>>): Internal.App<F, R>;
        apply<R>(arg0: Internal.Applicative_<F, any>, arg1: Internal.Function7_<T1, T2, T3, T4, T5, T6, T7, R>): Internal.App<F, R>;
        notifyAll(): void;
        notify(): void;
        hashCode(): number;
        and<T8>(arg0: Internal.App_<F, T8>): Internal.Products$P8<F, T1, T2, T3, T4, T5, T6, T7, T8>;
        equals(arg0: any): boolean;
        toString(): string;
        t1(): Internal.App<F, T1>;
        t2(): Internal.App<F, T2>;
        t3(): Internal.App<F, T3>;
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    type Products$P7_<F, T1, T2, T3, T4, T5, T6, T7> = Products$P7<F, T1, T2, T3, T4, T5, T6, T7>;
    interface Function16 <T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, R> {
        curry12(): Internal.Function12<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, Internal.Function4<T13, T14, T15, T16, R>>;
        curry9(): Internal.Function9<T1, T2, T3, T4, T5, T6, T7, T8, T9, Internal.Function7<T10, T11, T12, T13, T14, T15, T16, R>>;
        curry13(): Internal.Function13<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, Internal.Function3<T14, T15, T16, R>>;
        apply(arg0: T1, arg1: T2, arg2: T3, arg3: T4, arg4: T5, arg5: T6, arg6: T7, arg7: T8, arg8: T9, arg9: T10, arg10: T11, arg11: T12, arg12: T13, arg13: T14, arg14: T15, arg15: T16): R;
        curry7(): Internal.Function7<T1, T2, T3, T4, T5, T6, T7, Internal.Function9<T8, T9, T10, T11, T12, T13, T14, T15, T16, R>>;
        curry14(): Internal.Function14<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, Internal.BiFunction<T15, T16, R>>;
        curry8(): Internal.Function8<T1, T2, T3, T4, T5, T6, T7, T8, Internal.Function8<T9, T10, T11, T12, T13, T14, T15, T16, R>>;
        curry15(): Internal.Function15<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, java_.util.function_.Function<T16, R>>;
        curry10(): Internal.Function10<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, Internal.Function6<T11, T12, T13, T14, T15, T16, R>>;
        curry11(): Internal.Function11<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, Internal.Function5<T12, T13, T14, T15, T16, R>>;
        curry(): java_.util.function_.Function<T1, Internal.Function15<T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, R>>;
        curry5(): Internal.Function5<T1, T2, T3, T4, T5, Internal.Function11<T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, R>>;
        curry6(): Internal.Function6<T1, T2, T3, T4, T5, T6, Internal.Function10<T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, R>>;
        curry3(): Internal.Function3<T1, T2, T3, Internal.Function13<T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, R>>;
        curry4(): Internal.Function4<T1, T2, T3, T4, Internal.Function12<T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, R>>;
        curry2(): Internal.BiFunction<T1, T2, Internal.Function14<T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, R>>;
    }
    type Function16_<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, R> = Function16<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, R>;
    class PageAttributes$PrintQualityType extends Internal.AttributeValue {
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        notifyAll(): void;
        equals(arg0: any): boolean;
        notify(): void;
        static readonly HIGH : Internal.PageAttributes$PrintQualityType;
        static readonly DRAFT : Internal.PageAttributes$PrintQualityType;
        static readonly NORMAL : Internal.PageAttributes$PrintQualityType;
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    type PageAttributes$PrintQualityType_ = PageAttributes$PrintQualityType;
    interface Int2IntFunction extends Internal.Function<number, number>, Internal.IntUnaryOperator {
        getOrDefault(arg0: any, arg1: number): number;
        getOrDefault(arg0: number, arg1: number): number;
        andThenShort(arg0: Internal.Int2ShortFunction_): Internal.Int2ShortFunction;
        composeByte(arg0: Internal.Byte2IntFunction_): Internal.Byte2IntFunction;
        andThenInt(arg0: Internal.Int2IntFunction_): Internal.Int2IntFunction;
        composeReference<T_>(arg0: Internal.Reference2IntFunction_<T_>): Internal.Reference2IntFunction<T_>;
        andThen<T_>(arg0: java_.util.function_.Function_<number, T_>): java_.util.function_.Function<number, T_>;
        andThen(arg0: Internal.IntUnaryOperator_): Internal.IntUnaryOperator;
        put(arg0: number, arg1: number): number;
        remove(arg0: number): number;
        remove(arg0: any): number;
        defaultReturnValue(): number;
        defaultReturnValue(arg0: number): void;
        andThenDouble(arg0: Internal.Int2DoubleFunction_): Internal.Int2DoubleFunction;
        andThenObject<T_>(arg0: Internal.Int2ObjectFunction_<T_>): Internal.Int2ObjectFunction<T_>;
        get(arg0: any): number;
        get(arg0: number): number;
        andThenLong(arg0: Internal.Int2LongFunction_): Internal.Int2LongFunction;
        composeLong(arg0: Internal.Long2IntFunction_): Internal.Long2IntFunction;
        andThenByte(arg0: Internal.Int2ByteFunction_): Internal.Int2ByteFunction;
        andThenFloat(arg0: Internal.Int2FloatFunction_): Internal.Int2FloatFunction;
        applyAsInt(arg0: number): number;
        apply(arg0: number): number;
        containsKey(arg0: any): boolean;
        containsKey(arg0: number): boolean;
        composeInt(arg0: Internal.Int2IntFunction_): Internal.Int2IntFunction;
        clear(): void;
        composeFloat(arg0: Internal.Float2IntFunction_): Internal.Float2IntFunction;
        andThenChar(arg0: Internal.Int2CharFunction_): Internal.Int2CharFunction;
        composeObject<T_>(arg0: Internal.Object2IntFunction_<T_>): Internal.Object2IntFunction<T_>;
        size(): number;
        compose<T_>(arg0: java_.util.function_.Function_<T_, number>): java_.util.function_.Function<T_, number>;
        compose(arg0: Internal.IntUnaryOperator_): Internal.IntUnaryOperator;
        composeShort(arg0: Internal.Short2IntFunction_): Internal.Short2IntFunction;
        andThenReference<T_>(arg0: Internal.Int2ReferenceFunction_<T_>): Internal.Int2ReferenceFunction<T_>;
        composeChar(arg0: Internal.Char2IntFunction_): Internal.Char2IntFunction;
        composeDouble(arg0: Internal.Double2IntFunction_): Internal.Double2IntFunction;
    }
    type Int2IntFunction_ = ((arg0: number) => number) | Int2IntFunction;
    interface IntIterator extends Internal.PrimitiveIterator$OfInt {
        next(): number;
        hasNext(): boolean;
        skip(arg0: number): number;
        nextInt(): number;
        forEachRemaining(arg0: Internal.Consumer_<number>): void;
        forEachRemaining(arg0: Internal.IntConsumer_): void;
        forEachRemaining(arg0: java_.util.function_.IntConsumer_): void;
        remove(): void;
    }
    type IntIterator_ = IntIterator;
    class Collector$Characteristics extends Internal.Enum<Internal.Collector$Characteristics> {
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        static valueOf(arg0: string): Internal.Collector$Characteristics;
        static valueOf<T_>(arg0: Internal.Class_<T_>, arg1: string): T_;
        notifyAll(): void;
        static values(): Internal.Collector$Characteristics[];
        compareTo(arg0: Internal.Collector$Characteristics_): number;
        describeConstable(): Internal.Optional<Internal.Enum$EnumDesc<Internal.Collector$Characteristics>>;
        notify(): void;
        getDeclaringClass(): Internal.Class<Internal.Collector$Characteristics>;
        hashCode(): number;
        equals(arg0: any): boolean;
        name(): string;
        toString(): string;
        ordinal(): number;
        static readonly IDENTITY_FINISH : Internal.Collector$Characteristics;
        static readonly UNORDERED : Internal.Collector$Characteristics;
        static readonly CONCURRENT : Internal.Collector$Characteristics;
        get class(): Internal.Class<any>;
        get declaringClass(): Internal.Class<Internal.Collector$Characteristics>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    type Collector$Characteristics_ = "unordered" | "identity_finish" | "concurrent" | Collector$Characteristics;
    interface Float2BooleanFunction extends Internal.Function<number, boolean>, java_.util.function_.DoublePredicate {
        getOrDefault(arg0: any, arg1: boolean): boolean;
        getOrDefault(arg0: number, arg1: boolean): boolean;
        andThenShort(arg0: Internal.Boolean2ShortFunction_): Internal.Float2ShortFunction;
        composeByte(arg0: Internal.Byte2FloatFunction_): Internal.Byte2BooleanFunction;
        andThenInt(arg0: Internal.Boolean2IntFunction_): Internal.Float2IntFunction;
        composeReference<T_>(arg0: Internal.Reference2FloatFunction_<T_>): Internal.Reference2BooleanFunction<T_>;
        andThen<T_>(arg0: java_.util.function_.Function_<boolean, T_>): java_.util.function_.Function<number, T_>;
        put(arg0: number, arg1: boolean): boolean;
        remove(arg0: number): boolean;
        remove(arg0: any): boolean;
        defaultReturnValue(): boolean;
        defaultReturnValue(arg0: boolean): void;
        andThenDouble(arg0: Internal.Boolean2DoubleFunction_): Internal.Float2DoubleFunction;
        andThenObject<T_>(arg0: Internal.Boolean2ObjectFunction_<T_>): Internal.Float2ObjectFunction<T_>;
        and(arg0: java_.util.function_.DoublePredicate_): java_.util.function_.DoublePredicate;
        get(arg0: any): boolean;
        get(arg0: number): boolean;
        andThenLong(arg0: Internal.Boolean2LongFunction_): Internal.Float2LongFunction;
        composeLong(arg0: Internal.Long2FloatFunction_): Internal.Long2BooleanFunction;
        andThenByte(arg0: Internal.Boolean2ByteFunction_): Internal.Float2ByteFunction;
        andThenFloat(arg0: Internal.Boolean2FloatFunction_): Internal.Float2FloatFunction;
        or(arg0: java_.util.function_.DoublePredicate_): java_.util.function_.DoublePredicate;
        test(arg0: number): boolean;
        apply(arg0: number): boolean;
        containsKey(arg0: number): boolean;
        containsKey(arg0: any): boolean;
        composeInt(arg0: Internal.Int2FloatFunction_): Internal.Int2BooleanFunction;
        clear(): void;
        composeFloat(arg0: Internal.Float2FloatFunction_): Internal.Float2BooleanFunction;
        andThenChar(arg0: Internal.Boolean2CharFunction_): Internal.Float2CharFunction;
        composeObject<T_>(arg0: Internal.Object2FloatFunction_<T_>): Internal.Object2BooleanFunction<T_>;
        size(): number;
        compose<T_>(arg0: java_.util.function_.Function_<T_, number>): java_.util.function_.Function<T_, boolean>;
        negate(): java_.util.function_.DoublePredicate;
        composeShort(arg0: Internal.Short2FloatFunction_): Internal.Short2BooleanFunction;
        andThenReference<T_>(arg0: Internal.Boolean2ReferenceFunction_<T_>): Internal.Float2ReferenceFunction<T_>;
        composeChar(arg0: Internal.Char2FloatFunction_): Internal.Char2BooleanFunction;
        composeDouble(arg0: Internal.Double2FloatFunction_): Internal.Double2BooleanFunction;
    }
    type Float2BooleanFunction_ = ((arg0: number) => boolean) | Float2BooleanFunction;
    /**
    * Fired when you need to modify recipes.
    */
    class RecipeEventJS extends Internal.EventJS {
        cancel(): void;
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        notifyAll(): void;
        countRecipes(filter: Internal.RecipeFilter_): number;
        forEachRecipe(filter: Internal.RecipeFilter_, consumer: Internal.Consumer_<Internal.RecipeJS_>): void;
        notify(): void;
        /**
        * Remove recipe(s) by given recipe filter.
        *
        * Please note that some of the recipes are not removable from KubeJS side.
        *
        * An example is tipped arrows, because they do not have actual recipe registered in datapack.
        */
        remove(filter: Internal.RecipeFilter_): number;
        replaceOutput(ingredient: Internal.IngredientJS_, with_: Internal.ItemStackJS_): number;
        replaceOutput(filter: Internal.RecipeFilter_, ingredient: Internal.IngredientJS_, with_: Internal.ItemStackJS_, exact: boolean): number;
        replaceOutput(filter: Internal.RecipeFilter_, ingredient: Internal.IngredientJS_, with_: Internal.ItemStackJS_): number;
        post(t: Internal.ScriptType_, id: string, sub: string): boolean;
        post(t: Internal.ScriptType_, id: string): boolean;
        hashCode(): number;
        printAllTypes(): void;
        customFilter(filter: Internal.RecipeFilter_): Internal.RecipeFilter;
        isCancelled(): boolean;
        printTypes(): void;
        getRecipeFunction(id: string): Internal.RecipeFunction;
        custom(o: any): Internal.RecipeJS;
        forEachRecipeAsync(filter: Internal.RecipeFilter_, consumer: Internal.Consumer_<Internal.RecipeJS_>): void;
        addRecipe(r: Internal.RecipeJS_, type: Internal.RecipeTypeJS_, args1: Internal.ListJS_): Internal.RecipeJS;
        printExamples(type: string): void;
        stage(filter: Internal.RecipeFilter_, stage: string): void;
        replaceInput(filter: Internal.RecipeFilter_, ingredient: Internal.IngredientJS_, with_: Internal.IngredientJS_): number;
        replaceInput(filter: Internal.RecipeFilter_, ingredient: Internal.IngredientJS_, with_: Internal.IngredientJS_, exact: boolean): number;
        replaceInput(ingredient: Internal.IngredientJS_, with_: Internal.IngredientJS_): number;
        equals(arg0: any): boolean;
        toString(): string;
        /**
        * Holds all the recipes collected from documents.
        */
        getRecipes(): Document.RecipeHolder;
        canCancel(): boolean;
        setItemErrors(b: boolean): void;
        static instance : Internal.RecipeEventJS;
        static modifyResultCallbackMap : {};
        static readonly FORGE_CONDITIONAL : "forge:conditional";
        static customIngredientMap : {};
        /**
        * Holds all the recipes collected from documents.
        */
        get recipes(): Document.RecipeHolder;
        get cancelled(): boolean;
        get class(): Internal.Class<any>;
        set itemErrors(b: boolean);
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
        /**
        * Adds a smelting recipe to Minecraft.
        *
        * This is used by Furnaces.
        */
        smelting(output: Internal.ItemStackJS_, input: Internal.IngredientJS_): Internal.CookingRecipeJS;
        /**
        * Adds a smelting recipe to Minecraft.
        *
        * This is used by Smokers.
        */
        smoking(output: Internal.ItemStackJS_, input: Internal.IngredientJS_): Internal.CookingRecipeJS;
        /**
        * Adds a smelting recipe to Minecraft.
        *
        * This is used by Blast Furnaces.
        */
        blasting(output: Internal.ItemStackJS_, input: Internal.IngredientJS_): Internal.CookingRecipeJS;
        /**
        * Adds a shaped crafting recipe.
        */
        shaped(output: Internal.ItemStackJS_, pattern: Internal.IngredientJS_[][]): Internal.ShapedRecipeJS;
        /**
        * Adds a shaped crafting recipe.
        */
        shaped(output: Internal.ItemStackJS_, pattern: string[], items: { [string]: Internal.IngredientJS_ }): Internal.ShapedRecipeJS;
        /**
        * Adds a shapeless crafting recipe.
        */
        shapeless(output: Internal.ItemStackJS_, inputs: Internal.IngredientJS_[]): Internal.ShapelessRecipeJS;
        /**
        * Adds a smelting recipe to Minecraft.
        *
        * This is used by Campfire.
        */
        campfireCooking(output: Internal.ItemStackJS_, input: Internal.IngredientJS_): Internal.CookingRecipeJS;
        /**
        * Adds a stonecutting recipe.
        */
        stonecutting(output: Internal.ItemStackJS_, inputs: Internal.IngredientJS_): Internal.StonecuttingRecipeJS;
        /**
        * Adds a smithing recipe.
        */
        smithing(output: Internal.ItemStackJS_, base: Internal.IngredientJS_, addition: Internal.IngredientJS_): Internal.SmithingRecipeJS;
    }
    /**
    * Fired when you need to modify recipes.
    */
    type RecipeEventJS_ = RecipeEventJS;
    interface DoubleStream$Builder extends java_.util.function_.DoubleConsumer {
        add(arg0: number): Internal.DoubleStream$Builder;
        build(): Internal.DoubleStream;
        andThen(arg0: java_.util.function_.DoubleConsumer_): java_.util.function_.DoubleConsumer;
        accept(arg0: number): void;
    }
    type DoubleStream$Builder_ = DoubleStream$Builder;
    interface AttributeMap {
        hasAttr<T>(arg0: Internal.AttributeKey_<T>): boolean;
        attr<T>(arg0: Internal.AttributeKey_<T>): io.netty.util.Attribute<T>;
    }
    type AttributeMap_ = AttributeMap;
    abstract class UserPrincipalLookupService {
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        hashCode(): number;
        notifyAll(): void;
        equals(arg0: any): boolean;
        toString(): string;
        lookupPrincipalByGroupName(arg0: string): Internal.GroupPrincipal;
        lookupPrincipalByName(arg0: string): Internal.UserPrincipal;
        notify(): void;
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    type UserPrincipalLookupService_ = UserPrincipalLookupService;
    class BlockIDPredicate implements Internal.BlockPredicate {
        getBlockProperties(): Internal.List<Internal.BlockIDPredicate$PropertyObject>;
        getClass(): Internal.Class<any>;
        with(key: string, value: string): Internal.BlockIDPredicate;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        hashCode(): number;
        notifyAll(): void;
        equals(arg0: any): boolean;
        checkState(state: Internal.BlockState_): boolean;
        toString(): string;
        check(b: Internal.BlockContainerJS_): boolean;
        getBlockState(): Internal.BlockState;
        notify(): void;
        get blockState(): Internal.BlockState;
        get blockProperties(): Internal.List<Internal.BlockIDPredicate$PropertyObject>;
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    type BlockIDPredicate_ = BlockIDPredicate;
    class EventsJS {
        getClass(): Internal.Class<any>;
        postToHandlers(id: string, list: Internal.List_<Internal.EventsJS$ScriptEventHandler_>, event: Internal.EventJS_): boolean;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        hashCode(): number;
        handlers(id: string): Internal.List<Internal.EventsJS$ScriptEventHandler>;
        notifyAll(): void;
        equals(arg0: any): boolean;
        clear(): void;
        toString(): string;
        notify(): void;
        listen(id: string, handler: Internal.IEventHandler_): void;
        readonly scriptManager : Internal.ScriptManager;
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    type EventsJS_ = EventsJS;
    interface AccessorItemRenderer {
        callRenderQuadList(arg0: Internal.PoseStack_, arg1: Internal.VertexConsumer_, arg2: Internal.List_<Internal.BakedQuad_>, arg3: Internal.ItemStack_, arg4: number, arg5: number): void;
    }
    type AccessorItemRenderer_ = AccessorItemRenderer;
    class CountingMap {
        add(key: any, value: number): number;
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        set(key: any, value: number): number;
        getValues(): Internal.Collection<number>;
        forEach(forEach: Internal.Consumer_<Internal.Object2LongEntry_>): void;
        notifyAll(): void;
        clear(): void;
        getTotalCount(): number;
        getKeys(): Internal.Set<any>;
        notify(): void;
        getSize(): number;
        getEntries(): Internal.List<Internal.Object2LongEntry>;
        hashCode(): number;
        equals(arg0: any): boolean;
        get(key: any): number;
        toString(): string;
        get entries(): Internal.List<Internal.Object2LongEntry>;
        get size(): number;
        get keys(): Internal.Set<any>;
        get values(): Internal.Collection<number>;
        get totalCount(): number;
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    type CountingMap_ = CountingMap;
    class EntityPotionEffectsJS {
        add(mobEffect: Internal.MobEffect_, duration: number): void;
        add(mobEffect: Internal.MobEffect_, duration: number, amplifier: number): void;
        add(mobEffect: Internal.MobEffect_): void;
        add(mobEffect: Internal.MobEffect_, duration: number, amplifier: number, ambient: boolean, showParticles: boolean): void;
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        notifyAll(): void;
        isApplicable(effect: Internal.MobEffectInstance_): boolean;
        clear(): void;
        isActive(mobEffect: Internal.MobEffect_): boolean;
        notify(): void;
        getMap(): Internal.Map<Internal.MobEffect, Internal.MobEffectInstance>;
        getDuration(mobEffect: Internal.MobEffect_): number;
        hashCode(): number;
        equals(arg0: any): boolean;
        toString(): string;
        getActive(): Internal.Collection<Internal.MobEffectInstance>;
        getActive(mobEffect: Internal.MobEffect_): Internal.MobEffectInstance;
        get active(): Internal.Collection<Internal.MobEffectInstance>;
        get class(): Internal.Class<any>;
        get map(): Internal.Map<Internal.MobEffect, Internal.MobEffectInstance>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    type EntityPotionEffectsJS_ = EntityPotionEffectsJS;
    interface ItemFTBL {
        setCraftingRemainingItemFTBL(arg0: Internal.Item_): void;
    }
    type ItemFTBL_ = ItemFTBL;
    abstract class Either <L, R> implements Internal.App<Internal.Either$Mu<R>, L> {
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        swap(): Internal.Either<R, L>;
        notifyAll(): void;
        mapBoth<C_, D_>(arg0: java_.util.function_.Function_<L, C_>, arg1: java_.util.function_.Function_<R, D_>): Internal.Either<C_, D_>;
        ifLeft(arg0: Internal.Consumer_<L>): Internal.Either<L, R>;
        static right<L_, R_>(arg0: R_): Internal.Either<L_, R_>;
        right(): Internal.Optional<R>;
        notify(): void;
        ifRight(arg0: Internal.Consumer_<R>): Internal.Either<L, R>;
        orThrow(): L;
        mapRight<T_>(arg0: java_.util.function_.Function_<R, T_>): Internal.Either<L, T_>;
        flatMap<L2_>(arg0: java_.util.function_.Function_<L, Internal.Either_<L2_, R>>): Internal.Either<L2_, R>;
        static left<L_, R_>(arg0: L_): Internal.Either<L_, R_>;
        left(): Internal.Optional<L>;
        hashCode(): number;
        static unbox<L_, R_>(arg0: Internal.App_<Internal.Either$Mu_<R_>, L_>): Internal.Either<L_, R_>;
        equals(arg0: any): boolean;
        mapLeft<T_>(arg0: java_.util.function_.Function_<L, T_>): Internal.Either<T_, R>;
        toString(): string;
        map<T_>(arg0: java_.util.function_.Function_<L, T_>, arg1: java_.util.function_.Function_<R, T_>): T_;
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    type Either_<L, R> = Either<L, R>;
    interface IConfigSpec <T> extends Internal.UnmodifiableConfig {
        getShortOrElse(arg0: string, arg1: number): number;
        getShortOrElse(arg0: Internal.List_<string>, arg1: number): number;
        getByte(arg0: Internal.List_<string>): number;
        getByte(arg0: string): number;
        correct(arg0: Internal.CommentedConfig_): number;
        acceptConfig(arg0: Internal.CommentedConfig_): void;
        getEnum<T_>(arg0: string, arg1: Internal.Class_<T_>, arg2: Internal.EnumGetMethod_): T_;
        getEnum<T_>(arg0: Internal.List_<string>, arg1: Internal.Class_<T_>): T_;
        getEnum<T_>(arg0: Internal.List_<string>, arg1: Internal.Class_<T_>, arg2: Internal.EnumGetMethod_): T_;
        getEnum<T_>(arg0: string, arg1: Internal.Class_<T_>): T_;
        getLongOrElse(arg0: string, arg1: Internal.LongSupplier_): number;
        getLongOrElse(arg0: Internal.List_<string>, arg1: Internal.LongSupplier_): number;
        getLongOrElse(arg0: Internal.List_<string>, arg1: number): number;
        getLongOrElse(arg0: string, arg1: number): number;
        isCorrecting(): boolean;
        getByteOrElse(arg0: Internal.List_<string>, arg1: number): number;
        getByteOrElse(arg0: string, arg1: number): number;
        get<T_>(arg0: string): T_;
        get<T_>(arg0: Internal.List_<string>): T_;
        valueMap(): Internal.Map<string, any>;
        getOrElse<T_>(arg0: Internal.List_<string>, arg1: T_): T_;
        getOrElse<T_>(arg0: string, arg1: Internal.Supplier_<T_>): T_;
        getOrElse<T_>(arg0: string, arg1: T_): T_;
        getOrElse<T_>(arg0: Internal.List_<string>, arg1: Internal.Supplier_<T_>): T_;
        getEnumOrElse<T_>(arg0: string, arg1: Internal.Class_<T_>, arg2: Internal.EnumGetMethod_, arg3: Internal.Supplier_<T_>): T_;
        getEnumOrElse<T_>(arg0: Internal.List_<string>, arg1: T_): T_;
        getEnumOrElse<T_>(arg0: Internal.List_<string>, arg1: T_, arg2: Internal.EnumGetMethod_): T_;
        getEnumOrElse<T_>(arg0: string, arg1: T_): T_;
        getEnumOrElse<T_>(arg0: string, arg1: T_, arg2: Internal.EnumGetMethod_): T_;
        getEnumOrElse<T_>(arg0: Internal.List_<string>, arg1: Internal.Class_<T_>, arg2: Internal.EnumGetMethod_, arg3: Internal.Supplier_<T_>): T_;
        getEnumOrElse<T_>(arg0: Internal.List_<string>, arg1: Internal.Class_<T_>, arg2: Internal.Supplier_<T_>): T_;
        getEnumOrElse<T_>(arg0: string, arg1: Internal.Class_<T_>, arg2: Internal.Supplier_<T_>): T_;
        getIntOrElse(arg0: string, arg1: Internal.IntSupplier_): number;
        getIntOrElse(arg0: string, arg1: number): number;
        getIntOrElse(arg0: Internal.List_<string>, arg1: number): number;
        getIntOrElse(arg0: Internal.List_<string>, arg1: Internal.IntSupplier_): number;
        entrySet(): Internal.Set<Internal.UnmodifiableConfig$Entry>;
        apply<T_>(arg0: string): T_;
        apply<T_>(arg0: Internal.List_<string>): T_;
        getShort(arg0: string): number;
        getShort(arg0: Internal.List_<string>): number;
        configFormat(): Internal.ConfigFormat<any>;
        isEmpty(): boolean;
        getOptionalInt(arg0: string): Internal.OptionalInt;
        getOptionalInt(arg0: Internal.List_<string>): Internal.OptionalInt;
        getCharOrElse(arg0: Internal.List_<string>, arg1: string): string;
        getCharOrElse(arg0: string, arg1: string): string;
        afterReload(): void;
        getLong(arg0: string): number;
        getLong(arg0: Internal.List_<string>): number;
        getInt(arg0: string): number;
        getInt(arg0: Internal.List_<string>): number;
        getChar(arg0: string): string;
        getChar(arg0: Internal.List_<string>): string;
        getOptional<T_>(arg0: string): Internal.Optional<T_>;
        getOptional<T_>(arg0: Internal.List_<string>): Internal.Optional<T_>;
        contains(arg0: Internal.List_<string>): boolean;
        contains(arg0: string): boolean;
        size(): number;
        isNull(arg0: string): boolean;
        isNull(arg0: Internal.List_<string>): boolean;
        self(): T;
        getRaw<T_>(arg0: string): T_;
        getRaw<T_>(arg0: Internal.List_<string>): T_;
        getOptionalLong(arg0: string): Internal.OptionalLong;
        getOptionalLong(arg0: Internal.List_<string>): Internal.OptionalLong;
        getOptionalEnum<T_>(arg0: string, arg1: Internal.Class_<T_>): Internal.Optional<T_>;
        getOptionalEnum<T_>(arg0: Internal.List_<string>, arg1: Internal.Class_<T_>): Internal.Optional<T_>;
        getOptionalEnum<T_>(arg0: string, arg1: Internal.Class_<T_>, arg2: Internal.EnumGetMethod_): Internal.Optional<T_>;
        getOptionalEnum<T_>(arg0: Internal.List_<string>, arg1: Internal.Class_<T_>, arg2: Internal.EnumGetMethod_): Internal.Optional<T_>;
        isCorrect(arg0: Internal.CommentedConfig_): boolean;
    }
    type IConfigSpec_<T> = IConfigSpec<T>;
    interface ChronoZonedDateTime <D> extends Internal.Temporal, Internal.Comparable<Internal.ChronoZonedDateTime<any>> {
        minus(arg0: number, arg1: Internal.TemporalUnit_): Internal.ChronoZonedDateTime<D>;
        minus(arg0: Internal.TemporalAmount_): Internal.ChronoZonedDateTime<D>;
        isEqual(arg0: Internal.ChronoZonedDateTime_<any>): boolean;
        getOffset(): Internal.ZoneOffset;
        toLocalTime(): Internal.LocalTime;
        range(arg0: Internal.TemporalField_): Internal.ValueRange;
        compareTo(arg0: Internal.ChronoZonedDateTime_<any>): number;
        withLaterOffsetAtOverlap(): Internal.ChronoZonedDateTime<D>;
        hashCode(): number;
        get(arg0: Internal.TemporalField_): number;
        withZoneSameLocal(arg0: Internal.ZoneId_): Internal.ChronoZonedDateTime<D>;
        withEarlierOffsetAtOverlap(): Internal.ChronoZonedDateTime<D>;
        getChronology(): Internal.Chronology;
        withZoneSameInstant(arg0: Internal.ZoneId_): Internal.ChronoZonedDateTime<D>;
        query<R_>(arg0: Internal.TemporalQuery_<R_>): R_;
        format(arg0: Internal.DateTimeFormatter_): string;
        getZone(): Internal.ZoneId;
        isSupported(arg0: Internal.TemporalUnit_): boolean;
        isSupported(arg0: Internal.TemporalField_): boolean;
        toInstant(): Internal.Instant;
        isBefore(arg0: Internal.ChronoZonedDateTime_<any>): boolean;
        plus(arg0: number, arg1: Internal.TemporalUnit_): Internal.ChronoZonedDateTime<D>;
        plus(arg0: Internal.TemporalAmount_): Internal.ChronoZonedDateTime<D>;
        getLong(arg0: Internal.TemporalField_): number;
        with(arg0: Internal.TemporalAdjuster_): Internal.ChronoZonedDateTime<D>;
        with(arg0: Internal.TemporalField_, arg1: number): Internal.ChronoZonedDateTime<D>;
        toLocalDate(): D;
        toEpochSecond(): number;
        toLocalDateTime(): Internal.ChronoLocalDateTime<D>;
        equals(arg0: any): boolean;
        until(arg0: Internal.Temporal_, arg1: Internal.TemporalUnit_): number;
        toString(): string;
        isAfter(arg0: Internal.ChronoZonedDateTime_<any>): boolean;
    }
    type ChronoZonedDateTime_<D> = ChronoZonedDateTime<D>;
    class CallbackInfo implements Internal.Cancellable {
        cancel(): void;
        getClass(): Internal.Class<any>;
        static getCallInfoClassName(arg0: Internal.Type_): string;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        isCancelled(): boolean;
        hashCode(): number;
        notifyAll(): void;
        equals(arg0: any): boolean;
        isCancellable(): boolean;
        getId(): string;
        toString(): string;
        notify(): void;
        get cancelled(): boolean;
        get id(): string;
        get class(): Internal.Class<any>;
        get cancellable(): boolean;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    type CallbackInfo_ = CallbackInfo;
    class ItemModelPropertiesEventJS extends Internal.StartupEventJS {
        cancel(): void;
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        isCancelled(): boolean;
        post(id: string): boolean;
        post(id: string, sub: string): boolean;
        post(t: Internal.ScriptType_, id: string, sub: string): boolean;
        post(t: Internal.ScriptType_, id: string): boolean;
        hashCode(): number;
        registerAll(overwriteId: string, callback: Internal.ItemModelPropertiesEventJS$ItemPropertiesCallback_): void;
        notifyAll(): void;
        equals(arg0: any): boolean;
        toString(): string;
        notify(): void;
        canCancel(): boolean;
        register(ingredient: Internal.IngredientJS_, overwriteId: string, callback: Internal.ItemModelPropertiesEventJS$ItemPropertiesCallback_): void;
        get cancelled(): boolean;
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    type ItemModelPropertiesEventJS_ = ItemModelPropertiesEventJS;
    interface Era extends Internal.TemporalAccessor, Internal.TemporalAdjuster {
        getLong(arg0: Internal.TemporalField_): number;
        getValue(): number;
        getDisplayName(arg0: Internal.TextStyle_, arg1: Internal.Locale_): string;
        query<R_>(arg0: Internal.TemporalQuery_<R_>): R_;
        get(arg0: Internal.TemporalField_): number;
        adjustInto(arg0: Internal.Temporal_): Internal.Temporal;
        range(arg0: Internal.TemporalField_): Internal.ValueRange;
        isSupported(arg0: Internal.TemporalField_): boolean;
    }
    type Era_ = Era;
    abstract class EntityRenderer <T> {
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        hashCode(): number;
        notifyAll(): void;
        equals(arg0: any): boolean;
        toString(): string;
        notify(): void;
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    type EntityRenderer_<T> = EntityRenderer<T>;
    interface DirectMethodHandleDesc extends Internal.MethodHandleDesc {
        owner(): Internal.ClassDesc;
        invocationType(): Internal.MethodTypeDesc;
        kind(): Internal.DirectMethodHandleDesc$Kind;
        equals(arg0: any): boolean;
        refKind(): number;
        isOwnerInterface(): boolean;
        lookupDescriptor(): string;
        methodName(): string;
        resolveConstantDesc(arg0: Internal.MethodHandles$Lookup_): any;
        asType(arg0: Internal.MethodTypeDesc_): Internal.MethodHandleDesc;
    }
    type DirectMethodHandleDesc_ = DirectMethodHandleDesc;
    interface Double2DoubleFunction extends Internal.Function<number, number>, Internal.DoubleUnaryOperator {
        getOrDefault(arg0: any, arg1: number): number;
        getOrDefault(arg0: number, arg1: number): number;
        applyAsDouble(arg0: number): number;
        andThenShort(arg0: Internal.Double2ShortFunction_): Internal.Double2ShortFunction;
        composeByte(arg0: Internal.Byte2DoubleFunction_): Internal.Byte2DoubleFunction;
        andThenInt(arg0: Internal.Double2IntFunction_): Internal.Double2IntFunction;
        composeReference<T_>(arg0: Internal.Reference2DoubleFunction_<T_>): Internal.Reference2DoubleFunction<T_>;
        andThen<T_>(arg0: java_.util.function_.Function_<number, T_>): java_.util.function_.Function<number, T_>;
        andThen(arg0: Internal.DoubleUnaryOperator_): Internal.DoubleUnaryOperator;
        put(arg0: number, arg1: number): number;
        remove(arg0: number): number;
        remove(arg0: any): number;
        defaultReturnValue(): number;
        defaultReturnValue(arg0: number): void;
        andThenDouble(arg0: Internal.Double2DoubleFunction_): Internal.Double2DoubleFunction;
        andThenObject<T_>(arg0: Internal.Double2ObjectFunction_<T_>): Internal.Double2ObjectFunction<T_>;
        get(arg0: any): number;
        get(arg0: number): number;
        andThenLong(arg0: Internal.Double2LongFunction_): Internal.Double2LongFunction;
        composeLong(arg0: Internal.Long2DoubleFunction_): Internal.Long2DoubleFunction;
        andThenByte(arg0: Internal.Double2ByteFunction_): Internal.Double2ByteFunction;
        andThenFloat(arg0: Internal.Double2FloatFunction_): Internal.Double2FloatFunction;
        apply(arg0: number): number;
        containsKey(arg0: any): boolean;
        containsKey(arg0: number): boolean;
        composeInt(arg0: Internal.Int2DoubleFunction_): Internal.Int2DoubleFunction;
        clear(): void;
        composeFloat(arg0: Internal.Float2DoubleFunction_): Internal.Float2DoubleFunction;
        andThenChar(arg0: Internal.Double2CharFunction_): Internal.Double2CharFunction;
        composeObject<T_>(arg0: Internal.Object2DoubleFunction_<T_>): Internal.Object2DoubleFunction<T_>;
        size(): number;
        compose<T_>(arg0: java_.util.function_.Function_<T_, number>): java_.util.function_.Function<T_, number>;
        compose(arg0: Internal.DoubleUnaryOperator_): Internal.DoubleUnaryOperator;
        composeShort(arg0: Internal.Short2DoubleFunction_): Internal.Short2DoubleFunction;
        andThenReference<T_>(arg0: Internal.Double2ReferenceFunction_<T_>): Internal.Double2ReferenceFunction<T_>;
        composeChar(arg0: Internal.Char2DoubleFunction_): Internal.Char2DoubleFunction;
        composeDouble(arg0: Internal.Double2DoubleFunction_): Internal.Double2DoubleFunction;
    }
    type Double2DoubleFunction_ = ((arg0: number) => number) | Double2DoubleFunction;
    /**
    */
    class ArmorItemBuilder$Chestplate extends Internal.ArmorItemBuilder {
        barWidth(barWidth: Internal.ToIntFunction_<Internal.ItemStackJS_>): Internal.ItemBuilder;
        getClass(): Internal.Class<any>;
        maxStackSize(v: number): Internal.ItemBuilder;
        translationKey(key: string): Internal.BuilderBase<Internal.Item>;
        newID(pre: string, post: string): ResourceLocation;
        use(use: Internal.ItemBuilder$UseCallback_): Internal.ItemBuilder;
        maxDamage(v: number): Internal.ItemBuilder;
        textureJson(json: Internal.JsonObject_): Internal.ItemBuilder;
        tooltip(text: Internal.Component_): Internal.ItemBuilder;
        modifyTier(callback: Internal.Consumer_<Internal.MutableArmorTier_>): Internal.ArmorItemBuilder;
        type(type: string): Internal.BuilderBase<Internal.Item>;
        containerItem(id: string): Internal.ItemBuilder;
        subtypes(fn: java_.util.function_.Function_<Internal.ItemStackJS_, Internal.Collection_<Internal.ItemStackJS_>>): Internal.ItemBuilder;
        modelJson(json: Internal.JsonObject_): Internal.ItemBuilder;
        burnTime(v: number): Internal.ItemBuilder;
        useDuration(useDuration: Internal.ToIntFunction_<Internal.ItemStackJS_>): Internal.ItemBuilder;
        tag(tag: ResourceLocation_): Internal.BuilderBase<Internal.Item>;
        parentModel(m: string): Internal.ItemBuilder;
        generateDataJsons(generator: Internal.DataJsonGenerator_): void;
        group(g: string): Internal.ItemBuilder;
        static ofArmorMaterial(o: any): Internal.ArmorMaterial;
        /**
        */
        modifyAttribute(attribute: net.minecraft.world.entity.ai.attributes.Attribute_, identifier: string, d: number, operation: Internal.AttributeModifier$Operation_): Internal.ItemBuilder;
        getRegistryType(): Internal.RegistryObjectBuilderTypes<Internal.Item>;
        glow(v: boolean): Internal.ItemBuilder;
        useAnimation(animation: Internal.UseAnim_): Internal.ItemBuilder;
        rarity(v: Rarity_): Internal.ItemBuilder;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        clientRegistry(minecraft: Internal.Minecraft_): void;
        transformObject(obj: Internal.Item_): Internal.Item;
        color(callback: Internal.ItemBuilder$ItemColorJS_): Internal.ItemBuilder;
        color(index: number, c: Internal.Color_): Internal.ItemBuilder;
        displayName(name: string): Internal.BuilderBase<Internal.Item>;
        notifyAll(): void;
        barColor(barColor: java_.util.function_.Function_<Internal.ItemStackJS_, Internal.Color_>): Internal.ItemBuilder;
        notify(): void;
        createAdditionalObjects(): void;
        tier(t: Internal.ArmorMaterial_): Internal.ArmorItemBuilder;
        hashCode(): number;
        get(): Internal.Item;
        generateAssetJsons(generator: Internal.AssetJsonGenerator_): void;
        getTranslationKeyGroup(): string;
        texture(key: string, tex: string): Internal.ItemBuilder;
        texture(tex: string): Internal.ItemBuilder;
        generateLang(lang: Internal.Map_<string, string>): void;
        food(b: Internal.Consumer_<Internal.FoodBuilder_>): Internal.ItemBuilder;
        createObject(): Internal.Item;
        releaseUsing(releaseUsing: Internal.ItemBuilder$ReleaseUsingCallback_): Internal.ItemBuilder;
        unstackable(): Internal.ItemBuilder;
        addResourcePackLocations(path: string, list: Internal.List_<ResourceLocation_>, packType: Internal.PackType_): void;
        equals(arg0: any): boolean;
        toString(): string;
        finishUsing(finishUsing: Internal.ItemBuilder$FinishUsingCallback_): Internal.ItemBuilder;
        createItemProperties(): Internal.Item$Properties;
        armorTier : Internal.MutableArmorTier;
        static readonly TOOL_TIERS : {"gold":any,"diamond":any,"iron":any,"wood":any,"stone":any,"netherite":any};
        static readonly ARMOR_TIERS : {"gold":any,"chain":any,"diamond":any,"turtle":any,"iron":any,"leather":any,"netherite":any};
        readonly equipmentSlot : EquipmentSlot;
        readonly id : ResourceLocation;
        get registryType(): Internal.RegistryObjectBuilderTypes<Internal.Item>;
        get class(): Internal.Class<any>;
        get translationKeyGroup(): string;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    /**
    */
    type ArmorItemBuilder$Chestplate_ = ArmorItemBuilder$Chestplate;
    class ConditionalFunction implements Internal.FunctionContainer, Internal.ConditionContainer {
        enchantWithLevels(levels: Internal.NumberProvider_, treasure: boolean): Internal.FunctionContainer;
        damage(damage: Internal.NumberProvider_): Internal.FunctionContainer;
        nbt(tag: Internal.CompoundTag_): Internal.FunctionContainer;
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        survivesExplosion(): Internal.ConditionContainer;
        notifyAll(): void;
        addConditionalFunction(func: Internal.Consumer_<Internal.ConditionalFunction_>): Internal.FunctionContainer;
        addCondition(o: Internal.JsonObject_): Internal.ConditionalFunction;
        notify(): void;
        lootTable(table: ResourceLocation_, seed: number): Internal.FunctionContainer;
        hashCode(): number;
        killedByPlayer(): Internal.ConditionContainer;
        randomChance(chance: number): Internal.ConditionContainer;
        addFunction(o: Internal.JsonObject_): Internal.ConditionalFunction;
        count(count: Internal.NumberProvider_): Internal.FunctionContainer;
        lootingEnchant(count: Internal.NumberProvider_, limit: number): Internal.FunctionContainer;
        entityScores(entity: Internal.LootContext$EntityTarget_, scores: Internal.Map_<string, any>): Internal.ConditionContainer;
        copyName(source: Internal.CopyNameFunction$NameSource_): Internal.FunctionContainer;
        equals(arg0: any): boolean;
        name(name: Internal.Text_, entity: Internal.LootContext$EntityTarget_): Internal.FunctionContainer;
        name(name: Internal.Text_): Internal.FunctionContainer;
        randomChanceWithLooting(chance: number, multiplier: number): Internal.ConditionContainer;
        furnaceSmelt(): Internal.FunctionContainer;
        toString(): string;
        enchantRandomly(enchantments: ResourceLocation_[]): Internal.FunctionContainer;
        entityProperties(entity: Internal.LootContext$EntityTarget_, properties: Internal.JsonObject_): Internal.ConditionContainer;
        function : Internal.JsonObject;
        conditions : Internal.JsonArray;
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    type ConditionalFunction_ = ConditionalFunction;
    interface LevelWriter {
    }
    type LevelWriter_ = LevelWriter;
    interface FileNameMap {
        getContentTypeFor(arg0: string): string;
    }
    type FileNameMap_ = FileNameMap;
    class ScheduledEvent {
        getServer(): Internal.ServerJS;
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        notifyAll(): void;
        isUsingTicks(): boolean;
        notify(): void;
        getTimerDuration(): number;
        reschedule(): void;
        reschedule(timer: number): Internal.ScheduledEvent;
        getEndTime(): number;
        hashCode(): number;
        equals(arg0: any): boolean;
        toString(): string;
        getTimer(): number;
        getData(): any;
        get server(): Internal.ServerJS;
        get timer(): number;
        get timerDuration(): number;
        get data(): any;
        get usingTicks(): boolean;
        get endTime(): number;
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    type ScheduledEvent_ = ScheduledEvent;
    interface LevelSimulatedReader {
    }
    type LevelSimulatedReader_ = LevelSimulatedReader;
    interface ILootCondition extends Internal.ILootHandler, Internal.Predicate<Internal.LootContext> {
        or(arg0: Internal.Predicate_<Internal.LootContext_>): Internal.Predicate<Internal.LootContext>;
        test(arg0: Internal.LootContext_): boolean;
        and(arg0: Internal.Predicate_<Internal.LootContext_>): Internal.Predicate<Internal.LootContext>;
        negate(): Internal.Predicate<Internal.LootContext>;
        applyLootHandler(arg0: Internal.LootContext_, arg1: Internal.List_<Internal.ItemStack_>): boolean;
    }
    type ILootCondition_ = ILootCondition;
    interface MenuAccess <T> {
    }
    type MenuAccess_<T> = MenuAccess<T>;
    class EntityRenderDispatcher implements Internal.ResourceManagerReloadListener {
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        getSkinMap(): Internal.Map<string, Internal.EntityRenderer<Internal.Player>>;
        hashCode(): number;
        notifyAll(): void;
        equals(arg0: any): boolean;
        toString(): string;
        notify(): void;
        get skinMap(): Internal.Map<string, Internal.EntityRenderer<Internal.Player>>;
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    type EntityRenderDispatcher_ = EntityRenderDispatcher;
    abstract class AbstractTexture implements Internal.AutoCloseable {
        restoreLastBlurMipmap(): void;
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        setBlurMipmap(arg0: boolean, arg1: boolean): void;
        hashCode(): number;
        notifyAll(): void;
        equals(arg0: any): boolean;
        toString(): string;
        close(): void;
        notify(): void;
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    type AbstractTexture_ = AbstractTexture;
    class NetworkEvent extends Internal.Event {
        setCanceled(arg0: boolean): void;
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        getLoginIndex(): number;
        isCanceled(): boolean;
        setResult(arg0: Internal.Event$Result_): void;
        notifyAll(): void;
        hasResult(): boolean;
        notify(): void;
        getPayload(): Internal.FriendlyByteBuf;
        getListenerList(): Internal.ListenerList;
        hashCode(): number;
        getSource(): Internal.Supplier<Internal.NetworkEvent$Context>;
        equals(arg0: any): boolean;
        getResult(): Internal.Event$Result;
        toString(): string;
        isCancelable(): boolean;
        getPhase(): Internal.EventPriority;
        setPhase(arg0: Internal.EventPriority_): void;
        get result(): Internal.Event$Result;
        get phase(): Internal.EventPriority;
        get canceled(): boolean;
        get cancelable(): boolean;
        get loginIndex(): number;
        get payload(): Internal.FriendlyByteBuf;
        get listenerList(): Internal.ListenerList;
        get source(): Internal.Supplier<Internal.NetworkEvent$Context>;
        get class(): Internal.Class<any>;
        set phase(arg0: Internal.EventPriority_);
        set result(arg0: Internal.Event$Result_);
        set canceled(arg0: boolean);
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    type NetworkEvent_ = NetworkEvent;
    class DisplayMode {
        getClass(): Internal.Class<any>;
        getRefreshRate(): number;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        getHeight(): number;
        hashCode(): number;
        notifyAll(): void;
        getBitDepth(): number;
        equals(arg0: Internal.DisplayMode_): boolean;
        equals(arg0: any): boolean;
        toString(): string;
        getWidth(): number;
        notify(): void;
        static readonly BIT_DEPTH_MULTI : -1;
        static readonly REFRESH_RATE_UNKNOWN : 0;
        get refreshRate(): number;
        get bitDepth(): number;
        get width(): number;
        get class(): Internal.Class<any>;
        get height(): number;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    type DisplayMode_ = DisplayMode;
    class Point extends Internal.Point2D implements Internal.Serializable {
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        move(arg0: number, arg1: number): void;
        getLocation(): Internal.Point;
        static distance(arg0: number, arg1: number, arg2: number, arg3: number): number;
        distance(arg0: Internal.Point2D_): number;
        distance(arg0: number, arg1: number): number;
        notifyAll(): void;
        distanceSq(arg0: number, arg1: number): number;
        distanceSq(arg0: Internal.Point2D_): number;
        static distanceSq(arg0: number, arg1: number, arg2: number, arg3: number): number;
        notify(): void;
        translate(arg0: number, arg1: number): void;
        getX(): number;
        getY(): number;
        setLocation(arg0: Internal.Point_): void;
        setLocation(arg0: number, arg1: number): void;
        setLocation(arg0: Internal.Point2D_): void;
        hashCode(): number;
        equals(arg0: any): boolean;
        clone(): any;
        toString(): string;
        x : number;
        y : number;
        get location(): Internal.Point;
        get class(): Internal.Class<any>;
        set location(arg0: Internal.Point_);
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    type Point_ = Point;
    interface Byte2FloatFunction extends Internal.Function<number, number>, Internal.IntToDoubleFunction {
        getOrDefault(arg0: any, arg1: number): number;
        getOrDefault(arg0: number, arg1: number): number;
        applyAsDouble(arg0: number): number;
        andThenShort(arg0: Internal.Float2ShortFunction_): Internal.Byte2ShortFunction;
        composeByte(arg0: Internal.Byte2ByteFunction_): Internal.Byte2FloatFunction;
        andThenInt(arg0: Internal.Float2IntFunction_): Internal.Byte2IntFunction;
        composeReference<T_>(arg0: Internal.Reference2ByteFunction_<T_>): Internal.Reference2FloatFunction<T_>;
        andThen<T_>(arg0: java_.util.function_.Function_<number, T_>): java_.util.function_.Function<number, T_>;
        put(arg0: number, arg1: number): number;
        remove(arg0: number): number;
        remove(arg0: any): number;
        defaultReturnValue(): number;
        defaultReturnValue(arg0: number): void;
        andThenDouble(arg0: Internal.Float2DoubleFunction_): Internal.Byte2DoubleFunction;
        andThenObject<T_>(arg0: Internal.Float2ObjectFunction_<T_>): Internal.Byte2ObjectFunction<T_>;
        get(arg0: any): number;
        get(arg0: number): number;
        andThenLong(arg0: Internal.Float2LongFunction_): Internal.Byte2LongFunction;
        composeLong(arg0: Internal.Long2ByteFunction_): Internal.Long2FloatFunction;
        andThenByte(arg0: Internal.Float2ByteFunction_): Internal.Byte2ByteFunction;
        andThenFloat(arg0: Internal.Float2FloatFunction_): Internal.Byte2FloatFunction;
        apply(arg0: number): number;
        containsKey(arg0: any): boolean;
        containsKey(arg0: number): boolean;
        composeInt(arg0: Internal.Int2ByteFunction_): Internal.Int2FloatFunction;
        clear(): void;
        composeFloat(arg0: Internal.Float2ByteFunction_): Internal.Float2FloatFunction;
        andThenChar(arg0: Internal.Float2CharFunction_): Internal.Byte2CharFunction;
        composeObject<T_>(arg0: Internal.Object2ByteFunction_<T_>): Internal.Object2FloatFunction<T_>;
        size(): number;
        compose<T_>(arg0: java_.util.function_.Function_<T_, number>): java_.util.function_.Function<T_, number>;
        composeShort(arg0: Internal.Short2ByteFunction_): Internal.Short2FloatFunction;
        andThenReference<T_>(arg0: Internal.Float2ReferenceFunction_<T_>): Internal.Byte2ReferenceFunction<T_>;
        composeChar(arg0: Internal.Char2ByteFunction_): Internal.Char2FloatFunction;
        composeDouble(arg0: Internal.Double2ByteFunction_): Internal.Double2FloatFunction;
    }
    type Byte2FloatFunction_ = ((arg0: number) => number) | Byte2FloatFunction;
    interface IIngredientSerializer <T> {
        parse(arg0: Internal.JsonObject_): T;
        parse(arg0: Internal.FriendlyByteBuf_): T;
        write(arg0: Internal.FriendlyByteBuf_, arg1: T): void;
    }
    type IIngredientSerializer_<T> = IIngredientSerializer<T>;
    class RuntimeException extends Internal.Exception {
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        printStackTrace(): void;
        printStackTrace(arg0: Internal.PrintWriter_): void;
        printStackTrace(arg0: Internal.PrintStream_): void;
        getLocalizedMessage(): string;
        notifyAll(): void;
        initCause(arg0: Internal.Throwable_): Internal.Throwable;
        getMessage(): string;
        getCause(): Internal.Throwable;
        notify(): void;
        addSuppressed(arg0: Internal.Throwable_): void;
        setStackTrace(arg0: any_[]): void;
        getStackTrace(): any[];
        hashCode(): number;
        equals(arg0: any): boolean;
        getSuppressed(): Internal.Throwable[];
        toString(): string;
        fillInStackTrace(): Internal.Throwable;
        get localizedMessage(): string;
        get cause(): Internal.Throwable;
        get stackTrace(): any[];
        get suppressed(): Internal.Throwable[];
        get message(): string;
        get class(): Internal.Class<any>;
        set stackTrace(arg0: any_[]);
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    type RuntimeException_ = RuntimeException;
    class VertexFormat$Mode extends Internal.Enum<Internal.VertexFormat$Mode> {
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        static valueOf(arg0: string): Internal.VertexFormat$Mode;
        static valueOf<T_>(arg0: Internal.Class_<T_>, arg1: string): T_;
        notifyAll(): void;
        static values(): Internal.VertexFormat$Mode[];
        compareTo(arg0: Internal.VertexFormat$Mode_): number;
        describeConstable(): Internal.Optional<Internal.Enum$EnumDesc<Internal.VertexFormat$Mode>>;
        notify(): void;
        getDeclaringClass(): Internal.Class<Internal.VertexFormat$Mode>;
        hashCode(): number;
        equals(arg0: any): boolean;
        name(): string;
        toString(): string;
        ordinal(): number;
        static readonly QUADS : Internal.VertexFormat$Mode;
        static readonly TRIANGLE_FAN : Internal.VertexFormat$Mode;
        static readonly DEBUG_LINES : Internal.VertexFormat$Mode;
        static readonly TRIANGLES : Internal.VertexFormat$Mode;
        static readonly DEBUG_LINE_STRIP : Internal.VertexFormat$Mode;
        static readonly LINE_STRIP : Internal.VertexFormat$Mode;
        static readonly LINES : Internal.VertexFormat$Mode;
        static readonly TRIANGLE_STRIP : Internal.VertexFormat$Mode;
        get class(): Internal.Class<any>;
        get declaringClass(): Internal.Class<Internal.VertexFormat$Mode>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    type VertexFormat$Mode_ = "triangles" | "triangle_fan" | "quads" | "line_strip" | "lines" | "debug_line_strip" | "triangle_strip" | "debug_lines" | VertexFormat$Mode;
    interface Float2ShortFunction extends Internal.Function<number, number>, Internal.DoubleToIntFunction {
        getOrDefault(arg0: any, arg1: number): number;
        getOrDefault(arg0: number, arg1: number): number;
        andThenShort(arg0: Internal.Short2ShortFunction_): Internal.Float2ShortFunction;
        composeByte(arg0: Internal.Byte2FloatFunction_): Internal.Byte2ShortFunction;
        andThenInt(arg0: Internal.Short2IntFunction_): Internal.Float2IntFunction;
        composeReference<T_>(arg0: Internal.Reference2FloatFunction_<T_>): Internal.Reference2ShortFunction<T_>;
        andThen<T_>(arg0: java_.util.function_.Function_<number, T_>): java_.util.function_.Function<number, T_>;
        put(arg0: number, arg1: number): number;
        remove(arg0: number): number;
        remove(arg0: any): number;
        defaultReturnValue(): number;
        defaultReturnValue(arg0: number): void;
        andThenDouble(arg0: Internal.Short2DoubleFunction_): Internal.Float2DoubleFunction;
        andThenObject<T_>(arg0: Internal.Short2ObjectFunction_<T_>): Internal.Float2ObjectFunction<T_>;
        get(arg0: any): number;
        get(arg0: number): number;
        andThenLong(arg0: Internal.Short2LongFunction_): Internal.Float2LongFunction;
        composeLong(arg0: Internal.Long2FloatFunction_): Internal.Long2ShortFunction;
        andThenByte(arg0: Internal.Short2ByteFunction_): Internal.Float2ByteFunction;
        andThenFloat(arg0: Internal.Short2FloatFunction_): Internal.Float2FloatFunction;
        applyAsInt(arg0: number): number;
        apply(arg0: number): number;
        containsKey(arg0: any): boolean;
        containsKey(arg0: number): boolean;
        composeInt(arg0: Internal.Int2FloatFunction_): Internal.Int2ShortFunction;
        clear(): void;
        composeFloat(arg0: Internal.Float2FloatFunction_): Internal.Float2ShortFunction;
        andThenChar(arg0: Internal.Short2CharFunction_): Internal.Float2CharFunction;
        composeObject<T_>(arg0: Internal.Object2FloatFunction_<T_>): Internal.Object2ShortFunction<T_>;
        size(): number;
        compose<T_>(arg0: java_.util.function_.Function_<T_, number>): java_.util.function_.Function<T_, number>;
        composeShort(arg0: Internal.Short2FloatFunction_): Internal.Short2ShortFunction;
        andThenReference<T_>(arg0: Internal.Short2ReferenceFunction_<T_>): Internal.Float2ReferenceFunction<T_>;
        composeChar(arg0: Internal.Char2FloatFunction_): Internal.Char2ShortFunction;
        composeDouble(arg0: Internal.Double2FloatFunction_): Internal.Double2ShortFunction;
    }
    type Float2ShortFunction_ = ((arg0: number) => number) | Float2ShortFunction;
    abstract class Clock implements Internal.InstantSource {
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        withZone(arg0: Internal.ZoneId_): Internal.Clock;
        static tickMinutes(arg0: Internal.ZoneId_): Internal.Clock;
        static tickMillis(arg0: Internal.ZoneId_): Internal.Clock;
        static offset(arg0: Internal.Clock_, arg1: Internal.Duration_): Internal.Clock;
        notifyAll(): void;
        getZone(): Internal.ZoneId;
        static tick(arg0: Internal.Clock_, arg1: Internal.Duration_): Internal.Clock;
        notify(): void;
        instant(): Internal.Instant;
        static system(arg0: Internal.ZoneId_): Internal.Clock;
        hashCode(): number;
        equals(arg0: any): boolean;
        static tickSeconds(arg0: Internal.ZoneId_): Internal.Clock;
        static systemDefaultZone(): Internal.Clock;
        static systemUTC(): Internal.Clock;
        toString(): string;
        static fixed(arg0: Internal.Instant_, arg1: Internal.ZoneId_): Internal.Clock;
        millis(): number;
        get zone(): Internal.ZoneId;
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    type Clock_ = Clock;
    class ModelGenerator$Element {
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        face(direction: Internal.Direction_, consumer: Internal.Consumer_<Internal.ModelGenerator$Face_>): void;
        toJson(): Internal.JsonObject;
        hashCode(): number;
        notifyAll(): void;
        equals(arg0: any): boolean;
        toString(): string;
        box(b: Internal.AABB_): Internal.ModelGenerator$Element;
        notify(): void;
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    type ModelGenerator$Element_ = ModelGenerator$Element;
    interface ByteCollection extends Internal.Collection<number>, Internal.ByteIterable {
        intIterator(): Internal.IntIterator;
        intSpliterator(): Internal.IntSpliterator;
        remove(arg0: any): boolean;
        intStream(): Internal.IntStream;
        removeAll(arg0: Internal.ByteCollection_): boolean;
        removeAll(arg0: Internal.Collection_<any>): boolean;
        iterator(): Internal.ByteIterator;
        stream(): Internal.Stream<number>;
        hashCode(): number;
        toArray(arg0: number[]): number[];
        toArray<T_>(arg0: T_[]): T_[];
        toArray<T_>(arg0: Internal.IntFunction_<T_[]>): T_[];
        toArray(): any[];
        parallelStream(): Internal.Stream<number>;
        rem(arg0: number): boolean;
        add(arg0: number): boolean;
        spliterator(): Internal.ByteSpliterator;
        forEach(arg0: Internal.Consumer_<number>): void;
        forEach(arg0: Internal.ByteConsumer_): void;
        forEach(arg0: java_.util.function_.IntConsumer_): void;
        containsAll(arg0: Internal.ByteCollection_): boolean;
        containsAll(arg0: Internal.Collection_<any>): boolean;
        isEmpty(): boolean;
        clear(): void;
        removeIf(arg0: Internal.Predicate_<number>): boolean;
        removeIf(arg0: Internal.BytePredicate_): boolean;
        removeIf(arg0: java_.util.function_.IntPredicate_): boolean;
        contains(arg0: any): boolean;
        contains(arg0: number): boolean;
        size(): number;
        addAll(arg0: Internal.ByteCollection_): boolean;
        addAll(arg0: Internal.Collection_<number>): boolean;
        equals(arg0: any): boolean;
        toByteArray(): number[];
        toByteArray(arg0: number[]): number[];
        intParallelStream(): Internal.IntStream;
        retainAll(arg0: Internal.ByteCollection_): boolean;
        retainAll(arg0: Internal.Collection_<any>): boolean;
    }
    type ByteCollection_ = ByteCollection;
    class Object2LongEntry implements Internal.Comparable<Internal.Object2LongEntry> {
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        hashCode(): number;
        notifyAll(): void;
        equals(arg0: any): boolean;
        toString(): string;
        compareTo(o: Internal.Object2LongEntry_): number;
        notify(): void;
        readonly value : number;
        readonly key : any;
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    type Object2LongEntry_ = Object2LongEntry;
    interface Reference2ByteFunction <K> extends Internal.Function<K, number>, Internal.ToIntFunction<K> {
        getOrDefault(arg0: any, arg1: number): number;
        getByte(arg0: any): number;
        andThenShort(arg0: Internal.Byte2ShortFunction_): Internal.Reference2ShortFunction<K>;
        composeByte(arg0: Internal.Byte2ReferenceFunction_<K>): Internal.Byte2ByteFunction;
        andThenInt(arg0: Internal.Byte2IntFunction_): Internal.Reference2IntFunction<K>;
        composeReference<T_>(arg0: Internal.Reference2ReferenceFunction_<T_, K>): Internal.Reference2ByteFunction<T_>;
        andThen<T_>(arg0: java_.util.function_.Function_<number, T_>): java_.util.function_.Function<K, T_>;
        put(arg0: K, arg1: number): number;
        remove(arg0: any): number;
        defaultReturnValue(): number;
        defaultReturnValue(arg0: number): void;
        andThenDouble(arg0: Internal.Byte2DoubleFunction_): Internal.Reference2DoubleFunction<K>;
        andThenObject<T_>(arg0: Internal.Byte2ObjectFunction_<T_>): Internal.Reference2ObjectFunction<K, T_>;
        get(arg0: any): number;
        andThenLong(arg0: Internal.Byte2LongFunction_): Internal.Reference2LongFunction<K>;
        composeLong(arg0: Internal.Long2ReferenceFunction_<K>): Internal.Long2ByteFunction;
        removeByte(arg0: any): number;
        andThenByte(arg0: Internal.Byte2ByteFunction_): Internal.Reference2ByteFunction<K>;
        andThenFloat(arg0: Internal.Byte2FloatFunction_): Internal.Reference2FloatFunction<K>;
        applyAsInt(arg0: K): number;
        apply(arg0: K): number;
        containsKey(arg0: any): boolean;
        composeInt(arg0: Internal.Int2ReferenceFunction_<K>): Internal.Int2ByteFunction;
        clear(): void;
        composeFloat(arg0: Internal.Float2ReferenceFunction_<K>): Internal.Float2ByteFunction;
        andThenChar(arg0: Internal.Byte2CharFunction_): Internal.Reference2CharFunction<K>;
        composeObject<T_>(arg0: Internal.Object2ReferenceFunction_<T_, K>): Internal.Object2ByteFunction<T_>;
        size(): number;
        compose<V_>(arg0: java_.util.function_.Function_<V_, K>): java_.util.function_.Function<V_, number>;
        composeShort(arg0: Internal.Short2ReferenceFunction_<K>): Internal.Short2ByteFunction;
        andThenReference<T_>(arg0: Internal.Byte2ReferenceFunction_<T_>): Internal.Reference2ReferenceFunction<K, T_>;
        composeChar(arg0: Internal.Char2ReferenceFunction_<K>): Internal.Char2ByteFunction;
        composeDouble(arg0: Internal.Double2ReferenceFunction_<K>): Internal.Double2ByteFunction;
    }
    type Reference2ByteFunction_<K> = ((arg0: any) => number) | Reference2ByteFunction<K>;
    class NameMap$Builder <T> {
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        color(p: java_.util.function_.Function_<T, Internal.Color4I_>): Internal.NameMap$Builder<T>;
        notifyAll(): void;
        icon(p: java_.util.function_.Function_<T, Internal.Icon_>): Internal.NameMap$Builder<T>;
        notify(): void;
        baseNameKey(key: string): Internal.NameMap$Builder<T>;
        hashCode(): number;
        nameKey(p: java_.util.function_.Function_<T, string>): Internal.NameMap$Builder<T>;
        equals(arg0: any): boolean;
        name(p: java_.util.function_.Function_<T, Internal.Component_>): Internal.NameMap$Builder<T>;
        create(): Internal.NameMap<T>;
        toString(): string;
        id(p: java_.util.function_.Function_<T, string>): Internal.NameMap$Builder<T>;
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    type NameMap$Builder_<T> = NameMap$Builder<T>;
    interface Double2ObjectFunction <V> extends Internal.Function<number, V>, Internal.DoubleFunction<V> {
        getOrDefault(arg0: number, arg1: V): V;
        getOrDefault(arg0: any, arg1: V): V;
        andThenShort(arg0: Internal.Object2ShortFunction_<V>): Internal.Double2ShortFunction;
        composeByte(arg0: Internal.Byte2DoubleFunction_): Internal.Byte2ObjectFunction<V>;
        andThenInt(arg0: Internal.Object2IntFunction_<V>): Internal.Double2IntFunction;
        andThen<V_>(arg0: java_.util.function_.Function_<V, V_>): java_.util.function_.Function<number, V_>;
        composeReference<T_>(arg0: Internal.Reference2DoubleFunction_<T_>): Internal.Reference2ObjectFunction<T_, V>;
        put(arg0: number, arg1: V): V;
        remove(arg0: any): V;
        remove(arg0: number): V;
        defaultReturnValue(arg0: V): void;
        defaultReturnValue(): V;
        andThenDouble(arg0: Internal.Object2DoubleFunction_<V>): Internal.Double2DoubleFunction;
        andThenObject<T_>(arg0: Internal.Object2ObjectFunction_<V, T_>): Internal.Double2ObjectFunction<T_>;
        get(arg0: any): V;
        get(arg0: number): V;
        andThenLong(arg0: Internal.Object2LongFunction_<V>): Internal.Double2LongFunction;
        composeLong(arg0: Internal.Long2DoubleFunction_): Internal.Long2ObjectFunction<V>;
        andThenByte(arg0: Internal.Object2ByteFunction_<V>): Internal.Double2ByteFunction;
        andThenFloat(arg0: Internal.Object2FloatFunction_<V>): Internal.Double2FloatFunction;
        apply(arg0: number): V;
        containsKey(arg0: any): boolean;
        containsKey(arg0: number): boolean;
        composeInt(arg0: Internal.Int2DoubleFunction_): Internal.Int2ObjectFunction<V>;
        clear(): void;
        composeFloat(arg0: Internal.Float2DoubleFunction_): Internal.Float2ObjectFunction<V>;
        andThenChar(arg0: Internal.Object2CharFunction_<V>): Internal.Double2CharFunction;
        composeObject<T_>(arg0: Internal.Object2DoubleFunction_<T_>): Internal.Object2ObjectFunction<T_, V>;
        size(): number;
        compose<T_>(arg0: java_.util.function_.Function_<T_, number>): java_.util.function_.Function<T_, V>;
        composeShort(arg0: Internal.Short2DoubleFunction_): Internal.Short2ObjectFunction<V>;
        andThenReference<T_>(arg0: Internal.Object2ReferenceFunction_<V, T_>): Internal.Double2ReferenceFunction<T_>;
        composeChar(arg0: Internal.Char2DoubleFunction_): Internal.Char2ObjectFunction<V>;
        composeDouble(arg0: Internal.Double2DoubleFunction_): Internal.Double2ObjectFunction<V>;
    }
    type Double2ObjectFunction_<V> = ((arg0: number) => V) | Double2ObjectFunction<V>;
    interface Collector <T, A, R> {
        characteristics(): Internal.Set<Internal.Collector$Characteristics>;
        supplier(): Internal.Supplier<A>;
        finisher(): java_.util.function_.Function<A, R>;
        accumulator(): Internal.BiConsumer<A, T>;
        combiner(): Internal.BinaryOperator<A>;
    }
    type Collector_<T, A, R> = Collector<T, A, R>;
    /**
    * Fired when player right clicks on an Block that is not fluid.
    *
    * Note that both main hand and off hand will be called if not cancelled.
    *
    * On cancellation, Result.SUCCESS is returned, thus making player swing his arm.
    */
    class BlockRightClickEventJS extends Internal.PlayerEventJS {
        cancel(): void;
        getServer(): Internal.ServerJS;
        getClass(): Internal.Class<any>;
        addGameStage(stage: string): void;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        isCancelled(): boolean;
        getPlayer(): Internal.PlayerJS<any>;
        getBlock(): Internal.BlockContainerJS;
        getHand(): Hand;
        notifyAll(): void;
        getItem(): Internal.ItemStackJS;
        getEntity(): Internal.EntityJS;
        notify(): void;
        getLevel(): Internal.LevelJS;
        getMinecraftPlayer(): Internal.Player;
        post(id: string): boolean;
        post(id: string, sub: string): boolean;
        post(t: Internal.ScriptType_, id: string, sub: string): boolean;
        post(t: Internal.ScriptType_, id: string): boolean;
        hasGameStage(stage: string): boolean;
        hashCode(): number;
        equals(arg0: any): boolean;
        removeGameStage(stage: string): void;
        toString(): string;
        getFacing(): Internal.Direction;
        canCancel(): boolean;
        get server(): Internal.ServerJS;
        get item(): Internal.ItemStackJS;
        get level(): Internal.LevelJS;
        get minecraftPlayer(): Internal.Player;
        get cancelled(): boolean;
        get facing(): Internal.Direction;
        get block(): Internal.BlockContainerJS;
        get class(): Internal.Class<any>;
        get entity(): Internal.EntityJS;
        get player(): Internal.PlayerJS<any>;
        get hand(): Hand;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    /**
    * Fired when player right clicks on an Block that is not fluid.
    *
    * Note that both main hand and off hand will be called if not cancelled.
    *
    * On cancellation, Result.SUCCESS is returned, thus making player swing his arm.
    */
    type BlockRightClickEventJS_ = BlockRightClickEventJS;
    interface Composite {
        createContext(arg0: Internal.ColorModel_, arg1: Internal.ColorModel_, arg2: Internal.RenderingHints_): Internal.CompositeContext;
    }
    type Composite_ = Composite;
    class ParticleTypeBuilder extends Internal.BuilderBase<Internal.ParticleType<any>> {
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        clientRegistry(minecraft: Internal.Minecraft_): void;
        generateAssetJsons(generator: Internal.AssetJsonGenerator_): void;
        transformObject(obj: Internal.ParticleType_<any>): Internal.ParticleType<any>;
        translationKey(key: string): Internal.BuilderBase<Internal.ParticleType<any>>;
        getTranslationKeyGroup(): string;
        newID(pre: string, post: string): ResourceLocation;
        displayName(name: string): Internal.BuilderBase<Internal.ParticleType<any>>;
        notifyAll(): void;
        generateLang(lang: Internal.Map_<string, string>): void;
        deserializer(d: Internal.ParticleOptions$Deserializer_<any>): Internal.ParticleTypeBuilder;
        type(type: string): Internal.BuilderBase<Internal.ParticleType<any>>;
        notify(): void;
        createAdditionalObjects(): void;
        createObject(): Internal.ParticleType<any>;
        overrideLimiter(o: boolean): Internal.ParticleTypeBuilder;
        addResourcePackLocations(path: string, list: Internal.List_<ResourceLocation_>, packType: Internal.PackType_): void;
        hashCode(): number;
        equals(arg0: any): boolean;
        get(): Internal.ParticleType<any>;
        getRegistryType(): Internal.RegistryObjectBuilderTypes<Internal.ParticleType<any>>;
        toString(): string;
        tag(tag: ResourceLocation_): Internal.BuilderBase<Internal.ParticleType<any>>;
        generateDataJsons(generator: Internal.DataJsonGenerator_): void;
        readonly id : ResourceLocation;
        get registryType(): Internal.RegistryObjectBuilderTypes<Internal.ParticleType<any>>;
        get class(): Internal.Class<any>;
        get translationKeyGroup(): string;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    type ParticleTypeBuilder_ = ParticleTypeBuilder;
    interface Multimap <K, V> {
        containsEntry(arg0: any, arg1: any): boolean;
        asMap(): Internal.Map<K, Internal.Collection<V>>;
        keys(): Internal.Multiset<K>;
        containsKey(arg0: any): boolean;
        forEach(arg0: Internal.BiConsumer_<K, V>): void;
        values(): Internal.Collection<V>;
        isEmpty(): boolean;
        clear(): void;
        replaceValues(arg0: K, arg1: Internal.Iterable_<V>): Internal.Collection<V>;
        containsValue(arg0: any): boolean;
        put(arg0: K, arg1: V): boolean;
        remove(arg0: any, arg1: any): boolean;
        removeAll(arg0: any): Internal.Collection<V>;
        entries(): Internal.Collection<Internal.Map$Entry<K, V>>;
        size(): number;
        hashCode(): number;
        putAll(arg0: Internal.Multimap_<K, V>): boolean;
        putAll(arg0: K, arg1: Internal.Iterable_<V>): boolean;
        equals(arg0: any): boolean;
        get(arg0: K): Internal.Collection<V>;
        keySet(): Internal.Set<K>;
    }
    type Multimap_<K, V> = Multimap<K, V>;
    interface FunctionContainer {
        lootingEnchant(count: Internal.NumberProvider_, limit: number): Internal.FunctionContainer;
        enchantWithLevels(levels: Internal.NumberProvider_, treasure: boolean): Internal.FunctionContainer;
        damage(damage: Internal.NumberProvider_): Internal.FunctionContainer;
        nbt(tag: Internal.CompoundTag_): Internal.FunctionContainer;
        lootTable(table: ResourceLocation_, seed: number): Internal.FunctionContainer;
        copyName(source: Internal.CopyNameFunction$NameSource_): Internal.FunctionContainer;
        addFunction(arg0: Internal.JsonObject_): Internal.FunctionContainer;
        count(count: Internal.NumberProvider_): Internal.FunctionContainer;
        name(name: Internal.Text_, entity: Internal.LootContext$EntityTarget_): Internal.FunctionContainer;
        name(name: Internal.Text_): Internal.FunctionContainer;
        furnaceSmelt(): Internal.FunctionContainer;
        addConditionalFunction(func: Internal.Consumer_<Internal.ConditionalFunction_>): Internal.FunctionContainer;
        enchantRandomly(enchantments: ResourceLocation_[]): Internal.FunctionContainer;
    }
    type FunctionContainer_ = FunctionContainer;
    interface Object2ShortFunction <K> extends Internal.Function<K, number>, Internal.ToIntFunction<K> {
        getOrDefault(arg0: any, arg1: number): number;
        andThenShort(arg0: Internal.Short2ShortFunction_): Internal.Object2ShortFunction<K>;
        composeByte(arg0: Internal.Byte2ObjectFunction_<K>): Internal.Byte2ShortFunction;
        removeShort(arg0: any): number;
        andThenInt(arg0: Internal.Short2IntFunction_): Internal.Object2IntFunction<K>;
        composeReference<T_>(arg0: Internal.Reference2ObjectFunction_<T_, K>): Internal.Reference2ShortFunction<T_>;
        andThen<T_>(arg0: java_.util.function_.Function_<number, T_>): java_.util.function_.Function<K, T_>;
        put(arg0: K, arg1: number): number;
        remove(arg0: any): number;
        defaultReturnValue(): number;
        defaultReturnValue(arg0: number): void;
        andThenDouble(arg0: Internal.Short2DoubleFunction_): Internal.Object2DoubleFunction<K>;
        andThenObject<T_>(arg0: Internal.Short2ObjectFunction_<T_>): Internal.Object2ObjectFunction<K, T_>;
        get(arg0: any): number;
        andThenLong(arg0: Internal.Short2LongFunction_): Internal.Object2LongFunction<K>;
        composeLong(arg0: Internal.Long2ObjectFunction_<K>): Internal.Long2ShortFunction;
        andThenByte(arg0: Internal.Short2ByteFunction_): Internal.Object2ByteFunction<K>;
        andThenFloat(arg0: Internal.Short2FloatFunction_): Internal.Object2FloatFunction<K>;
        applyAsInt(arg0: K): number;
        apply(arg0: K): number;
        getShort(arg0: any): number;
        containsKey(arg0: any): boolean;
        composeInt(arg0: Internal.Int2ObjectFunction_<K>): Internal.Int2ShortFunction;
        clear(): void;
        composeFloat(arg0: Internal.Float2ObjectFunction_<K>): Internal.Float2ShortFunction;
        andThenChar(arg0: Internal.Short2CharFunction_): Internal.Object2CharFunction<K>;
        composeObject<T_>(arg0: Internal.Object2ObjectFunction_<T_, K>): Internal.Object2ShortFunction<T_>;
        size(): number;
        compose<V_>(arg0: java_.util.function_.Function_<V_, K>): java_.util.function_.Function<V_, number>;
        composeShort(arg0: Internal.Short2ObjectFunction_<K>): Internal.Short2ShortFunction;
        andThenReference<T_>(arg0: Internal.Short2ReferenceFunction_<T_>): Internal.Object2ReferenceFunction<K, T_>;
        composeChar(arg0: Internal.Char2ObjectFunction_<K>): Internal.Char2ShortFunction;
        composeDouble(arg0: Internal.Double2ObjectFunction_<K>): Internal.Double2ShortFunction;
    }
    type Object2ShortFunction_<K> = ((arg0: any) => number) | Object2ShortFunction<K>;
    class ResolvedModule {
        reference(): Internal.ModuleReference;
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        configuration(): Internal.Configuration;
        hashCode(): number;
        notifyAll(): void;
        equals(arg0: any): boolean;
        reads(): Internal.Set<Internal.ResolvedModule>;
        name(): string;
        toString(): string;
        notify(): void;
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    type ResolvedModule_ = ResolvedModule;
    class BufferBuilder$DrawState {
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        hashCode(): number;
        notifyAll(): void;
        equals(arg0: any): boolean;
        toString(): string;
        notify(): void;
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    type BufferBuilder$DrawState_ = BufferBuilder$DrawState;
    interface TemporalUnit {
        isDurationEstimated(): boolean;
        getDuration(): Internal.Duration;
        isTimeBased(): boolean;
        addTo<R>(arg0: R, arg1: number): R;
        toString(): string;
        isDateBased(): boolean;
        between(arg0: Internal.Temporal_, arg1: Internal.Temporal_): number;
        isSupportedBy(arg0: Internal.Temporal_): boolean;
    }
    type TemporalUnit_ = TemporalUnit;
    abstract class Level extends Internal.CapabilityProvider<Internal.Level> implements Internal.LevelAccessor, Internal.AutoCloseable, Internal.IForgeLevel, Internal.LevelKJS {
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        getCapability<T_>(arg0: Internal.Capability_<T_>, arg1: Internal.Direction_): Internal.LazyOptional<T_>;
        getCapability<T_>(arg0: Internal.Capability_<T_>): Internal.LazyOptional<T_>;
        notifyAll(): void;
        areCapsCompatible(arg0: Internal.CapabilityProvider_<Internal.Level_>): boolean;
        areCapsCompatible(arg0: Internal.CapabilityDispatcher_): boolean;
        getMaxEntityRadius(): number;
        addFreshBlockEntities(arg0: Internal.Collection_<Internal.BlockEntity_>): void;
        asKJS(): any;
        notify(): void;
        reviveCaps(): void;
        markAndNotifyBlock(arg0: BlockPos_, arg1: Internal.LevelChunk_, arg2: Internal.BlockState_, arg3: Internal.BlockState_, arg4: number, arg5: number): void;
        redirect$zoc000$redirectTick(blockEntity: Internal.TickingBlockEntity_): void;
        invalidateCaps(): void;
        hashCode(): number;
        increaseMaxEntityRadius(arg0: number): number;
        equals(arg0: any): boolean;
        getExistingBlockEntity(arg0: BlockPos_): Internal.BlockEntity;
        isAreaLoaded(arg0: BlockPos_, arg1: number): boolean;
        toString(): string;
        close(): void;
        restoringBlockSnapshots : boolean;
        capturedBlockSnapshots : Internal.ArrayList<Internal.BlockSnapshot>;
        captureBlockSnapshots : boolean;
        get maxEntityRadius(): number;
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    type Level_ = Level;
    interface CommentedConfig$Entry extends Internal.Config$Entry, Internal.UnmodifiableCommentedConfig$Entry {
        getShortOrElse(arg0: number): number;
        getKey(): string;
        getByte(): number;
        getShort(): number;
        getOptionalInt(): Internal.OptionalInt;
        getRawValue<T_>(): T_;
        getCharOrElse(arg0: string): string;
        getLongOrElse(arg0: number): number;
        getByteOrElse(arg0: number): number;
        getLong(): number;
        getValue<T_>(): T_;
        getInt(): number;
        getChar(): string;
        getOptional<T_>(): Internal.Optional<T_>;
        isNull(): boolean;
        setValue<T_>(arg0: any): T_;
        setComment(arg0: string): string;
        getComment(): string;
        getOrElse<T_>(arg0: T_): T_;
        getIntOrElse(arg0: number): number;
        removeComment(): string;
        getOptionalLong(): Internal.OptionalLong;
    }
    type CommentedConfig$Entry_ = CommentedConfig$Entry;
    class Chapter extends Internal.QuestObject {
        getClass(): Internal.Class<any>;
        getIndex(): number;
        getMutableTitle(): Internal.MutableComponent;
        getTags(): Internal.Set<string>;
        static getCodeString(object: Internal.QuestObjectBase_): string;
        getCodeString(): string;
        static getCodeString(id: number): string;
        writeData(nbt: Internal.CompoundTag_): void;
        createSubGroup(group: Internal.ConfigGroup_): Internal.ConfigGroup;
        editedFromGUIOnServer(): void;
        forceProgress(teamData: Internal.TeamData_, progressChange: Internal.ProgressChange_): void;
        isCompletedRaw(data: Internal.TeamData_): boolean;
        getTitle(): Internal.Component;
        hasGroup(): boolean;
        getPath(): string;
        clearCachedData(): void;
        editedFromGUI(): void;
        static parseCodeString(id: string): number;
        readData(nbt: Internal.CompoundTag_): void;
        hasTag(tag: string): boolean;
        onCompleted(data: Internal.QuestProgressEventData_<any>): void;
        static getID(object: Internal.QuestObjectBase_): number;
        isVisible(data: Internal.TeamData_): boolean;
        onEditButtonClicked(gui: Internal.Runnable_): void;
        getChildren(): Internal.Collection<Internal.QuestObject>;
        onStarted(data: Internal.QuestProgressEventData_<any>): void;
        getAltTitle(): Internal.MutableComponent;
        deleteSelf(): void;
        cacheProgress(): boolean;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        deleteChildren(): void;
        readNetData(buffer: Internal.FriendlyByteBuf_): void;
        notifyAll(): void;
        getDefaultQuestShape(): string;
        notify(): void;
        getRelativeProgressFromChildren(data: Internal.TeamData_): number;
        static getRelativeProgressFromChildren(progressSum: number, count: number): number;
        hashCode(): number;
        getAltIcon(): Internal.Icon;
        getObjectType(): Internal.QuestObjectType;
        hasUnclaimedRewardsRaw(teamData: Internal.TeamData_, player: Internal.UUID_): boolean;
        getParentID(): number;
        getProgressColor(data: Internal.TeamData_, dim: boolean): Internal.Color4I;
        getProgressColor(data: Internal.TeamData_): Internal.Color4I;
        refreshJEI(): number;
        getQuestChapter(): Internal.Chapter;
        getQuestFile(): Internal.QuestFile;
        writeNetData(buffer: Internal.FriendlyByteBuf_): void;
        getConfig(config: Internal.ConfigGroup_): void;
        getIcon(): Internal.Icon;
        forceProgressRaw(teamData: Internal.TeamData_, progressChange: Internal.ProgressChange_): void;
        getFilename(): string;
        static isNull(object: Internal.QuestObjectBase_): boolean;
        equals(object: any): boolean;
        toString(): string;
        static titleToID(s: string): Internal.Optional<string>;
        onCreated(): void;
        disableToast : boolean;
        readonly images : Internal.List<Internal.ChapterImage>;
        readonly quests : Internal.List<Internal.Quest>;
        alwaysInvisible : boolean;
        icon : Internal.ItemStack;
        title : string;
        defaultQuestShape : string;
        readonly file : Internal.QuestFile;
        filename : string;
        readonly subtitle : Internal.List<string>;
        invalid : boolean;
        defaultHideDependencyLines : boolean;
        static sendNotifications : Internal.Tristate;
        id : number;
        group : Internal.ChapterGroup;
        get codeString(): string;
        get index(): number;
        get questFile(): Internal.QuestFile;
        get parentID(): number;
        get mutableTitle(): Internal.MutableComponent;
        get tags(): Internal.Set<string>;
        get altIcon(): Internal.Icon;
        get objectType(): Internal.QuestObjectType;
        get path(): string;
        get children(): Internal.Collection<Internal.QuestObject>;
        get altTitle(): Internal.MutableComponent;
        get class(): Internal.Class<any>;
        get questChapter(): Internal.Chapter;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    type Chapter_ = Chapter;
    interface SetMultimap <K, V> extends Internal.Multimap<K, V> {
        containsEntry(arg0: any, arg1: any): boolean;
        keys(): Internal.Multiset<K>;
        containsKey(arg0: any): boolean;
        forEach(arg0: Internal.BiConsumer_<K, V>): void;
        asMap(): Internal.Map<K, Internal.Collection<V>>;
        values(): Internal.Collection<V>;
        isEmpty(): boolean;
        clear(): void;
        replaceValues(arg0: K, arg1: Internal.Iterable_<V>): Internal.Set<V>;
        containsValue(arg0: any): boolean;
        put(arg0: K, arg1: V): boolean;
        remove(arg0: any, arg1: any): boolean;
        removeAll(arg0: any): Internal.Set<V>;
        entries(): Internal.Set<Internal.Map$Entry<K, V>>;
        size(): number;
        hashCode(): number;
        putAll(arg0: Internal.Multimap_<K, V>): boolean;
        putAll(arg0: K, arg1: Internal.Iterable_<V>): boolean;
        equals(arg0: any): boolean;
        get(arg0: K): Internal.Set<V>;
        keySet(): Internal.Set<K>;
    }
    type SetMultimap_<K, V> = SetMultimap<K, V>;
    abstract class Graphics2D extends Internal.Graphics {
        getClass(): Internal.Class<any>;
        rotate(arg0: number, arg1: number, arg2: number): void;
        rotate(arg0: number): void;
        drawOval(arg0: number, arg1: number, arg2: number, arg3: number): void;
        getRenderingHint(arg0: Internal.RenderingHints$Key_): any;
        drawRenderableImage(arg0: Internal.RenderableImage_, arg1: Internal.AffineTransform_): void;
        fillRect(arg0: number, arg1: number, arg2: number, arg3: number): void;
        translate(arg0: number, arg1: number): void;
        hit(arg0: Internal.Rectangle_, arg1: Internal.Shape_, arg2: boolean): boolean;
        getDeviceConfiguration(): Internal.GraphicsConfiguration;
        fillPolygon(arg0: number[], arg1: number[], arg2: number): void;
        fillPolygon(arg0: Internal.Polygon_): void;
        getClipBounds(arg0: Internal.Rectangle_): Internal.Rectangle;
        getClipBounds(): Internal.Rectangle;
        drawRoundRect(arg0: number, arg1: number, arg2: number, arg3: number, arg4: number, arg5: number): void;
        setComposite(arg0: Internal.Composite_): void;
        create(arg0: number, arg1: number, arg2: number, arg3: number): Internal.Graphics;
        create(): Internal.Graphics;
        setClip(arg0: number, arg1: number, arg2: number, arg3: number): void;
        setClip(arg0: Internal.Shape_): void;
        setFont(arg0: Internal.Font_): void;
        setStroke(arg0: Internal.Stroke_): void;
        drawPolyline(arg0: number[], arg1: number[], arg2: number): void;
        getTransform(): Internal.AffineTransform;
        setPaint(arg0: Internal.Paint_): void;
        setRenderingHint(arg0: Internal.RenderingHints$Key_, arg1: any): void;
        fill(arg0: Internal.Shape_): void;
        drawBytes(arg0: number[], arg1: number, arg2: number, arg3: number, arg4: number): void;
        getComposite(): Internal.Composite;
        hitClip(arg0: number, arg1: number, arg2: number, arg3: number): boolean;
        getClip(): Internal.Shape;
        getFont(): Internal.Font;
        dispose(): void;
        addRenderingHints(arg0: Internal.Map_<any, any>): void;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        getStroke(): Internal.Stroke;
        fillArc(arg0: number, arg1: number, arg2: number, arg3: number, arg4: number, arg5: number): void;
        drawRenderedImage(arg0: Internal.RenderedImage_, arg1: Internal.AffineTransform_): void;
        notifyAll(): void;
        getClipRect(): Internal.Rectangle;
        getRenderingHints(): Internal.RenderingHints;
        scale(arg0: number, arg1: number): void;
        setBackground(arg0: java_.awt.Color_): void;
        notify(): void;
        drawString(arg0: Internal.AttributedCharacterIterator_, arg1: number, arg2: number): void;
        drawString(arg0: string, arg1: number, arg2: number): void;
        getFontMetrics(arg0: Internal.Font_): Internal.FontMetrics;
        getFontMetrics(): Internal.FontMetrics;
        transform(arg0: Internal.AffineTransform_): void;
        draw3DRect(arg0: number, arg1: number, arg2: number, arg3: number, arg4: boolean): void;
        setTransform(arg0: Internal.AffineTransform_): void;
        drawGlyphVector(arg0: Internal.GlyphVector_, arg1: number, arg2: number): void;
        hashCode(): number;
        drawChars(arg0: string[], arg1: number, arg2: number, arg3: number, arg4: number): void;
        getFontRenderContext(): Internal.FontRenderContext;
        fill3DRect(arg0: number, arg1: number, arg2: number, arg3: number, arg4: boolean): void;
        getPaint(): Internal.Paint;
        fillRoundRect(arg0: number, arg1: number, arg2: number, arg3: number, arg4: number, arg5: number): void;
        shear(arg0: number, arg1: number): void;
        clipRect(arg0: number, arg1: number, arg2: number, arg3: number): void;
        getColor(): java_.awt.Color;
        drawLine(arg0: number, arg1: number, arg2: number, arg3: number): void;
        drawArc(arg0: number, arg1: number, arg2: number, arg3: number, arg4: number, arg5: number): void;
        draw(arg0: Internal.Shape_): void;
        copyArea(arg0: number, arg1: number, arg2: number, arg3: number, arg4: number, arg5: number): void;
        clearRect(arg0: number, arg1: number, arg2: number, arg3: number): void;
        setPaintMode(): void;
        drawImage(arg0: Internal.Image_, arg1: Internal.AffineTransform_, arg2: Internal.ImageObserver_): boolean;
        drawImage(arg0: Internal.BufferedImage_, arg1: Internal.BufferedImageOp_, arg2: number, arg3: number): void;
        drawImage(arg0: Internal.Image_, arg1: number, arg2: number, arg3: number, arg4: number, arg5: Internal.ImageObserver_): boolean;
        drawImage(arg0: Internal.Image_, arg1: number, arg2: number, arg3: java_.awt.Color_, arg4: Internal.ImageObserver_): boolean;
        drawImage(arg0: Internal.Image_, arg1: number, arg2: number, arg3: Internal.ImageObserver_): boolean;
        drawImage(arg0: Internal.Image_, arg1: number, arg2: number, arg3: number, arg4: number, arg5: number, arg6: number, arg7: number, arg8: number, arg9: java_.awt.Color_, arg10: Internal.ImageObserver_): boolean;
        drawImage(arg0: Internal.Image_, arg1: number, arg2: number, arg3: number, arg4: number, arg5: java_.awt.Color_, arg6: Internal.ImageObserver_): boolean;
        drawImage(arg0: Internal.Image_, arg1: number, arg2: number, arg3: number, arg4: number, arg5: number, arg6: number, arg7: number, arg8: number, arg9: Internal.ImageObserver_): boolean;
        setColor(arg0: java_.awt.Color_): void;
        equals(arg0: any): boolean;
        setRenderingHints(arg0: Internal.Map_<any, any>): void;
        toString(): string;
        finalize(): void;
        fillOval(arg0: number, arg1: number, arg2: number, arg3: number): void;
        drawRect(arg0: number, arg1: number, arg2: number, arg3: number): void;
        setXORMode(arg0: java_.awt.Color_): void;
        drawPolygon(arg0: number[], arg1: number[], arg2: number): void;
        drawPolygon(arg0: Internal.Polygon_): void;
        getBackground(): java_.awt.Color;
        clip(arg0: Internal.Shape_): void;
        get color(): java_.awt.Color;
        get composite(): Internal.Composite;
        get background(): java_.awt.Color;
        get renderingHints(): Internal.RenderingHints;
        get fontRenderContext(): Internal.FontRenderContext;
        get clipBounds(): Internal.Rectangle;
        get paint(): Internal.Paint;
        get deviceConfiguration(): Internal.GraphicsConfiguration;
        get fontMetrics(): Internal.FontMetrics;
        get class(): Internal.Class<any>;
        get stroke(): Internal.Stroke;
        get font(): Internal.Font;
        set color(arg0: java_.awt.Color_);
        set background(arg0: java_.awt.Color_);
        set composite(arg0: Internal.Composite_);
        set paint(arg0: Internal.Paint_);
        set xORMode(arg0: java_.awt.Color_);
        set stroke(arg0: Internal.Stroke_);
        set font(arg0: Internal.Font_);
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    type Graphics2D_ = Graphics2D;
    class TypeToken <T> {
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        getRawType(): Internal.Class<T>;
        getType(): java_.lang.reflect.Type;
        hashCode(): number;
        notifyAll(): void;
        equals(arg0: any): boolean;
        static get(arg0: java_.lang.reflect.Type_): Internal.TypeToken<any>;
        static get<T>(arg0: Internal.Class_<T>): Internal.TypeToken<T>;
        static getArray(arg0: java_.lang.reflect.Type_): Internal.TypeToken<any>;
        toString(): string;
        isAssignableFrom(arg0: Internal.TypeToken_<any>): boolean;
        isAssignableFrom(arg0: java_.lang.reflect.Type_): boolean;
        isAssignableFrom(arg0: Internal.Class_<any>): boolean;
        notify(): void;
        static getParameterized(arg0: java_.lang.reflect.Type_, arg1: java_.lang.reflect.Type_[]): Internal.TypeToken<any>;
        get rawType(): Internal.Class<T>;
        get type(): java_.lang.reflect.Type;
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    type TypeToken_<T> = TypeToken<T>;
    abstract class AbstractByte2ObjectFunction <V> implements Internal.Byte2ObjectFunction<V>, Internal.Serializable {
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        getOrDefault(arg0: number, arg1: V): V;
        getOrDefault(arg0: any, arg1: V): V;
        notifyAll(): void;
        andThenShort(arg0: Internal.Object2ShortFunction_<V>): Internal.Byte2ShortFunction;
        composeByte(arg0: Internal.Byte2ByteFunction_): Internal.Byte2ObjectFunction<V>;
        andThenInt(arg0: Internal.Object2IntFunction_<V>): Internal.Byte2IntFunction;
        andThen<V_>(arg0: java_.util.function_.Function_<V, V_>): java_.util.function_.Function<number, V_>;
        composeReference<T_>(arg0: Internal.Reference2ByteFunction_<T_>): Internal.Reference2ObjectFunction<T_, V>;
        put(arg0: number, arg1: V): V;
        remove(arg0: any): V;
        remove(arg0: number): V;
        notify(): void;
        defaultReturnValue(arg0: V): void;
        defaultReturnValue(): V;
        andThenDouble(arg0: Internal.Object2DoubleFunction_<V>): Internal.Byte2DoubleFunction;
        andThenObject<T_>(arg0: Internal.Object2ObjectFunction_<V, T_>): Internal.Byte2ObjectFunction<T_>;
        hashCode(): number;
        get(arg0: any): V;
        get(arg0: number): V;
        andThenLong(arg0: Internal.Object2LongFunction_<V>): Internal.Byte2LongFunction;
        composeLong(arg0: Internal.Long2ByteFunction_): Internal.Long2ObjectFunction<V>;
        andThenByte(arg0: Internal.Object2ByteFunction_<V>): Internal.Byte2ByteFunction;
        andThenFloat(arg0: Internal.Object2FloatFunction_<V>): Internal.Byte2FloatFunction;
        apply(arg0: number): V;
        containsKey(arg0: any): boolean;
        containsKey(arg0: number): boolean;
        composeInt(arg0: Internal.Int2ByteFunction_): Internal.Int2ObjectFunction<V>;
        clear(): void;
        composeFloat(arg0: Internal.Float2ByteFunction_): Internal.Float2ObjectFunction<V>;
        andThenChar(arg0: Internal.Object2CharFunction_<V>): Internal.Byte2CharFunction;
        composeObject<T_>(arg0: Internal.Object2ByteFunction_<T_>): Internal.Object2ObjectFunction<T_, V>;
        size(): number;
        compose<T_>(arg0: java_.util.function_.Function_<T_, number>): java_.util.function_.Function<T_, V>;
        composeShort(arg0: Internal.Short2ByteFunction_): Internal.Short2ObjectFunction<V>;
        equals(arg0: any): boolean;
        andThenReference<T_>(arg0: Internal.Object2ReferenceFunction_<V, T_>): Internal.Byte2ReferenceFunction<T_>;
        composeChar(arg0: Internal.Char2ByteFunction_): Internal.Char2ObjectFunction<V>;
        toString(): string;
        composeDouble(arg0: Internal.Double2ByteFunction_): Internal.Double2ObjectFunction<V>;
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    type AbstractByte2ObjectFunction_<V> = AbstractByte2ObjectFunction<V>;
    class EntityWeight {
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        readData(nbt: Internal.CompoundTag_): void;
        hashCode(): number;
        readNetData(data: Internal.FriendlyByteBuf_): void;
        getWeight(entity: Internal.Entity_): number;
        notifyAll(): void;
        equals(arg0: any): boolean;
        toString(): string;
        writeData(nbt: Internal.CompoundTag_): void;
        notify(): void;
        writeNetData(data: Internal.FriendlyByteBuf_): void;
        boss : number;
        passive : number;
        monster : number;
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    type EntityWeight_ = EntityWeight;
    interface LongFunction <R> {
        apply(arg0: number): R;
    }
    type LongFunction_<R> = ((arg0: number) => R) | LongFunction<R>;
    interface Matrix3fExtended {
        getA20(): number;
        rotate(arg0: Internal.Quaternion_): void;
        getA10(): number;
        getA21(): number;
        getA00(): number;
        getA22(): number;
        getA11(): number;
        getA01(): number;
        getA12(): number;
        getA02(): number;
        transformVecZ(arg0: number, arg1: number, arg2: number): number;
        transformVecZ(dir: Internal.Vector3f_): number;
        transformVecY(arg0: number, arg1: number, arg2: number): number;
        transformVecY(dir: Internal.Vector3f_): number;
        transformVecX(dir: Internal.Vector3f_): number;
        transformVecX(arg0: number, arg1: number, arg2: number): number;
        computeNormal(arg0: Internal.Direction_): number;
    }
    type Matrix3fExtended_ = Matrix3fExtended;
    interface BufferVertexType <T> extends Internal.VertexType<T> {
        getBufferVertexFormat(): Internal.BufferVertexFormat;
        createFallbackWriter(arg0: Internal.VertexConsumer_): T;
        asBlittable(): Internal.BlittableVertexType<T>;
    }
    type BufferVertexType_<T> = BufferVertexType<T>;
    class MultipartBlockStateGenerator {
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        toJson(): Internal.JsonObject;
        hashCode(): number;
        notifyAll(): void;
        equals(arg0: any): boolean;
        part(when: string, model: string): void;
        part(when: string, consumer: Internal.Consumer_<Internal.MultipartBlockStateGenerator$Part_>): void;
        toString(): string;
        notify(): void;
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    type MultipartBlockStateGenerator_ = MultipartBlockStateGenerator;
    interface IForgeBucketPickup {
        getPickupSound(arg0: Internal.BlockState_): Internal.Optional<Internal.SoundEvent>;
    }
    type IForgeBucketPickup_ = IForgeBucketPickup;
    interface ObjectIterable <K> extends Internal.Iterable<K> {
        iterator(): Internal.ObjectIterator<K>;
        spliterator(): Internal.ObjectSpliterator<K>;
        forEach(arg0: Internal.Consumer_<K>): void;
    }
    type ObjectIterable_<K> = ObjectIterable<K>;
    interface Reference2DoubleFunction <K> extends Internal.Function<K, number>, Internal.ToDoubleFunction<K> {
        getOrDefault(arg0: any, arg1: number): number;
        applyAsDouble(arg0: K): number;
        andThenShort(arg0: Internal.Double2ShortFunction_): Internal.Reference2ShortFunction<K>;
        getDouble(arg0: any): number;
        composeByte(arg0: Internal.Byte2ReferenceFunction_<K>): Internal.Byte2DoubleFunction;
        andThenInt(arg0: Internal.Double2IntFunction_): Internal.Reference2IntFunction<K>;
        composeReference<T_>(arg0: Internal.Reference2ReferenceFunction_<T_, K>): Internal.Reference2DoubleFunction<T_>;
        andThen<T_>(arg0: java_.util.function_.Function_<number, T_>): java_.util.function_.Function<K, T_>;
        put(arg0: K, arg1: number): number;
        remove(arg0: any): number;
        defaultReturnValue(): number;
        defaultReturnValue(arg0: number): void;
        andThenDouble(arg0: Internal.Double2DoubleFunction_): Internal.Reference2DoubleFunction<K>;
        andThenObject<T_>(arg0: Internal.Double2ObjectFunction_<T_>): Internal.Reference2ObjectFunction<K, T_>;
        get(arg0: any): number;
        andThenLong(arg0: Internal.Double2LongFunction_): Internal.Reference2LongFunction<K>;
        composeLong(arg0: Internal.Long2ReferenceFunction_<K>): Internal.Long2DoubleFunction;
        andThenByte(arg0: Internal.Double2ByteFunction_): Internal.Reference2ByteFunction<K>;
        andThenFloat(arg0: Internal.Double2FloatFunction_): Internal.Reference2FloatFunction<K>;
        apply(arg0: K): number;
        containsKey(arg0: any): boolean;
        composeInt(arg0: Internal.Int2ReferenceFunction_<K>): Internal.Int2DoubleFunction;
        clear(): void;
        composeFloat(arg0: Internal.Float2ReferenceFunction_<K>): Internal.Float2DoubleFunction;
        andThenChar(arg0: Internal.Double2CharFunction_): Internal.Reference2CharFunction<K>;
        composeObject<T_>(arg0: Internal.Object2ReferenceFunction_<T_, K>): Internal.Object2DoubleFunction<T_>;
        size(): number;
        compose<V_>(arg0: java_.util.function_.Function_<V_, K>): java_.util.function_.Function<V_, number>;
        removeDouble(arg0: any): number;
        composeShort(arg0: Internal.Short2ReferenceFunction_<K>): Internal.Short2DoubleFunction;
        andThenReference<T_>(arg0: Internal.Double2ReferenceFunction_<T_>): Internal.Reference2ReferenceFunction<K, T_>;
        composeChar(arg0: Internal.Char2ReferenceFunction_<K>): Internal.Char2DoubleFunction;
        composeDouble(arg0: Internal.Double2ReferenceFunction_<K>): Internal.Double2DoubleFunction;
    }
    type Reference2DoubleFunction_<K> = ((arg0: any) => number) | Reference2DoubleFunction<K>;
    interface Marker extends Internal.Serializable {
        add(arg0: Internal.Marker_): void;
        contains(arg0: string): boolean;
        contains(arg0: Internal.Marker_): boolean;
        iterator(): Internal.Iterator<Internal.Marker>;
        getName(): string;
        hasChildren(): boolean;
        hashCode(): number;
        hasReferences(): boolean;
        equals(arg0: any): boolean;
        remove(arg0: Internal.Marker_): boolean;
    }
    type Marker_ = Marker;
    class Instant implements Internal.Temporal, Internal.TemporalAdjuster, Internal.Comparable<Internal.Instant>, Internal.Serializable {
        static ofEpochSecond(arg0: number): Internal.Instant;
        static ofEpochSecond(arg0: number, arg1: number): Internal.Instant;
        getClass(): Internal.Class<any>;
        minus(arg0: Internal.TemporalAmount_): Internal.Instant;
        minus(arg0: number, arg1: Internal.TemporalUnit_): Internal.Instant;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        notifyAll(): void;
        static ofEpochMilli(arg0: number): Internal.Instant;
        adjustInto(arg0: Internal.Temporal_): Internal.Temporal;
        range(arg0: Internal.TemporalField_): Internal.ValueRange;
        minusMillis(arg0: number): Internal.Instant;
        compareTo(arg0: Internal.Instant_): number;
        notify(): void;
        hashCode(): number;
        static now(): Internal.Instant;
        static now(arg0: Internal.Clock_): Internal.Instant;
        get(arg0: Internal.TemporalField_): number;
        plusSeconds(arg0: number): Internal.Instant;
        static from(arg0: Internal.TemporalAccessor_): Internal.Instant;
        plusNanos(arg0: number): Internal.Instant;
        atOffset(arg0: Internal.ZoneOffset_): Internal.OffsetDateTime;
        truncatedTo(arg0: Internal.TemporalUnit_): Internal.Instant;
        query<R_>(arg0: Internal.TemporalQuery_<R_>): R_;
        minusNanos(arg0: number): Internal.Instant;
        getNano(): number;
        toEpochMilli(): number;
        static parse(arg0: Internal.CharSequence_): Internal.Instant;
        isSupported(arg0: Internal.TemporalUnit_): boolean;
        isSupported(arg0: Internal.TemporalField_): boolean;
        atZone(arg0: Internal.ZoneId_): Internal.ZonedDateTime;
        isBefore(arg0: Internal.Instant_): boolean;
        plus(arg0: number, arg1: Internal.TemporalUnit_): Internal.Instant;
        plus(arg0: Internal.TemporalAmount_): Internal.Instant;
        getLong(arg0: Internal.TemporalField_): number;
        with(arg0: Internal.TemporalField_, arg1: number): Internal.Instant;
        with(arg0: Internal.TemporalAdjuster_): Internal.Instant;
        plusMillis(arg0: number): Internal.Instant;
        equals(arg0: any): boolean;
        until(arg0: Internal.Temporal_, arg1: Internal.TemporalUnit_): number;
        toString(): string;
        minusSeconds(arg0: number): Internal.Instant;
        getEpochSecond(): number;
        isAfter(arg0: Internal.Instant_): boolean;
        static readonly MIN : Internal.Instant;
        static readonly MAX : Internal.Instant;
        static readonly EPOCH : Internal.Instant;
        get nano(): number;
        get epochSecond(): number;
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    type Instant_ = Instant;
    interface VertexBufferView {
        ensureBufferCapacity(arg0: number): boolean;
        flush(arg0: number, arg1: Internal.BufferVertexFormat_): void;
        getWriterPosition(): number;
        getVertexFormat(): Internal.BufferVertexFormat;
        getDirectBuffer(): Internal.ByteBuffer;
    }
    type VertexBufferView_ = VertexBufferView;
    abstract class ByteBuffer extends Internal.Buffer implements Internal.Comparable<Internal.ByteBuffer> {
        asIntBuffer(): Internal.IntBuffer;
        getClass(): Internal.Class<any>;
        compact(): Internal.ByteBuffer;
        asLongBuffer(): Internal.LongBuffer;
        compareTo(arg0: Internal.ByteBuffer_): number;
        put(arg0: Internal.ByteBuffer_): Internal.ByteBuffer;
        put(arg0: number, arg1: number): Internal.ByteBuffer;
        put(arg0: number[]): Internal.ByteBuffer;
        put(arg0: number, arg1: number[], arg2: number, arg3: number): Internal.ByteBuffer;
        put(arg0: number, arg1: number[]): Internal.ByteBuffer;
        put(arg0: number): Internal.ByteBuffer;
        put(arg0: number, arg1: Internal.ByteBuffer_, arg2: number, arg3: number): Internal.ByteBuffer;
        put(arg0: number[], arg1: number, arg2: number): Internal.ByteBuffer;
        slice(arg0: number, arg1: number): Internal.ByteBuffer;
        slice(): Internal.ByteBuffer;
        limit(arg0: number): Internal.ByteBuffer;
        limit(): number;
        order(arg0: Internal.ByteOrder_): Internal.ByteBuffer;
        order(): Internal.ByteOrder;
        asFloatBuffer(): Internal.FloatBuffer;
        asCharBuffer(): Internal.CharBuffer;
        static allocateDirect(arg0: number): Internal.ByteBuffer;
        putInt(arg0: number, arg1: number): Internal.ByteBuffer;
        putInt(arg0: number): Internal.ByteBuffer;
        duplicate(): Internal.ByteBuffer;
        remaining(): number;
        putFloat(arg0: number, arg1: number): Internal.ByteBuffer;
        putFloat(arg0: number): Internal.ByteBuffer;
        getInt(arg0: number): number;
        getInt(): number;
        getChar(): string;
        getChar(arg0: number): string;
        static allocate(arg0: number): Internal.ByteBuffer;
        reset(): Internal.ByteBuffer;
        position(arg0: number): Internal.ByteBuffer;
        position(): number;
        asShortBuffer(): Internal.ShortBuffer;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        notifyAll(): void;
        putDouble(arg0: number, arg1: number): Internal.ByteBuffer;
        putDouble(arg0: number): Internal.ByteBuffer;
        getDouble(arg0: number): number;
        getDouble(): number;
        getFloat(): number;
        getFloat(arg0: number): number;
        putLong(arg0: number, arg1: number): Internal.ByteBuffer;
        putLong(arg0: number): Internal.ByteBuffer;
        notify(): void;
        asReadOnlyBuffer(): Internal.ByteBuffer;
        capacity(): number;
        isReadOnly(): boolean;
        asDoubleBuffer(): Internal.DoubleBuffer;
        array(): number[];
        hashCode(): number;
        get(arg0: number): number;
        get(): number;
        get(arg0: number[], arg1: number, arg2: number): Internal.ByteBuffer;
        get(arg0: number, arg1: number[]): Internal.ByteBuffer;
        get(arg0: number, arg1: number[], arg2: number, arg3: number): Internal.ByteBuffer;
        get(arg0: number[]): Internal.ByteBuffer;
        arrayOffset(): number;
        putShort(arg0: number, arg1: number): Internal.ByteBuffer;
        putShort(arg0: number): Internal.ByteBuffer;
        flip(): Internal.ByteBuffer;
        hasArray(): boolean;
        getShort(): number;
        getShort(arg0: number): number;
        putChar(arg0: number, arg1: string): Internal.ByteBuffer;
        putChar(arg0: string): Internal.ByteBuffer;
        hasRemaining(): boolean;
        clear(): Internal.ByteBuffer;
        getLong(arg0: number): number;
        getLong(): number;
        alignmentOffset(arg0: number, arg1: number): number;
        rewind(): Internal.ByteBuffer;
        mismatch(arg0: Internal.ByteBuffer_): number;
        equals(arg0: any): boolean;
        toString(): string;
        alignedSlice(arg0: number): Internal.ByteBuffer;
        isDirect(): boolean;
        static wrap(arg0: number[], arg1: number, arg2: number): Internal.ByteBuffer;
        static wrap(arg0: number[]): Internal.ByteBuffer;
        mark(): Internal.ByteBuffer;
        get double(): number;
        get char(): string;
        get direct(): boolean;
        get short(): number;
        get readOnly(): boolean;
        get float(): number;
        get class(): Internal.Class<any>;
        get int(): number;
        get long(): number;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    type ByteBuffer_ = ByteBuffer;
    abstract class UnmodifiableConfigWrapper <C> implements Internal.UnmodifiableConfig {
        getShortOrElse(arg0: string, arg1: number): number;
        getShortOrElse(arg0: Internal.List_<string>, arg1: number): number;
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        getByte(arg0: Internal.List_<string>): number;
        getByte(arg0: string): number;
        notifyAll(): void;
        getEnum<T_>(arg0: string, arg1: Internal.Class_<T_>, arg2: Internal.EnumGetMethod_): T_;
        getEnum<T_>(arg0: Internal.List_<string>, arg1: Internal.Class_<T_>): T_;
        getEnum<T_>(arg0: Internal.List_<string>, arg1: Internal.Class_<T_>, arg2: Internal.EnumGetMethod_): T_;
        getEnum<T_>(arg0: string, arg1: Internal.Class_<T_>): T_;
        getLongOrElse(arg0: string, arg1: Internal.LongSupplier_): number;
        getLongOrElse(arg0: Internal.List_<string>, arg1: Internal.LongSupplier_): number;
        getLongOrElse(arg0: Internal.List_<string>, arg1: number): number;
        getLongOrElse(arg0: string, arg1: number): number;
        notify(): void;
        getByteOrElse(arg0: Internal.List_<string>, arg1: number): number;
        getByteOrElse(arg0: string, arg1: number): number;
        hashCode(): number;
        get<T_>(arg0: string): T_;
        get<T_>(arg0: Internal.List_<string>): T_;
        valueMap(): Internal.Map<string, any>;
        getOrElse<T_>(arg0: Internal.List_<string>, arg1: T_): T_;
        getOrElse<T_>(arg0: string, arg1: Internal.Supplier_<T_>): T_;
        getOrElse<T_>(arg0: string, arg1: T_): T_;
        getOrElse<T_>(arg0: Internal.List_<string>, arg1: Internal.Supplier_<T_>): T_;
        getEnumOrElse<T_>(arg0: string, arg1: Internal.Class_<T_>, arg2: Internal.EnumGetMethod_, arg3: Internal.Supplier_<T_>): T_;
        getEnumOrElse<T_>(arg0: Internal.List_<string>, arg1: T_): T_;
        getEnumOrElse<T_>(arg0: Internal.List_<string>, arg1: T_, arg2: Internal.EnumGetMethod_): T_;
        getEnumOrElse<T_>(arg0: string, arg1: T_): T_;
        getEnumOrElse<T_>(arg0: string, arg1: T_, arg2: Internal.EnumGetMethod_): T_;
        getEnumOrElse<T_>(arg0: Internal.List_<string>, arg1: Internal.Class_<T_>, arg2: Internal.EnumGetMethod_, arg3: Internal.Supplier_<T_>): T_;
        getEnumOrElse<T_>(arg0: Internal.List_<string>, arg1: Internal.Class_<T_>, arg2: Internal.Supplier_<T_>): T_;
        getEnumOrElse<T_>(arg0: string, arg1: Internal.Class_<T_>, arg2: Internal.Supplier_<T_>): T_;
        getIntOrElse(arg0: string, arg1: Internal.IntSupplier_): number;
        getIntOrElse(arg0: string, arg1: number): number;
        getIntOrElse(arg0: Internal.List_<string>, arg1: number): number;
        getIntOrElse(arg0: Internal.List_<string>, arg1: Internal.IntSupplier_): number;
        apply<T_>(arg0: string): T_;
        apply<T_>(arg0: Internal.List_<string>): T_;
        getShort(arg0: string): number;
        getShort(arg0: Internal.List_<string>): number;
        entrySet(): Internal.Set<Internal.UnmodifiableConfig$Entry>;
        configFormat(): Internal.ConfigFormat<any>;
        isEmpty(): boolean;
        getOptionalInt(arg0: string): Internal.OptionalInt;
        getOptionalInt(arg0: Internal.List_<string>): Internal.OptionalInt;
        getCharOrElse(arg0: Internal.List_<string>, arg1: string): string;
        getCharOrElse(arg0: string, arg1: string): string;
        getLong(arg0: string): number;
        getLong(arg0: Internal.List_<string>): number;
        getInt(arg0: string): number;
        getInt(arg0: Internal.List_<string>): number;
        getChar(arg0: string): string;
        getChar(arg0: Internal.List_<string>): string;
        getOptional<T_>(arg0: string): Internal.Optional<T_>;
        getOptional<T_>(arg0: Internal.List_<string>): Internal.Optional<T_>;
        contains(arg0: Internal.List_<string>): boolean;
        contains(arg0: string): boolean;
        size(): number;
        isNull(arg0: string): boolean;
        isNull(arg0: Internal.List_<string>): boolean;
        equals(arg0: any): boolean;
        toString(): string;
        getRaw<T_>(arg0: Internal.List_<string>): T_;
        getRaw<T_>(arg0: string): T_;
        getOptionalLong(arg0: string): Internal.OptionalLong;
        getOptionalLong(arg0: Internal.List_<string>): Internal.OptionalLong;
        getOptionalEnum<T_>(arg0: string, arg1: Internal.Class_<T_>): Internal.Optional<T_>;
        getOptionalEnum<T_>(arg0: Internal.List_<string>, arg1: Internal.Class_<T_>): Internal.Optional<T_>;
        getOptionalEnum<T_>(arg0: string, arg1: Internal.Class_<T_>, arg2: Internal.EnumGetMethod_): Internal.Optional<T_>;
        getOptionalEnum<T_>(arg0: Internal.List_<string>, arg1: Internal.Class_<T_>, arg2: Internal.EnumGetMethod_): Internal.Optional<T_>;
        get class(): Internal.Class<any>;
        get empty(): boolean;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    type UnmodifiableConfigWrapper_<C> = UnmodifiableConfigWrapper<C>;
    abstract class RectangularShape implements Internal.Shape, Internal.Cloneable {
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        intersects(arg0: Internal.Rectangle2D_): boolean;
        intersects(arg0: number, arg1: number, arg2: number, arg3: number): boolean;
        notifyAll(): void;
        getFrame(): Internal.Rectangle2D;
        getWidth(): number;
        notify(): void;
        getBounds(): Internal.Rectangle;
        setFrameFromCenter(arg0: Internal.Point2D_, arg1: Internal.Point2D_): void;
        setFrameFromCenter(arg0: number, arg1: number, arg2: number, arg3: number): void;
        getHeight(): number;
        getPathIterator(arg0: Internal.AffineTransform_, arg1: number): Internal.PathIterator;
        getPathIterator(arg0: Internal.AffineTransform_): Internal.PathIterator;
        setFrame(arg0: number, arg1: number, arg2: number, arg3: number): void;
        setFrame(arg0: Internal.Rectangle2D_): void;
        setFrame(arg0: Internal.Point2D_, arg1: Internal.Dimension2D_): void;
        hashCode(): number;
        getCenterY(): number;
        getCenterX(): number;
        getMaxX(): number;
        isEmpty(): boolean;
        getMaxY(): number;
        setFrameFromDiagonal(arg0: number, arg1: number, arg2: number, arg3: number): void;
        setFrameFromDiagonal(arg0: Internal.Point2D_, arg1: Internal.Point2D_): void;
        getX(): number;
        contains(arg0: Internal.Point2D_): boolean;
        contains(arg0: Internal.Rectangle2D_): boolean;
        contains(arg0: number, arg1: number, arg2: number, arg3: number): boolean;
        contains(arg0: number, arg1: number): boolean;
        getY(): number;
        equals(arg0: any): boolean;
        getBounds2D(): Internal.Rectangle2D;
        clone(): any;
        toString(): string;
        getMinX(): number;
        getMinY(): number;
        get centerY(): number;
        get centerX(): number;
        get maxY(): number;
        get maxX(): number;
        get bounds2D(): Internal.Rectangle2D;
        get empty(): boolean;
        get minY(): number;
        get minX(): number;
        get width(): number;
        get bounds(): Internal.Rectangle;
        get x(): number;
        get y(): number;
        get class(): Internal.Class<any>;
        get frame(): Internal.Rectangle2D;
        get height(): number;
        set frame(arg0: Internal.Rectangle2D_);
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    type RectangularShape_ = RectangularShape;
    class BufferCapabilities$FlipContents extends Internal.AttributeValue {
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        notifyAll(): void;
        equals(arg0: any): boolean;
        notify(): void;
        static readonly UNDEFINED : Internal.BufferCapabilities$FlipContents;
        static readonly PRIOR : Internal.BufferCapabilities$FlipContents;
        static readonly COPIED : Internal.BufferCapabilities$FlipContents;
        static readonly BACKGROUND : Internal.BufferCapabilities$FlipContents;
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    type BufferCapabilities$FlipContents_ = BufferCapabilities$FlipContents;
    interface IItemRenderProperties {
        getItemStackRenderer(): Internal.BlockEntityWithoutLevelRenderer;
        getBaseArmorModel(arg0: Internal.LivingEntity_, arg1: Internal.ItemStack_, arg2: EquipmentSlot_, arg3: Internal.HumanoidModel_<any>): Internal.Model;
        getFont(arg0: Internal.ItemStack_): net.minecraft.client.gui.Font;
        getArmorModel(arg0: Internal.LivingEntity_, arg1: Internal.ItemStack_, arg2: EquipmentSlot_, arg3: Internal.HumanoidModel_<any>): Internal.HumanoidModel<any>;
        renderHelmetOverlay(arg0: Internal.ItemStack_, arg1: Internal.Player_, arg2: number, arg3: number, arg4: number): void;
    }
    type IItemRenderProperties_ = IItemRenderProperties;
    class PartyTeam extends Internal.Team {
        msg(player: Internal.ServerPlayer_, message: string): number;
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        listAllies(source: Internal.CommandSourceStack_): number;
        getName(): Internal.Component;
        notifyAll(): void;
        getHighestRank(playerId: Internal.UUID_): Internal.TeamRank;
        save(): void;
        getId(): Internal.UUID;
        isMember(uuid: Internal.UUID_): boolean;
        getOwner(): Internal.UUID;
        isOfficer(profile: Internal.UUID_): boolean;
        getDescription(): string;
        notify(): void;
        getColoredName(): Internal.Component;
        serializeNBT(): Internal.SNBTCompoundTag;
        isOwner(profile: Internal.UUID_): boolean;
        hashCode(): number;
        leave(player: Internal.ServerPlayer_): number;
        join(source: Internal.CommandSourceStack_): number;
        info(source: Internal.CommandSourceStack_): number;
        settings(source: Internal.CommandSourceStack_, key: Internal.TeamProperty_<any>, value: string): number;
        isAlly(profile: Internal.UUID_): boolean;
        getProperty<T_>(property: Internal.TeamProperty_<T_>): T_;
        isValid(): boolean;
        getExtraData(): Internal.CompoundTag;
        getColor(): number;
        sendMessage(from: Internal.UUID_, text: Internal.Component_): void;
        deserializeNBT(tag: Internal.CompoundTag_): void;
        getRanked(rank: Internal.TeamRank_): Internal.Map<Internal.UUID, Internal.TeamRank>;
        getOnlineRanked(rank: Internal.TeamRank_): Internal.List<Internal.ServerPlayer>;
        removeAlly(source: Internal.CommandSourceStack_, players: Internal.Collection_<Internal.GameProfile_>): number;
        denyInvite(source: Internal.CommandSourceStack_): number;
        isFreeToJoin(): boolean;
        kick(from: Internal.ServerPlayer_, players: Internal.Collection_<Internal.GameProfile_>): number;
        isInvited(profile: Internal.UUID_): boolean;
        getStringID(): string;
        getDisplayName(): string;
        getOnlineMembers(): Internal.List<Internal.ServerPlayer>;
        getOwnerPlayer(): Internal.ServerPlayer;
        getType(): Internal.TeamType;
        setProperty<T_>(property: Internal.TeamProperty_<T_>, value: T_): void;
        equals(o: any): boolean;
        addAlly(source: Internal.CommandSourceStack_, players: Internal.Collection_<Internal.GameProfile_>): number;
        transferOwnership(from: Internal.ServerPlayer_, to: Internal.ServerPlayer_): number;
        toString(): string;
        invite(from: Internal.ServerPlayer_, players: Internal.Collection_<Internal.GameProfile_>): number;
        getMembers(): Internal.Set<Internal.UUID>;
        static readonly FREE_TO_JOIN : Internal.BooleanProperty;
        readonly manager : Internal.TeamManager;
        static readonly DESCRIPTION : Internal.StringProperty;
        static readonly COLOR : Internal.ColorProperty;
        readonly messageHistory : Internal.List<Internal.TeamMessage>;
        static readonly DISPLAY_NAME : Internal.StringProperty;
        readonly properties : Internal.TeamProperties;
        get owner(): Internal.UUID;
        get ownerPlayer(): Internal.ServerPlayer;
        get onlineMembers(): Internal.List<Internal.ServerPlayer>;
        get color(): number;
        get extraData(): Internal.CompoundTag;
        get displayName(): string;
        get description(): string;
        get type(): Internal.TeamType;
        get freeToJoin(): boolean;
        get valid(): boolean;
        get stringID(): string;
        get members(): Internal.Set<Internal.UUID>;
        get name(): Internal.Component;
        get id(): Internal.UUID;
        get class(): Internal.Class<any>;
        get coloredName(): Internal.Component;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    type PartyTeam_ = PartyTeam;
    class ClientWrapper {
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        getPlayer(): Internal.ClientPlayerJS;
        notifyAll(): void;
        getCurrentScreen(): Internal.Screen;
        setTitle(t: string): void;
        getMinecraft(): Internal.Minecraft;
        notify(): void;
        getLevel(): Internal.ClientLevelJS;
        hashCode(): number;
        equals(arg0: any): boolean;
        isKeyDown(key: number): boolean;
        getCurrentWorldName(): string;
        toString(): string;
        setCurrentScreen(gui: Internal.Screen_): void;
        get minecraft(): Internal.Minecraft;
        get currentScreen(): Internal.Screen;
        get level(): Internal.ClientLevelJS;
        get class(): Internal.Class<any>;
        get player(): Internal.ClientPlayerJS;
        get currentWorldName(): string;
        set currentScreen(gui: Internal.Screen_);
        set title(t: string);
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    type ClientWrapper_ = ClientWrapper;
    class ConsoleJS {
        getClass(): Internal.Class<any>;
        printObject(o: any): void;
        printObject(o: any, tree: boolean): void;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        infof(message: any, args: any[]): void;
        log(message: any): void;
        notifyAll(): void;
        setMuted(m: boolean): void;
        errorf(message: string, args: any[]): void;
        error(message: string, throwable: Internal.Throwable_): void;
        error(message: any): void;
        error(message: string, throwable: Internal.Throwable_, skip: Internal.Pattern_): void;
        notify(): void;
        debugf(message: string, args: any[]): void;
        trace(): void;
        flush(): void;
        hashCode(): number;
        setWriteToFile(m: boolean): void;
        setLineNumber(b: boolean): void;
        getScriptLine(): number;
        warnf(message: string, args: any[]): void;
        info(message: any): void;
        group(): void;
        getMuted(): boolean;
        debug(message: any): void;
        printStackTrace(throwable: Internal.Throwable_, skip: Internal.Pattern_): void;
        getLogger(): Internal.Logger;
        shouldPrintDebug(): boolean;
        setDebugEnabled(m: boolean): void;
        resetFile(): void;
        warn(message: any): void;
        warn(message: string, throwable: Internal.Throwable_, skip: Internal.Pattern_): void;
        warn(message: string, throwable: Internal.Throwable_): void;
        getDebugEnabled(): boolean;
        groupEnd(): void;
        printClass(className: string): void;
        printClass(className: string, tree: boolean): void;
        equals(arg0: any): boolean;
        toString(): string;
        getWriteToFile(): boolean;
        static SERVER : Internal.ConsoleJS;
        static STARTUP : Internal.ConsoleJS;
        static CLIENT : Internal.ConsoleJS;
        get scriptLine(): number;
        get writeToFile(): boolean;
        get logger(): Internal.Logger;
        get debugEnabled(): boolean;
        get class(): Internal.Class<any>;
        get muted(): boolean;
        set writeToFile(m: boolean);
        set debugEnabled(m: boolean);
        set lineNumber(b: boolean);
        set muted(m: boolean);
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    type ConsoleJS_ = ConsoleJS;
    interface ObjectInput extends Internal.DataInput, Internal.AutoCloseable {
        read(arg0: number[], arg1: number, arg2: number): number;
        read(arg0: number[]): number;
        read(): number;
        available(): number;
        skip(arg0: number): number;
        readLine(): string;
        readChar(): string;
        skipBytes(arg0: number): number;
        readObject(): any;
        readLong(): number;
        readUTF(): string;
        readShort(): number;
        readDouble(): number;
        readFully(arg0: number[]): void;
        readFully(arg0: number[], arg1: number, arg2: number): void;
        readFloat(): number;
        readBoolean(): boolean;
        readByte(): number;
        readInt(): number;
        readUnsignedByte(): number;
        close(): void;
        readUnsignedShort(): number;
    }
    type ObjectInput_ = ObjectInput;
    interface FuncSupplier$Func2 extends Internal.FuncSupplier {
        create2(arg0: dev.latvian.mods.rhino.util.unit.Unit_, arg1: dev.latvian.mods.rhino.util.unit.Unit_): dev.latvian.mods.rhino.util.unit.Unit;
        create(args: Internal.List_<dev.latvian.mods.rhino.util.unit.Unit_>): dev.latvian.mods.rhino.util.unit.Unit;
    }
    type FuncSupplier$Func2_ = ((arg0: dev.latvian.mods.rhino.util.unit.Unit, arg1: dev.latvian.mods.rhino.util.unit.Unit) => dev.latvian.mods.rhino.util.unit.Unit) | FuncSupplier$Func2;
    class PainterObjectStorage {
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        getObject(key: string): Internal.PainterObject;
        notifyAll(): void;
        clear(): void;
        handle(root: Internal.CompoundTag_): void;
        notify(): void;
        remove(id: string): void;
        createScreenObjects(): any[];
        createWorldObjects(): any[];
        hashCode(): number;
        equals(arg0: any): boolean;
        toString(): string;
        getObjects(): Internal.Collection<Internal.PainterObject>;
        get objects(): Internal.Collection<Internal.PainterObject>;
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    type PainterObjectStorage_ = PainterObjectStorage;
    interface Boolean2FloatFunction extends Internal.Function<boolean, number> {
        getOrDefault(arg0: any, arg1: number): number;
        getOrDefault(arg0: boolean, arg1: number): number;
        andThenShort(arg0: Internal.Float2ShortFunction_): Internal.Boolean2ShortFunction;
        composeByte(arg0: Internal.Byte2BooleanFunction_): Internal.Byte2FloatFunction;
        andThenInt(arg0: Internal.Float2IntFunction_): Internal.Boolean2IntFunction;
        composeReference<T_>(arg0: Internal.Reference2BooleanFunction_<T_>): Internal.Reference2FloatFunction<T_>;
        andThen<T_>(arg0: java_.util.function_.Function_<number, T_>): java_.util.function_.Function<boolean, T_>;
        put(arg0: boolean, arg1: number): number;
        remove(arg0: any): number;
        remove(arg0: boolean): number;
        defaultReturnValue(): number;
        defaultReturnValue(arg0: number): void;
        andThenDouble(arg0: Internal.Float2DoubleFunction_): Internal.Boolean2DoubleFunction;
        andThenObject<T_>(arg0: Internal.Float2ObjectFunction_<T_>): Internal.Boolean2ObjectFunction<T_>;
        get(arg0: any): number;
        get(arg0: boolean): number;
        andThenLong(arg0: Internal.Float2LongFunction_): Internal.Boolean2LongFunction;
        composeLong(arg0: Internal.Long2BooleanFunction_): Internal.Long2FloatFunction;
        andThenByte(arg0: Internal.Float2ByteFunction_): Internal.Boolean2ByteFunction;
        andThenFloat(arg0: Internal.Float2FloatFunction_): Internal.Boolean2FloatFunction;
        apply(arg0: boolean): number;
        containsKey(arg0: boolean): boolean;
        containsKey(arg0: any): boolean;
        composeInt(arg0: Internal.Int2BooleanFunction_): Internal.Int2FloatFunction;
        clear(): void;
        composeFloat(arg0: Internal.Float2BooleanFunction_): Internal.Float2FloatFunction;
        andThenChar(arg0: Internal.Float2CharFunction_): Internal.Boolean2CharFunction;
        composeObject<T_>(arg0: Internal.Object2BooleanFunction_<T_>): Internal.Object2FloatFunction<T_>;
        size(): number;
        compose<T_>(arg0: java_.util.function_.Function_<T_, boolean>): java_.util.function_.Function<T_, number>;
        composeShort(arg0: Internal.Short2BooleanFunction_): Internal.Short2FloatFunction;
        andThenReference<T_>(arg0: Internal.Float2ReferenceFunction_<T_>): Internal.Boolean2ReferenceFunction<T_>;
        composeChar(arg0: Internal.Char2BooleanFunction_): Internal.Char2FloatFunction;
        composeDouble(arg0: Internal.Double2BooleanFunction_): Internal.Double2FloatFunction;
    }
    type Boolean2FloatFunction_ = ((arg0: boolean) => number) | Boolean2FloatFunction;
    class JsonToken extends Internal.Enum<Internal.JsonToken> {
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        static valueOf(arg0: string): Internal.JsonToken;
        static valueOf<T_>(arg0: Internal.Class_<T_>, arg1: string): T_;
        notifyAll(): void;
        static values(): Internal.JsonToken[];
        compareTo(arg0: Internal.JsonToken_): number;
        describeConstable(): Internal.Optional<Internal.Enum$EnumDesc<Internal.JsonToken>>;
        notify(): void;
        getDeclaringClass(): Internal.Class<Internal.JsonToken>;
        hashCode(): number;
        equals(arg0: any): boolean;
        name(): string;
        toString(): string;
        ordinal(): number;
        static readonly NUMBER : Internal.JsonToken;
        static readonly NULL : Internal.JsonToken;
        static readonly END_DOCUMENT : Internal.JsonToken;
        static readonly BEGIN_OBJECT : Internal.JsonToken;
        static readonly END_ARRAY : Internal.JsonToken;
        static readonly STRING : Internal.JsonToken;
        static readonly END_OBJECT : Internal.JsonToken;
        static readonly BEGIN_ARRAY : Internal.JsonToken;
        static readonly BOOLEAN : Internal.JsonToken;
        static readonly NAME : Internal.JsonToken;
        get class(): Internal.Class<any>;
        get declaringClass(): Internal.Class<Internal.JsonToken>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    type JsonToken_ = "number" | "end_document" | "begin_array" | "boolean" | "end_object" | "string" | "null" | "name" | "end_array" | "begin_object" | JsonToken;
    interface TickingBlockEntity {
    }
    type TickingBlockEntity_ = TickingBlockEntity;
    interface BlockEntityPredicateDataCheck {
        checkData(arg0: Internal.CompoundTag_): boolean;
    }
    type BlockEntityPredicateDataCheck_ = ((arg0: Internal.CompoundTag) => boolean) | BlockEntityPredicateDataCheck;
    class LocalPlayer extends Internal.AbstractClientPlayer {
        getClass(): Internal.Class<any>;
        setItemSwapAnimationTimer(count: number): void;
        resetDynamicLight(): void;
        getCapability<T_>(arg0: Internal.Capability_<T_>, arg1: Internal.Direction_): Internal.LazyOptional<T_>;
        getCapability<T_>(arg0: Internal.Capability_<T_>): Internal.LazyOptional<T_>;
        captureDrops(arg0: Internal.Collection_<Internal.ItemEntity_>): Internal.Collection<Internal.ItemEntity>;
        captureDrops(): Internal.Collection<Internal.ItemEntity>;
        botania$setCritTarget(arg0: Internal.LivingEntity_): void;
        canBeRiddenInWater(arg0: Internal.Entity_): boolean;
        setCitadelEntityData(arg0: Internal.CompoundTag_): void;
        isDynamicLightEnabled(): boolean;
        changeDimension(arg0: Internal.ServerLevel_, arg1: Internal.ITeleporter_): Internal.Entity;
        serializeNBT(): Internal.CompoundTag;
        invalidateCaps(): void;
        setDynamicLightEnabled(arg0: boolean): void;
        shouldUpdateDynamicLight(): boolean;
        foodEatenKJS(is: Internal.ItemStack_): void;
        redirect$bid001$elytraOverride(arg0: Internal.ItemStack_, arg1: Internal.LivingEntity_): boolean;
        revive(): void;
        setVisualScale(arg0: number): void;
        getDigSpeed(arg0: Internal.BlockState_, arg1: BlockPos_): number;
        write(): net.minecraft.nbt.Tag;
        dynamicLightTick(): void;
        readBYG(arg0: Internal.CompoundTag_): void;
        getPersistentDataKJS(): Internal.CompoundTag;
        canUpdate(): boolean;
        canUpdate(arg0: boolean): void;
        getDynamicLightY(): number;
        getSuffixes(): Internal.Collection<Internal.MutableComponent>;
        getDynamicLightZ(): number;
        handler$zbj000$curio$canFreeze(arg0: Internal.CallbackInfoReturnable_<any>): void;
        read(arg0: Internal.CompoundTag_): void;
        getDynamicLightX(): number;
        areCapsCompatible(arg0: Internal.CapabilityProvider_<Internal.Entity_>): boolean;
        areCapsCompatible(arg0: Internal.CapabilityDispatcher_): boolean;
        getSideSword(): Internal.ItemStack;
        redirect$bie002$elytraOverride(arg0: Internal.ItemStack_, arg1: Internal.LivingEntity_): boolean;
        getEyeHeightAccess(arg0: Internal.Pose_, arg1: Internal.EntityDimensions_): number;
        reviveCaps(): void;
        lambdynlights$updateDynamicLight(arg0: Internal.LevelRenderer_): boolean;
        handler$bih000$removed(arg0: Internal.CallbackInfo_): void;
        setForcedPose(arg0: Internal.Pose_): void;
        canRiderInteract(): boolean;
        lambdynlights$scheduleTrackedChunksRebuild(arg0: Internal.LevelRenderer_): void;
        handler$bih001$onTick(arg0: Internal.CallbackInfo_): void;
        setLastAnimationSwapTick(count: number): void;
        onAddedToWorld(): void;
        lastUpdate(): number;
        getItemSwapAnimationTimer(): number;
        getPrefixes(): Internal.Collection<Internal.MutableComponent>;
        canTrample(arg0: Internal.BlockState_, arg1: BlockPos_, arg2: number): boolean;
        getCitadelEntityData(): Internal.CompoundTag;
        getPoseOverwrite(): Internal.Pose;
        setUpdated(frameId: number): void;
        getClassification(arg0: boolean): Internal.MobCategory;
        handler$bih000$onRemove(arg0: Internal.CallbackInfo_): void;
        getLastAnimationSwapTick(): number;
        shouldRiderSit(): boolean;
        getPickedResult(arg0: Internal.HitResult_): Internal.ItemStack;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        notifyAll(): void;
        isActuallyReallyBlocking(): boolean;
        setSideSword(item: Internal.ItemStack_): void;
        isUpdated(frameId: number): boolean;
        getPersistentData(): Internal.CompoundTag;
        getStagesRawKJS(): Internal.Stages;
        handler$bjh000$tick(info: Internal.CallbackInfo_): void;
        notify(): void;
        redirect$bie000$eytraValidOverride(arg0: Internal.ItemStack_, arg1: Internal.LivingEntity_, arg2: number): boolean;
        getStages(): Internal.Stages;
        getLastHeldItems(): Internal.ItemStack[];
        hashCode(): number;
        getPlayerTrackedData(): Internal.BYGPlayerTrackedData;
        setDimension(arg0: Internal.EntityDimensions_): void;
        updateSyncFields(arg0: Internal.LocalPlayer_): void;
        isBodyRotationDisabled(): boolean;
        isAddedToWorld(): boolean;
        getData(holder: Internal.DataHolder_<any>, builder: Internal.Supplier_<any>): any;
        getParts(): any[];
        getDynamicLightWorld(): Internal.Level;
        writeBYG(arg0: Internal.CompoundTag_): void;
        disableBodyRotation(val: boolean): void;
        onRemovedFromWorld(): void;
        getLuminance(): number;
        isMultipartEntity(): boolean;
        deserializeNBT(arg0: Internal.CompoundTag_): void;
        curePotionEffects(arg0: Internal.ItemStack_): boolean;
        asKJS(): any;
        setPlayerTrackedData(arg0: Internal.BYGPlayerTrackedData_): Internal.BYGPlayerTrackedData;
        handler$cfc000$getPortalWaitTime(arg0: Internal.CallbackInfoReturnable_<any>): void;
        redirect$bic000$elytraOverride(arg0: Internal.ItemStack_, arg1: Internal.LivingEntity_): boolean;
        shouldRiderFaceForward(arg0: Internal.Player_): boolean;
        setPoseOverwrite(state: Internal.Pose_): void;
        equals(arg0: any): boolean;
        toString(): string;
        getVisualScale(): number;
        getLastRotations(): number[];
        refreshDisplayName(): void;
        getForcedPose(): Internal.Pose;
        static readonly PERSISTED_NBT_TAG : "PlayerPersisted";
        get luminance(): number;
        get suffixes(): Internal.Collection<Internal.MutableComponent>;
        get citadelEntityData(): Internal.CompoundTag;
        get playerTrackedData(): Internal.BYGPlayerTrackedData;
        get stagesRawKJS(): Internal.Stages;
        get addedToWorld(): boolean;
        get dynamicLightY(): number;
        get dynamicLightZ(): number;
        get sideSword(): Internal.ItemStack;
        get dynamicLightX(): number;
        get visualScale(): number;
        get persistentDataKJS(): Internal.CompoundTag;
        get class(): Internal.Class<any>;
        get dynamicLightWorld(): Internal.Level;
        get dynamicLightEnabled(): boolean;
        get poseOverwrite(): Internal.Pose;
        get persistentData(): Internal.CompoundTag;
        get lastHeldItems(): Internal.ItemStack[];
        get multipartEntity(): boolean;
        get lastRotations(): number[];
        get prefixes(): Internal.Collection<Internal.MutableComponent>;
        get lastAnimationSwapTick(): number;
        get bodyRotationDisabled(): boolean;
        get forcedPose(): Internal.Pose;
        get actuallyReallyBlocking(): boolean;
        get stages(): Internal.Stages;
        get parts(): any[];
        get itemSwapAnimationTimer(): number;
        set poseOverwrite(state: Internal.Pose_);
        set dynamicLightEnabled(arg0: boolean);
        set visualScale(arg0: number);
        set lastAnimationSwapTick(count: number);
        set forcedPose(arg0: Internal.Pose_);
        set playerTrackedData(arg0: Internal.BYGPlayerTrackedData_);
        set citadelEntityData(arg0: Internal.CompoundTag_);
        set dimension(arg0: Internal.EntityDimensions_);
        set sideSword(item: Internal.ItemStack_);
        set updated(frameId: number);
        set itemSwapAnimationTimer(count: number);
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    type LocalPlayer_ = LocalPlayer;
    class RoundingMode extends Internal.Enum<Internal.RoundingMode> {
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        static valueOf(arg0: string): Internal.RoundingMode;
        static valueOf(arg0: number): Internal.RoundingMode;
        static valueOf<T_>(arg0: Internal.Class_<T_>, arg1: string): T_;
        notifyAll(): void;
        static values(): Internal.RoundingMode[];
        compareTo(arg0: Internal.RoundingMode_): number;
        describeConstable(): Internal.Optional<Internal.Enum$EnumDesc<Internal.RoundingMode>>;
        notify(): void;
        getDeclaringClass(): Internal.Class<Internal.RoundingMode>;
        hashCode(): number;
        equals(arg0: any): boolean;
        name(): string;
        toString(): string;
        ordinal(): number;
        static readonly DOWN : Internal.RoundingMode;
        static readonly FLOOR : Internal.RoundingMode;
        static readonly UNNECESSARY : Internal.RoundingMode;
        static readonly CEILING : Internal.RoundingMode;
        static readonly HALF_EVEN : Internal.RoundingMode;
        static readonly UP : Internal.RoundingMode;
        static readonly HALF_UP : Internal.RoundingMode;
        static readonly HALF_DOWN : Internal.RoundingMode;
        get class(): Internal.Class<any>;
        get declaringClass(): Internal.Class<Internal.RoundingMode>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    type RoundingMode_ = "ceiling" | "half_down" | "half_up" | "unnecessary" | "up" | "floor" | "down" | "half_even" | RoundingMode;
    interface LootItemFunction extends Internal.LootContextUser, Internal.BiFunction<Internal.ItemStack, Internal.LootContext, Internal.ItemStack> {
        apply(arg0: Internal.ItemStack_, arg1: Internal.LootContext_): Internal.ItemStack;
        andThen<V_>(arg0: java_.util.function_.Function_<Internal.ItemStack_, V_>): Internal.BiFunction<Internal.ItemStack, Internal.LootContext, V_>;
    }
    type LootItemFunction_ = LootItemFunction;
    interface UnmodifiableConfig {
        getShortOrElse(arg0: string, arg1: number): number;
        getShortOrElse(arg0: Internal.List_<string>, arg1: number): number;
        getByte(arg0: Internal.List_<string>): number;
        getByte(arg0: string): number;
        getEnum<T>(arg0: string, arg1: Internal.Class_<T>, arg2: Internal.EnumGetMethod_): T;
        getEnum<T>(arg0: Internal.List_<string>, arg1: Internal.Class_<T>): T;
        getEnum<T>(arg0: Internal.List_<string>, arg1: Internal.Class_<T>, arg2: Internal.EnumGetMethod_): T;
        getEnum<T>(arg0: string, arg1: Internal.Class_<T>): T;
        getLongOrElse(arg0: string, arg1: Internal.LongSupplier_): number;
        getLongOrElse(arg0: Internal.List_<string>, arg1: Internal.LongSupplier_): number;
        getLongOrElse(arg0: Internal.List_<string>, arg1: number): number;
        getLongOrElse(arg0: string, arg1: number): number;
        getByteOrElse(arg0: Internal.List_<string>, arg1: number): number;
        getByteOrElse(arg0: string, arg1: number): number;
        get<T>(arg0: string): T;
        get<T>(arg0: Internal.List_<string>): T;
        valueMap(): Internal.Map<string, any>;
        getOrElse<T>(arg0: Internal.List_<string>, arg1: T): T;
        getOrElse<T>(arg0: string, arg1: Internal.Supplier_<T>): T;
        getOrElse<T>(arg0: string, arg1: T): T;
        getOrElse<T>(arg0: Internal.List_<string>, arg1: Internal.Supplier_<T>): T;
        getEnumOrElse<T>(arg0: string, arg1: Internal.Class_<T>, arg2: Internal.EnumGetMethod_, arg3: Internal.Supplier_<T>): T;
        getEnumOrElse<T>(arg0: Internal.List_<string>, arg1: T): T;
        getEnumOrElse<T>(arg0: Internal.List_<string>, arg1: T, arg2: Internal.EnumGetMethod_): T;
        getEnumOrElse<T>(arg0: string, arg1: T): T;
        getEnumOrElse<T>(arg0: string, arg1: T, arg2: Internal.EnumGetMethod_): T;
        getEnumOrElse<T>(arg0: Internal.List_<string>, arg1: Internal.Class_<T>, arg2: Internal.EnumGetMethod_, arg3: Internal.Supplier_<T>): T;
        getEnumOrElse<T>(arg0: Internal.List_<string>, arg1: Internal.Class_<T>, arg2: Internal.Supplier_<T>): T;
        getEnumOrElse<T>(arg0: string, arg1: Internal.Class_<T>, arg2: Internal.Supplier_<T>): T;
        getIntOrElse(arg0: string, arg1: Internal.IntSupplier_): number;
        getIntOrElse(arg0: string, arg1: number): number;
        getIntOrElse(arg0: Internal.List_<string>, arg1: number): number;
        getIntOrElse(arg0: Internal.List_<string>, arg1: Internal.IntSupplier_): number;
        entrySet(): Internal.Set<Internal.UnmodifiableConfig$Entry>;
        apply<T>(arg0: string): T;
        apply<T>(arg0: Internal.List_<string>): T;
        getShort(arg0: string): number;
        getShort(arg0: Internal.List_<string>): number;
        configFormat(): Internal.ConfigFormat<any>;
        isEmpty(): boolean;
        getOptionalInt(arg0: string): Internal.OptionalInt;
        getOptionalInt(arg0: Internal.List_<string>): Internal.OptionalInt;
        getCharOrElse(arg0: Internal.List_<string>, arg1: string): string;
        getCharOrElse(arg0: string, arg1: string): string;
        getLong(arg0: string): number;
        getLong(arg0: Internal.List_<string>): number;
        getInt(arg0: string): number;
        getInt(arg0: Internal.List_<string>): number;
        getChar(arg0: string): string;
        getChar(arg0: Internal.List_<string>): string;
        getOptional<T>(arg0: string): Internal.Optional<T>;
        getOptional<T>(arg0: Internal.List_<string>): Internal.Optional<T>;
        contains(arg0: Internal.List_<string>): boolean;
        contains(arg0: string): boolean;
        size(): number;
        isNull(arg0: string): boolean;
        isNull(arg0: Internal.List_<string>): boolean;
        getRaw<T>(arg0: string): T;
        getRaw<T>(arg0: Internal.List_<string>): T;
        getOptionalLong(arg0: string): Internal.OptionalLong;
        getOptionalLong(arg0: Internal.List_<string>): Internal.OptionalLong;
        getOptionalEnum<T>(arg0: string, arg1: Internal.Class_<T>): Internal.Optional<T>;
        getOptionalEnum<T>(arg0: Internal.List_<string>, arg1: Internal.Class_<T>): Internal.Optional<T>;
        getOptionalEnum<T>(arg0: string, arg1: Internal.Class_<T>, arg2: Internal.EnumGetMethod_): Internal.Optional<T>;
        getOptionalEnum<T>(arg0: Internal.List_<string>, arg1: Internal.Class_<T>, arg2: Internal.EnumGetMethod_): Internal.Optional<T>;
    }
    type UnmodifiableConfig_ = UnmodifiableConfig;
    class BlockEntityType <T> extends Internal.ForgeRegistryEntry<Internal.BlockEntityType<any>> implements Internal.BlockEntityTypeAccess {
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        hashCode(): number;
        notifyAll(): void;
        equals(arg0: any): boolean;
        getRegistryType(): Internal.Class<Internal.BlockEntityType<any>>;
        getRegistryName(): ResourceLocation;
        toString(): string;
        setRegistryName(arg0: ResourceLocation_): Internal.BlockEntityType<any>;
        setRegistryName(arg0: string): Internal.BlockEntityType<any>;
        setRegistryName(arg0: string, arg1: string): Internal.BlockEntityType<any>;
        notify(): void;
        readonly delegate : Internal.IRegistryDelegate<Internal.BlockEntityType<any>>;
        get registryType(): Internal.Class<Internal.BlockEntityType<any>>;
        get registryName(): ResourceLocation;
        get class(): Internal.Class<any>;
        set registryName(arg0: ResourceLocation_);
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    type BlockEntityType_<T> = BlockEntityType<T>;
    class Context {
        getClass(): Internal.Class<any>;
        static throwAsScriptRuntimeEx(e: Internal.Throwable_): Internal.RuntimeException;
        isSealed(): boolean;
        callFunctionWithContinuations(function_: Internal.Callable_, scope: Internal.Scriptable_, args: any[]): any;
        getClassShutterSetter(): Internal.Context$ClassShutterSetter;
        executeScriptWithContinuations(script: Internal.Script_, scope: Internal.Scriptable_): any;
        createClassLoader(parent: Internal.ClassLoader_): Internal.GeneratedClassLoader;
        getApplicationClassLoader(): Internal.ClassLoader;
        evaluateReader(scope: Internal.Scriptable_, in_: Internal.Reader_, sourceName: string, lineno: number, securityDomain: any): any;
        getTypeWrappers(): Internal.TypeWrappers;
        setRemapper(remapper: Internal.Remapper_): void;
        addCustomJavaToJsWrapper<T>(predicate: Internal.Predicate_<T>, provider: Internal.CustomJavaToJsWrapperProvider_<T>): void;
        addCustomJavaToJsWrapper<T>(type: Internal.Class_<T>, provider: Internal.CustomJavaToJsWrapperProvider_<T>): void;
        static javaToJS(value: any, scope: Internal.Scriptable_): any;
        compileReader(in_: Internal.Reader_, sourceName: string, lineno: number, securityDomain: any): Internal.Script;
        static toBoolean(value: any): boolean;
        captureContinuation(): Internal.ContinuationPending;
        resumeContinuation(continuation: any, scope: Internal.Scriptable_, functionResult: any): any;
        static enter(): Internal.Context;
        static reportRuntimeError0(messageId: string): Internal.EvaluatorException;
        static reportRuntimeError1(messageId: string, arg1: any): Internal.EvaluatorException;
        static reportRuntimeError2(messageId: string, arg1: any, arg2: any): Internal.EvaluatorException;
        static reportRuntimeError3(messageId: string, arg1: any, arg2: any, arg3: any): Internal.EvaluatorException;
        static reportRuntimeError(message: string, sourceName: string, lineno: number, lineSource: string, lineOffset: number): Internal.EvaluatorException;
        static reportRuntimeError(message: string): Internal.EvaluatorException;
        getInstructionObserverThreshold(): number;
        hasTypeWrappers(): boolean;
        getThreadLocal(key: any): any;
        getRemapper(): Internal.Remapper;
        removePropertyChangeListener(l: Internal.PropertyChangeListener_): void;
        static getUndefinedValue(): any;
        putThreadLocal(key: any, value: any): void;
        setClassShutter(shutter: Internal.ClassShutter_): void;
        static exit(): void;
        setInstructionObserverThreshold(threshold: number): void;
        getElements(object: Internal.Scriptable_): any[];
        static reportRuntimeError4(messageId: string, arg1: any, arg2: any, arg3: any, arg4: any): Internal.EvaluatorException;
        hasFeature(featureIndex: number): boolean;
        initSafeStandardObjects(): Internal.ScriptableObject;
        initSafeStandardObjects(scope: Internal.ScriptableObject_): Internal.Scriptable;
        initSafeStandardObjects(scope: Internal.ScriptableObject_, sealed: boolean): Internal.ScriptableObject;
        static toNumber(value: any): number;
        setLocale(loc: Internal.Locale_): Internal.Locale;
        initStandardObjects(): Internal.ScriptableObject;
        initStandardObjects(scope: Internal.ScriptableObject_, sealed: boolean): Internal.ScriptableObject;
        initStandardObjects(scope: Internal.ScriptableObject_): Internal.Scriptable;
        isStrictMode(): boolean;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        setApplicationClassLoader(loader: Internal.ClassLoader_): void;
        getWrapFactory(): Internal.WrapFactory;
        notifyAll(): void;
        setGenerateObserverCount(generateObserverCount: boolean): void;
        seal(sealKey: any): void;
        setWrapFactory(wrapFactory: Internal.WrapFactory_): void;
        evaluateString(scope: Internal.Scriptable_, source: string, sourceName: string, lineno: number, securityDomain: any): any;
        notify(): void;
        compileFunction(scope: Internal.Scriptable_, source: string, sourceName: string, lineno: number, securityDomain: any): dev.latvian.mods.rhino.Function;
        getClassShutter(): Internal.ClassShutter;
        setErrorReporter(reporter: Internal.ErrorReporter_): Internal.ErrorReporter;
        hashCode(): number;
        newObject(scope: Internal.Scriptable_, constructorName: string, args: any[]): Internal.Scriptable;
        newObject(scope: Internal.Scriptable_, constructorName: string): Internal.Scriptable;
        newObject(scope: Internal.Scriptable_): Internal.Scriptable;
        static jsToJava(value: any, desiredType: Internal.Class_<any>): any;
        static toObject(value: any, scope: Internal.Scriptable_): Internal.Scriptable;
        static getSourcePositionFromStack(linep: number[]): string;
        wrapCustomJavaToJs(javaObject: any): Internal.CustomJavaToJsWrapper;
        addPropertyChangeListener(l: Internal.PropertyChangeListener_): void;
        static reportWarning(message: string, t: Internal.Throwable_): void;
        static reportWarning(message: string, sourceName: string, lineno: number, lineSource: string, lineOffset: number): void;
        static reportWarning(message: string): void;
        setLanguageVersion(version: number): void;
        stringIsCompilableUnit(source: string): boolean;
        removeThreadLocal(key: any): void;
        static getCurrentContext(): Internal.Context;
        newArray(scope: Internal.Scriptable_, elements: any[]): Internal.Scriptable;
        newArray(scope: Internal.Scriptable_, length: number): Internal.Scriptable;
        static reportError(message: string): void;
        static reportError(message: string, sourceName: string, lineno: number, lineSource: string, lineOffset: number): void;
        getFactory(): Internal.ContextFactory;
        getErrorReporter(): Internal.ErrorReporter;
        static call(factory: Internal.ContextFactory_, callable: Internal.Callable_, scope: Internal.Scriptable_, thisObj: Internal.Scriptable_, args: any[]): any;
        getMaximumInterpreterStackDepth(): number;
        setMaximumInterpreterStackDepth(max: number): void;
        equals(arg0: any): boolean;
        compileString(source: string, sourceName: string, lineno: number, securityDomain: any): Internal.Script;
        static toString(value: any): string;
        toString(): string;
        unseal(sealKey: any): void;
        getLocale(): Internal.Locale;
        static getContext(): Internal.Context;
        static enterWithNewFactory(): Internal.Context;
        getImplementationVersion(): string;
        static readonly FEATURE_INTEGER_WITHOUT_DECIMAL_PLACE : 18;
        static readonly FEATURE_ENHANCED_JAVA_ACCESS : 13;
        static readonly FEATURE_RESERVED_KEYWORD_AS_IDENTIFIER : 3;
        static readonly FEATURE_DYNAMIC_SCOPE : 7;
        static readonly FEATURE_LITTLE_ENDIAN : 19;
        static readonly FEATURE_THREAD_SAFE_OBJECTS : 17;
        generateObserverCount : boolean;
        static readonly FEATURE_STRICT_MODE : 11;
        static readonly FEATURE_WARNING_AS_ERROR : 12;
        static readonly FEATURE_STRICT_EVAL : 9;
        static readonly FEATURE_LOCATION_INFORMATION_IN_ERROR : 10;
        static readonly errorReporterProperty : "error reporter";
        static readonly FEATURE_V8_EXTENSIONS : 14;
        static readonly FEATURE_STRICT_VARS : 8;
        static readonly FEATURE_MEMBER_EXPR_AS_FUNCTION_NAME : 2;
        static readonly FEATURE_PARENT_PROTO_PROPERTIES : 5;
        static readonly languageVersionProperty : "language version";
        static readonly emptyArgs : any[];
        get factory(): Internal.ContextFactory;
        get undefinedValue(): any;
        get implementationVersion(): string;
        get currentContext(): Internal.Context;
        get sealed(): boolean;
        get strictMode(): boolean;
        get maximumInterpreterStackDepth(): number;
        get locale(): Internal.Locale;
        get typeWrappers(): Internal.TypeWrappers;
        get classShutterSetter(): Internal.Context$ClassShutterSetter;
        get remapper(): Internal.Remapper;
        get errorReporter(): Internal.ErrorReporter;
        get applicationClassLoader(): Internal.ClassLoader;
        get wrapFactory(): Internal.WrapFactory;
        get context(): Internal.Context;
        get class(): Internal.Class<any>;
        get instructionObserverThreshold(): number;
        get classShutter(): Internal.ClassShutter;
        set remapper(remapper: Internal.Remapper_);
        set errorReporter(reporter: Internal.ErrorReporter_);
        set languageVersion(version: number);
        set applicationClassLoader(loader: Internal.ClassLoader_);
        set wrapFactory(wrapFactory: Internal.WrapFactory_);
        set maximumInterpreterStackDepth(max: number);
        set locale(loc: Internal.Locale_);
        set instructionObserverThreshold(threshold: number);
        set classShutter(shutter: Internal.ClassShutter_);
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    type Context_ = Context;
    interface FilenameFilter {
        accept(arg0: Internal.File_, arg1: string): boolean;
    }
    type FilenameFilter_ = ((arg0: Internal.File, arg1: string) => boolean) | FilenameFilter;
    interface FloatComparator extends Internal.Comparator<number> {
        compare(arg0: number, arg1: number): number;
        thenComparingLong(arg0: Internal.ToLongFunction_<number>): Internal.Comparator<number>;
        thenComparingInt(arg0: Internal.ToIntFunction_<number>): Internal.Comparator<number>;
        thenComparing(arg0: Internal.Comparator_<number>): Internal.Comparator<number>;
        thenComparing(arg0: Internal.FloatComparator_): Internal.FloatComparator;
        thenComparing<U_>(arg0: java_.util.function_.Function_<number, U_>, arg1: Internal.Comparator_<U_>): Internal.Comparator<number>;
        thenComparing<U_>(arg0: java_.util.function_.Function_<number, U_>): Internal.Comparator<number>;
        thenComparingDouble(arg0: Internal.ToDoubleFunction_<number>): Internal.Comparator<number>;
        equals(arg0: any): boolean;
        reversed(): Internal.FloatComparator;
    }
    type FloatComparator_ = ((arg0: number, arg1: number) => number) | FloatComparator;
    abstract class ImmutableSet <E> extends Internal.ImmutableCollection<E> implements Internal.Set<E> {
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        notifyAll(): void;
        notify(): void;
        asList(): Internal.ImmutableList<E>;
        remove(arg0: any): boolean;
        removeAll(arg0: Internal.Collection_<any>): boolean;
        iterator(): Internal.UnmodifiableIterator<E>;
        stream(): Internal.Stream<E>;
        hashCode(): number;
        static of<E_>(arg0: E_, arg1: E_, arg2: E_, arg3: E_): Internal.ImmutableSet<E_>;
        static of<E_>(arg0: E_, arg1: E_, arg2: E_): Internal.ImmutableSet<E_>;
        static of<E_>(): Internal.ImmutableSet<E_>;
        static of<E_>(arg0: E_): Internal.ImmutableSet<E_>;
        static of<E_>(arg0: E_, arg1: E_): Internal.ImmutableSet<E_>;
        static of<E_>(arg0: E_, arg1: E_, arg2: E_, arg3: E_, arg4: E_, arg5: E_, arg6: E_[]): Internal.ImmutableSet<E_>;
        static of<E_>(arg0: E_, arg1: E_, arg2: E_, arg3: E_, arg4: E_): Internal.ImmutableSet<E_>;
        toArray(): any[];
        toArray<T_>(arg0: T_[]): T_[];
        toArray<T_>(arg0: Internal.IntFunction_<T_[]>): T_[];
        static builder<E_>(): Internal.ImmutableSet$Builder<E_>;
        parallelStream(): Internal.Stream<E>;
        static toImmutableSet<E_>(): Internal.Collector<E_, any, Internal.ImmutableSet<E_>>;
        add(arg0: E): boolean;
        spliterator(): Internal.Spliterator<E>;
        forEach(arg0: Internal.Consumer_<E>): void;
        containsAll(arg0: Internal.Collection_<any>): boolean;
        isEmpty(): boolean;
        clear(): void;
        static copyOf<E_>(arg0: E_[]): Internal.ImmutableSet<E_>;
        static copyOf<E_>(arg0: Internal.Iterable_<E_>): Internal.ImmutableSet<E_>;
        static copyOf<E_>(arg0: Internal.Collection_<E_>): Internal.ImmutableSet<E_>;
        static copyOf<E_>(arg0: Internal.Iterator_<E_>): Internal.ImmutableSet<E_>;
        removeIf(arg0: Internal.Predicate_<E>): boolean;
        static builderWithExpectedSize<E_>(arg0: number): Internal.ImmutableSet$Builder<E_>;
        contains(arg0: any): boolean;
        size(): number;
        addAll(arg0: Internal.Collection_<E>): boolean;
        equals(arg0: any): boolean;
        toString(): string;
        retainAll(arg0: Internal.Collection_<any>): boolean;
        get class(): Internal.Class<any>;
        get empty(): boolean;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    type ImmutableSet_<E> = ImmutableSet<E>;
    interface SeekableByteChannel extends Internal.ByteChannel {
        isOpen(): boolean;
        read(arg0: Internal.ByteBuffer_): number;
        truncate(arg0: number): Internal.SeekableByteChannel;
        size(): number;
        position(): number;
        position(arg0: number): Internal.SeekableByteChannel;
        close(): void;
        write(arg0: Internal.ByteBuffer_): number;
    }
    type SeekableByteChannel_ = SeekableByteChannel;
    class MobEffectInstance implements Internal.Comparable<Internal.MobEffectInstance>, Internal.IForgeMobEffectInstance, Internal.AccessorMobEffectInstance {
        writeCurativeItems(arg0: Internal.CompoundTag_): void;
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        addCurativeItem(arg0: Internal.ItemStack_): void;
        setCurativeItems(arg0: Internal.List_<Internal.ItemStack_>): void;
        hashCode(): number;
        notifyAll(): void;
        equals(arg0: any): boolean;
        toString(): string;
        compareTo(arg0: Internal.MobEffectInstance_): number;
        isCurativeItem(arg0: Internal.ItemStack_): boolean;
        getCurativeItems(): Internal.List<Internal.ItemStack>;
        notify(): void;
        get curativeItems(): Internal.List<Internal.ItemStack>;
        get class(): Internal.Class<any>;
        set curativeItems(arg0: Internal.List_<Internal.ItemStack_>);
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    type MobEffectInstance_ = MobEffectInstance;
    class DistancePredicateBuilder {
        getClass(): Internal.Class<any>;
        horizontal(arg0: Internal.MinMaxBounds$Doubles_): Internal.DistancePredicateBuilder;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        build(): Internal.DistancePredicate;
        hashCode(): number;
        absolute(arg0: Internal.MinMaxBounds$Doubles_): Internal.DistancePredicateBuilder;
        notifyAll(): void;
        equals(arg0: any): boolean;
        x(arg0: Internal.MinMaxBounds$Doubles_): Internal.DistancePredicateBuilder;
        y(arg0: Internal.MinMaxBounds$Doubles_): Internal.DistancePredicateBuilder;
        toString(): string;
        z(arg0: Internal.MinMaxBounds$Doubles_): Internal.DistancePredicateBuilder;
        notify(): void;
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    type DistancePredicateBuilder_ = DistancePredicateBuilder;
    interface Byte2CharFunction extends Internal.Function<number, string>, Internal.IntUnaryOperator {
        getOrDefault(arg0: any, arg1: string): string;
        getOrDefault(arg0: number, arg1: string): string;
        andThenShort(arg0: Internal.Char2ShortFunction_): Internal.Byte2ShortFunction;
        composeByte(arg0: Internal.Byte2ByteFunction_): Internal.Byte2CharFunction;
        andThenInt(arg0: Internal.Char2IntFunction_): Internal.Byte2IntFunction;
        composeReference<T_>(arg0: Internal.Reference2ByteFunction_<T_>): Internal.Reference2CharFunction<T_>;
        andThen<T_>(arg0: java_.util.function_.Function_<string, T_>): java_.util.function_.Function<number, T_>;
        andThen(arg0: Internal.IntUnaryOperator_): Internal.IntUnaryOperator;
        put(arg0: number, arg1: string): string;
        remove(arg0: number): string;
        remove(arg0: any): string;
        defaultReturnValue(): string;
        defaultReturnValue(arg0: string): void;
        andThenDouble(arg0: Internal.Char2DoubleFunction_): Internal.Byte2DoubleFunction;
        andThenObject<T_>(arg0: Internal.Char2ObjectFunction_<T_>): Internal.Byte2ObjectFunction<T_>;
        get(arg0: any): string;
        get(arg0: number): string;
        andThenLong(arg0: Internal.Char2LongFunction_): Internal.Byte2LongFunction;
        composeLong(arg0: Internal.Long2ByteFunction_): Internal.Long2CharFunction;
        andThenByte(arg0: Internal.Char2ByteFunction_): Internal.Byte2ByteFunction;
        andThenFloat(arg0: Internal.Char2FloatFunction_): Internal.Byte2FloatFunction;
        applyAsInt(arg0: number): number;
        apply(arg0: number): string;
        containsKey(arg0: any): boolean;
        containsKey(arg0: number): boolean;
        composeInt(arg0: Internal.Int2ByteFunction_): Internal.Int2CharFunction;
        clear(): void;
        composeFloat(arg0: Internal.Float2ByteFunction_): Internal.Float2CharFunction;
        andThenChar(arg0: Internal.Char2CharFunction_): Internal.Byte2CharFunction;
        composeObject<T_>(arg0: Internal.Object2ByteFunction_<T_>): Internal.Object2CharFunction<T_>;
        size(): number;
        compose<T_>(arg0: java_.util.function_.Function_<T_, number>): java_.util.function_.Function<T_, string>;
        compose(arg0: Internal.IntUnaryOperator_): Internal.IntUnaryOperator;
        composeShort(arg0: Internal.Short2ByteFunction_): Internal.Short2CharFunction;
        andThenReference<T_>(arg0: Internal.Char2ReferenceFunction_<T_>): Internal.Byte2ReferenceFunction<T_>;
        composeChar(arg0: Internal.Char2ByteFunction_): Internal.Char2CharFunction;
        composeDouble(arg0: Internal.Double2ByteFunction_): Internal.Double2CharFunction;
    }
    type Byte2CharFunction_ = ((arg0: number) => string) | Byte2CharFunction;
    interface IRecipeLayout {
        getIngredientsGroup<T>(arg0: Internal.IIngredientType_<T>): Internal.IGuiIngredientGroup<T>;
        moveRecipeTransferButton(arg0: number, arg1: number): void;
        getItemStacks(): Internal.IGuiItemStackGroup;
        getFluidStacks(): Internal.IGuiFluidStackGroup;
        getFocus<V>(arg0: Internal.IIngredientType_<V>): Internal.IFocus<V>;
        setShapeless(): void;
    }
    type IRecipeLayout_ = IRecipeLayout;
    class CropBlockBuilder$ShapeBuilder {
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        getShapes(): Internal.List<Internal.VoxelShape>;
        shape(age: number, minX: number, minY: number, minZ: number, maxX: number, maxY: number, maxZ: number): Internal.CropBlockBuilder$ShapeBuilder;
        hashCode(): number;
        notifyAll(): void;
        equals(arg0: any): boolean;
        toString(): string;
        notify(): void;
        get shapes(): Internal.List<Internal.VoxelShape>;
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    type CropBlockBuilder$ShapeBuilder_ = CropBlockBuilder$ShapeBuilder;
    class ResolverStyle extends Internal.Enum<Internal.ResolverStyle> {
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        static valueOf(arg0: string): Internal.ResolverStyle;
        static valueOf<T_>(arg0: Internal.Class_<T_>, arg1: string): T_;
        notifyAll(): void;
        static values(): Internal.ResolverStyle[];
        compareTo(arg0: Internal.ResolverStyle_): number;
        describeConstable(): Internal.Optional<Internal.Enum$EnumDesc<Internal.ResolverStyle>>;
        notify(): void;
        getDeclaringClass(): Internal.Class<Internal.ResolverStyle>;
        hashCode(): number;
        equals(arg0: any): boolean;
        name(): string;
        toString(): string;
        ordinal(): number;
        static readonly STRICT : Internal.ResolverStyle;
        static readonly LENIENT : Internal.ResolverStyle;
        static readonly SMART : Internal.ResolverStyle;
        get class(): Internal.Class<any>;
        get declaringClass(): Internal.Class<Internal.ResolverStyle>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    type ResolverStyle_ = "strict" | "smart" | "lenient" | ResolverStyle;
    class Heightmap$Types extends Internal.Enum<Internal.Heightmap$Types> implements Internal.StringRepresentable {
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        static valueOf(arg0: string): Internal.Heightmap$Types;
        static valueOf<T_>(arg0: Internal.Class_<T_>, arg1: string): T_;
        notifyAll(): void;
        static values(): Internal.Heightmap$Types[];
        compareTo(arg0: Internal.Heightmap$Types_): number;
        describeConstable(): Internal.Optional<Internal.Enum$EnumDesc<Internal.Heightmap$Types>>;
        notify(): void;
        getDeclaringClass(): Internal.Class<Internal.Heightmap$Types>;
        hashCode(): number;
        equals(arg0: any): boolean;
        name(): string;
        toString(): string;
        ordinal(): number;
        static readonly OCEAN_FLOOR : Internal.Heightmap$Types;
        static readonly MOTION_BLOCKING_NO_LEAVES : Internal.Heightmap$Types;
        static readonly MOTION_BLOCKING : Internal.Heightmap$Types;
        static readonly WORLD_SURFACE : Internal.Heightmap$Types;
        static readonly OCEAN_FLOOR_WG : Internal.Heightmap$Types;
        static readonly WORLD_SURFACE_WG : Internal.Heightmap$Types;
        get class(): Internal.Class<any>;
        get declaringClass(): Internal.Class<Internal.Heightmap$Types>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    type Heightmap$Types_ = "world_surface_wg" | "world_surface" | "ocean_floor" | "motion_blocking_no_leaves" | "motion_blocking" | "ocean_floor_wg" | Heightmap$Types;
    abstract class ImmutableMultimap <K, V> extends Internal.BaseImmutableMultimap<K, V> implements Internal.Serializable {
        getClass(): Internal.Class<any>;
        inverse(): Internal.ImmutableMultimap<V, K>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        asMap(): Internal.ImmutableMap<K, Internal.Collection<V>>;
        keys(): Internal.ImmutableMultiset<K>;
        containsKey(arg0: any): boolean;
        forEach(arg0: Internal.BiConsumer_<K, V>): void;
        notifyAll(): void;
        values(): Internal.ImmutableCollection<V>;
        clear(): void;
        static copyOf<K_, V_>(arg0: Internal.Iterable_<Internal.Map$Entry_<K_, V_>>): Internal.ImmutableMultimap<K_, V_>;
        static copyOf<K_, V_>(arg0: Internal.Multimap_<K_, V_>): Internal.ImmutableMultimap<K_, V_>;
        replaceValues(arg0: K, arg1: Internal.Iterable_<V>): Internal.ImmutableCollection<V>;
        notify(): void;
        containsValue(arg0: any): boolean;
        put(arg0: K, arg1: V): boolean;
        remove(arg0: any, arg1: any): boolean;
        removeAll(arg0: any): Internal.ImmutableCollection<V>;
        entries(): Internal.ImmutableCollection<Internal.Map$Entry<K, V>>;
        size(): number;
        putAll(arg0: K, arg1: Internal.Iterable_<V>): boolean;
        putAll(arg0: Internal.Multimap_<K, V>): boolean;
        static of<K_, V_>(): Internal.ImmutableMultimap<K_, V_>;
        static of<K_, V_>(arg0: K_, arg1: V_, arg2: K_, arg3: V_, arg4: K_, arg5: V_, arg6: K_, arg7: V_): Internal.ImmutableMultimap<K_, V_>;
        static of<K_, V_>(arg0: K_, arg1: V_, arg2: K_, arg3: V_): Internal.ImmutableMultimap<K_, V_>;
        static of<K_, V_>(arg0: K_, arg1: V_, arg2: K_, arg3: V_, arg4: K_, arg5: V_, arg6: K_, arg7: V_, arg8: K_, arg9: V_): Internal.ImmutableMultimap<K_, V_>;
        static of<K_, V_>(arg0: K_, arg1: V_, arg2: K_, arg3: V_, arg4: K_, arg5: V_): Internal.ImmutableMultimap<K_, V_>;
        static of<K_, V_>(arg0: K_, arg1: V_): Internal.ImmutableMultimap<K_, V_>;
        get(arg0: K): Internal.ImmutableCollection<V>;
        static builder<K_, V_>(): Internal.ImmutableMultimap$Builder<K_, V_>;
        keySet(): Internal.ImmutableSet<K>;
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    type ImmutableMultimap_<K, V> = ImmutableMultimap<K, V>;
    interface PathIterator {
        next(): void;
        getWindingRule(): number;
        currentSegment(arg0: number[]): number;
        isDone(): boolean;
    }
    type PathIterator_ = PathIterator;
    abstract class DragGestureRecognizer implements Internal.Serializable {
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        removeDragGestureListener(arg0: Internal.DragGestureListener_): void;
        notifyAll(): void;
        resetRecognizer(): void;
        setComponent(arg0: java_.awt.Component_): void;
        notify(): void;
        getSourceActions(): number;
        getTriggerEvent(): Internal.InputEvent;
        hashCode(): number;
        getDragSource(): Internal.DragSource;
        equals(arg0: any): boolean;
        addDragGestureListener(arg0: Internal.DragGestureListener_): void;
        setSourceActions(arg0: number): void;
        toString(): string;
        getComponent(): java_.awt.Component;
        get sourceActions(): number;
        get component(): java_.awt.Component;
        get triggerEvent(): Internal.InputEvent;
        get class(): Internal.Class<any>;
        get dragSource(): Internal.DragSource;
        set sourceActions(arg0: number);
        set component(arg0: java_.awt.Component_);
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    type DragGestureRecognizer_ = DragGestureRecognizer;
    class Suggestions {
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        getList(): Internal.List<Internal.Suggestion>;
        getRange(): Internal.StringRange;
        hashCode(): number;
        notifyAll(): void;
        static merge(arg0: string, arg1: Internal.Collection_<Internal.Suggestions_>): Internal.Suggestions;
        equals(arg0: any): boolean;
        isEmpty(): boolean;
        static create(arg0: string, arg1: Internal.Collection_<Internal.Suggestion_>): Internal.Suggestions;
        toString(): string;
        notify(): void;
        static empty(): Internal.CompletableFuture<Internal.Suggestions>;
        get range(): Internal.StringRange;
        get list(): Internal.List<Internal.Suggestion>;
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    type Suggestions_ = Suggestions;
    interface ByteConsumer extends Internal.Consumer<number>, java_.util.function_.IntConsumer {
        andThen(arg0: Internal.Consumer_<number>): Internal.Consumer<number>;
        andThen(arg0: java_.util.function_.IntConsumer_): Internal.ByteConsumer;
        andThen(arg0: Internal.ByteConsumer_): Internal.ByteConsumer;
        accept(arg0: number): void;
    }
    type ByteConsumer_ = ((arg0: number) => void) | ByteConsumer;
    interface LongStream extends Internal.BaseStream<number, Internal.LongStream> {
        average(): Internal.OptionalDouble;
        sequential(): Internal.LongStream;
        takeWhile(arg0: Internal.LongPredicate_): Internal.LongStream;
        distinct(): Internal.LongStream;
        findFirst(): Internal.OptionalLong;
        sum(): number;
        skip(arg0: number): Internal.LongStream;
        allMatch(arg0: Internal.LongPredicate_): boolean;
        mapToObj<U_>(arg0: Internal.LongFunction_<U_>): Internal.Stream<U_>;
        mapMulti(arg0: Internal.LongStream$LongMapMultiConsumer_): Internal.LongStream;
        iterator(): Internal.PrimitiveIterator$OfLong;
        asDoubleStream(): Internal.DoubleStream;
        min(): Internal.OptionalLong;
        parallel(): Internal.LongStream;
        noneMatch(arg0: Internal.LongPredicate_): boolean;
        findAny(): Internal.OptionalLong;
        isParallel(): boolean;
        limit(arg0: number): Internal.LongStream;
        toArray(): number[];
        forEachOrdered(arg0: java_.util.function_.LongConsumer_): void;
        close(): void;
        anyMatch(arg0: Internal.LongPredicate_): boolean;
        map(arg0: Internal.LongUnaryOperator_): Internal.LongStream;
        mapToDouble(arg0: Internal.LongToDoubleFunction_): Internal.DoubleStream;
        unordered(): Internal.LongStream;
        reduce(arg0: Internal.LongBinaryOperator_): Internal.OptionalLong;
        reduce(arg0: number, arg1: Internal.LongBinaryOperator_): number;
        spliterator(): Internal.Spliterator$OfLong;
        max(): Internal.OptionalLong;
        forEach(arg0: java_.util.function_.LongConsumer_): void;
        count(): number;
        dropWhile(arg0: Internal.LongPredicate_): Internal.LongStream;
        peek(arg0: java_.util.function_.LongConsumer_): Internal.LongStream;
        flatMap(arg0: Internal.LongFunction_<Internal.LongStream_>): Internal.LongStream;
        filter(arg0: Internal.LongPredicate_): Internal.LongStream;
        onClose(arg0: Internal.Runnable_): Internal.LongStream;
        sorted(): Internal.LongStream;
        boxed(): Internal.Stream<number>;
        summaryStatistics(): Internal.LongSummaryStatistics;
        mapToInt(arg0: Internal.LongToIntFunction_): Internal.IntStream;
        collect<R_>(arg0: Internal.Supplier_<R_>, arg1: Internal.ObjLongConsumer_<R_>, arg2: Internal.BiConsumer_<R_, R_>): R_;
    }
    type LongStream_ = LongStream;
    abstract class AbstractList <E> extends Internal.AbstractCollection<E> implements Internal.List<E> {
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        notifyAll(): void;
        replaceAll(arg0: Internal.UnaryOperator_<E>): void;
        notify(): void;
        remove(arg0: number): E;
        remove(arg0: any): boolean;
        removeAll(arg0: Internal.Collection_<any>): boolean;
        iterator(): Internal.Iterator<E>;
        stream(): Internal.Stream<E>;
        hashCode(): number;
        get(arg0: number): E;
        toArray(): any[];
        toArray<T_>(arg0: T_[]): T_[];
        toArray<T_>(arg0: Internal.IntFunction_<T_[]>): T_[];
        parallelStream(): Internal.Stream<E>;
        indexOf(arg0: any): number;
        add(arg0: number, arg1: E): void;
        add(arg0: E): boolean;
        subList(arg0: number, arg1: number): Internal.List<E>;
        set(arg0: number, arg1: E): E;
        spliterator(): Internal.Spliterator<E>;
        forEach(arg0: Internal.Consumer_<E>): void;
        containsAll(arg0: Internal.Collection_<any>): boolean;
        isEmpty(): boolean;
        clear(): void;
        sort(arg0: Internal.Comparator_<E>): void;
        removeIf(arg0: Internal.Predicate_<E>): boolean;
        lastIndexOf(arg0: any): number;
        contains(arg0: any): boolean;
        size(): number;
        addAll(arg0: number, arg1: Internal.Collection_<E>): boolean;
        addAll(arg0: Internal.Collection_<E>): boolean;
        equals(arg0: any): boolean;
        listIterator(): Internal.ListIterator<E>;
        listIterator(arg0: number): Internal.ListIterator<E>;
        toString(): string;
        retainAll(arg0: Internal.Collection_<any>): boolean;
        get class(): Internal.Class<any>;
        get empty(): boolean;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    type AbstractList_<E> = AbstractList<E>;
    interface Codec$ResultFunction <A> {
        apply<T>(arg0: Internal.DynamicOps_<T>, arg1: T, arg2: Internal.DataResult_<Internal.Pair_<A, T>>): Internal.DataResult<Internal.Pair<A, T>>;
        coApply<T>(arg0: Internal.DynamicOps_<T>, arg1: A, arg2: Internal.DataResult_<T>): Internal.DataResult<T>;
    }
    type Codec$ResultFunction_<A> = Codec$ResultFunction<A>;
    class AccessControlContext {
        getClass(): Internal.Class<any>;
        checkPermission(arg0: Internal.Permission_): void;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        hashCode(): number;
        notifyAll(): void;
        equals(arg0: any): boolean;
        getDomainCombiner(): Internal.DomainCombiner;
        toString(): string;
        notify(): void;
        get domainCombiner(): Internal.DomainCombiner;
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    type AccessControlContext_ = AccessControlContext;
    interface ConstProperties {
        defineConst(arg0: string, arg1: Internal.Scriptable_): void;
        isConst(arg0: string): boolean;
        putConst(arg0: string, arg1: Internal.Scriptable_, arg2: any): void;
    }
    type ConstProperties_ = ConstProperties;
    class SpawnPlacements$Type extends Internal.Enum<Internal.SpawnPlacements$Type> implements Internal.IExtensibleEnum {
        init(): void;
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        static valueOf(arg0: string): Internal.SpawnPlacements$Type;
        static valueOf<T_>(arg0: Internal.Class_<T_>, arg1: string): T_;
        notifyAll(): void;
        static values(): Internal.SpawnPlacements$Type[];
        compareTo(arg0: Internal.SpawnPlacements$Type_): number;
        describeConstable(): Internal.Optional<Internal.Enum$EnumDesc<Internal.SpawnPlacements$Type>>;
        notify(): void;
        getDeclaringClass(): Internal.Class<Internal.SpawnPlacements$Type>;
        hashCode(): number;
        canSpawnAt(arg0: Internal.LevelReader_, arg1: BlockPos_, arg2: Internal.EntityType_<any>): boolean;
        equals(arg0: any): boolean;
        name(): string;
        static create(arg0: string, arg1: Internal.TriPredicate_<Internal.LevelReader_, BlockPos_, Internal.EntityType_<Internal.Mob_>>): Internal.SpawnPlacements$Type;
        toString(): string;
        ordinal(): number;
        static readonly IN_LAVA : Internal.SpawnPlacements$Type;
        static readonly IN_WATER : Internal.SpawnPlacements$Type;
        static readonly ON_GROUND : Internal.SpawnPlacements$Type;
        static readonly NO_RESTRICTIONS : Internal.SpawnPlacements$Type;
        get class(): Internal.Class<any>;
        get declaringClass(): Internal.Class<Internal.SpawnPlacements$Type>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    type SpawnPlacements$Type_ = "tf_on_ice" | "cloud_dwellers" | "no_restrictions" | "in_lava" | "on_ground" | "blue_skies:on_ground_or_water" | "in_water" | SpawnPlacements$Type;
    interface ObjIntConsumer <T> {
        accept(arg0: T, arg1: number): void;
    }
    type ObjIntConsumer_<T> = ((arg0: T, arg1: number) => void) | ObjIntConsumer<T>;
    interface IGuiIngredient <T> {
        getDisplayedIngredient(): T;
        getIngredientType(): Internal.IIngredientType<T>;
        isInput(): boolean;
        getAllIngredients(): Internal.List<T>;
        drawHighlight(arg0: Internal.PoseStack_, arg1: number, arg2: number, arg3: number): void;
    }
    type IGuiIngredient_<T> = IGuiIngredient<T>;
    class SoundEvent extends Internal.ForgeRegistryEntry<Internal.SoundEvent> {
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        hashCode(): number;
        notifyAll(): void;
        equals(arg0: any): boolean;
        getRegistryType(): Internal.Class<Internal.SoundEvent>;
        getRegistryName(): ResourceLocation;
        toString(): string;
        setRegistryName(arg0: ResourceLocation_): Internal.SoundEvent;
        setRegistryName(arg0: string): Internal.SoundEvent;
        setRegistryName(arg0: string, arg1: string): Internal.SoundEvent;
        notify(): void;
        readonly delegate : Internal.IRegistryDelegate<Internal.SoundEvent>;
        get registryType(): Internal.Class<Internal.SoundEvent>;
        get registryName(): ResourceLocation;
        get class(): Internal.Class<any>;
        set registryName(arg0: ResourceLocation_);
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    type SoundEvent_ = SoundEvent;
    interface ToLongFunction <T> {
        applyAsLong(arg0: T): number;
    }
    type ToLongFunction_<T> = ((arg0: T) => number) | ToLongFunction<T>;
    abstract class ResourceBundle {
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        getObject(arg0: string): any;
        getBaseBundleName(): string;
        containsKey(arg0: string): boolean;
        notifyAll(): void;
        static clearCache(): void;
        static clearCache(arg0: Internal.ClassLoader_): void;
        getKeys(): Internal.Enumeration<string>;
        getString(arg0: string): string;
        notify(): void;
        static getBundle(arg0: string, arg1: Internal.Locale_): Internal.ResourceBundle;
        static getBundle(arg0: string, arg1: Internal.ResourceBundle$Control_): Internal.ResourceBundle;
        static getBundle(arg0: string): Internal.ResourceBundle;
        static getBundle(arg0: string, arg1: Internal.Locale_, arg2: Internal.ClassLoader_): Internal.ResourceBundle;
        static getBundle(arg0: string, arg1: Internal.Locale_, arg2: Internal.ClassLoader_, arg3: Internal.ResourceBundle$Control_): Internal.ResourceBundle;
        static getBundle(arg0: string, arg1: Internal.Locale_, arg2: Internal.ResourceBundle$Control_): Internal.ResourceBundle;
        static getBundle(arg0: string, arg1: Internal.Locale_, arg2: Internal.Module_): Internal.ResourceBundle;
        static getBundle(arg0: string, arg1: Internal.Module_): Internal.ResourceBundle;
        hashCode(): number;
        equals(arg0: any): boolean;
        toString(): string;
        getStringArray(arg0: string): string[];
        getLocale(): Internal.Locale;
        keySet(): Internal.Set<string>;
        get baseBundleName(): string;
        get keys(): Internal.Enumeration<string>;
        get locale(): Internal.Locale;
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    type ResourceBundle_ = ResourceBundle;
    class Products$P8 <F, T1, T2, T3, T4, T5, T6, T7, T8> {
        t4(): Internal.App<F, T4>;
        getClass(): Internal.Class<any>;
        t5(): Internal.App<F, T5>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        t6(): Internal.App<F, T6>;
        t7(): Internal.App<F, T7>;
        t8(): Internal.App<F, T8>;
        apply<R>(arg0: Internal.Applicative_<F, any>, arg1: Internal.Function8_<T1, T2, T3, T4, T5, T6, T7, T8, R>): Internal.App<F, R>;
        apply<R>(arg0: Internal.Applicative_<F, any>, arg1: Internal.App_<F, Internal.Function8_<T1, T2, T3, T4, T5, T6, T7, T8, R>>): Internal.App<F, R>;
        notifyAll(): void;
        notify(): void;
        hashCode(): number;
        equals(arg0: any): boolean;
        toString(): string;
        t1(): Internal.App<F, T1>;
        t2(): Internal.App<F, T2>;
        t3(): Internal.App<F, T3>;
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    type Products$P8_<F, T1, T2, T3, T4, T5, T6, T7, T8> = Products$P8<F, T1, T2, T3, T4, T5, T6, T7, T8>;
    /**
    * Fired on an entity is spawned.
    */
    class EntitySpawnedEventJS extends Internal.EntityEventJS {
        cancel(): void;
        getServer(): Internal.ServerJS;
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        isCancelled(): boolean;
        notifyAll(): void;
        getEntity(): Internal.EntityJS;
        notify(): void;
        getLevel(): Internal.LevelJS;
        post(id: string): boolean;
        post(id: string, sub: string): boolean;
        post(t: Internal.ScriptType_, id: string, sub: string): boolean;
        post(t: Internal.ScriptType_, id: string): boolean;
        hashCode(): number;
        equals(arg0: any): boolean;
        toString(): string;
        canCancel(): boolean;
        get server(): Internal.ServerJS;
        get level(): Internal.LevelJS;
        get cancelled(): boolean;
        get class(): Internal.Class<any>;
        get entity(): Internal.EntityJS;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    /**
    * Fired on an entity is spawned.
    */
    type EntitySpawnedEventJS_ = EntitySpawnedEventJS;
    interface ClassDesc extends Internal.ConstantDesc, Internal.TypeDescriptor$OfField<Internal.ClassDesc> {
        componentType(): Internal.ClassDesc;
        arrayType(): Internal.ClassDesc;
        arrayType(arg0: number): Internal.ClassDesc;
        displayName(): string;
        equals(arg0: any): boolean;
        descriptorString(): string;
        isArray(): boolean;
        resolveConstantDesc(arg0: Internal.MethodHandles$Lookup_): any;
        packageName(): string;
        isClassOrInterface(): boolean;
        nested(arg0: string): Internal.ClassDesc;
        nested(arg0: string, arg1: string[]): Internal.ClassDesc;
        isPrimitive(): boolean;
    }
    type ClassDesc_ = ClassDesc;
    class ParseResults <S> {
        getExceptions(): Internal.Map<Internal.CommandNode<S>, Internal.CommandSyntaxException>;
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        getReader(): Internal.ImmutableStringReader;
        hashCode(): number;
        notifyAll(): void;
        equals(arg0: any): boolean;
        toString(): string;
        getContext(): Internal.CommandContextBuilder<S>;
        notify(): void;
        get reader(): Internal.ImmutableStringReader;
        get context(): Internal.CommandContextBuilder<S>;
        get class(): Internal.Class<any>;
        get exceptions(): Internal.Map<Internal.CommandNode<S>, Internal.CommandSyntaxException>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    type ParseResults_<S> = ParseResults<S>;
    interface ChannelPipeline extends Internal.ChannelInboundInvoker, Internal.ChannelOutboundInvoker, Internal.Iterable<Internal.Map$Entry<string, Internal.ChannelHandler>> {
        disconnect(): Internal.ChannelFuture;
        disconnect(arg0: Internal.ChannelPromise_): Internal.ChannelFuture;
        newProgressivePromise(): Internal.ChannelProgressivePromise;
        fireChannelWritabilityChanged(): Internal.ChannelPipeline;
        fireChannelWritabilityChanged(): Internal.ChannelInboundInvoker;
        channel(): io.netty.channel.Channel;
        replace(arg0: Internal.ChannelHandler_, arg1: string, arg2: Internal.ChannelHandler_): Internal.ChannelPipeline;
        replace(arg0: string, arg1: string, arg2: Internal.ChannelHandler_): Internal.ChannelHandler;
        replace<T_>(arg0: Internal.Class_<T_>, arg1: string, arg2: Internal.ChannelHandler_): T_;
        fireExceptionCaught(arg0: Internal.Throwable_): Internal.ChannelPipeline;
        fireExceptionCaught(arg0: Internal.Throwable_): Internal.ChannelInboundInvoker;
        fireChannelActive(): Internal.ChannelPipeline;
        fireChannelActive(): Internal.ChannelInboundInvoker;
        removeLast(): Internal.ChannelHandler;
        remove(arg0: string): Internal.ChannelHandler;
        remove<T_>(arg0: Internal.Class_<T_>): T_;
        remove(arg0: Internal.ChannelHandler_): Internal.ChannelPipeline;
        writeAndFlush(arg0: any, arg1: Internal.ChannelPromise_): Internal.ChannelFuture;
        writeAndFlush(arg0: any): Internal.ChannelFuture;
        addLast(arg0: string, arg1: Internal.ChannelHandler_): Internal.ChannelPipeline;
        addLast(arg0: Internal.EventExecutorGroup_, arg1: string, arg2: Internal.ChannelHandler_): Internal.ChannelPipeline;
        addLast(arg0: Internal.ChannelHandler_[]): Internal.ChannelPipeline;
        addLast(arg0: Internal.EventExecutorGroup_, arg1: Internal.ChannelHandler_[]): Internal.ChannelPipeline;
        iterator(): Internal.Iterator<Internal.Map$Entry<string, Internal.ChannelHandler>>;
        addAfter(arg0: string, arg1: string, arg2: Internal.ChannelHandler_): Internal.ChannelPipeline;
        addAfter(arg0: Internal.EventExecutorGroup_, arg1: string, arg2: string, arg3: Internal.ChannelHandler_): Internal.ChannelPipeline;
        bind(arg0: Internal.SocketAddress_): Internal.ChannelFuture;
        bind(arg0: Internal.SocketAddress_, arg1: Internal.ChannelPromise_): Internal.ChannelFuture;
        flush(): Internal.ChannelPipeline;
        flush(): Internal.ChannelOutboundInvoker;
        removeFirst(): Internal.ChannelHandler;
        get<T_>(arg0: Internal.Class_<T_>): T_;
        get(arg0: string): Internal.ChannelHandler;
        context(arg0: Internal.Class_<Internal.ChannelHandler_>): Internal.ChannelHandlerContext;
        context(arg0: string): Internal.ChannelHandlerContext;
        context(arg0: Internal.ChannelHandler_): Internal.ChannelHandlerContext;
        close(arg0: Internal.ChannelPromise_): Internal.ChannelFuture;
        close(): Internal.ChannelFuture;
        write(arg0: any): Internal.ChannelFuture;
        write(arg0: any, arg1: Internal.ChannelPromise_): Internal.ChannelFuture;
        connect(arg0: Internal.SocketAddress_, arg1: Internal.SocketAddress_, arg2: Internal.ChannelPromise_): Internal.ChannelFuture;
        connect(arg0: Internal.SocketAddress_, arg1: Internal.ChannelPromise_): Internal.ChannelFuture;
        connect(arg0: Internal.SocketAddress_): Internal.ChannelFuture;
        connect(arg0: Internal.SocketAddress_, arg1: Internal.SocketAddress_): Internal.ChannelFuture;
        newPromise(): Internal.ChannelPromise;
        firstContext(): Internal.ChannelHandlerContext;
        read(): Internal.ChannelOutboundInvoker;
        fireChannelInactive(): Internal.ChannelPipeline;
        fireChannelInactive(): Internal.ChannelInboundInvoker;
        fireChannelReadComplete(): Internal.ChannelPipeline;
        fireChannelReadComplete(): Internal.ChannelInboundInvoker;
        last(): Internal.ChannelHandler;
        spliterator(): Internal.Spliterator<Internal.Map$Entry<string, Internal.ChannelHandler>>;
        forEach(arg0: Internal.Consumer_<Internal.Map$Entry_<string, Internal.ChannelHandler_>>): void;
        deregister(arg0: Internal.ChannelPromise_): Internal.ChannelFuture;
        deregister(): Internal.ChannelFuture;
        newFailedFuture(arg0: Internal.Throwable_): Internal.ChannelFuture;
        fireChannelRegistered(): Internal.ChannelPipeline;
        fireChannelRegistered(): Internal.ChannelInboundInvoker;
        addBefore(arg0: string, arg1: string, arg2: Internal.ChannelHandler_): Internal.ChannelPipeline;
        addBefore(arg0: Internal.EventExecutorGroup_, arg1: string, arg2: string, arg3: Internal.ChannelHandler_): Internal.ChannelPipeline;
        fireChannelRead(arg0: any): Internal.ChannelPipeline;
        fireChannelRead(arg0: any): Internal.ChannelInboundInvoker;
        names(): Internal.List<string>;
        voidPromise(): Internal.ChannelPromise;
        newSucceededFuture(): Internal.ChannelFuture;
        toMap(): Internal.Map<string, Internal.ChannelHandler>;
        fireUserEventTriggered(arg0: any): Internal.ChannelPipeline;
        fireUserEventTriggered(arg0: any): Internal.ChannelInboundInvoker;
        fireChannelUnregistered(): Internal.ChannelPipeline;
        fireChannelUnregistered(): Internal.ChannelInboundInvoker;
        lastContext(): Internal.ChannelHandlerContext;
        addFirst(arg0: string, arg1: Internal.ChannelHandler_): Internal.ChannelPipeline;
        addFirst(arg0: Internal.ChannelHandler_[]): Internal.ChannelPipeline;
        addFirst(arg0: Internal.EventExecutorGroup_, arg1: string, arg2: Internal.ChannelHandler_): Internal.ChannelPipeline;
        addFirst(arg0: Internal.EventExecutorGroup_, arg1: Internal.ChannelHandler_[]): Internal.ChannelPipeline;
        first(): Internal.ChannelHandler;
    }
    type ChannelPipeline_ = ChannelPipeline;
    class OffsetTime implements Internal.Temporal, Internal.TemporalAdjuster, Internal.Comparable<Internal.OffsetTime>, Internal.Serializable {
        getClass(): Internal.Class<any>;
        plusHours(arg0: number): Internal.OffsetTime;
        isEqual(arg0: Internal.OffsetTime_): boolean;
        atDate(arg0: Internal.LocalDate_): Internal.OffsetDateTime;
        toLocalTime(): Internal.LocalTime;
        compareTo(arg0: Internal.OffsetTime_): number;
        withOffsetSameLocal(arg0: Internal.ZoneOffset_): Internal.OffsetTime;
        plusSeconds(arg0: number): Internal.OffsetTime;
        getMinute(): number;
        static from(arg0: Internal.TemporalAccessor_): Internal.OffsetTime;
        plusNanos(arg0: number): Internal.OffsetTime;
        withHour(arg0: number): Internal.OffsetTime;
        truncatedTo(arg0: Internal.TemporalUnit_): Internal.OffsetTime;
        query<R_>(arg0: Internal.TemporalQuery_<R_>): R_;
        minusNanos(arg0: number): Internal.OffsetTime;
        getNano(): number;
        format(arg0: Internal.DateTimeFormatter_): string;
        isSupported(arg0: Internal.TemporalField_): boolean;
        isSupported(arg0: Internal.TemporalUnit_): boolean;
        plus(arg0: number, arg1: Internal.TemporalUnit_): Internal.OffsetTime;
        plus(arg0: Internal.TemporalAmount_): Internal.OffsetTime;
        toEpochSecond(arg0: Internal.LocalDate_): number;
        isAfter(arg0: Internal.OffsetTime_): boolean;
        static ofInstant(arg0: Internal.Instant_, arg1: Internal.ZoneId_): Internal.OffsetTime;
        minus(arg0: Internal.TemporalAmount_): Internal.OffsetTime;
        minus(arg0: number, arg1: Internal.TemporalUnit_): Internal.OffsetTime;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        minusHours(arg0: number): Internal.OffsetTime;
        notifyAll(): void;
        getOffset(): Internal.ZoneOffset;
        adjustInto(arg0: Internal.Temporal_): Internal.Temporal;
        range(arg0: Internal.TemporalField_): Internal.ValueRange;
        plusMinutes(arg0: number): Internal.OffsetTime;
        notify(): void;
        minusMinutes(arg0: number): Internal.OffsetTime;
        hashCode(): number;
        static now(): Internal.OffsetTime;
        static now(arg0: Internal.Clock_): Internal.OffsetTime;
        static now(arg0: Internal.ZoneId_): Internal.OffsetTime;
        static of(arg0: Internal.LocalTime_, arg1: Internal.ZoneOffset_): Internal.OffsetTime;
        static of(arg0: number, arg1: number, arg2: number, arg3: number, arg4: Internal.ZoneOffset_): Internal.OffsetTime;
        get(arg0: Internal.TemporalField_): number;
        getHour(): number;
        withMinute(arg0: number): Internal.OffsetTime;
        static parse(arg0: Internal.CharSequence_): Internal.OffsetTime;
        static parse(arg0: Internal.CharSequence_, arg1: Internal.DateTimeFormatter_): Internal.OffsetTime;
        isBefore(arg0: Internal.OffsetTime_): boolean;
        withNano(arg0: number): Internal.OffsetTime;
        getLong(arg0: Internal.TemporalField_): number;
        with(arg0: Internal.TemporalAdjuster_): Internal.OffsetTime;
        with(arg0: Internal.TemporalField_, arg1: number): Internal.OffsetTime;
        withOffsetSameInstant(arg0: Internal.ZoneOffset_): Internal.OffsetTime;
        equals(arg0: any): boolean;
        getSecond(): number;
        until(arg0: Internal.Temporal_, arg1: Internal.TemporalUnit_): number;
        toString(): string;
        minusSeconds(arg0: number): Internal.OffsetTime;
        withSecond(arg0: number): Internal.OffsetTime;
        static readonly MIN : Internal.OffsetTime;
        static readonly MAX : Internal.OffsetTime;
        get offset(): Internal.ZoneOffset;
        get hour(): number;
        get nano(): number;
        get class(): Internal.Class<any>;
        get minute(): number;
        get second(): number;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    type OffsetTime_ = OffsetTime;
    class IntSummaryStatistics implements java_.util.function_.IntConsumer {
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        getMax(): number;
        notifyAll(): void;
        getAverage(): number;
        andThen(arg0: java_.util.function_.IntConsumer_): java_.util.function_.IntConsumer;
        notify(): void;
        accept(arg0: number): void;
        getMin(): number;
        hashCode(): number;
        equals(arg0: any): boolean;
        toString(): string;
        getSum(): number;
        getCount(): number;
        combine(arg0: Internal.IntSummaryStatistics_): void;
        get average(): number;
        get min(): number;
        get max(): number;
        get count(): number;
        get sum(): number;
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    type IntSummaryStatistics_ = IntSummaryStatistics;
    class MalumSpiritFocusingRecipeJS extends Internal.RecipeJS {
        parseResultItemList(o: any): Internal.List<Internal.ItemStackJS>;
        getClass(): Internal.Class<any>;
        ingredientAction(filter: Internal.IngredientActionFilter_, action: Internal.IngredientAction_): Internal.RecipeJS;
        convertReplacedInput(index: number, oldIngredient: Internal.IngredientJS_, newIngredient: Internal.IngredientJS_): Internal.IngredientJS;
        getUniqueId(): string;
        replaceOutput(i: Internal.IngredientJS_, with_: Internal.ItemStackJS_, exact: boolean): boolean;
        replaceOutput(i: Internal.IngredientJS_, with_: Internal.ItemStackJS_, exact: boolean, func: Internal.BiFunction_<Internal.ItemStackJS_, Internal.ItemStackJS_, Internal.ItemStackJS_>): boolean;
        parseIngredientItemList(o: any): Internal.List<Internal.IngredientJS>;
        merge(data: any): Internal.RecipeJS;
        getPath(): string;
        create(args: Internal.ListJS_): void;
        parseIngredientItemStackList(o: any): Internal.List<Internal.IngredientStackJS>;
        id(_id: ResourceLocation_): Internal.RecipeJS;
        parseIngredientItem(o: any, key: string): Internal.IngredientJS;
        parseIngredientItem(o: any): Internal.IngredientJS;
        group(g: string): Internal.RecipeJS;
        getOriginalRecipeResult(): Internal.ItemStackJS;
        getOriginalRecipeIngredients(): Internal.List<Internal.IngredientJS>;
        getInputIndex(ingredient: Internal.IngredientJS_, exact: boolean): number;
        setGroup(g: string): void;
        serialize(): void;
        replaceInput(i: Internal.IngredientJS_, with_: Internal.IngredientJS_, exact: boolean, func: Internal.BiFunction_<Internal.IngredientJS_, Internal.IngredientJS_, Internal.IngredientJS_>): boolean;
        replaceInput(i: Internal.IngredientJS_, with_: Internal.IngredientJS_, exact: boolean): boolean;
        getType(): string;
        getGroup(): string;
        hasOutput(ingredient: Internal.IngredientJS_, exact: boolean): boolean;
        keepIngredient(filter: Internal.IngredientActionFilter_): Internal.RecipeJS;
        customIngredientAction(filter: Internal.IngredientActionFilter_, id: string): Internal.RecipeJS;
        modifyResult(callback: Internal.ModifyRecipeResultCallback_): Internal.RecipeJS;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        getMod(): string;
        notifyAll(): void;
        convertReplacedOutput(index: number, oldStack: Internal.ItemStackJS_, newStack: Internal.ItemStackJS_): Internal.ItemStackJS;
        save(): void;
        damageIngredient(filter: Internal.IngredientActionFilter_): Internal.RecipeJS;
        damageIngredient(filter: Internal.IngredientActionFilter_, damage: number): Internal.RecipeJS;
        getId(): string;
        dontAdd(): void;
        notify(): void;
        serializeJson(): void;
        createRecipe(): Internal.Recipe<any>;
        getFromToString(): string;
        hashCode(): number;
        deserializeJson(): void;
        getOrCreateId(): ResourceLocation;
        deserialize(): void;
        serializeNBTAsJson(): boolean;
        getOutputIndex(ingredient: Internal.IngredientJS_, exact: boolean): number;
        durabilityCost(durabilityCost: number): Internal.MalumSpiritFocusingRecipeJS;
        serializeIngredientStack(in_: Internal.IngredientStackJS_): Internal.JsonElement;
        resultFromRecipeJson(json: Internal.JsonObject_): Internal.ItemStackJS;
        stage(s: string): Internal.RecipeJS;
        equals(arg0: any): boolean;
        serializeItemStack(stack: Internal.ItemStackJS_): Internal.JsonElement;
        toString(): string;
        time(time: number): Internal.MalumSpiritFocusingRecipeJS;
        hasInput(ingredient: Internal.IngredientJS_, exact: boolean): boolean;
        parseResultItem(o: any): Internal.ItemStackJS;
        replaceIngredient(filter: Internal.IngredientActionFilter_, item: Internal.ItemStackJS_): Internal.RecipeJS;
        static currentRecipe : Internal.RecipeJS;
        originalJson : Internal.JsonObject;
        serializeOutputs : boolean;
        originalRecipe : Internal.Recipe<any>;
        readonly inputItems : Internal.List<((arg0: Internal.ItemStackJS) => boolean)>;
        static itemErrors : false;
        json : Internal.JsonObject;
        readonly outputItems : Internal.List<Internal.ItemStackJS>;
        type : Internal.RecipeTypeJS;
        serializeInputs : boolean;
        get path(): string;
        get originalRecipeIngredients(): Internal.List<Internal.IngredientJS>;
        get mod(): string;
        get originalRecipeResult(): Internal.ItemStackJS;
        get orCreateId(): ResourceLocation;
        get class(): Internal.Class<any>;
        get fromToString(): string;
        get uniqueId(): string;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    type MalumSpiritFocusingRecipeJS_ = MalumSpiritFocusingRecipeJS;
    class ModuleDescriptor$Modifier extends Internal.Enum<Internal.ModuleDescriptor$Modifier> {
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        static valueOf(arg0: string): Internal.ModuleDescriptor$Modifier;
        static valueOf<T_>(arg0: Internal.Class_<T_>, arg1: string): T_;
        notifyAll(): void;
        static values(): Internal.ModuleDescriptor$Modifier[];
        compareTo(arg0: Internal.ModuleDescriptor$Modifier_): number;
        describeConstable(): Internal.Optional<Internal.Enum$EnumDesc<Internal.ModuleDescriptor$Modifier>>;
        notify(): void;
        getDeclaringClass(): Internal.Class<Internal.ModuleDescriptor$Modifier>;
        hashCode(): number;
        equals(arg0: any): boolean;
        name(): string;
        toString(): string;
        ordinal(): number;
        static readonly AUTOMATIC : Internal.ModuleDescriptor$Modifier;
        static readonly SYNTHETIC : Internal.ModuleDescriptor$Modifier;
        static readonly MANDATED : Internal.ModuleDescriptor$Modifier;
        static readonly OPEN : Internal.ModuleDescriptor$Modifier;
        get class(): Internal.Class<any>;
        get declaringClass(): Internal.Class<Internal.ModuleDescriptor$Modifier>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    type ModuleDescriptor$Modifier_ = "synthetic" | "automatic" | "mandated" | "open" | ModuleDescriptor$Modifier;
    abstract class PlayerEventJS extends Internal.LivingEntityEventJS {
        cancel(): void;
        getServer(): Internal.ServerJS;
        getClass(): Internal.Class<any>;
        addGameStage(stage: string): void;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        isCancelled(): boolean;
        getPlayer(): Internal.PlayerJS<any>;
        notifyAll(): void;
        getEntity(): Internal.EntityJS;
        notify(): void;
        getLevel(): Internal.LevelJS;
        getMinecraftPlayer(): Internal.Player;
        post(id: string): boolean;
        post(id: string, sub: string): boolean;
        post(t: Internal.ScriptType_, id: string, sub: string): boolean;
        post(t: Internal.ScriptType_, id: string): boolean;
        hasGameStage(stage: string): boolean;
        hashCode(): number;
        equals(arg0: any): boolean;
        removeGameStage(stage: string): void;
        toString(): string;
        canCancel(): boolean;
        get server(): Internal.ServerJS;
        get level(): Internal.LevelJS;
        get minecraftPlayer(): Internal.Player;
        get cancelled(): boolean;
        get class(): Internal.Class<any>;
        get entity(): Internal.EntityJS;
        get player(): Internal.PlayerJS<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    type PlayerEventJS_ = PlayerEventJS;
    class DragSourceEvent extends Internal.EventObject {
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        getX(): number;
        getLocation(): Internal.Point;
        getY(): number;
        hashCode(): number;
        getSource(): any;
        getDragSourceContext(): Internal.DragSourceContext;
        notifyAll(): void;
        equals(arg0: any): boolean;
        toString(): string;
        notify(): void;
        get x(): number;
        get dragSourceContext(): Internal.DragSourceContext;
        get y(): number;
        get location(): Internal.Point;
        get source(): any;
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    type DragSourceEvent_ = DragSourceEvent;
    interface TooltipComponent {
    }
    type TooltipComponent_ = TooltipComponent;
    interface BYGAdditionalData {
        writeBYG(arg0: Internal.CompoundTag_): void;
        read(arg0: Internal.CompoundTag_): void;
        write(): net.minecraft.nbt.Tag;
        readBYG(arg0: Internal.CompoundTag_): void;
    }
    type BYGAdditionalData_ = BYGAdditionalData;
    interface ModuleReader extends Internal.Closeable {
        read(arg0: string): Internal.Optional<Internal.ByteBuffer>;
        release(arg0: Internal.ByteBuffer_): void;
        find(arg0: string): Internal.Optional<Internal.URI>;
        list(): Internal.Stream<string>;
        close(): void;
        open(arg0: string): Internal.Optional<Internal.InputStream>;
    }
    type ModuleReader_ = ModuleReader;
    class Style {
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        hashCode(): number;
        notifyAll(): void;
        equals(arg0: any): boolean;
        setObfuscated(arg0: boolean): Internal.Style;
        toString(): string;
        notify(): void;
        setUnderlined(arg0: boolean): Internal.Style;
        setStrikethrough(arg0: boolean): Internal.Style;
        get class(): Internal.Class<any>;
        set underlined(arg0: boolean);
        set strikethrough(arg0: boolean);
        set obfuscated(arg0: boolean);
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    type Style_ = Style;
    abstract class HandheldItemBuilder extends Internal.ItemBuilder {
        barWidth(barWidth: Internal.ToIntFunction_<Internal.ItemStackJS_>): Internal.ItemBuilder;
        getClass(): Internal.Class<any>;
        maxStackSize(v: number): Internal.ItemBuilder;
        translationKey(key: string): Internal.BuilderBase<Internal.Item>;
        newID(pre: string, post: string): ResourceLocation;
        use(use: Internal.ItemBuilder$UseCallback_): Internal.ItemBuilder;
        maxDamage(v: number): Internal.ItemBuilder;
        textureJson(json: Internal.JsonObject_): Internal.ItemBuilder;
        tooltip(text: Internal.Component_): Internal.ItemBuilder;
        modifyTier(callback: Internal.Consumer_<Internal.MutableToolTier_>): Internal.HandheldItemBuilder;
        type(type: string): Internal.BuilderBase<Internal.Item>;
        containerItem(id: string): Internal.ItemBuilder;
        subtypes(fn: java_.util.function_.Function_<Internal.ItemStackJS_, Internal.Collection_<Internal.ItemStackJS_>>): Internal.ItemBuilder;
        modelJson(json: Internal.JsonObject_): Internal.ItemBuilder;
        burnTime(v: number): Internal.ItemBuilder;
        useDuration(useDuration: Internal.ToIntFunction_<Internal.ItemStackJS_>): Internal.ItemBuilder;
        tag(tag: ResourceLocation_): Internal.BuilderBase<Internal.Item>;
        parentModel(m: string): Internal.ItemBuilder;
        generateDataJsons(generator: Internal.DataJsonGenerator_): void;
        group(g: string): Internal.ItemBuilder;
        static ofArmorMaterial(o: any): Internal.ArmorMaterial;
        modifyAttribute(attribute: ResourceLocation_, identifier: string, d: number, operation: Internal.AttributeModifier$Operation_): Internal.ItemBuilder;
        getRegistryType(): Internal.RegistryObjectBuilderTypes<Internal.Item>;
        attackDamageBonus(f: number): Internal.HandheldItemBuilder;
        glow(v: boolean): Internal.ItemBuilder;
        useAnimation(animation: Internal.UseAnim_): Internal.ItemBuilder;
        rarity(v: Rarity_): Internal.ItemBuilder;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        clientRegistry(minecraft: Internal.Minecraft_): void;
        transformObject(obj: Internal.Item_): Internal.Item;
        color(callback: Internal.ItemBuilder$ItemColorJS_): Internal.ItemBuilder;
        color(index: number, c: Internal.Color_): Internal.ItemBuilder;
        displayName(name: string): Internal.BuilderBase<Internal.Item>;
        notifyAll(): void;
        barColor(barColor: java_.util.function_.Function_<Internal.ItemStackJS_, Internal.Color_>): Internal.ItemBuilder;
        notify(): void;
        createAdditionalObjects(): void;
        speed(f: number): Internal.HandheldItemBuilder;
        tier(t: Internal.Tier_): Internal.HandheldItemBuilder;
        hashCode(): number;
        get(): Internal.Item;
        speedBaseline(f: number): Internal.HandheldItemBuilder;
        generateAssetJsons(generator: Internal.AssetJsonGenerator_): void;
        getTranslationKeyGroup(): string;
        texture(key: string, tex: string): Internal.ItemBuilder;
        texture(tex: string): Internal.ItemBuilder;
        generateLang(lang: Internal.Map_<string, string>): void;
        createObject(): Internal.Item;
        food(b: Internal.Consumer_<Internal.FoodBuilder_>): Internal.ItemBuilder;
        releaseUsing(releaseUsing: Internal.ItemBuilder$ReleaseUsingCallback_): Internal.ItemBuilder;
        attackDamageBaseline(f: number): Internal.HandheldItemBuilder;
        unstackable(): Internal.ItemBuilder;
        addResourcePackLocations(path: string, list: Internal.List_<ResourceLocation_>, packType: Internal.PackType_): void;
        equals(arg0: any): boolean;
        toString(): string;
        finishUsing(finishUsing: Internal.ItemBuilder$FinishUsingCallback_): Internal.ItemBuilder;
        createItemProperties(): Internal.Item$Properties;
        static readonly TOOL_TIERS : {"gold":any,"diamond":any,"iron":any,"wood":any,"stone":any,"netherite":any};
        static readonly ARMOR_TIERS : {"gold":any,"chain":any,"diamond":any,"turtle":any,"iron":any,"leather":any,"netherite":any};
        readonly id : ResourceLocation;
        get registryType(): Internal.RegistryObjectBuilderTypes<Internal.Item>;
        get class(): Internal.Class<any>;
        get translationKeyGroup(): string;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    type HandheldItemBuilder_ = HandheldItemBuilder;
    class ItemModificationProperties {
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        setBurnTime(i: number): void;
        setMaxStackSize(i: number): void;
        setMaxDamage(i: number): void;
        notifyAll(): void;
        setCraftingRemainder(i: Internal.Item_): void;
        setFoodProperties(consumer: Internal.Consumer_<Internal.FoodBuilder_>): void;
        setRarity(r: Rarity_): void;
        notify(): void;
        setTier(c: Internal.Consumer_<Internal.MutableToolTier_>): void;
        hashCode(): number;
        equals(arg0: any): boolean;
        toString(): string;
        setFireResistant(b: boolean): void;
        readonly item : Internal.ItemKJS;
        get class(): Internal.Class<any>;
        set maxStackSize(i: number);
        set tier(c: Internal.Consumer_<Internal.MutableToolTier_>);
        set burnTime(i: number);
        set maxDamage(i: number);
        set foodProperties(consumer: Internal.Consumer_<Internal.FoodBuilder_>);
        set craftingRemainder(i: Internal.Item_);
        set fireResistant(b: boolean);
        set rarity(r: Rarity_);
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    type ItemModificationProperties_ = ItemModificationProperties;
    interface PackResources extends Internal.AutoCloseable, Internal.IForgePackResources {
        close(): void;
        isHidden(): boolean;
    }
    type PackResources_ = PackResources;
    class PrivacyMode extends Internal.Enum<Internal.PrivacyMode> implements Internal.StringRepresentable {
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        static valueOf(name: string): Internal.PrivacyMode;
        static valueOf<T_>(arg0: Internal.Class_<T_>, arg1: string): T_;
        notifyAll(): void;
        static values(): Internal.PrivacyMode[];
        compareTo(arg0: Internal.PrivacyMode_): number;
        describeConstable(): Internal.Optional<Internal.Enum$EnumDesc<Internal.PrivacyMode>>;
        notify(): void;
        getDeclaringClass(): Internal.Class<Internal.PrivacyMode>;
        hashCode(): number;
        equals(arg0: any): boolean;
        name(): string;
        toString(): string;
        ordinal(): number;
        static readonly NAME_MAP : Internal.NameMap<Internal.PrivacyMode>;
        static readonly PUBLIC : Internal.PrivacyMode;
        static readonly VALUES : Internal.PrivacyMode[];
        static readonly ALLIES : Internal.PrivacyMode;
        static readonly PRIVATE : Internal.PrivacyMode;
        get class(): Internal.Class<any>;
        get declaringClass(): Internal.Class<Internal.PrivacyMode>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    type PrivacyMode_ = "private" | "public" | "allies" | PrivacyMode;
    interface AccessibleValue {
        getMinimumAccessibleValue(): Internal.Number;
        setCurrentAccessibleValue(arg0: Internal.Number_): boolean;
        getCurrentAccessibleValue(): Internal.Number;
        getMaximumAccessibleValue(): Internal.Number;
    }
    type AccessibleValue_ = AccessibleValue;
    abstract class RuleTest {
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        hashCode(): number;
        notifyAll(): void;
        equals(arg0: any): boolean;
        toString(): string;
        notify(): void;
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    type RuleTest_ = RuleTest;
    class ZoneOffsetTransition implements Internal.Comparable<Internal.ZoneOffsetTransition>, Internal.Serializable {
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        getDateTimeAfter(): Internal.LocalDateTime;
        notifyAll(): void;
        getDateTimeBefore(): Internal.LocalDateTime;
        getOffsetAfter(): Internal.ZoneOffset;
        getOffsetBefore(): Internal.ZoneOffset;
        compareTo(arg0: Internal.ZoneOffsetTransition_): number;
        notify(): void;
        getInstant(): Internal.Instant;
        isGap(): boolean;
        getDuration(): Internal.Duration;
        toEpochSecond(): number;
        hashCode(): number;
        static of(arg0: Internal.LocalDateTime_, arg1: Internal.ZoneOffset_, arg2: Internal.ZoneOffset_): Internal.ZoneOffsetTransition;
        equals(arg0: any): boolean;
        isOverlap(): boolean;
        toString(): string;
        isValidOffset(arg0: Internal.ZoneOffset_): boolean;
        get duration(): Internal.Duration;
        get overlap(): boolean;
        get gap(): boolean;
        get dateTimeBefore(): Internal.LocalDateTime;
        get offsetAfter(): Internal.ZoneOffset;
        get dateTimeAfter(): Internal.LocalDateTime;
        get class(): Internal.Class<any>;
        get offsetBefore(): Internal.ZoneOffset;
        get instant(): Internal.Instant;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    type ZoneOffsetTransition_ = ZoneOffsetTransition;
    class ModuleDescriptor$Requires implements Internal.Comparable<Internal.ModuleDescriptor$Requires> {
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        compiledVersion(): Internal.Optional<Internal.ModuleDescriptor$Version>;
        hashCode(): number;
        notifyAll(): void;
        equals(arg0: any): boolean;
        rawCompiledVersion(): Internal.Optional<string>;
        name(): string;
        toString(): string;
        compareTo(arg0: Internal.ModuleDescriptor$Requires_): number;
        modifiers(): Internal.Set<Internal.ModuleDescriptor$Requires$Modifier>;
        notify(): void;
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    type ModuleDescriptor$Requires_ = ModuleDescriptor$Requires;
    interface Message {
        getString(): string;
    }
    type Message_ = Message;
    interface IForgeBakedModel {
        doesHandlePerspectives(): boolean;
        getModelData(arg0: Internal.BlockAndTintGetter_, arg1: BlockPos_, arg2: Internal.BlockState_, arg3: Internal.IModelData_): Internal.IModelData;
        isLayered(): boolean;
        handlePerspective(arg0: Internal.ItemTransforms$TransformType_, arg1: Internal.PoseStack_): Internal.BakedModel;
        getQuads(arg0: Internal.BlockState_, arg1: Internal.Direction_, arg2: Internal.Random_, arg3: Internal.IModelData_): Internal.List<Internal.BakedQuad>;
        useAmbientOcclusion(arg0: Internal.BlockState_): boolean;
        getLayerModels(arg0: Internal.ItemStack_, arg1: boolean): Internal.List<Internal.Pair<Internal.BakedModel, Internal.RenderType>>;
        getParticleIcon(arg0: Internal.IModelData_): Internal.TextureAtlasSprite;
    }
    type IForgeBakedModel_ = IForgeBakedModel;
    interface Double2BooleanFunction extends Internal.Function<number, boolean>, java_.util.function_.DoublePredicate {
        getOrDefault(arg0: any, arg1: boolean): boolean;
        getOrDefault(arg0: number, arg1: boolean): boolean;
        andThenShort(arg0: Internal.Boolean2ShortFunction_): Internal.Double2ShortFunction;
        composeByte(arg0: Internal.Byte2DoubleFunction_): Internal.Byte2BooleanFunction;
        andThenInt(arg0: Internal.Boolean2IntFunction_): Internal.Double2IntFunction;
        composeReference<T_>(arg0: Internal.Reference2DoubleFunction_<T_>): Internal.Reference2BooleanFunction<T_>;
        andThen<T_>(arg0: java_.util.function_.Function_<boolean, T_>): java_.util.function_.Function<number, T_>;
        put(arg0: number, arg1: boolean): boolean;
        remove(arg0: number): boolean;
        remove(arg0: any): boolean;
        defaultReturnValue(): boolean;
        defaultReturnValue(arg0: boolean): void;
        andThenDouble(arg0: Internal.Boolean2DoubleFunction_): Internal.Double2DoubleFunction;
        andThenObject<T_>(arg0: Internal.Boolean2ObjectFunction_<T_>): Internal.Double2ObjectFunction<T_>;
        and(arg0: java_.util.function_.DoublePredicate_): java_.util.function_.DoublePredicate;
        get(arg0: any): boolean;
        get(arg0: number): boolean;
        andThenLong(arg0: Internal.Boolean2LongFunction_): Internal.Double2LongFunction;
        composeLong(arg0: Internal.Long2DoubleFunction_): Internal.Long2BooleanFunction;
        andThenByte(arg0: Internal.Boolean2ByteFunction_): Internal.Double2ByteFunction;
        andThenFloat(arg0: Internal.Boolean2FloatFunction_): Internal.Double2FloatFunction;
        or(arg0: java_.util.function_.DoublePredicate_): java_.util.function_.DoublePredicate;
        test(arg0: number): boolean;
        apply(arg0: number): boolean;
        containsKey(arg0: number): boolean;
        containsKey(arg0: any): boolean;
        composeInt(arg0: Internal.Int2DoubleFunction_): Internal.Int2BooleanFunction;
        clear(): void;
        composeFloat(arg0: Internal.Float2DoubleFunction_): Internal.Float2BooleanFunction;
        andThenChar(arg0: Internal.Boolean2CharFunction_): Internal.Double2CharFunction;
        composeObject<T_>(arg0: Internal.Object2DoubleFunction_<T_>): Internal.Object2BooleanFunction<T_>;
        size(): number;
        compose<T_>(arg0: java_.util.function_.Function_<T_, number>): java_.util.function_.Function<T_, boolean>;
        negate(): java_.util.function_.DoublePredicate;
        composeShort(arg0: Internal.Short2DoubleFunction_): Internal.Short2BooleanFunction;
        andThenReference<T_>(arg0: Internal.Boolean2ReferenceFunction_<T_>): Internal.Double2ReferenceFunction<T_>;
        composeChar(arg0: Internal.Char2DoubleFunction_): Internal.Char2BooleanFunction;
        composeDouble(arg0: Internal.Double2DoubleFunction_): Internal.Double2BooleanFunction;
    }
    type Double2BooleanFunction_ = ((arg0: number) => boolean) | Double2BooleanFunction;
    interface ParticleOptions$Deserializer <T> {
    }
    type ParticleOptions$Deserializer_<T> = ParticleOptions$Deserializer<T>;
    class InventoryJS {
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        getBlock(level: Internal.LevelJS_): Internal.BlockContainerJS;
        countNonEmpty(ingredient: Internal.IngredientJS_): number;
        countNonEmpty(): number;
        set(slot: number, item: Internal.ItemStack_): void;
        markDirty(): void;
        notifyAll(): void;
        count(): number;
        count(ingredient: Internal.IngredientJS_): number;
        isEmpty(): boolean;
        clear(): void;
        clear(ingredient: Internal.IngredientJS_): void;
        isItemValid(slot: number, item: Internal.ItemStack_): boolean;
        insert(slot: number, item: Internal.ItemStack_, simulate: boolean): Internal.ItemStackJS;
        getWidth(): number;
        notify(): void;
        getHeight(): number;
        getSize(): number;
        extract(slot: number, amount: number, simulate: boolean): Internal.ItemStackJS;
        hashCode(): number;
        find(ingredient: Internal.IngredientJS_): number;
        find(): number;
        equals(arg0: any): boolean;
        getSlotLimit(slot: number): number;
        get(slot: number): Internal.ItemStackJS;
        toString(): string;
        readonly minecraftInventory : Internal.ItemHandler;
        get size(): number;
        get width(): number;
        get class(): Internal.Class<any>;
        get empty(): boolean;
        get height(): number;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    type InventoryJS_ = InventoryJS;
    interface BaseMapCodec <K, V> {
        encode<T>(arg0: Internal.Map_<K, V>, arg1: Internal.DynamicOps_<T>, arg2: Internal.RecordBuilder_<T>): Internal.RecordBuilder<T>;
        elementCodec(): Internal.Codec<V>;
        keyCodec(): Internal.Codec<K>;
        decode<T>(arg0: Internal.DynamicOps_<T>, arg1: Internal.MapLike_<T>): Internal.DataResult<Internal.Map<K, V>>;
    }
    type BaseMapCodec_<K, V> = BaseMapCodec<K, V>;
    class KeyEvent extends Internal.InputEvent {
        getClass(): Internal.Class<any>;
        setSource(arg0: any): void;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        static getKeyText(arg0: number): string;
        notifyAll(): void;
        isMetaDown(): boolean;
        static getExtendedKeyCodeForChar(arg0: number): number;
        setKeyChar(arg0: string): void;
        consume(): void;
        getModifiersEx(): number;
        setModifiers(arg0: number): void;
        notify(): void;
        isShiftDown(): boolean;
        paramString(): string;
        isConsumed(): boolean;
        static getModifiersExText(arg0: number): string;
        hashCode(): number;
        isAltGraphDown(): boolean;
        static getMaskForButton(arg0: number): number;
        getKeyLocation(): number;
        getModifiers(): number;
        getKeyCode(): number;
        isAltDown(): boolean;
        getExtendedKeyCode(): number;
        isControlDown(): boolean;
        getID(): number;
        isActionKey(): boolean;
        static getKeyModifiersText(arg0: number): string;
        getKeyChar(): string;
        getSource(): any;
        setKeyCode(arg0: number): void;
        equals(arg0: any): boolean;
        getWhen(): number;
        toString(): string;
        getComponent(): java_.awt.Component;
        static readonly VK_UNDEFINED : 0;
        static readonly VK_QUOTEDBL : 152;
        static readonly BUTTON1_MASK : 16;
        static readonly VK_BRACERIGHT : 162;
        static readonly INVOCATION_EVENT_MASK : 16384;
        static readonly VK_COPY : 65485;
        static readonly VK_LEFT_PARENTHESIS : 519;
        static readonly VK_NUMPAD3 : 99;
        static readonly VK_NUMPAD4 : 100;
        static readonly VK_NUMPAD5 : 101;
        static readonly VK_NUMPAD6 : 102;
        static readonly VK_HELP : 156;
        static readonly VK_NUMPAD0 : 96;
        static readonly VK_NUMPAD1 : 97;
        static readonly VK_NUMPAD2 : 98;
        static readonly VK_RIGHT : 39;
        static readonly COMPONENT_SHOWN : 102;
        static readonly BUTTON3_DOWN_MASK : 4096;
        static readonly VK_AMPERSAND : 150;
        static readonly VK_ALT_GRAPH : 65406;
        static readonly VK_CANCEL : 3;
        static readonly COMPONENT_RESIZED : 101;
        static readonly VK_COLON : 513;
        static readonly MOUSE_EVENT_MASK : 16;
        static readonly VK_CIRCUMFLEX : 514;
        static readonly VK_CAPS_LOCK : 20;
        static readonly COMPONENT_HIDDEN : 103;
        static readonly VK_ALL_CANDIDATES : 256;
        static readonly VK_LESS : 153;
        static readonly VK_PLUS : 521;
        static readonly VK_WINDOWS : 524;
        static readonly KEY_RELEASED : 402;
        static readonly VK_KANA : 21;
        static readonly VK_ASTERISK : 151;
        static readonly COMPONENT_MOVED : 100;
        static readonly VK_DOLLAR : 515;
        static readonly ACTION_EVENT_MASK : 128;
        static readonly VK_PAUSE : 19;
        static readonly ITEM_EVENT_MASK : 512;
        static readonly BUTTON3_MASK : 4;
        static readonly VK_FINAL : 24;
        static readonly VK_DEAD_SEMIVOICED_SOUND : 143;
        static readonly VK_PROPS : 65482;
        static readonly VK_RIGHT_PARENTHESIS : 522;
        static readonly VK_BEGIN : 65368;
        static readonly VK_DEAD_BREVE : 133;
        static readonly FOCUS_EVENT_MASK : 4;
        static readonly VK_DEAD_ABOVEDOT : 134;
        static readonly VK_CUT : 65489;
        static readonly VK_BACK_QUOTE : 192;
        static readonly CONTAINER_EVENT_MASK : 2;
        static readonly VK_HOME : 36;
        static readonly VK_UNDO : 65483;
        static readonly ALT_DOWN_MASK : 512;
        static readonly VK_ESCAPE : 27;
        static readonly VK_F9 : 120;
        static readonly VK_F8 : 119;
        static readonly VK_F7 : 118;
        static readonly VK_F6 : 117;
        static readonly VK_EXCLAMATION_MARK : 517;
        static readonly VK_F5 : 116;
        static readonly VK_F4 : 115;
        static readonly VK_F3 : 114;
        static readonly VK_HALF_WIDTH : 244;
        static readonly VK_F2 : 113;
        static readonly VK_F1 : 112;
        static readonly VK_GREATER : 160;
        static readonly META_DOWN_MASK : 256;
        static readonly VK_KATAKANA : 241;
        static readonly VK_INVERTED_EXCLAMATION_MARK : 518;
        static readonly VK_UP : 38;
        static readonly VK_SLASH : 47;
        static readonly VK_CONVERT : 28;
        static readonly PAINT_EVENT_MASK : 8192;
        static readonly VK_SUBTRACT : 109;
        static readonly HIERARCHY_BOUNDS_EVENT_MASK : 65536;
        static readonly VK_CODE_INPUT : 258;
        static readonly VK_KP_UP : 224;
        static readonly VK_EURO_SIGN : 516;
        static readonly KEY_LAST : 402;
        static readonly VK_DIVIDE : 111;
        static readonly CTRL_MASK : 2;
        static readonly ALT_MASK : 8;
        static readonly COMPONENT_FIRST : 100;
        static readonly KEY_TYPED : 400;
        static readonly SHIFT_DOWN_MASK : 64;
        static readonly CTRL_DOWN_MASK : 128;
        static readonly VK_PAGE_UP : 33;
        static readonly VK_SEMICOLON : 59;
        static readonly ALT_GRAPH_DOWN_MASK : 8192;
        static readonly VK_SEPARATOR : 108;
        static readonly VK_ADD : 107;
        static readonly WINDOW_STATE_EVENT_MASK : 262144;
        static readonly KEY_PRESSED : 401;
        static readonly META_MASK : 4;
        static readonly VK_2 : 50;
        static readonly ADJUSTMENT_EVENT_MASK : 256;
        static readonly VK_3 : 51;
        static readonly VK_4 : 52;
        static readonly VK_5 : 53;
        static readonly VK_6 : 54;
        static readonly VK_ALPHANUMERIC : 240;
        static readonly VK_7 : 55;
        static readonly VK_8 : 56;
        static readonly VK_9 : 57;
        static readonly VK_DEAD_DOUBLEACUTE : 137;
        static readonly VK_0 : 48;
        static readonly VK_1 : 49;
        static readonly VK_DEAD_CEDILLA : 139;
        static readonly VK_B : 66;
        static readonly VK_C : 67;
        static readonly VK_D : 68;
        static readonly VK_E : 69;
        static readonly VK_F : 70;
        static readonly VK_G : 71;
        static readonly VK_H : 72;
        static readonly BUTTON2_MASK : 8;
        static readonly VK_I : 73;
        static readonly VK_OPEN_BRACKET : 91;
        static readonly VK_HIRAGANA : 242;
        static readonly MOUSE_MOTION_EVENT_MASK : 32;
        static readonly VK_A : 65;
        static readonly VK_JAPANESE_KATAKANA : 259;
        static readonly VK_NUM_LOCK : 144;
        static readonly VK_AT : 512;
        static readonly VK_UNDERSCORE : 523;
        static readonly VK_KP_DOWN : 225;
        static readonly VK_BACK_SPACE : 8;
        static readonly VK_CLEAR : 12;
        static readonly VK_DELETE : 127;
        static readonly VK_DEAD_VOICED_SOUND : 142;
        static readonly VK_MULTIPLY : 106;
        static readonly VK_SPACE : 32;
        static readonly VK_FULL_WIDTH : 243;
        static readonly VK_PAGE_DOWN : 34;
        static readonly VK_END : 35;
        static readonly CHAR_UNDEFINED : "￿";
        static readonly KEY_LOCATION_LEFT : 2;
        static readonly VK_DOWN : 40;
        static readonly SHIFT_MASK : 1;
        static readonly VK_DEAD_CIRCUMFLEX : 130;
        static readonly INPUT_METHOD_EVENT_MASK : 2048;
        static readonly VK_EQUALS : 61;
        static readonly VK_JAPANESE_ROMAN : 261;
        static readonly VK_PERIOD : 46;
        static readonly VK_F12 : 123;
        static readonly VK_F11 : 122;
        static readonly VK_F14 : 61441;
        static readonly VK_F13 : 61440;
        static readonly VK_COMPOSE : 65312;
        static readonly VK_DEAD_ACUTE : 129;
        static readonly VK_F10 : 121;
        static readonly WINDOW_EVENT_MASK : 64;
        static readonly VK_DEAD_DIAERESIS : 135;
        static readonly VK_PRINTSCREEN : 154;
        static readonly WINDOW_FOCUS_EVENT_MASK : 524288;
        static readonly VK_R : 82;
        static readonly VK_DEAD_ABOVERING : 136;
        static readonly VK_S : 83;
        static readonly VK_T : 84;
        static readonly VK_U : 85;
        static readonly VK_PREVIOUS_CANDIDATE : 257;
        static readonly VK_V : 86;
        static readonly VK_W : 87;
        static readonly VK_X : 88;
        static readonly VK_Y : 89;
        static readonly VK_J : 74;
        static readonly VK_K : 75;
        static readonly VK_F19 : 61446;
        static readonly VK_L : 76;
        static readonly VK_M : 77;
        static readonly VK_N : 78;
        static readonly VK_F16 : 61443;
        static readonly VK_O : 79;
        static readonly VK_F15 : 61442;
        static readonly VK_P : 80;
        static readonly VK_F18 : 61445;
        static readonly VK_Q : 81;
        static readonly VK_F17 : 61444;
        static readonly KEY_LOCATION_NUMPAD : 4;
        static readonly VK_F23 : 61450;
        static readonly KEY_FIRST : 400;
        static readonly VK_F22 : 61449;
        static readonly KEY_LOCATION_UNKNOWN : 0;
        static readonly VK_F24 : 61451;
        static readonly VK_DEAD_TILDE : 131;
        static readonly KEY_LOCATION_RIGHT : 3;
        static readonly VK_DEAD_GRAVE : 128;
        static readonly VK_F21 : 61448;
        static readonly VK_F20 : 61447;
        static readonly VK_CONTROL : 17;
        static readonly VK_Z : 90;
        static readonly VK_QUOTE : 222;
        static readonly VK_KANA_LOCK : 262;
        static readonly VK_KP_RIGHT : 227;
        static readonly VK_NUMBER_SIGN : 520;
        static readonly VK_KP_LEFT : 226;
        static readonly VK_ENTER : 10;
        static readonly RESERVED_ID_MAX : 1999;
        static readonly VK_DEAD_OGONEK : 140;
        static readonly VK_CONTEXT_MENU : 525;
        static readonly VK_KANJI : 25;
        static readonly VK_NONCONVERT : 29;
        static readonly MOUSE_WHEEL_EVENT_MASK : 131072;
        static readonly BUTTON1_DOWN_MASK : 1024;
        static readonly VK_COMMA : 44;
        static readonly VK_DECIMAL : 110;
        static readonly VK_FIND : 65488;
        static readonly VK_DEAD_IOTA : 141;
        static readonly TEXT_EVENT_MASK : 1024;
        static readonly VK_SHIFT : 16;
        static readonly VK_MODECHANGE : 31;
        static readonly VK_BACK_SLASH : 92;
        static readonly VK_ROMAN_CHARACTERS : 245;
        static readonly COMPONENT_EVENT_MASK : 1;
        static readonly VK_DEAD_MACRON : 132;
        static readonly COMPONENT_LAST : 103;
        static readonly VK_SEPARATER : 108;
        static readonly ALT_GRAPH_MASK : 32;
        static readonly KEY_EVENT_MASK : 8;
        static readonly VK_MINUS : 45;
        static readonly VK_SCROLL_LOCK : 145;
        static readonly VK_PASTE : 65487;
        static readonly KEY_LOCATION_STANDARD : 1;
        static readonly VK_NUMPAD7 : 103;
        static readonly VK_AGAIN : 65481;
        static readonly VK_NUMPAD8 : 104;
        static readonly VK_NUMPAD9 : 105;
        static readonly VK_LEFT : 37;
        static readonly VK_DEAD_CARON : 138;
        static readonly VK_TAB : 9;
        static readonly VK_INPUT_METHOD_ON_OFF : 263;
        static readonly VK_CLOSE_BRACKET : 93;
        static readonly VK_INSERT : 155;
        static readonly BUTTON2_DOWN_MASK : 2048;
        static readonly VK_ALT : 18;
        static readonly VK_ACCEPT : 30;
        static readonly VK_JAPANESE_HIRAGANA : 260;
        static readonly VK_STOP : 65480;
        static readonly HIERARCHY_EVENT_MASK : 32768;
        static readonly VK_META : 157;
        static readonly VK_BRACELEFT : 161;
        get consumed(): boolean;
        get altDown(): boolean;
        get controlDown(): boolean;
        get keyLocation(): number;
        get keyChar(): string;
        get source(): any;
        get modifiers(): number;
        get when(): number;
        get extendedKeyCode(): number;
        get altGraphDown(): boolean;
        get keyCode(): number;
        get component(): java_.awt.Component;
        get modifiersEx(): number;
        get shiftDown(): boolean;
        get metaDown(): boolean;
        get actionKey(): boolean;
        get iD(): number;
        get class(): Internal.Class<any>;
        set keyCode(arg0: number);
        set keyChar(arg0: string);
        set source(arg0: any);
        set modifiers(arg0: number);
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    type KeyEvent_ = KeyEvent;
    class Slot implements Internal.SlotAccessor {
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        hashCode(): number;
        getSlotIndex(): number;
        notifyAll(): void;
        equals(arg0: any): boolean;
        toString(): string;
        isSameInventory(arg0: Internal.Slot_): boolean;
        setBackground(arg0: ResourceLocation_, arg1: ResourceLocation_): Internal.Slot;
        notify(): void;
        get class(): Internal.Class<any>;
        get slotIndex(): number;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    type Slot_ = Slot;
    class EntityJS implements Internal.MessageSender, Internal.WrappedJS {
        setY(y: number): void;
        setX(x: number): void;
        isOnScoreboardTeam(teamID: string): boolean;
        isLiving(): boolean;
        isSprinting(): boolean;
        getItem(): Internal.ItemStackJS;
        getTags(): Internal.Set<string>;
        setGlowing(glowing: boolean): void;
        setZ(z: number): void;
        getHasCustomName(): boolean;
        setInvisible(invisible: boolean): void;
        runCommandSilent(command: string): number;
        getDistanceSq(pos: BlockPos_): number;
        getDistanceSq(x: number, y: number, z: number): number;
        isBoss(): boolean;
        isGlowing(): boolean;
        getHorizontalFacing(): Internal.Direction;
        getServer(): Internal.ServerJS;
        setMotion(x: number, y: number, z: number): void;
        getProfile(): Internal.GameProfile;
        setRotation(yaw: number, pitch: number): void;
        isOnSameTeam(e: Internal.EntityJS_): boolean;
        isAnimal(): boolean;
        getDisplayName(): Internal.Text;
        getType(): string;
        setCustomNameAlwaysVisible(b: boolean): void;
        addMotion(x: number, y: number, z: number): void;
        isInvisible(): boolean;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        isUnderWater(): boolean;
        getEyeHeight(): number;
        notify(): void;
        getFallDistance(): number;
        setOnFire(seconds: number): void;
        removePassengers(): void;
        attack(source: string, hp: number): void;
        attack(hp: number): void;
        playSound(id: Internal.SoundEvent_, volume: number, pitch: number): void;
        playSound(id: Internal.SoundEvent_): void;
        getDistance(x: number, y: number, z: number): number;
        getDistance(pos: BlockPos_): number;
        setStatusMessage(message: Internal.Component_): void;
        isSwimming(): boolean;
        getCustomName(): Internal.Text;
        getStepHeight(): number;
        mergeFullNBT(tag: Internal.CompoundTag_): Internal.EntityJS;
        kill(): void;
        getRidingEntity(): Internal.EntityJS;
        setPositionAndRotation(x: number, y: number, z: number, yaw: number, pitch: number): void;
        getLevel(): Internal.LevelJS;
        getPitch(): number;
        getPassengers(): Internal.EntityArrayList;
        isMonster(): boolean;
        equals(arg0: any): boolean;
        setPitch(pitch: number): void;
        getFacing(): Internal.Direction;
        isOnGround(): boolean;
        toString(): string;
        isSilent(): boolean;
        isPassenger(e: Internal.EntityJS_): boolean;
        getClass(): Internal.Class<any>;
        getRecursivePassengers(): Internal.EntityArrayList;
        getNbt(): Internal.CompoundTag;
        setFallDistance(fallDistance: number): void;
        getName(): Internal.Text;
        setCustomName(name: Internal.Component_): void;
        setStepHeight(stepHeight: number): void;
        tell(message: Internal.Component_): void;
        getTeamId(): string;
        isWaterCreature(): boolean;
        setNoClip(noClip: boolean): void;
        setPosition(x: number, y: number, z: number): void;
        setPosition(block: Internal.BlockContainerJS_): void;
        extinguish(): void;
        setInvulnerable(invulnerable: boolean): void;
        setFullNBT(nbt: Internal.CompoundTag_): void;
        getFullNBT(): Internal.CompoundTag;
        getNoClip(): boolean;
        setYaw(yaw: number): void;
        getYaw(): number;
        isAlive(): boolean;
        setNoGravity(noGravity: boolean): void;
        isPlayer(): boolean;
        isCrouching(): boolean;
        notifyAll(): void;
        getId(): Internal.UUID;
        getTicksExisted(): number;
        setSilent(isSilent: boolean): void;
        hashCode(): number;
        isFrame(): boolean;
        startRiding(e: Internal.EntityJS_, force: boolean): boolean;
        runCommand(command: string): number;
        getCustomNameAlwaysVisible(): boolean;
        setMotionZ(z: number): void;
        setMotionY(y: number): void;
        getBlock(): Internal.BlockContainerJS;
        setMotionX(x: number): void;
        isInWater(): boolean;
        dismountRidingEntity(): void;
        isAmbientCreature(): boolean;
        rayTrace(distance: number): Internal.RayTraceResultJS;
        isInvulnerable(): boolean;
        getX(): number;
        spawn(): void;
        getY(): number;
        getZ(): number;
        isPeacefulCreature(): boolean;
        getMotionZ(): number;
        getMotionX(): number;
        getMotionY(): number;
        getNoGravity(): boolean;
        readonly persistentData : Internal.CompoundTag;
        readonly minecraftEntity : Internal.Entity;
        get invisible(): boolean;
        get customNameAlwaysVisible(): boolean;
        get type(): string;
        get hasCustomName(): boolean;
        get block(): Internal.BlockContainerJS;
        get pitch(): number;
        get id(): Internal.UUID;
        get item(): Internal.ItemStackJS;
        get passengers(): Internal.EntityArrayList;
        get level(): Internal.LevelJS;
        get profile(): Internal.GameProfile;
        get customName(): Internal.Text;
        get horizontalFacing(): Internal.Direction;
        get tags(): Internal.Set<string>;
        get sprinting(): boolean;
        get crouching(): boolean;
        get noGravity(): boolean;
        get fullNBT(): Internal.CompoundTag;
        get name(): Internal.Text;
        get animal(): boolean;
        get peacefulCreature(): boolean;
        get stepHeight(): number;
        get frame(): boolean;
        get noClip(): boolean;
        get server(): Internal.ServerJS;
        get nbt(): Internal.CompoundTag;
        get boss(): boolean;
        get alive(): boolean;
        get ticksExisted(): number;
        get displayName(): Internal.Text;
        get fallDistance(): number;
        get facing(): Internal.Direction;
        get ambientCreature(): boolean;
        get swimming(): boolean;
        get waterCreature(): boolean;
        get invulnerable(): boolean;
        get eyeHeight(): number;
        get underWater(): boolean;
        get class(): Internal.Class<any>;
        get player(): boolean;
        get motionZ(): number;
        get silent(): boolean;
        get living(): boolean;
        get motionY(): number;
        get motionX(): number;
        get ridingEntity(): Internal.EntityJS;
        get inWater(): boolean;
        get recursivePassengers(): Internal.EntityArrayList;
        get yaw(): number;
        get monster(): boolean;
        get glowing(): boolean;
        get onGround(): boolean;
        get teamId(): string;
        get x(): number;
        get y(): number;
        get z(): number;
        set noClip(noClip: boolean);
        set motionZ(z: number);
        set silent(isSilent: boolean);
        set motionY(y: number);
        set fallDistance(fallDistance: number);
        set motionX(x: number);
        set invisible(invisible: boolean);
        set customNameAlwaysVisible(b: boolean);
        set onFire(seconds: number);
        set yaw(yaw: number);
        set statusMessage(message: Internal.Component_);
        set invulnerable(invulnerable: boolean);
        set glowing(glowing: boolean);
        set noGravity(noGravity: boolean);
        set fullNBT(nbt: Internal.CompoundTag_);
        set x(x: number);
        set y(y: number);
        set z(z: number);
        set position(block: Internal.BlockContainerJS_);
        set pitch(pitch: number);
        set stepHeight(stepHeight: number);
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    type EntityJS_ = EntityJS;
    class KnownClientPlayer implements Internal.Comparable<Internal.KnownClientPlayer> {
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        notifyAll(): void;
        isValid(): boolean;
        getExtraData(): Internal.CompoundTag;
        getProfile(): Internal.GameProfile;
        update(p: Internal.KnownClientPlayer_): void;
        compareTo(o: Internal.KnownClientPlayer_): number;
        notify(): void;
        hashCode(): number;
        equals(arg0: any): boolean;
        toString(): string;
        write(buf: Internal.FriendlyByteBuf_): void;
        isInternalTeam(): boolean;
        teamId : Internal.UUID;
        name : string;
        online : boolean;
        readonly uuid : Internal.UUID;
        get valid(): boolean;
        get internalTeam(): boolean;
        get extraData(): Internal.CompoundTag;
        get profile(): Internal.GameProfile;
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    type KnownClientPlayer_ = KnownClientPlayer;
    class TeamPropertyType <T> {
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        static read(buf: Internal.FriendlyByteBuf_): Internal.TeamProperty<any>;
        hashCode(): number;
        notifyAll(): void;
        equals(arg0: any): boolean;
        toString(): string;
        static write(buf: Internal.FriendlyByteBuf_, p: Internal.TeamProperty_<any>): void;
        notify(): void;
        static register<Y>(id: string, p: Internal.TeamPropertyType$FromNet_<Y>): Internal.TeamPropertyType<Y>;
        static readonly ENUM : Internal.TeamPropertyType<string>;
        static readonly PRIVACY_MODE : Internal.TeamPropertyType<Internal.PrivacyMode>;
        static readonly COLOR : Internal.TeamPropertyType<Internal.Color4I>;
        static readonly STRING : Internal.TeamPropertyType<string>;
        readonly deserializer : Internal.TeamPropertyType$FromNet<T>;
        static readonly DOUBLE : Internal.TeamPropertyType<number>;
        readonly id : string;
        static readonly MAP : {"boolean":Internal.TeamPropertyType<any>,"string":Internal.TeamPropertyType<any>,"color":Internal.TeamPropertyType<any>,"double":Internal.TeamPropertyType<any>,"privacy_mode":Internal.TeamPropertyType<any>,"int":Internal.TeamPropertyType<any>,"enum":Internal.TeamPropertyType<any>};
        static readonly BOOLEAN : Internal.TeamPropertyType<boolean>;
        static readonly INT : Internal.TeamPropertyType<number>;
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    type TeamPropertyType_<T> = TeamPropertyType<T>;
    interface Predicate <T> {
        or(arg0: Internal.Predicate_<T>): Internal.Predicate<T>;
        test(arg0: T): boolean;
        and(arg0: Internal.Predicate_<T>): Internal.Predicate<T>;
        negate(): Internal.Predicate<T>;
    }
    type Predicate_<T> = ((arg0: T) => boolean) | Predicate<T>;
    interface Int2ObjectMap <V> extends Internal.Int2ObjectFunction<V>, Internal.Map<number, V> {
        getOrDefault(arg0: number, arg1: V): V;
        getOrDefault(arg0: any, arg1: V): V;
        computeIfAbsent(arg0: number, arg1: Internal.Int2ObjectFunction_<V>): V;
        computeIfAbsent(arg0: number, arg1: Internal.IntFunction_<V>): V;
        computeIfAbsent(arg0: number, arg1: java_.util.function_.Function_<number, V>): V;
        values(): Internal.ObjectCollection<V>;
        andThenShort(arg0: Internal.Object2ShortFunction_<V>): Internal.Int2ShortFunction;
        replace(arg0: number, arg1: V, arg2: V): boolean;
        replace(arg0: number, arg1: V): V;
        composeByte(arg0: Internal.Byte2IntFunction_): Internal.Byte2ObjectFunction<V>;
        computeIfAbsentPartial(arg0: number, arg1: Internal.Int2ObjectFunction_<V>): V;
        replaceAll(arg0: Internal.BiFunction_<number, V, V>): void;
        andThenInt(arg0: Internal.Object2IntFunction_<V>): Internal.Int2IntFunction;
        containsValue(arg0: any): boolean;
        andThen<V_>(arg0: java_.util.function_.Function_<V, V_>): java_.util.function_.Function<number, V_>;
        composeReference<T_>(arg0: Internal.Reference2IntFunction_<T_>): Internal.Reference2ObjectFunction<T_, V>;
        put(arg0: number, arg1: V): V;
        remove(arg0: any): V;
        remove(arg0: number, arg1: any): boolean;
        remove(arg0: number): V;
        remove(arg0: any, arg1: any): boolean;
        compute(arg0: number, arg1: Internal.BiFunction_<number, V, V>): V;
        defaultReturnValue(arg0: V): void;
        defaultReturnValue(): V;
        andThenDouble(arg0: Internal.Object2DoubleFunction_<V>): Internal.Int2DoubleFunction;
        andThenObject<T_>(arg0: Internal.Object2ObjectFunction_<V, T_>): Internal.Int2ObjectFunction<T_>;
        int2ObjectEntrySet(): Internal.ObjectSet<Internal.Int2ObjectMap$Entry<V>>;
        hashCode(): number;
        putAll(arg0: Internal.Map_<number, V>): void;
        merge(arg0: number, arg1: V, arg2: Internal.BiFunction_<V, V, V>): V;
        get(arg0: any): V;
        get(arg0: number): V;
        andThenLong(arg0: Internal.Object2LongFunction_<V>): Internal.Int2LongFunction;
        composeLong(arg0: Internal.Long2IntFunction_): Internal.Long2ObjectFunction<V>;
        keySet(): Internal.IntSet;
        andThenByte(arg0: Internal.Object2ByteFunction_<V>): Internal.Int2ByteFunction;
        andThenFloat(arg0: Internal.Object2FloatFunction_<V>): Internal.Int2FloatFunction;
        apply(arg0: number): V;
        entrySet(): Internal.ObjectSet<Internal.Map$Entry<number, V>>;
        containsKey(arg0: number): boolean;
        containsKey(arg0: any): boolean;
        forEach(arg0: Internal.BiConsumer_<number, V>): void;
        composeInt(arg0: Internal.Int2IntFunction_): Internal.Int2ObjectFunction<V>;
        isEmpty(): boolean;
        clear(): void;
        composeFloat(arg0: Internal.Float2IntFunction_): Internal.Float2ObjectFunction<V>;
        andThenChar(arg0: Internal.Object2CharFunction_<V>): Internal.Int2CharFunction;
        composeObject<T_>(arg0: Internal.Object2IntFunction_<T_>): Internal.Object2ObjectFunction<T_, V>;
        computeIfPresent(arg0: number, arg1: Internal.BiFunction_<number, V, V>): V;
        size(): number;
        compose<T_>(arg0: java_.util.function_.Function_<T_, number>): java_.util.function_.Function<T_, V>;
        equals(arg0: any): boolean;
        composeShort(arg0: Internal.Short2IntFunction_): Internal.Short2ObjectFunction<V>;
        andThenReference<T_>(arg0: Internal.Object2ReferenceFunction_<V, T_>): Internal.Int2ReferenceFunction<T_>;
        composeChar(arg0: Internal.Char2IntFunction_): Internal.Char2ObjectFunction<V>;
        composeDouble(arg0: Internal.Double2IntFunction_): Internal.Double2ObjectFunction<V>;
        putIfAbsent(arg0: number, arg1: V): V;
    }
    type Int2ObjectMap_<V> = Int2ObjectMap<V>;
    class FireworkRocketEntity extends Internal.Projectile implements Internal.ItemSupplier, Internal.FireworkRocketEntityKJS {
        getClass(): Internal.Class<any>;
        resetDynamicLight(): void;
        getCapability<T_>(arg0: Internal.Capability_<T_>, arg1: Internal.Direction_): Internal.LazyOptional<T_>;
        getCapability<T_>(arg0: Internal.Capability_<T_>): Internal.LazyOptional<T_>;
        captureDrops(arg0: Internal.Collection_<Internal.ItemEntity_>): Internal.Collection<Internal.ItemEntity>;
        captureDrops(): Internal.Collection<Internal.ItemEntity>;
        canBeRiddenInWater(arg0: Internal.Entity_): boolean;
        setAddDamage(arg0: number): void;
        isDynamicLightEnabled(): boolean;
        changeDimension(arg0: Internal.ServerLevel_, arg1: Internal.ITeleporter_): Internal.Entity;
        serializeNBT(): Internal.CompoundTag;
        invalidateCaps(): void;
        setDynamicLightEnabled(arg0: boolean): void;
        shouldUpdateDynamicLight(): boolean;
        revive(): void;
        setVisualScale(arg0: number): void;
        dynamicLightTick(): void;
        getPersistentDataKJS(): Internal.CompoundTag;
        canUpdate(): boolean;
        canUpdate(arg0: boolean): void;
        getDynamicLightY(): number;
        getDynamicLightZ(): number;
        getDynamicLightX(): number;
        areCapsCompatible(arg0: Internal.CapabilityProvider_<Internal.Entity_>): boolean;
        areCapsCompatible(arg0: Internal.CapabilityDispatcher_): boolean;
        getEyeHeightAccess(arg0: Internal.Pose_, arg1: Internal.EntityDimensions_): number;
        reviveCaps(): void;
        lambdynlights$updateDynamicLight(arg0: Internal.LevelRenderer_): boolean;
        handler$bih000$removed(arg0: Internal.CallbackInfo_): void;
        canRiderInteract(): boolean;
        lambdynlights$scheduleTrackedChunksRebuild(arg0: Internal.LevelRenderer_): void;
        handler$bih001$onTick(arg0: Internal.CallbackInfo_): void;
        onAddedToWorld(): void;
        canTrample(arg0: Internal.BlockState_, arg1: BlockPos_, arg2: number): boolean;
        setMaxLifeTime(arg0: number): void;
        setOnHitAction(arg0: Internal.Consumer_<any>): void;
        getClassification(arg0: boolean): Internal.MobCategory;
        handler$bih000$onRemove(arg0: Internal.CallbackInfo_): void;
        shouldRiderSit(): boolean;
        getPickedResult(arg0: Internal.HitResult_): Internal.ItemStack;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        notifyAll(): void;
        getPersistentData(): Internal.CompoundTag;
        notify(): void;
        hashCode(): number;
        setDimension(arg0: Internal.EntityDimensions_): void;
        isAddedToWorld(): boolean;
        getParts(): any[];
        getDynamicLightWorld(): Internal.Level;
        onRemovedFromWorld(): void;
        getLuminance(): number;
        isMultipartEntity(): boolean;
        deserializeNBT(arg0: Internal.CompoundTag_): void;
        getAddDamage(): number;
        asKJS(): any;
        handler$bhf000$onHitCallback(arg0: Internal.HitResult_, arg1: Internal.CallbackInfo_): void;
        equals(arg0: any): boolean;
        toString(): string;
        getVisualScale(): number;
        get luminance(): number;
        get dynamicLightEnabled(): boolean;
        get persistentData(): Internal.CompoundTag;
        get multipartEntity(): boolean;
        get addedToWorld(): boolean;
        get dynamicLightY(): number;
        get dynamicLightZ(): number;
        get dynamicLightX(): number;
        get visualScale(): number;
        get persistentDataKJS(): Internal.CompoundTag;
        get addDamage(): number;
        get parts(): any[];
        get class(): Internal.Class<any>;
        get dynamicLightWorld(): Internal.Level;
        set onHitAction(arg0: Internal.Consumer_<any>);
        set dynamicLightEnabled(arg0: boolean);
        set visualScale(arg0: number);
        set addDamage(arg0: number);
        set maxLifeTime(arg0: number);
        set dimension(arg0: Internal.EntityDimensions_);
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    type FireworkRocketEntity_ = FireworkRocketEntity;
    interface WritableByteChannel extends Internal.Channel {
        isOpen(): boolean;
        close(): void;
        write(arg0: Internal.ByteBuffer_): number;
    }
    type WritableByteChannel_ = WritableByteChannel;
    class MultiPackResourceManager implements Internal.CloseableResourceManager, Internal.ReloadableResourceManagerImplAccessor {
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        hashCode(): number;
        notifyAll(): void;
        equals(arg0: any): boolean;
        toString(): string;
        close(): void;
        notify(): void;
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    type MultiPackResourceManager_ = MultiPackResourceManager;
    interface TextureAtlasInterface {
        getAtlasSize(): Internal.Vec2;
        setAtlasSize(arg0: number, arg1: number): void;
    }
    type TextureAtlasInterface_ = TextureAtlasInterface;
    abstract class AbstractIntSet extends Internal.AbstractIntCollection implements Internal.Cloneable, Internal.IntSet {
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        notifyAll(): void;
        intIterator(): Internal.IntIterator;
        intSpliterator(): Internal.IntSpliterator;
        notify(): void;
        remove(arg0: number): boolean;
        remove(arg0: any): boolean;
        intStream(): Internal.IntStream;
        removeAll(arg0: Internal.IntCollection_): boolean;
        removeAll(arg0: Internal.Collection_<any>): boolean;
        iterator(): Internal.IntIterator;
        stream(): Internal.Stream<number>;
        hashCode(): number;
        toIntArray(arg0: number[]): number[];
        toIntArray(): number[];
        toArray(arg0: number[]): number[];
        toArray(): any[];
        toArray<T_>(arg0: T_[]): T_[];
        toArray<T_>(arg0: Internal.IntFunction_<T_[]>): T_[];
        parallelStream(): Internal.Stream<number>;
        rem(arg0: number): boolean;
        add(arg0: number): boolean;
        spliterator(): Internal.IntSpliterator;
        forEach(arg0: Internal.IntConsumer_): void;
        forEach(arg0: Internal.Consumer_<number>): void;
        forEach(arg0: java_.util.function_.IntConsumer_): void;
        containsAll(arg0: Internal.Collection_<any>): boolean;
        containsAll(arg0: Internal.IntCollection_): boolean;
        isEmpty(): boolean;
        clear(): void;
        removeIf(arg0: Internal.IntPredicate_): boolean;
        removeIf(arg0: Internal.Predicate_<number>): boolean;
        removeIf(arg0: java_.util.function_.IntPredicate_): boolean;
        contains(arg0: number): boolean;
        contains(arg0: any): boolean;
        size(): number;
        addAll(arg0: Internal.IntCollection_): boolean;
        addAll(arg0: Internal.Collection_<number>): boolean;
        equals(arg0: any): boolean;
        toString(): string;
        intParallelStream(): Internal.IntStream;
        retainAll(arg0: Internal.Collection_<any>): boolean;
        retainAll(arg0: Internal.IntCollection_): boolean;
        get class(): Internal.Class<any>;
        get empty(): boolean;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    type AbstractIntSet_ = AbstractIntSet;
    interface Multiset <E> extends Internal.Collection<E> {
        add(arg0: E, arg1: number): number;
        add(arg0: E): boolean;
        forEachEntry(arg0: Internal.ObjIntConsumer_<E>): void;
        entrySet(): Internal.Set<Internal.Multiset$Entry<E>>;
        spliterator(): Internal.Spliterator<E>;
        forEach(arg0: Internal.Consumer_<E>): void;
        containsAll(arg0: Internal.Collection_<any>): boolean;
        isEmpty(): boolean;
        clear(): void;
        count(arg0: any): number;
        remove(arg0: any, arg1: number): number;
        remove(arg0: any): boolean;
        removeIf(arg0: Internal.Predicate_<E>): boolean;
        removeAll(arg0: Internal.Collection_<any>): boolean;
        contains(arg0: any): boolean;
        iterator(): Internal.Iterator<E>;
        size(): number;
        addAll(arg0: Internal.Collection_<E>): boolean;
        stream(): Internal.Stream<E>;
        elementSet(): Internal.Set<E>;
        hashCode(): number;
        equals(arg0: any): boolean;
        toArray<T_>(arg0: T_[]): T_[];
        toArray<T_>(arg0: Internal.IntFunction_<T_[]>): T_[];
        toArray(): any[];
        parallelStream(): Internal.Stream<E>;
        toString(): string;
        setCount(arg0: E, arg1: number): number;
        setCount(arg0: E, arg1: number, arg2: number): boolean;
        retainAll(arg0: Internal.Collection_<any>): boolean;
    }
    type Multiset_<E> = Multiset<E>;
    interface Byte2IntFunction extends Internal.Function<number, number>, Internal.IntUnaryOperator {
        getOrDefault(arg0: any, arg1: number): number;
        getOrDefault(arg0: number, arg1: number): number;
        andThenShort(arg0: Internal.Int2ShortFunction_): Internal.Byte2ShortFunction;
        composeByte(arg0: Internal.Byte2ByteFunction_): Internal.Byte2IntFunction;
        andThenInt(arg0: Internal.Int2IntFunction_): Internal.Byte2IntFunction;
        composeReference<T_>(arg0: Internal.Reference2ByteFunction_<T_>): Internal.Reference2IntFunction<T_>;
        andThen<T_>(arg0: java_.util.function_.Function_<number, T_>): java_.util.function_.Function<number, T_>;
        andThen(arg0: Internal.IntUnaryOperator_): Internal.IntUnaryOperator;
        put(arg0: number, arg1: number): number;
        remove(arg0: number): number;
        remove(arg0: any): number;
        defaultReturnValue(): number;
        defaultReturnValue(arg0: number): void;
        andThenDouble(arg0: Internal.Int2DoubleFunction_): Internal.Byte2DoubleFunction;
        andThenObject<T_>(arg0: Internal.Int2ObjectFunction_<T_>): Internal.Byte2ObjectFunction<T_>;
        get(arg0: any): number;
        get(arg0: number): number;
        andThenLong(arg0: Internal.Int2LongFunction_): Internal.Byte2LongFunction;
        composeLong(arg0: Internal.Long2ByteFunction_): Internal.Long2IntFunction;
        andThenByte(arg0: Internal.Int2ByteFunction_): Internal.Byte2ByteFunction;
        andThenFloat(arg0: Internal.Int2FloatFunction_): Internal.Byte2FloatFunction;
        applyAsInt(arg0: number): number;
        apply(arg0: number): number;
        containsKey(arg0: any): boolean;
        containsKey(arg0: number): boolean;
        composeInt(arg0: Internal.Int2ByteFunction_): Internal.Int2IntFunction;
        clear(): void;
        composeFloat(arg0: Internal.Float2ByteFunction_): Internal.Float2IntFunction;
        andThenChar(arg0: Internal.Int2CharFunction_): Internal.Byte2CharFunction;
        composeObject<T_>(arg0: Internal.Object2ByteFunction_<T_>): Internal.Object2IntFunction<T_>;
        size(): number;
        compose<T_>(arg0: java_.util.function_.Function_<T_, number>): java_.util.function_.Function<T_, number>;
        compose(arg0: Internal.IntUnaryOperator_): Internal.IntUnaryOperator;
        composeShort(arg0: Internal.Short2ByteFunction_): Internal.Short2IntFunction;
        andThenReference<T_>(arg0: Internal.Int2ReferenceFunction_<T_>): Internal.Byte2ReferenceFunction<T_>;
        composeChar(arg0: Internal.Char2ByteFunction_): Internal.Char2IntFunction;
        composeDouble(arg0: Internal.Double2ByteFunction_): Internal.Double2IntFunction;
    }
    type Byte2IntFunction_ = ((arg0: number) => number) | Byte2IntFunction;
    interface WithAttachedData {
        getData(): Internal.AttachedData;
    }
    type WithAttachedData_ = WithAttachedData;
    class ClickAction extends Internal.Enum<Internal.ClickAction> {
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        static valueOf(arg0: string): Internal.ClickAction;
        static valueOf<T_>(arg0: Internal.Class_<T_>, arg1: string): T_;
        notifyAll(): void;
        static values(): Internal.ClickAction[];
        compareTo(arg0: Internal.ClickAction_): number;
        describeConstable(): Internal.Optional<Internal.Enum$EnumDesc<Internal.ClickAction>>;
        notify(): void;
        getDeclaringClass(): Internal.Class<Internal.ClickAction>;
        hashCode(): number;
        equals(arg0: any): boolean;
        name(): string;
        toString(): string;
        ordinal(): number;
        static readonly SECONDARY : Internal.ClickAction;
        static readonly PRIMARY : Internal.ClickAction;
        get class(): Internal.Class<any>;
        get declaringClass(): Internal.Class<Internal.ClickAction>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    type ClickAction_ = "secondary" | "primary" | ClickAction;
    interface OpenOption {
    }
    type OpenOption_ = OpenOption;
    interface FileAttributeView extends Internal.AttributeView {
        name(): string;
    }
    type FileAttributeView_ = FileAttributeView;
    class ForgeConfigSpec$DoubleValue extends Internal.ForgeConfigSpec$ConfigValue<number> {
        next(): Internal.ForgeConfigSpec$Builder;
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        set(arg0: number): void;
        hashCode(): number;
        notifyAll(): void;
        equals(arg0: any): boolean;
        get(): number;
        getPath(): Internal.List<string>;
        save(): void;
        toString(): string;
        clearCache(): void;
        notify(): void;
        get path(): Internal.List<string>;
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    type ForgeConfigSpec$DoubleValue_ = ForgeConfigSpec$DoubleValue;
    interface ConditionContainer {
        entityScores(entity: Internal.LootContext$EntityTarget_, scores: Internal.Map_<string, any>): Internal.ConditionContainer;
        killedByPlayer(): Internal.ConditionContainer;
        survivesExplosion(): Internal.ConditionContainer;
        randomChance(chance: number): Internal.ConditionContainer;
        randomChanceWithLooting(chance: number, multiplier: number): Internal.ConditionContainer;
        addCondition(arg0: Internal.JsonObject_): Internal.ConditionContainer;
        entityProperties(entity: Internal.LootContext$EntityTarget_, properties: Internal.JsonObject_): Internal.ConditionContainer;
    }
    type ConditionContainer_ = ConditionContainer;
    interface Char2ReferenceFunction <V> extends Internal.Function<string, V>, Internal.IntFunction<V> {
        getOrDefault(arg0: string, arg1: V): V;
        getOrDefault(arg0: any, arg1: V): V;
        andThenShort(arg0: Internal.Reference2ShortFunction_<V>): Internal.Char2ShortFunction;
        composeByte(arg0: Internal.Byte2CharFunction_): Internal.Byte2ReferenceFunction<V>;
        andThenInt(arg0: Internal.Reference2IntFunction_<V>): Internal.Char2IntFunction;
        andThen<V_>(arg0: java_.util.function_.Function_<V, V_>): java_.util.function_.Function<string, V_>;
        composeReference<T_>(arg0: Internal.Reference2CharFunction_<T_>): Internal.Reference2ReferenceFunction<T_, V>;
        put(arg0: string, arg1: V): V;
        remove(arg0: any): V;
        remove(arg0: string): V;
        defaultReturnValue(arg0: V): void;
        defaultReturnValue(): V;
        andThenDouble(arg0: Internal.Reference2DoubleFunction_<V>): Internal.Char2DoubleFunction;
        andThenObject<T_>(arg0: Internal.Reference2ObjectFunction_<V, T_>): Internal.Char2ObjectFunction<T_>;
        get(arg0: any): V;
        get(arg0: string): V;
        andThenLong(arg0: Internal.Reference2LongFunction_<V>): Internal.Char2LongFunction;
        composeLong(arg0: Internal.Long2CharFunction_): Internal.Long2ReferenceFunction<V>;
        andThenByte(arg0: Internal.Reference2ByteFunction_<V>): Internal.Char2ByteFunction;
        andThenFloat(arg0: Internal.Reference2FloatFunction_<V>): Internal.Char2FloatFunction;
        apply(arg0: number): V;
        apply(arg0: string): V;
        containsKey(arg0: any): boolean;
        containsKey(arg0: string): boolean;
        composeInt(arg0: Internal.Int2CharFunction_): Internal.Int2ReferenceFunction<V>;
        clear(): void;
        composeFloat(arg0: Internal.Float2CharFunction_): Internal.Float2ReferenceFunction<V>;
        andThenChar(arg0: Internal.Reference2CharFunction_<V>): Internal.Char2CharFunction;
        composeObject<T_>(arg0: Internal.Object2CharFunction_<T_>): Internal.Object2ReferenceFunction<T_, V>;
        size(): number;
        compose<T_>(arg0: java_.util.function_.Function_<T_, string>): java_.util.function_.Function<T_, V>;
        composeShort(arg0: Internal.Short2CharFunction_): Internal.Short2ReferenceFunction<V>;
        andThenReference<T_>(arg0: Internal.Reference2ReferenceFunction_<V, T_>): Internal.Char2ReferenceFunction<T_>;
        composeChar(arg0: Internal.Char2CharFunction_): Internal.Char2ReferenceFunction<V>;
        composeDouble(arg0: Internal.Double2CharFunction_): Internal.Double2ReferenceFunction<V>;
    }
    type Char2ReferenceFunction_<V> = ((arg0: string) => V) | Char2ReferenceFunction<V>;
    class Potion extends Internal.ForgeRegistryEntry<Internal.Potion> {
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        hashCode(): number;
        notifyAll(): void;
        equals(arg0: any): boolean;
        getRegistryType(): Internal.Class<Internal.Potion>;
        getRegistryName(): ResourceLocation;
        toString(): string;
        setRegistryName(arg0: ResourceLocation_): Internal.Potion;
        setRegistryName(arg0: string): Internal.Potion;
        setRegistryName(arg0: string, arg1: string): Internal.Potion;
        notify(): void;
        readonly delegate : Internal.IRegistryDelegate<Internal.Potion>;
        get registryType(): Internal.Class<Internal.Potion>;
        get registryName(): ResourceLocation;
        get class(): Internal.Class<any>;
        set registryName(arg0: ResourceLocation_);
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    type Potion_ = Potion;
    class CopyNameFunction$NameSource extends Internal.Enum<Internal.CopyNameFunction$NameSource> {
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        static valueOf(arg0: string): Internal.CopyNameFunction$NameSource;
        static valueOf<T_>(arg0: Internal.Class_<T_>, arg1: string): T_;
        notifyAll(): void;
        static values(): Internal.CopyNameFunction$NameSource[];
        compareTo(arg0: Internal.CopyNameFunction$NameSource_): number;
        describeConstable(): Internal.Optional<Internal.Enum$EnumDesc<Internal.CopyNameFunction$NameSource>>;
        notify(): void;
        getDeclaringClass(): Internal.Class<Internal.CopyNameFunction$NameSource>;
        hashCode(): number;
        equals(arg0: any): boolean;
        name(): string;
        toString(): string;
        ordinal(): number;
        static readonly KILLER_PLAYER : Internal.CopyNameFunction$NameSource;
        static readonly KILLER : Internal.CopyNameFunction$NameSource;
        static readonly BLOCK_ENTITY : Internal.CopyNameFunction$NameSource;
        static readonly THIS : Internal.CopyNameFunction$NameSource;
        get class(): Internal.Class<any>;
        get declaringClass(): Internal.Class<Internal.CopyNameFunction$NameSource>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    type CopyNameFunction$NameSource_ = "block_entity" | "this" | "killer_player" | "killer" | CopyNameFunction$NameSource;
    /**
    * Fired by different tag when the client is:
    * - logged in
    * - logged out
    */
    class ClientLoggedInEventJS extends Internal.ClientEventJS {
        cancel(): void;
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        isCancelled(): boolean;
        getPlayer(): Internal.ClientPlayerJS;
        notifyAll(): void;
        getEntity(): Internal.EntityJS;
        notify(): void;
        getLevel(): Internal.ClientLevelJS;
        post(id: string): boolean;
        post(id: string, sub: string): boolean;
        post(t: Internal.ScriptType_, id: string, sub: string): boolean;
        post(t: Internal.ScriptType_, id: string): boolean;
        hashCode(): number;
        equals(arg0: any): boolean;
        toString(): string;
        canCancel(): boolean;
        get level(): Internal.ClientLevelJS;
        get cancelled(): boolean;
        get class(): Internal.Class<any>;
        get entity(): Internal.EntityJS;
        get player(): Internal.ClientPlayerJS;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    /**
    * Fired by different tag when the client is:
    * - logged in
    * - logged out
    */
    type ClientLoggedInEventJS_ = ClientLoggedInEventJS;
    class HeightRangePlacement extends Internal.PlacementModifier {
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        hashCode(): number;
        notifyAll(): void;
        equals(arg0: any): boolean;
        toString(): string;
        notify(): void;
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    type HeightRangePlacement_ = HeightRangePlacement;
    interface ListBuilder <T> {
        withErrorsFrom(arg0: Internal.DataResult_<any>): Internal.ListBuilder<T>;
        add(arg0: Internal.DataResult_<T>): Internal.ListBuilder<T>;
        add(arg0: T): Internal.ListBuilder<T>;
        add<E>(arg0: E, arg1: Internal.Encoder_<E>): Internal.ListBuilder<T>;
        mapError(arg0: Internal.UnaryOperator_<string>): Internal.ListBuilder<T>;
        ops(): Internal.DynamicOps<T>;
        build(arg0: T): Internal.DataResult<T>;
        build(arg0: Internal.DataResult_<T>): Internal.DataResult<T>;
        addAll<E>(arg0: Internal.Iterable_<E>, arg1: Internal.Encoder_<E>): Internal.ListBuilder<T>;
    }
    type ListBuilder_<T> = ListBuilder<T>;
    interface DropTargetListener extends Internal.EventListener {
        drop(arg0: Internal.DropTargetDropEvent_): void;
        dragEnter(arg0: Internal.DropTargetDragEvent_): void;
        dropActionChanged(arg0: Internal.DropTargetDragEvent_): void;
        dragOver(arg0: Internal.DropTargetDragEvent_): void;
        dragExit(arg0: Internal.DropTargetEvent_): void;
    }
    type DropTargetListener_ = DropTargetListener;
    class Products$P2 <F, T1, T2> {
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        apply<R>(arg0: Internal.Applicative_<F, any>, arg1: Internal.BiFunction_<T1, T2, R>): Internal.App<F, R>;
        apply<R>(arg0: Internal.Applicative_<F, any>, arg1: Internal.App_<F, Internal.BiFunction_<T1, T2, R>>): Internal.App<F, R>;
        hashCode(): number;
        and<T3, T4, T5, T6, T7>(arg0: Internal.Products$P5_<F, T3, T4, T5, T6, T7>): Internal.Products$P7<F, T1, T2, T3, T4, T5, T6, T7>;
        and<T3, T4, T5, T6, T7, T8>(arg0: Internal.Products$P6_<F, T3, T4, T5, T6, T7, T8>): Internal.Products$P8<F, T1, T2, T3, T4, T5, T6, T7, T8>;
        and<T3>(arg0: Internal.App_<F, T3>): Internal.Products$P3<F, T1, T2, T3>;
        and<T3, T4>(arg0: Internal.Products$P2_<F, T3, T4>): Internal.Products$P4<F, T1, T2, T3, T4>;
        and<T3, T4, T5>(arg0: Internal.Products$P3_<F, T3, T4, T5>): Internal.Products$P5<F, T1, T2, T3, T4, T5>;
        and<T3, T4, T5, T6>(arg0: Internal.Products$P4_<F, T3, T4, T5, T6>): Internal.Products$P6<F, T1, T2, T3, T4, T5, T6>;
        notifyAll(): void;
        equals(arg0: any): boolean;
        toString(): string;
        t1(): Internal.App<F, T1>;
        notify(): void;
        t2(): Internal.App<F, T2>;
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    type Products$P2_<F, T1, T2> = Products$P2<F, T1, T2>;
    class VarHandle$VarHandleDesc extends Internal.DynamicConstantDesc<Internal.VarHandle> {
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        static ofCanonical<T_>(arg0: Internal.DirectMethodHandleDesc_, arg1: string, arg2: Internal.ClassDesc_, arg3: Internal.ConstantDesc_[]): Internal.ConstantDesc;
        bootstrapMethod(): Internal.DirectMethodHandleDesc;
        constantName(): string;
        notifyAll(): void;
        bootstrapArgsList(): Internal.List<Internal.ConstantDesc>;
        static ofArray(arg0: Internal.ClassDesc_): Internal.VarHandle$VarHandleDesc;
        resolveConstantDesc(arg0: Internal.MethodHandles$Lookup_): Internal.VarHandle;
        notify(): void;
        static ofField(arg0: Internal.ClassDesc_, arg1: string, arg2: Internal.ClassDesc_): Internal.VarHandle$VarHandleDesc;
        static ofStaticField(arg0: Internal.ClassDesc_, arg1: string, arg2: Internal.ClassDesc_): Internal.VarHandle$VarHandleDesc;
        varType(): Internal.ClassDesc;
        constantType(): Internal.ClassDesc;
        hashCode(): number;
        bootstrapArgs(): Internal.ConstantDesc[];
        static of<T_>(arg0: Internal.DirectMethodHandleDesc_, arg1: Internal.ConstantDesc_[]): Internal.DynamicConstantDesc<T_>;
        static of<T_>(arg0: Internal.DirectMethodHandleDesc_): Internal.DynamicConstantDesc<T_>;
        equals(arg0: any): boolean;
        static ofNamed<T_>(arg0: Internal.DirectMethodHandleDesc_, arg1: string, arg2: Internal.ClassDesc_, arg3: Internal.ConstantDesc_[]): Internal.DynamicConstantDesc<T_>;
        toString(): string;
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    type VarHandle$VarHandleDesc_ = VarHandle$VarHandleDesc;
    /**
    */
    class HoeItemBuilder extends Internal.HandheldItemBuilder {
        barWidth(barWidth: Internal.ToIntFunction_<Internal.ItemStackJS_>): Internal.ItemBuilder;
        getClass(): Internal.Class<any>;
        maxStackSize(v: number): Internal.ItemBuilder;
        translationKey(key: string): Internal.BuilderBase<Internal.Item>;
        newID(pre: string, post: string): ResourceLocation;
        use(use: Internal.ItemBuilder$UseCallback_): Internal.ItemBuilder;
        maxDamage(v: number): Internal.ItemBuilder;
        textureJson(json: Internal.JsonObject_): Internal.ItemBuilder;
        tooltip(text: Internal.Component_): Internal.ItemBuilder;
        modifyTier(callback: Internal.Consumer_<Internal.MutableToolTier_>): Internal.HandheldItemBuilder;
        type(type: string): Internal.BuilderBase<Internal.Item>;
        containerItem(id: string): Internal.ItemBuilder;
        subtypes(fn: java_.util.function_.Function_<Internal.ItemStackJS_, Internal.Collection_<Internal.ItemStackJS_>>): Internal.ItemBuilder;
        modelJson(json: Internal.JsonObject_): Internal.ItemBuilder;
        burnTime(v: number): Internal.ItemBuilder;
        useDuration(useDuration: Internal.ToIntFunction_<Internal.ItemStackJS_>): Internal.ItemBuilder;
        tag(tag: ResourceLocation_): Internal.BuilderBase<Internal.Item>;
        parentModel(m: string): Internal.ItemBuilder;
        generateDataJsons(generator: Internal.DataJsonGenerator_): void;
        group(g: string): Internal.ItemBuilder;
        static ofArmorMaterial(o: any): Internal.ArmorMaterial;
        /**
        */
        modifyAttribute(attribute: net.minecraft.world.entity.ai.attributes.Attribute_, identifier: string, d: number, operation: Internal.AttributeModifier$Operation_): Internal.ItemBuilder;
        getRegistryType(): Internal.RegistryObjectBuilderTypes<Internal.Item>;
        attackDamageBonus(f: number): Internal.HandheldItemBuilder;
        glow(v: boolean): Internal.ItemBuilder;
        useAnimation(animation: Internal.UseAnim_): Internal.ItemBuilder;
        rarity(v: Rarity_): Internal.ItemBuilder;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        clientRegistry(minecraft: Internal.Minecraft_): void;
        transformObject(obj: Internal.Item_): Internal.Item;
        color(callback: Internal.ItemBuilder$ItemColorJS_): Internal.ItemBuilder;
        color(index: number, c: Internal.Color_): Internal.ItemBuilder;
        displayName(name: string): Internal.BuilderBase<Internal.Item>;
        notifyAll(): void;
        barColor(barColor: java_.util.function_.Function_<Internal.ItemStackJS_, Internal.Color_>): Internal.ItemBuilder;
        notify(): void;
        createAdditionalObjects(): void;
        speed(f: number): Internal.HandheldItemBuilder;
        tier(t: Internal.Tier_): Internal.HandheldItemBuilder;
        hashCode(): number;
        get(): Internal.Item;
        speedBaseline(f: number): Internal.HandheldItemBuilder;
        generateAssetJsons(generator: Internal.AssetJsonGenerator_): void;
        getTranslationKeyGroup(): string;
        texture(key: string, tex: string): Internal.ItemBuilder;
        texture(tex: string): Internal.ItemBuilder;
        generateLang(lang: Internal.Map_<string, string>): void;
        food(b: Internal.Consumer_<Internal.FoodBuilder_>): Internal.ItemBuilder;
        createObject(): Internal.Item;
        releaseUsing(releaseUsing: Internal.ItemBuilder$ReleaseUsingCallback_): Internal.ItemBuilder;
        attackDamageBaseline(f: number): Internal.HandheldItemBuilder;
        unstackable(): Internal.ItemBuilder;
        addResourcePackLocations(path: string, list: Internal.List_<ResourceLocation_>, packType: Internal.PackType_): void;
        equals(arg0: any): boolean;
        toString(): string;
        finishUsing(finishUsing: Internal.ItemBuilder$FinishUsingCallback_): Internal.ItemBuilder;
        createItemProperties(): Internal.Item$Properties;
        static readonly TOOL_TIERS : {"gold":any,"diamond":any,"iron":any,"wood":any,"stone":any,"netherite":any};
        static readonly ARMOR_TIERS : {"gold":any,"chain":any,"diamond":any,"turtle":any,"iron":any,"leather":any,"netherite":any};
        readonly id : ResourceLocation;
        get registryType(): Internal.RegistryObjectBuilderTypes<Internal.Item>;
        get class(): Internal.Class<any>;
        get translationKeyGroup(): string;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    /**
    */
    type HoeItemBuilder_ = HoeItemBuilder;
    class PoiTypeBuilder extends Internal.BuilderBase<Internal.PoiType> {
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        clientRegistry(minecraft: Internal.Minecraft_): void;
        transformObject(obj: Internal.PoiType_): Internal.PoiType;
        translationKey(key: string): Internal.BuilderBase<Internal.PoiType>;
        newID(pre: string, post: string): ResourceLocation;
        displayName(name: string): Internal.BuilderBase<Internal.PoiType>;
        notifyAll(): void;
        type(type: string): Internal.BuilderBase<Internal.PoiType>;
        notify(): void;
        createAdditionalObjects(): void;
        hashCode(): number;
        get(): Internal.PoiType;
        block(r: Internal.Block_): Internal.PoiTypeBuilder;
        tag(tag: ResourceLocation_): Internal.BuilderBase<Internal.PoiType>;
        generateDataJsons(generator: Internal.DataJsonGenerator_): void;
        generateAssetJsons(generator: Internal.AssetJsonGenerator_): void;
        getTranslationKeyGroup(): string;
        blocks(r: Internal.BlockState_[]): Internal.PoiTypeBuilder;
        generateLang(lang: Internal.Map_<string, string>): void;
        validRange(i: number): Internal.PoiTypeBuilder;
        createObject(): Internal.PoiType;
        addResourcePackLocations(path: string, list: Internal.List_<ResourceLocation_>, packType: Internal.PackType_): void;
        equals(arg0: any): boolean;
        getRegistryType(): Internal.RegistryObjectBuilderTypes<Internal.PoiType>;
        toString(): string;
        maxTickets(i: number): Internal.PoiTypeBuilder;
        readonly id : ResourceLocation;
        get registryType(): Internal.RegistryObjectBuilderTypes<Internal.PoiType>;
        get class(): Internal.Class<any>;
        get translationKeyGroup(): string;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    type PoiTypeBuilder_ = PoiTypeBuilder;
    interface EventLoop extends Internal.OrderedEventExecutor, Internal.EventLoopGroup {
        next(): Internal.EventExecutor;
        next(): Internal.EventLoop;
        terminationFuture(): io.netty.util.concurrent.Future<any>;
        parent(): Internal.EventLoopGroup;
        parent(): Internal.EventExecutorGroup;
        newProgressivePromise<V_>(): Internal.ProgressivePromise<V_>;
        shutdownGracefully(): io.netty.util.concurrent.Future<any>;
        shutdownGracefully(arg0: number, arg1: number, arg2: Internal.TimeUnit_): io.netty.util.concurrent.Future<any>;
        submit<T_>(arg0: Internal.Runnable_, arg1: T_): io.netty.util.concurrent.Future<T_>;
        submit<T_>(arg0: Internal.Runnable_, arg1: T_): Internal.Future<T_>;
        submit<T_>(arg0: java_.util.concurrent.Callable_<T_>): io.netty.util.concurrent.Future<T_>;
        submit<T_>(arg0: java_.util.concurrent.Callable_<T_>): Internal.Future<T_>;
        submit(arg0: Internal.Runnable_): io.netty.util.concurrent.Future<any>;
        submit(arg0: Internal.Runnable_): Internal.Future<any>;
        isTerminated(): boolean;
        scheduleWithFixedDelay(arg0: Internal.Runnable_, arg1: number, arg2: number, arg3: Internal.TimeUnit_): io.netty.util.concurrent.ScheduledFuture<any>;
        scheduleWithFixedDelay(arg0: Internal.Runnable_, arg1: number, arg2: number, arg3: Internal.TimeUnit_): Internal.ScheduledFuture<any>;
        inEventLoop(): boolean;
        inEventLoop(arg0: Internal.Thread_): boolean;
        iterator(): Internal.Iterator<Internal.EventExecutor>;
        awaitTermination(arg0: number, arg1: Internal.TimeUnit_): boolean;
        shutdownNow(): Internal.List<Internal.Runnable>;
        newPromise<V_>(): Internal.Promise<V_>;
        scheduleAtFixedRate(arg0: Internal.Runnable_, arg1: number, arg2: number, arg3: Internal.TimeUnit_): io.netty.util.concurrent.ScheduledFuture<any>;
        scheduleAtFixedRate(arg0: Internal.Runnable_, arg1: number, arg2: number, arg3: Internal.TimeUnit_): Internal.ScheduledFuture<any>;
        spliterator(): Internal.Spliterator<Internal.EventExecutor>;
        forEach(arg0: Internal.Consumer_<Internal.EventExecutor_>): void;
        invokeAll<T_>(arg0: Internal.Collection_<java_.util.concurrent.Callable_<T_>>): Internal.List<Internal.Future<T_>>;
        invokeAll<T_>(arg0: Internal.Collection_<java_.util.concurrent.Callable_<T_>>, arg1: number, arg2: Internal.TimeUnit_): Internal.List<Internal.Future<T_>>;
        newFailedFuture<V_>(arg0: Internal.Throwable_): io.netty.util.concurrent.Future<V_>;
        execute(arg0: Internal.Runnable_): void;
        schedule<V_>(arg0: java_.util.concurrent.Callable_<V_>, arg1: number, arg2: Internal.TimeUnit_): io.netty.util.concurrent.ScheduledFuture<V_>;
        schedule<V_>(arg0: java_.util.concurrent.Callable_<V_>, arg1: number, arg2: Internal.TimeUnit_): Internal.ScheduledFuture<V_>;
        schedule(arg0: Internal.Runnable_, arg1: number, arg2: Internal.TimeUnit_): io.netty.util.concurrent.ScheduledFuture<any>;
        schedule(arg0: Internal.Runnable_, arg1: number, arg2: Internal.TimeUnit_): Internal.ScheduledFuture<any>;
        isShuttingDown(): boolean;
        newSucceededFuture<V_>(arg0: V_): io.netty.util.concurrent.Future<V_>;
        invokeAny<T_>(arg0: Internal.Collection_<java_.util.concurrent.Callable_<T_>>, arg1: number, arg2: Internal.TimeUnit_): T_;
        invokeAny<T_>(arg0: Internal.Collection_<java_.util.concurrent.Callable_<T_>>): T_;
        shutdown(): void;
        register(arg0: io.netty.channel.Channel_, arg1: Internal.ChannelPromise_): Internal.ChannelFuture;
        register(arg0: Internal.ChannelPromise_): Internal.ChannelFuture;
        register(arg0: io.netty.channel.Channel_): Internal.ChannelFuture;
        isShutdown(): boolean;
    }
    type EventLoop_ = EventLoop;
    interface AccessorAbstractContainerScreen {
        getHoveredSlot(): Internal.Slot;
    }
    type AccessorAbstractContainerScreen_ = AccessorAbstractContainerScreen;
    interface WorldRendererExtended {
        getSodiumWorldRenderer(): Internal.SodiumWorldRenderer;
    }
    type WorldRendererExtended_ = WorldRendererExtended;
    class AddOreProperties {
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        belowTop(y: number): Internal.VerticalAnchor;
        chance(c: number): Internal.AddOreProperties;
        addTarget(ruleTest: Internal.RuleTest_, targetState: BlockStatePredicate_): void;
        uniformHeight(absolute: Internal.VerticalAnchor_, absolute1: Internal.VerticalAnchor_): Internal.AddOreProperties;
        uniformHeight(min: number, max: number): Internal.AddOreProperties;
        bottom(): Internal.VerticalAnchor;
        notifyAll(): void;
        count(min: number, max: number): Internal.AddOreProperties;
        count(c: Internal.IntProvider_): Internal.AddOreProperties;
        count(c: number): Internal.AddOreProperties;
        triangleHeight(min: number, max: number): Internal.AddOreProperties;
        triangleHeight(absolute: Internal.VerticalAnchor_, absolute1: Internal.VerticalAnchor_): Internal.AddOreProperties;
        aboveBottom(y: number): Internal.VerticalAnchor;
        notify(): void;
        top(): Internal.VerticalAnchor;
        size(s: number): Internal.AddOreProperties;
        hashCode(): number;
        equals(arg0: any): boolean;
        squared(): Internal.AddOreProperties;
        toString(): string;
        noSurface : number;
        biomes : ((arg0: Internal.BiomeModifications$BiomeContext) => boolean);
        retrogen : number;
        id : ResourceLocation;
        targets : Internal.List<Internal.OreConfiguration$TargetBlockState>;
        worldgenLayer : DecorationGenerationStep;
        height : Internal.HeightRangePlacement;
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    type AddOreProperties_ = AddOreProperties;
    interface PrimitiveCodec <A> extends Internal.Codec<A> {
        encode<T_>(arg0: A, arg1: Internal.DynamicOps_<T_>, arg2: T_): Internal.DataResult<T_>;
        flatComapMap<S_>(arg0: java_.util.function_.Function_<A, S_>, arg1: java_.util.function_.Function_<S_, Internal.DataResult_<A>>): Internal.Codec<S_>;
        dispatch<E_>(arg0: java_.util.function_.Function_<E_, A>, arg1: java_.util.function_.Function_<A, Internal.Codec_<E_>>): Internal.Codec<E_>;
        dispatch<E_>(arg0: string, arg1: java_.util.function_.Function_<E_, A>, arg2: java_.util.function_.Function_<A, Internal.Codec_<E_>>): Internal.Codec<E_>;
        deprecated(arg0: number): Internal.Codec<A>;
        simple(): Internal.Decoder$Simple<A>;
        dispatchMap<E_>(arg0: string, arg1: java_.util.function_.Function_<E_, A>, arg2: java_.util.function_.Function_<A, Internal.Codec_<E_>>): Internal.MapCodec<E_>;
        dispatchMap<E_>(arg0: java_.util.function_.Function_<E_, A>, arg1: java_.util.function_.Function_<A, Internal.Codec_<E_>>): Internal.MapCodec<E_>;
        comapFlatMap<S_>(arg0: java_.util.function_.Function_<A, Internal.DataResult_<S_>>, arg1: java_.util.function_.Function_<S_, A>): Internal.Codec<S_>;
        decode<T_>(arg0: Internal.DynamicOps_<T_>, arg1: T_): Internal.DataResult<Internal.Pair<A, T_>>;
        decode<T_>(arg0: Internal.Dynamic_<T_>): Internal.DataResult<Internal.Pair<A, T_>>;
        promotePartial(arg0: Internal.Consumer_<string>): Internal.Codec<A>;
        flatXmap<S_>(arg0: java_.util.function_.Function_<A, Internal.DataResult_<S_>>, arg1: java_.util.function_.Function_<S_, Internal.DataResult_<A>>): Internal.Codec<S_>;
        comap<B_>(arg0: java_.util.function_.Function_<B_, A>): Internal.Encoder<B_>;
        fieldOf(arg0: string): Internal.MapCodec<A>;
        xmap<S_>(arg0: java_.util.function_.Function_<A, S_>, arg1: java_.util.function_.Function_<S_, A>): Internal.Codec<S_>;
        listOf(): Internal.Codec<Internal.List<A>>;
        map<B_>(arg0: java_.util.function_.Function_<A, B_>): Internal.Decoder<B_>;
        write<T_>(arg0: Internal.DynamicOps_<T_>, arg1: A): T_;
        encodeStart<T_>(arg0: Internal.DynamicOps_<T_>, arg1: A): Internal.DataResult<T_>;
        optionalFieldOf(arg0: string, arg1: A, arg2: Internal.Lifecycle_): Internal.MapCodec<A>;
        optionalFieldOf(arg0: string, arg1: A): Internal.MapCodec<A>;
        optionalFieldOf(arg0: string): Internal.MapCodec<Internal.Optional<A>>;
        optionalFieldOf(arg0: string, arg1: Internal.Lifecycle_, arg2: A, arg3: Internal.Lifecycle_): Internal.MapCodec<A>;
        flatComap<B_>(arg0: java_.util.function_.Function_<B_, Internal.DataResult_<A>>): Internal.Encoder<B_>;
        read<T_>(arg0: Internal.DynamicOps_<T_>, arg1: T_): Internal.DataResult<A>;
        partialDispatch<E_>(arg0: string, arg1: java_.util.function_.Function_<E_, Internal.DataResult_<A>>, arg2: java_.util.function_.Function_<A, Internal.DataResult_<Internal.Codec_<E_>>>): Internal.Codec<E_>;
        terminal(): Internal.Decoder$Terminal<A>;
        parse<T_>(arg0: Internal.DynamicOps_<T_>, arg1: T_): Internal.DataResult<A>;
        parse<T_>(arg0: Internal.Dynamic_<T_>): Internal.DataResult<A>;
        withLifecycle(arg0: Internal.Lifecycle_): Internal.Codec<A>;
        orElse(arg0: A): Internal.Codec<A>;
        orElse(arg0: Internal.Consumer_<string>, arg1: A): Internal.Codec<A>;
        orElse(arg0: Internal.UnaryOperator_<string>, arg1: A): Internal.Codec<A>;
        flatMap<B_>(arg0: java_.util.function_.Function_<A, Internal.DataResult_<B_>>): Internal.Decoder<B_>;
        boxed(): Internal.Decoder$Boxed<A>;
        dispatchStable<E_>(arg0: java_.util.function_.Function_<E_, A>, arg1: java_.util.function_.Function_<A, Internal.Codec_<E_>>): Internal.Codec<E_>;
        orElseGet(arg0: Internal.Consumer_<string>, arg1: Internal.Supplier_<A>): Internal.Codec<A>;
        orElseGet(arg0: Internal.Supplier_<A>): Internal.Codec<A>;
        orElseGet(arg0: Internal.UnaryOperator_<string>, arg1: Internal.Supplier_<A>): Internal.Codec<A>;
        stable(): Internal.Codec<A>;
        mapResult(arg0: Internal.Codec$ResultFunction_<A>): Internal.Codec<A>;
    }
    type PrimitiveCodec_<A> = PrimitiveCodec<A>;
    abstract class PainterObject implements Internal.SpecialEquality {
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        hashCode(): number;
        notifyAll(): void;
        equals(o: any): boolean;
        update(tag: Internal.CompoundTag_): void;
        toString(): string;
        id(i: string): Internal.PainterObject;
        notify(): void;
        specialEquals(o: any, shallow: boolean): boolean;
        parent : Internal.PainterObjectStorage;
        visible : boolean;
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    type PainterObject_ = PainterObject;
    class TextHitInfo {
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        getOffsetHit(arg0: number): Internal.TextHitInfo;
        isLeadingEdge(): boolean;
        static leading(arg0: number): Internal.TextHitInfo;
        notifyAll(): void;
        static afterOffset(arg0: number): Internal.TextHitInfo;
        notify(): void;
        getInsertionIndex(): number;
        static beforeOffset(arg0: number): Internal.TextHitInfo;
        getOtherHit(): Internal.TextHitInfo;
        static trailing(arg0: number): Internal.TextHitInfo;
        hashCode(): number;
        equals(arg0: any): boolean;
        equals(arg0: Internal.TextHitInfo_): boolean;
        toString(): string;
        getCharIndex(): number;
        get otherHit(): Internal.TextHitInfo;
        get charIndex(): number;
        get leadingEdge(): boolean;
        get insertionIndex(): number;
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    type TextHitInfo_ = TextHitInfo;
    interface InterruptibleChannel extends Internal.Channel {
        isOpen(): boolean;
        close(): void;
    }
    type InterruptibleChannel_ = InterruptibleChannel;
    class EvaluatorException extends Internal.RhinoException {
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        getLocalizedMessage(): string;
        getScriptStack(limit: number, hideFunction: string): any[];
        getScriptStack(): any[];
        notifyAll(): void;
        initColumnNumber(columnNumber: number): void;
        getCause(): Internal.Throwable;
        notify(): void;
        getScriptStackTrace(limit: number, functionName: string): string;
        getScriptStackTrace(): string;
        addSuppressed(arg0: Internal.Throwable_): void;
        getStackTrace(): any[];
        columnNumber(): number;
        hashCode(): number;
        getSuppressed(): Internal.Throwable[];
        details(): string;
        printStackTrace(s: Internal.PrintWriter_): void;
        printStackTrace(s: Internal.PrintStream_): void;
        printStackTrace(): void;
        initSourceName(sourceName: string): void;
        initCause(arg0: Internal.Throwable_): Internal.Throwable;
        getMessage(): string;
        initLineSource(lineSource: string): void;
        setStackTrace(arg0: any_[]): void;
        lineSource(): string;
        equals(arg0: any): boolean;
        initLineNumber(lineNumber: number): void;
        toString(): string;
        sourceName(): string;
        lineNumber(): number;
        fillInStackTrace(): Internal.Throwable;
        get localizedMessage(): string;
        get scriptStack(): any[];
        get cause(): Internal.Throwable;
        get scriptStackTrace(): string;
        get stackTrace(): any[];
        get suppressed(): Internal.Throwable[];
        get message(): string;
        get class(): Internal.Class<any>;
        set stackTrace(arg0: any_[]);
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    type EvaluatorException_ = EvaluatorException;
    class ForgeConfigSpec$BooleanValue extends Internal.ForgeConfigSpec$ConfigValue<boolean> {
        next(): Internal.ForgeConfigSpec$Builder;
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        set(arg0: boolean): void;
        hashCode(): number;
        notifyAll(): void;
        equals(arg0: any): boolean;
        get(): boolean;
        getPath(): Internal.List<string>;
        save(): void;
        toString(): string;
        clearCache(): void;
        notify(): void;
        get path(): Internal.List<string>;
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    type ForgeConfigSpec$BooleanValue_ = ForgeConfigSpec$BooleanValue;
    class DoubleSummaryStatistics implements java_.util.function_.DoubleConsumer {
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        getMax(): number;
        notifyAll(): void;
        getAverage(): number;
        andThen(arg0: java_.util.function_.DoubleConsumer_): java_.util.function_.DoubleConsumer;
        notify(): void;
        accept(arg0: number): void;
        getMin(): number;
        hashCode(): number;
        equals(arg0: any): boolean;
        toString(): string;
        getSum(): number;
        getCount(): number;
        combine(arg0: Internal.DoubleSummaryStatistics_): void;
        get average(): number;
        get min(): number;
        get max(): number;
        get count(): number;
        get sum(): number;
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    type DoubleSummaryStatistics_ = DoubleSummaryStatistics;
    interface IIngredientRenderer <T> {
        getHeight(): number;
        getTooltip(arg0: T, arg1: Internal.TooltipFlag_): Internal.List<Internal.Component>;
        getFontRenderer(arg0: Internal.Minecraft_, arg1: T): net.minecraft.client.gui.Font;
        getWidth(): number;
        render(arg0: Internal.PoseStack_, arg1: number, arg2: number, arg3: T): void;
        render(arg0: Internal.PoseStack_, arg1: T): void;
    }
    type IIngredientRenderer_<T> = IIngredientRenderer<T>;
    interface ILootAction extends Internal.ILootHandler {
        applyLootHandler(arg0: Internal.LootContext_, arg1: Internal.List_<Internal.ItemStack_>): boolean;
    }
    type ILootAction_ = ILootAction;
    class ModuleDescriptor$Provides implements Internal.Comparable<Internal.ModuleDescriptor$Provides> {
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        service(): string;
        hashCode(): number;
        notifyAll(): void;
        equals(arg0: any): boolean;
        toString(): string;
        compareTo(arg0: Internal.ModuleDescriptor$Provides_): number;
        notify(): void;
        providers(): Internal.List<string>;
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    type ModuleDescriptor$Provides_ = ModuleDescriptor$Provides;
    abstract class AccessibleBundle {
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        toDisplayString(): string;
        toDisplayString(arg0: Internal.Locale_): string;
        hashCode(): number;
        notifyAll(): void;
        equals(arg0: any): boolean;
        toString(): string;
        notify(): void;
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    type AccessibleBundle_ = AccessibleBundle;
    class OreConfiguration$TargetBlockState {
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        hashCode(): number;
        notifyAll(): void;
        equals(arg0: any): boolean;
        toString(): string;
        notify(): void;
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    type OreConfiguration$TargetBlockState_ = OreConfiguration$TargetBlockState;
    interface UserPrincipal extends Internal.Principal {
        getName(): string;
        hashCode(): number;
        equals(arg0: any): boolean;
        toString(): string;
        implies(arg0: Internal.Subject_): boolean;
    }
    type UserPrincipal_ = UserPrincipal;
    abstract class ShapedBlockBuilder extends Internal.BlockBuilder {
        noItem(): Internal.BlockBuilder;
        suffocating(b: boolean): Internal.BlockBuilder;
        getClass(): Internal.Class<any>;
        translationKey(key: string): Internal.BuilderBase<Internal.Block>;
        newID(pre: string, post: string): ResourceLocation;
        type(type: string): Internal.BuilderBase<Internal.Block>;
        unbreakable(): Internal.BlockBuilder;
        model(m: string): Internal.BlockBuilder;
        tag(tag: ResourceLocation_): Internal.BlockBuilder;
        generateDataJsons(generator: Internal.DataJsonGenerator_): void;
        tagBoth(tag: ResourceLocation_): Internal.BlockBuilder;
        defaultCutout(): Internal.BlockBuilder;
        item(i: Internal.Consumer_<Internal.BlockItemBuilder_>): Internal.BlockBuilder;
        resistance(r: number): Internal.BlockBuilder;
        hardness(h: number): Internal.BlockBuilder;
        slipperiness(f: number): Internal.BlockBuilder;
        getRegistryType(): Internal.RegistryObjectBuilderTypes<Internal.Block>;
        textureSide(direction: Internal.Direction_, tex: string): Internal.BlockBuilder;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        clientRegistry(minecraft: Internal.Minecraft_): void;
        waterlogged(): Internal.BlockBuilder;
        transformObject(obj: Internal.Block_): Internal.Block;
        color(index: number, c: Internal.Color_): Internal.BlockBuilder;
        textureAll(tex: string): Internal.BlockBuilder;
        displayName(name: string): Internal.BuilderBase<Internal.Block>;
        notifyAll(): void;
        box(x0: number, y0: number, z0: number, x1: number, y1: number, z1: number): Internal.BlockBuilder;
        box(x0: number, y0: number, z0: number, x1: number, y1: number, z1: number, scale16: boolean): Internal.BlockBuilder;
        viewBlocking(b: boolean): Internal.BlockBuilder;
        notify(): void;
        transparent(b: boolean): Internal.BlockBuilder;
        createAdditionalObjects(): void;
        tagBlock(tag: ResourceLocation_): Internal.BlockBuilder;
        fullBlock(f: boolean): Internal.BlockBuilder;
        createProperties(): Internal.BlockBehaviour$Properties;
        notSolid(): Internal.BlockBuilder;
        generateBlockModels(builder: Internal.BlockBuilder_): Internal.Map<ResourceLocation, Internal.JsonObject>;
        hashCode(): number;
        noCollission(): Internal.BlockBuilder;
        get(): Internal.Block;
        requiresTool(f: boolean): Internal.BlockBuilder;
        renderType(l: string): Internal.BlockBuilder;
        jumpFactor(f: number): Internal.BlockBuilder;
        createShape(): Internal.VoxelShape;
        generateAssetJsons(generator: Internal.AssetJsonGenerator_): void;
        noCollision(): Internal.BlockBuilder;
        opaque(o: boolean): Internal.BlockBuilder;
        randomTick(randomTickCallback: Internal.Consumer_<Internal.RandomTickCallbackJS_>): Internal.BlockBuilder;
        getTranslationKeyGroup(): string;
        texture(id: string, tex: string): Internal.BlockBuilder;
        noDrops(): Internal.BlockBuilder;
        generateLang(lang: Internal.Map_<string, string>): void;
        tagItem(tag: ResourceLocation_): Internal.BlockBuilder;
        speedFactor(f: number): Internal.BlockBuilder;
        noValidSpawns(b: boolean): Internal.BlockBuilder;
        createObject(): Internal.Block;
        lightLevel(light: number): Internal.BlockBuilder;
        addResourcePackLocations(path: string, list: Internal.List_<ResourceLocation_>, packType: Internal.PackType_): void;
        defaultTranslucent(): Internal.BlockBuilder;
        material(m: Internal.MaterialJS_): Internal.BlockBuilder;
        equals(arg0: any): boolean;
        toString(): string;
        redstoneConductor(b: boolean): Internal.BlockBuilder;
        lootTable : ((arg0: Internal.LootBuilder) => void);
        modelJson : Internal.JsonObject;
        blockstateJson : Internal.JsonObject;
        readonly id : ResourceLocation;
        randomTickCallback : ((arg0: Internal.RandomTickCallbackJS) => void);
        get registryType(): Internal.RegistryObjectBuilderTypes<Internal.Block>;
        get class(): Internal.Class<any>;
        get translationKeyGroup(): string;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    type ShapedBlockBuilder_ = ShapedBlockBuilder;
    class Component$BaselineResizeBehavior extends Internal.Enum<Internal.Component$BaselineResizeBehavior> {
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        static valueOf(arg0: string): Internal.Component$BaselineResizeBehavior;
        static valueOf<T_>(arg0: Internal.Class_<T_>, arg1: string): T_;
        notifyAll(): void;
        static values(): Internal.Component$BaselineResizeBehavior[];
        compareTo(arg0: Internal.Component$BaselineResizeBehavior_): number;
        describeConstable(): Internal.Optional<Internal.Enum$EnumDesc<Internal.Component$BaselineResizeBehavior>>;
        notify(): void;
        getDeclaringClass(): Internal.Class<Internal.Component$BaselineResizeBehavior>;
        hashCode(): number;
        equals(arg0: any): boolean;
        name(): string;
        toString(): string;
        ordinal(): number;
        static readonly OTHER : Internal.Component$BaselineResizeBehavior;
        static readonly CONSTANT_DESCENT : Internal.Component$BaselineResizeBehavior;
        static readonly CENTER_OFFSET : Internal.Component$BaselineResizeBehavior;
        static readonly CONSTANT_ASCENT : Internal.Component$BaselineResizeBehavior;
        get class(): Internal.Class<any>;
        get declaringClass(): Internal.Class<Internal.Component$BaselineResizeBehavior>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    type Component$BaselineResizeBehavior_ = "other" | "center_offset" | "constant_descent" | "constant_ascent" | Component$BaselineResizeBehavior;
    abstract class Format implements Internal.Serializable, Internal.Cloneable {
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        formatToCharacterIterator(arg0: any): Internal.AttributedCharacterIterator;
        hashCode(): number;
        notifyAll(): void;
        equals(arg0: any): boolean;
        format(arg0: any, arg1: Internal.StringBuffer_, arg2: Internal.FieldPosition_): Internal.StringBuffer;
        format(arg0: any): string;
        clone(): any;
        toString(): string;
        notify(): void;
        parseObject(arg0: string): any;
        parseObject(arg0: string, arg1: Internal.ParsePosition_): any;
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    type Format_ = Format;
    class ListJS extends Internal.ArrayList<any> implements Internal.StringBuilderAppendable, Internal.ChangeListener<any>, Internal.Copyable, Internal.JsonSerializable, Internal.NBTSerializable {
        getClass(): Internal.Class<any>;
        shift(): any;
        removeAll(arg0: Internal.Collection_<any>): boolean;
        iterator(): Internal.Iterator<any>;
        toArray(): any[];
        toArray<T_>(arg0: T_[]): T_[];
        toArray<T_>(arg0: Internal.IntFunction_<T_[]>): T_[];
        static orSelf(o: any): Internal.ListJS;
        parallelStream(): Internal.Stream<any>;
        indexOf(arg0: any): number;
        add(index: number, value: any): void;
        add(value: any): boolean;
        appendString(builder: Internal.StringBuilder_): void;
        spliterator(): Internal.Spliterator<any>;
        sort(arg0: Internal.Comparator_<any>): void;
        push(o: any[]): Internal.ListJS;
        removeIf(arg0: Internal.Predicate_<any>): boolean;
        contains(arg0: any): boolean;
        toJson(): Internal.JsonArray;
        size(): number;
        listIterator(): Internal.ListIterator<any>;
        listIterator(arg0: number): Internal.ListIterator<any>;
        ensureCapacity(arg0: number): void;
        static nbt(list: any): Internal.CollectionTag<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        notifyAll(): void;
        replaceAll(arg0: Internal.UnaryOperator_<any>): void;
        notify(): void;
        remove(index: number): any;
        remove(o: any): boolean;
        pop(): any;
        toNBT(): Internal.CollectionTag<any>;
        stream(): Internal.Stream<any>;
        hashCode(): number;
        get(arg0: number): any;
        static of(o: any): Internal.ListJS;
        static of(array: number[]): Internal.ListJS;
        static of(array: string[]): Internal.ListJS;
        static json(array: any): Internal.JsonArray;
        copy(): Internal.ListJS;
        map(transformer: java_.util.function_.Function_<any, any>): Internal.ListJS;
        subList(arg0: number, arg1: number): Internal.List<any>;
        trimToSize(): void;
        set(arg0: number, arg1: any): any;
        onChanged(o: any): void;
        forEach(arg0: Internal.Consumer_<any>): void;
        splice(pos: number, deleteCount: number, items: any[]): Internal.ListJS;
        containsAll(arg0: Internal.Collection_<any>): boolean;
        isEmpty(): boolean;
        clear(): void;
        static ofArray(array: any): Internal.ListJS;
        reverse(): Internal.ListJS;
        filter(predicate: Internal.Predicate_<any>): Internal.ListJS;
        lastIndexOf(arg0: any): number;
        addAll(index: number, c: Internal.Collection_<any>): boolean;
        addAll(c: Internal.Collection_<any>): boolean;
        equals(arg0: any): boolean;
        clone(): any;
        getLength(): number;
        unshift(o: any[]): Internal.ListJS;
        toString(): string;
        retainAll(arg0: Internal.Collection_<any>): boolean;
        changeListener : ((arg0: Internal.ListJS) => void);
        get length(): number;
        get class(): Internal.Class<any>;
        get empty(): boolean;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    type ListJS_ = ListJS;
    class DateTimeFormatter {
        withLocale(arg0: Internal.Locale_): Internal.DateTimeFormatter;
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        parseBest(arg0: Internal.CharSequence_, arg1: Internal.TemporalQuery_<any>[]): Internal.TemporalAccessor;
        static ofLocalizedDateTime(arg0: Internal.FormatStyle_): Internal.DateTimeFormatter;
        static ofLocalizedDateTime(arg0: Internal.FormatStyle_, arg1: Internal.FormatStyle_): Internal.DateTimeFormatter;
        notifyAll(): void;
        getResolverFields(): Internal.Set<Internal.TemporalField>;
        static ofPattern(arg0: string): Internal.DateTimeFormatter;
        static ofPattern(arg0: string, arg1: Internal.Locale_): Internal.DateTimeFormatter;
        notify(): void;
        static ofLocalizedDate(arg0: Internal.FormatStyle_): Internal.DateTimeFormatter;
        formatTo(arg0: Internal.TemporalAccessor_, arg1: Internal.Appendable_): void;
        static parsedLeapSecond(): Internal.TemporalQuery<boolean>;
        hashCode(): number;
        getChronology(): Internal.Chronology;
        withChronology(arg0: Internal.Chronology_): Internal.DateTimeFormatter;
        withDecimalStyle(arg0: Internal.DecimalStyle_): Internal.DateTimeFormatter;
        localizedBy(arg0: Internal.Locale_): Internal.DateTimeFormatter;
        withZone(arg0: Internal.ZoneId_): Internal.DateTimeFormatter;
        static parsedExcessDays(): Internal.TemporalQuery<Internal.Period>;
        withResolverStyle(arg0: Internal.ResolverStyle_): Internal.DateTimeFormatter;
        getResolverStyle(): Internal.ResolverStyle;
        format(arg0: Internal.TemporalAccessor_): string;
        getZone(): Internal.ZoneId;
        parse(arg0: Internal.CharSequence_, arg1: Internal.ParsePosition_): Internal.TemporalAccessor;
        parse(arg0: Internal.CharSequence_): Internal.TemporalAccessor;
        parse<T>(arg0: Internal.CharSequence_, arg1: Internal.TemporalQuery_<T>): T;
        getDecimalStyle(): Internal.DecimalStyle;
        toFormat(): Internal.Format;
        toFormat(arg0: Internal.TemporalQuery_<any>): Internal.Format;
        static ofLocalizedTime(arg0: Internal.FormatStyle_): Internal.DateTimeFormatter;
        equals(arg0: any): boolean;
        toString(): string;
        withResolverFields(arg0: Internal.TemporalField_[]): Internal.DateTimeFormatter;
        withResolverFields(arg0: Internal.Set_<Internal.TemporalField_>): Internal.DateTimeFormatter;
        getLocale(): Internal.Locale;
        parseUnresolved(arg0: Internal.CharSequence_, arg1: Internal.ParsePosition_): Internal.TemporalAccessor;
        static readonly ISO_OFFSET_TIME : Internal.DateTimeFormatter;
        static readonly ISO_LOCAL_DATE_TIME : Internal.DateTimeFormatter;
        static readonly RFC_1123_DATE_TIME : Internal.DateTimeFormatter;
        static readonly ISO_INSTANT : Internal.DateTimeFormatter;
        static readonly ISO_ZONED_DATE_TIME : Internal.DateTimeFormatter;
        static readonly ISO_OFFSET_DATE_TIME : Internal.DateTimeFormatter;
        static readonly ISO_DATE_TIME : Internal.DateTimeFormatter;
        static readonly ISO_DATE : Internal.DateTimeFormatter;
        static readonly ISO_TIME : Internal.DateTimeFormatter;
        static readonly ISO_LOCAL_TIME : Internal.DateTimeFormatter;
        static readonly ISO_OFFSET_DATE : Internal.DateTimeFormatter;
        static readonly ISO_ORDINAL_DATE : Internal.DateTimeFormatter;
        static readonly ISO_LOCAL_DATE : Internal.DateTimeFormatter;
        static readonly BASIC_ISO_DATE : Internal.DateTimeFormatter;
        static readonly ISO_WEEK_DATE : Internal.DateTimeFormatter;
        get resolverFields(): Internal.Set<Internal.TemporalField>;
        get zone(): Internal.ZoneId;
        get decimalStyle(): Internal.DecimalStyle;
        get resolverStyle(): Internal.ResolverStyle;
        get chronology(): Internal.Chronology;
        get locale(): Internal.Locale;
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    type DateTimeFormatter_ = DateTimeFormatter;
    class PoseStack$Pose {
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        hashCode(): number;
        notifyAll(): void;
        equals(arg0: any): boolean;
        toString(): string;
        notify(): void;
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    type PoseStack$Pose_ = PoseStack$Pose;
    class MultiBufferSource$BufferSource implements Internal.MultiBufferSource, Internal.AccessorMultiBufferSource, Internal.MemoryTrackingBuffer {
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        hashCode(): number;
        getUsedSize(): number;
        notifyAll(): void;
        equals(arg0: any): boolean;
        toString(): string;
        getAllocatedSize(): number;
        notify(): void;
        get allocatedSize(): number;
        get usedSize(): number;
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    type MultiBufferSource$BufferSource_ = MultiBufferSource$BufferSource;
    interface MobEffectBuilder$EffectTickCallback {
        applyEffectTick(arg0: Internal.LivingEntityJS_, arg1: number): void;
    }
    type MobEffectBuilder$EffectTickCallback_ = ((arg0: Internal.LivingEntityJS, arg1: number) => void) | MobEffectBuilder$EffectTickCallback;
    class ScriptType extends Internal.Enum<Internal.ScriptType> {
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        isServer(): boolean;
        static valueOf(name: string): Internal.ScriptType;
        static valueOf<T_>(arg0: Internal.Class_<T_>, arg1: string): T_;
        notifyAll(): void;
        static values(): Internal.ScriptType[];
        isClient(): boolean;
        compareTo(arg0: Internal.ScriptType_): number;
        describeConstable(): Internal.Optional<Internal.Enum$EnumDesc<Internal.ScriptType>>;
        notify(): void;
        getLogFile(): Internal.Path;
        getDeclaringClass(): Internal.Class<Internal.ScriptType>;
        hashCode(): number;
        equals(arg0: any): boolean;
        static of(level: Internal.LevelReader_): Internal.ScriptType;
        name(): string;
        toString(): string;
        ordinal(): number;
        readonly console : Internal.ConsoleJS;
        readonly manager : (() => Internal.ScriptManager);
        static readonly SERVER : Internal.ScriptType;
        readonly executor : Internal.ExecutorService;
        readonly warnings : Internal.List<string>;
        static readonly STARTUP : Internal.ScriptType;
        static readonly CLIENT : Internal.ScriptType;
        readonly errors : Internal.List<string>;
        get server(): boolean;
        get logFile(): Internal.Path;
        get client(): boolean;
        get class(): Internal.Class<any>;
        get declaringClass(): Internal.Class<Internal.ScriptType>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    type ScriptType_ = "server" | "startup" | "client" | ScriptType;
    class Item extends Internal.ForgeRegistryEntry<Internal.Item> implements Internal.ItemLike, Internal.IForgeItem, Internal.AccessorItem, Internal.ItemFTBL, Internal.ItemAccess, Internal.ForgeItemAccessor, Internal.IPlaceableItem, Internal.ItemKJS {
        getClass(): Internal.Class<any>;
        canElytraFly(arg0: Internal.ItemStack_, arg1: Internal.LivingEntity_): boolean;
        setBurnTime(i: number): void;
        setDamage(arg0: Internal.ItemStack_, arg1: number): void;
        canPerformAction(arg0: Internal.ItemStack_, arg1: Internal.ToolAction_): boolean;
        damageItem<T_>(arg0: Internal.ItemStack_, arg1: number, arg2: T_, arg3: Internal.Consumer_<T_>): number;
        shouldCauseBlockBreakReset(arg0: Internal.ItemStack_, arg1: Internal.ItemStack_): boolean;
        getItemEnchantability(arg0: Internal.ItemStack_): number;
        getPlacer(): Internal.BlockPlacerItem;
        shouldCauseReequipAnimation(arg0: Internal.ItemStack_, arg1: Internal.ItemStack_, arg2: boolean): boolean;
        getXpRepairRatio(arg0: Internal.ItemStack_): number;
        readShareTag(arg0: Internal.ItemStack_, arg1: Internal.CompoundTag_): void;
        handler$bcn000$overrideOtherStackedOnMe(arg0: Internal.ItemStack_, arg1: Internal.ItemStack_, arg2: Internal.Slot_, arg3: Internal.ClickAction_, arg4: Internal.Player_, arg5: Internal.SlotAccess_, arg6: Internal.CallbackInfoReturnable_<any>): void;
        onEntityItemUpdate(arg0: Internal.ItemStack_, arg1: Internal.ItemEntity_): boolean;
        getDamage(arg0: Internal.ItemStack_): number;
        isBookEnchantable(arg0: Internal.ItemStack_, arg1: Internal.ItemStack_): boolean;
        canDisableShield(arg0: Internal.ItemStack_, arg1: Internal.ItemStack_, arg2: Internal.LivingEntity_, arg3: Internal.LivingEntity_): boolean;
        onUsingTick(arg0: Internal.ItemStack_, arg1: Internal.LivingEntity_, arg2: number): void;
        isPiglinCurrency(arg0: Internal.ItemStack_): boolean;
        getCreativeTabs(): Internal.Collection<Internal.CreativeModeTab>;
        createEntity(arg0: Internal.Level_, arg1: Internal.Entity_, arg2: Internal.ItemStack_): Internal.Entity;
        getSweepHitBox(arg0: Internal.ItemStack_, arg1: Internal.Player_, arg2: Internal.Entity_): Internal.AABB;
        isRepairable(arg0: Internal.ItemStack_): boolean;
        getPlaceableBlock(): Internal.Block;
        getShareTag(arg0: Internal.ItemStack_): Internal.CompoundTag;
        getBurnTime(arg0: Internal.ItemStack_, arg1: Internal.RecipeType_<any>): number;
        onDroppedByPlayer(arg0: Internal.ItemStack_, arg1: Internal.Player_): boolean;
        isDamageable(arg0: Internal.ItemStack_): boolean;
        onEntitySwing(arg0: Internal.ItemStack_, arg1: Internal.LivingEntity_): boolean;
        getRegistryType(): Internal.Class<Internal.Item>;
        setItemBuilderKJS(b: Internal.ItemBuilder_): void;
        elytraFlightTick(arg0: Internal.ItemStack_, arg1: Internal.LivingEntity_, arg2: number): boolean;
        getItemBuilderKJS(): Internal.ItemBuilder;
        handler$bcn000$overrideStackedOnOther(arg0: Internal.ItemStack_, arg1: Internal.Slot_, arg2: Internal.ClickAction_, arg3: Internal.Player_, arg4: Internal.CallbackInfoReturnable_<any>): void;
        getAttributeModifiers(arg0: EquipmentSlot_, arg1: Internal.ItemStack_): Internal.Multimap<Internal.Attribute, Internal.AttributeModifier>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        onLeftClickEntity(arg0: Internal.ItemStack_, arg1: Internal.Player_, arg2: Internal.Entity_): boolean;
        canEquip(arg0: Internal.ItemStack_, arg1: EquipmentSlot_, arg2: Internal.Entity_): boolean;
        notifyAll(): void;
        getId(): string;
        notify(): void;
        onBlockStartBreak(arg0: Internal.ItemStack_, arg1: BlockPos_, arg2: Internal.Player_): boolean;
        onHorseArmorTick(arg0: Internal.ItemStack_, arg1: Internal.Level_, arg2: Internal.Mob_): void;
        canContinueUsing(arg0: Internal.ItemStack_, arg1: Internal.ItemStack_): boolean;
        getEntityLifespan(arg0: Internal.ItemStack_, arg1: Internal.Level_): number;
        getRenderPropertiesInternal(): any;
        getArmorTexture(arg0: Internal.ItemStack_, arg1: Internal.Entity_, arg2: EquipmentSlot_, arg3: string): string;
        getDefaultTooltipHideFlags(arg0: Internal.ItemStack_): number;
        hashCode(): number;
        hasCustomEntity(arg0: Internal.ItemStack_): boolean;
        getHighlightTip(arg0: Internal.ItemStack_, arg1: Internal.Component_): Internal.Component;
        canWalkOnPowderedSnow(arg0: Internal.ItemStack_, arg1: Internal.LivingEntity_): boolean;
        initializeClient(arg0: Internal.Consumer_<Internal.IItemRenderProperties_>): void;
        getMaxDamage(arg0: Internal.ItemStack_): number;
        getCreatorModId(arg0: Internal.ItemStack_): string;
        isDamaged(arg0: Internal.ItemStack_): boolean;
        onArmorTick(arg0: Internal.ItemStack_, arg1: Internal.Level_, arg2: Internal.Player_): void;
        hasContainerItem(arg0: Internal.ItemStack_): boolean;
        getFoodProperties(arg0: Internal.ItemStack_, arg1: Internal.LivingEntity_): Internal.FoodProperties;
        doesSneakBypassUse(arg0: Internal.ItemStack_, arg1: Internal.LevelReader_, arg2: BlockPos_, arg3: Internal.Player_): boolean;
        makePlaceable(arg0: Internal.Block_): void;
        onItemUseFirst(arg0: Internal.ItemStack_, arg1: Internal.UseOnContext_): Internal.InteractionResult;
        getContainerItem(arg0: Internal.ItemStack_): Internal.ItemStack;
        getRegistryName(): ResourceLocation;
        setRegistryName(arg0: ResourceLocation_): Internal.Item;
        setRegistryName(arg0: string): Internal.Item;
        setRegistryName(arg0: string, arg1: string): Internal.Item;
        onDestroyed(arg0: Internal.ItemEntity_, arg1: Internal.DamageSource_): void;
        isCorrectToolForDrops(arg0: Internal.ItemStack_, arg1: Internal.BlockState_): boolean;
        getEquipmentSlot(arg0: Internal.ItemStack_): EquipmentSlot;
        getItemStackLimit(arg0: Internal.ItemStack_): number;
        initCapabilities(arg0: Internal.ItemStack_, arg1: Internal.CompoundTag_): Internal.ICapabilityProvider;
        equals(arg0: any): boolean;
        makesPiglinsNeutral(arg0: Internal.ItemStack_, arg1: Internal.LivingEntity_): boolean;
        getTypeData(): Internal.CompoundTag;
        toString(): string;
        isEnderMask(arg0: Internal.ItemStack_, arg1: Internal.Player_, arg2: Internal.EnderMan_): boolean;
        canApplyAtEnchantingTable(arg0: Internal.ItemStack_, arg1: Internal.Enchantment_): boolean;
        readonly delegate : Internal.IRegistryDelegate<Internal.Item>;
        renderProperties : any;
        get registryType(): Internal.Class<Internal.Item>;
        get itemBuilderKJS(): Internal.ItemBuilder;
        get renderPropertiesInternal(): any;
        get placer(): Internal.BlockPlacerItem;
        get placeableBlock(): Internal.Block;
        get creativeTabs(): Internal.Collection<Internal.CreativeModeTab>;
        get id(): string;
        get registryName(): ResourceLocation;
        get typeData(): Internal.CompoundTag;
        get class(): Internal.Class<any>;
        set itemBuilderKJS(b: Internal.ItemBuilder_);
        set burnTime(i: number);
        set registryName(arg0: ResourceLocation_);
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    type Item_ = Item;
    class HideJEIEventJS <T> extends Internal.EventJS {
        cancel(): void;
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        isCancelled(): boolean;
        notifyAll(): void;
        getAllIngredients(): Internal.Collection<T>;
        notify(): void;
        hide(o: any): void;
        post(t: Internal.ScriptType_, id: string, sub: string): boolean;
        post(t: Internal.ScriptType_, id: string): boolean;
        hashCode(): number;
        equals(arg0: any): boolean;
        toString(): string;
        hideAll(): void;
        canCancel(): boolean;
        get allIngredients(): Internal.Collection<T>;
        get cancelled(): boolean;
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    type HideJEIEventJS_<T> = HideJEIEventJS<T>;
    class DropTargetEvent extends Internal.EventObject {
        getDropTargetContext(): Internal.DropTargetContext;
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        hashCode(): number;
        getSource(): any;
        notifyAll(): void;
        equals(arg0: any): boolean;
        toString(): string;
        notify(): void;
        get dropTargetContext(): Internal.DropTargetContext;
        get source(): any;
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    type DropTargetEvent_ = DropTargetEvent;
    interface Char2ShortFunction extends Internal.Function<string, number>, Internal.IntUnaryOperator {
        getOrDefault(arg0: any, arg1: number): number;
        getOrDefault(arg0: string, arg1: number): number;
        andThenShort(arg0: Internal.Short2ShortFunction_): Internal.Char2ShortFunction;
        composeByte(arg0: Internal.Byte2CharFunction_): Internal.Byte2ShortFunction;
        andThenInt(arg0: Internal.Short2IntFunction_): Internal.Char2IntFunction;
        composeReference<T_>(arg0: Internal.Reference2CharFunction_<T_>): Internal.Reference2ShortFunction<T_>;
        andThen<T_>(arg0: java_.util.function_.Function_<number, T_>): java_.util.function_.Function<string, T_>;
        andThen(arg0: Internal.IntUnaryOperator_): Internal.IntUnaryOperator;
        put(arg0: string, arg1: number): number;
        remove(arg0: string): number;
        remove(arg0: any): number;
        defaultReturnValue(): number;
        defaultReturnValue(arg0: number): void;
        andThenDouble(arg0: Internal.Short2DoubleFunction_): Internal.Char2DoubleFunction;
        andThenObject<T_>(arg0: Internal.Short2ObjectFunction_<T_>): Internal.Char2ObjectFunction<T_>;
        get(arg0: any): number;
        get(arg0: string): number;
        andThenLong(arg0: Internal.Short2LongFunction_): Internal.Char2LongFunction;
        composeLong(arg0: Internal.Long2CharFunction_): Internal.Long2ShortFunction;
        andThenByte(arg0: Internal.Short2ByteFunction_): Internal.Char2ByteFunction;
        andThenFloat(arg0: Internal.Short2FloatFunction_): Internal.Char2FloatFunction;
        applyAsInt(arg0: number): number;
        apply(arg0: string): number;
        containsKey(arg0: any): boolean;
        containsKey(arg0: string): boolean;
        composeInt(arg0: Internal.Int2CharFunction_): Internal.Int2ShortFunction;
        clear(): void;
        composeFloat(arg0: Internal.Float2CharFunction_): Internal.Float2ShortFunction;
        andThenChar(arg0: Internal.Short2CharFunction_): Internal.Char2CharFunction;
        composeObject<T_>(arg0: Internal.Object2CharFunction_<T_>): Internal.Object2ShortFunction<T_>;
        size(): number;
        compose<T_>(arg0: java_.util.function_.Function_<T_, string>): java_.util.function_.Function<T_, number>;
        compose(arg0: Internal.IntUnaryOperator_): Internal.IntUnaryOperator;
        composeShort(arg0: Internal.Short2CharFunction_): Internal.Short2ShortFunction;
        andThenReference<T_>(arg0: Internal.Short2ReferenceFunction_<T_>): Internal.Char2ReferenceFunction<T_>;
        composeChar(arg0: Internal.Char2CharFunction_): Internal.Char2ShortFunction;
        composeDouble(arg0: Internal.Double2CharFunction_): Internal.Double2ShortFunction;
    }
    type Char2ShortFunction_ = ((arg0: string) => number) | Char2ShortFunction;
    class AccessibleObject implements Internal.AnnotatedElement {
        trySetAccessible(): boolean;
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        isAccessible(): boolean;
        setAccessible(arg0: boolean): void;
        static setAccessible(arg0: Internal.AccessibleObject_[], arg1: boolean): void;
        isAnnotationPresent(arg0: Internal.Class_<Internal.Annotation_>): boolean;
        notifyAll(): void;
        getAnnotations(): Internal.Annotation[];
        notify(): void;
        getDeclaredAnnotations(): Internal.Annotation[];
        getAnnotationsByType<T_>(arg0: Internal.Class_<T_>): T_[];
        getDeclaredAnnotationsByType<T_>(arg0: Internal.Class_<T_>): T_[];
        getAnnotation<T_>(arg0: Internal.Class_<T_>): T_;
        hashCode(): number;
        equals(arg0: any): boolean;
        canAccess(arg0: any): boolean;
        getDeclaredAnnotation<T_>(arg0: Internal.Class_<T_>): T_;
        toString(): string;
        get accessible(): boolean;
        get declaredAnnotations(): Internal.Annotation[];
        get annotations(): Internal.Annotation[];
        get class(): Internal.Class<any>;
        set accessible(arg0: boolean);
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    type AccessibleObject_ = AccessibleObject;
    class LootPoolBuilder implements Internal.LootConditionsContainer<Internal.LootPoolBuilder>, Internal.LootFunctionsContainer<Internal.LootPoolBuilder>, Internal.LootActionsContainer<Internal.LootPoolBuilder> {
        killerPredicate(arg0: Internal.Predicate_<Internal.Entity_>): Internal.LootPoolBuilder;
        getClass(): Internal.Class<any>;
        functions(arg0: ItemFilter_, arg1: Internal.Consumer_<Internal.LootFunctionsContainer_<Internal.LootPoolBuilder_>>): Internal.LootPoolBuilder;
        triggerExplosion(arg0: number, arg1: boolean, arg2: boolean): Internal.LootPoolBuilder;
        addAttributes(arg0: Internal.Consumer_<Internal.AddAttributesFunction$Builder_>): Internal.LootPoolBuilder;
        createConditions(arg0: Internal.Consumer_<Internal.LootConditionsContainer_<Internal.LootPoolBuilder_>>): Internal.List<Internal.ILootCondition>;
        addCondition(arg0: Internal.ILootCondition_): Internal.LootPoolBuilder;
        addCondition(arg0: Internal.LootItemCondition$Builder_): Internal.LootPoolBuilder;
        applyBinomialDistributionBonus(arg0: Internal.Enchantment_, arg1: number, arg2: number): Internal.LootPoolBuilder;
        directKillerPredicate(arg0: Internal.Predicate_<Internal.Entity_>): Internal.LootPoolBuilder;
        applyOreBonus(arg0: Internal.Enchantment_): Internal.LootPoolBuilder;
        matchLoot(arg0: ItemFilter_): Internal.LootPoolBuilder;
        matchLoot(arg0: ItemFilter_, arg1: boolean): Internal.LootPoolBuilder;
        anyBiome(arg0: Internal.Resolver_[]): Internal.LootPoolBuilder;
        entityPredicate(arg0: Internal.Predicate_<Internal.Entity_>): Internal.LootPoolBuilder;
        smeltLoot(): Internal.LootPoolBuilder;
        simulateExplosionDecay(): Internal.LootPoolBuilder;
        addWeightedLoot(arg0: any_[]): Internal.LootPoolBuilder;
        addWeightedLoot(arg0: Internal.NumberProvider_, arg1: boolean, arg2: any_[]): Internal.LootPoolBuilder;
        addWeightedLoot(arg0: Internal.NumberProvider_, arg1: any_[]): Internal.LootPoolBuilder;
        anyDimension(arg0: ResourceLocation_[]): Internal.LootPoolBuilder;
        killedByPlayer(): Internal.LootPoolBuilder;
        addFunction(arg0: Internal.LootItemFunction$Builder_): Internal.LootPoolBuilder;
        matchOffHand(arg0: ItemFilter_): Internal.LootPoolBuilder;
        randomChance(arg0: number): Internal.LootPoolBuilder;
        timeCheck(arg0: number, arg1: number, arg2: number): Internal.LootPoolBuilder;
        timeCheck(arg0: number, arg1: number): Internal.LootPoolBuilder;
        limitCount(arg0: Internal.NumberProvider_, arg1: Internal.NumberProvider_): Internal.LootPoolBuilder;
        weatherCheck(arg0: Internal.Map_<string, boolean>): Internal.LootPoolBuilder;
        matchDirectKiller(arg0: Internal.Consumer_<Internal.EntityPredicateBuilderJS_>): Internal.LootPoolBuilder;
        addLore(arg0: Internal.Component_[]): Internal.LootPoolBuilder;
        modifyLoot(arg0: ItemFilter_, arg1: Internal.ModifyLootAction$Callback_): Internal.LootPoolBuilder;
        customCondition(arg0: Internal.JsonObject_): Internal.LootPoolBuilder;
        biome(arg0: Internal.Resolver_[]): Internal.LootPoolBuilder;
        randomChanceWithLooting(arg0: number, arg1: number): Internal.LootPoolBuilder;
        removeLoot(arg0: ItemFilter_): Internal.LootPoolBuilder;
        addPotion(arg0: Internal.Potion_): Internal.LootPoolBuilder;
        enchantRandomly(): Internal.LootPoolBuilder;
        enchantRandomly(arg0: Internal.Enchantment_[]): Internal.LootPoolBuilder;
        anyStructure(arg0: ResourceLocation_[], arg1: boolean): Internal.LootPoolBuilder;
        matchDamageSource(arg0: Internal.Consumer_<Internal.DamageSourcePredicateBuilderJS_>): Internal.LootPoolBuilder;
        setName(arg0: Internal.Component_): Internal.LootPoolBuilder;
        enchantWithLevels(arg0: Internal.NumberProvider_): Internal.LootPoolBuilder;
        enchantWithLevels(arg0: Internal.NumberProvider_, arg1: boolean): Internal.LootPoolBuilder;
        damage(arg0: Internal.NumberProvider_): Internal.LootPoolBuilder;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        survivesExplosion(): Internal.LootPoolBuilder;
        notifyAll(): void;
        matchFluid(arg0: Internal.Resolver_): Internal.LootPoolBuilder;
        customDistanceToPlayer(arg0: Internal.Consumer_<Internal.DistancePredicateBuilder_>): Internal.LootPoolBuilder;
        notify(): void;
        addAction(arg0: Internal.ILootAction_): Internal.LootPoolBuilder;
        not(arg0: Internal.Consumer_<Internal.LootConditionsContainer_<Internal.LootPoolBuilder_>>): Internal.LootPoolBuilder;
        matchEquip(arg0: EquipmentSlot_, arg1: ItemFilter_): Internal.LootPoolBuilder;
        and(arg0: Internal.Consumer_<Internal.LootConditionsContainer_<Internal.LootPoolBuilder_>>): Internal.LootPoolBuilder;
        hashCode(): number;
        distanceToKiller(arg0: Internal.MinMaxBounds$Doubles_): Internal.LootPoolBuilder;
        replaceLoot(arg0: ItemFilter_, arg1: Internal.ItemStack_): Internal.LootPoolBuilder;
        applyLootingBonus(arg0: Internal.NumberProvider_): Internal.LootPoolBuilder;
        matchEntity(arg0: Internal.Consumer_<Internal.EntityPredicateBuilderJS_>): Internal.LootPoolBuilder;
        or(arg0: Internal.Consumer_<Internal.LootConditionsContainer_<Internal.LootPoolBuilder_>>): Internal.LootPoolBuilder;
        playerPredicate(arg0: Internal.Predicate_<Internal.ServerPlayer_>): Internal.LootPoolBuilder;
        triggerLightningStrike(arg0: boolean): Internal.LootPoolBuilder;
        applyBonus(arg0: Internal.Enchantment_, arg1: number): Internal.LootPoolBuilder;
        addNBT(arg0: Internal.CompoundTag_): Internal.LootPoolBuilder;
        addNbt(arg0: Internal.CompoundTag_): Internal.LootPoolBuilder;
        replaceLore(arg0: Internal.Component_[]): Internal.LootPoolBuilder;
        rolls(arg0: Internal.NumberProvider_): Internal.LootPoolBuilder;
        matchBlockState(arg0: Internal.Block_, arg1: Internal.Map_<string, string>): Internal.LootPoolBuilder;
        addLoot(arg0: Internal.ItemStack_[]): Internal.LootPoolBuilder;
        matchMainHand(arg0: ItemFilter_): Internal.LootPoolBuilder;
        matchPlayer(arg0: Internal.Consumer_<Internal.EntityPredicateBuilderJS_>): Internal.LootPoolBuilder;
        lightLevel(arg0: number, arg1: number): Internal.LootPoolBuilder;
        build(): Internal.LootPoolAction;
        equals(arg0: any): boolean;
        matchKiller(arg0: Internal.Consumer_<Internal.EntityPredicateBuilderJS_>): Internal.LootPoolBuilder;
        hasAnyStage(arg0: string[]): Internal.LootPoolBuilder;
        toString(): string;
        randomChanceWithEnchantment(arg0: Internal.Enchantment_, arg1: number[]): Internal.LootPoolBuilder;
        get class(): Internal.Class<any>;
        set name(arg0: Internal.Component_);
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    type LootPoolBuilder_ = LootPoolBuilder;
    abstract class FileChannel extends Internal.AbstractInterruptibleChannel implements Internal.SeekableByteChannel, Internal.GatheringByteChannel, Internal.ScatteringByteChannel {
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        transferFrom(arg0: Internal.ReadableByteChannel_, arg1: number, arg2: number): number;
        read(arg0: Internal.ByteBuffer_): number;
        read(arg0: Internal.ByteBuffer_, arg1: number): number;
        read(arg0: Internal.ByteBuffer_[]): number;
        read(arg0: Internal.ByteBuffer_[], arg1: number, arg2: number): number;
        notifyAll(): void;
        transferTo(arg0: number, arg1: number, arg2: Internal.WritableByteChannel_): number;
        notify(): void;
        tryLock(arg0: number, arg1: number, arg2: boolean): Internal.FileLock;
        tryLock(): Internal.FileLock;
        isOpen(): boolean;
        truncate(arg0: number): Internal.FileChannel;
        size(): number;
        hashCode(): number;
        equals(arg0: any): boolean;
        lock(): Internal.FileLock;
        lock(arg0: number, arg1: number, arg2: boolean): Internal.FileLock;
        toString(): string;
        force(arg0: boolean): void;
        position(arg0: number): Internal.FileChannel;
        position(): number;
        close(): void;
        write(arg0: Internal.ByteBuffer_, arg1: number): number;
        write(arg0: Internal.ByteBuffer_): number;
        write(arg0: Internal.ByteBuffer_[], arg1: number, arg2: number): number;
        write(arg0: Internal.ByteBuffer_[]): number;
        map(arg0: Internal.FileChannel$MapMode_, arg1: number, arg2: number): Internal.MappedByteBuffer;
        static open(arg0: Internal.Path_, arg1: Internal.Set_<Internal.OpenOption_>, arg2: any_<any>[]): Internal.FileChannel;
        static open(arg0: Internal.Path_, arg1: Internal.OpenOption_[]): Internal.FileChannel;
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    type FileChannel_ = FileChannel;
    interface DragGestureListener extends Internal.EventListener {
        dragGestureRecognized(arg0: Internal.DragGestureEvent_): void;
    }
    type DragGestureListener_ = DragGestureListener;
    class Products$P12 <F, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12> {
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        apply<R>(arg0: Internal.Applicative_<F, any>, arg1: Internal.Function12_<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, R>): Internal.App<F, R>;
        apply<R>(arg0: Internal.Applicative_<F, any>, arg1: Internal.App_<F, Internal.Function12_<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, R>>): Internal.App<F, R>;
        hashCode(): number;
        notifyAll(): void;
        equals(arg0: any): boolean;
        toString(): string;
        notify(): void;
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    type Products$P12_<F, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12> = Products$P12<F, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12>;
    interface Long2DoubleFunction extends Internal.Function<number, number>, Internal.LongToDoubleFunction {
        getOrDefault(arg0: any, arg1: number): number;
        getOrDefault(arg0: number, arg1: number): number;
        applyAsDouble(arg0: number): number;
        andThenShort(arg0: Internal.Double2ShortFunction_): Internal.Long2ShortFunction;
        composeByte(arg0: Internal.Byte2LongFunction_): Internal.Byte2DoubleFunction;
        andThenInt(arg0: Internal.Double2IntFunction_): Internal.Long2IntFunction;
        composeReference<T_>(arg0: Internal.Reference2LongFunction_<T_>): Internal.Reference2DoubleFunction<T_>;
        andThen<T_>(arg0: java_.util.function_.Function_<number, T_>): java_.util.function_.Function<number, T_>;
        put(arg0: number, arg1: number): number;
        remove(arg0: number): number;
        remove(arg0: any): number;
        defaultReturnValue(): number;
        defaultReturnValue(arg0: number): void;
        andThenDouble(arg0: Internal.Double2DoubleFunction_): Internal.Long2DoubleFunction;
        andThenObject<T_>(arg0: Internal.Double2ObjectFunction_<T_>): Internal.Long2ObjectFunction<T_>;
        get(arg0: any): number;
        get(arg0: number): number;
        andThenLong(arg0: Internal.Double2LongFunction_): Internal.Long2LongFunction;
        composeLong(arg0: Internal.Long2LongFunction_): Internal.Long2DoubleFunction;
        andThenByte(arg0: Internal.Double2ByteFunction_): Internal.Long2ByteFunction;
        andThenFloat(arg0: Internal.Double2FloatFunction_): Internal.Long2FloatFunction;
        apply(arg0: number): number;
        containsKey(arg0: any): boolean;
        containsKey(arg0: number): boolean;
        composeInt(arg0: Internal.Int2LongFunction_): Internal.Int2DoubleFunction;
        clear(): void;
        composeFloat(arg0: Internal.Float2LongFunction_): Internal.Float2DoubleFunction;
        andThenChar(arg0: Internal.Double2CharFunction_): Internal.Long2CharFunction;
        composeObject<T_>(arg0: Internal.Object2LongFunction_<T_>): Internal.Object2DoubleFunction<T_>;
        size(): number;
        compose<T_>(arg0: java_.util.function_.Function_<T_, number>): java_.util.function_.Function<T_, number>;
        composeShort(arg0: Internal.Short2LongFunction_): Internal.Short2DoubleFunction;
        andThenReference<T_>(arg0: Internal.Double2ReferenceFunction_<T_>): Internal.Long2ReferenceFunction<T_>;
        composeChar(arg0: Internal.Char2LongFunction_): Internal.Char2DoubleFunction;
        composeDouble(arg0: Internal.Double2LongFunction_): Internal.Double2DoubleFunction;
    }
    type Long2DoubleFunction_ = ((arg0: number) => number) | Long2DoubleFunction;
    interface FloatIterator extends Internal.PrimitiveIterator<number, Internal.FloatConsumer> {
        nextFloat(): number;
        next(): number;
        hasNext(): boolean;
        skip(arg0: number): number;
        forEachRemaining(arg0: java_.util.function_.DoubleConsumer_): void;
        forEachRemaining(arg0: Internal.FloatConsumer_): void;
        forEachRemaining(arg0: Internal.Consumer_<number>): void;
        remove(): void;
    }
    type FloatIterator_ = FloatIterator;
    interface AnnotatedElement {
        getAnnotationsByType<T>(arg0: Internal.Class_<T>): T[];
        getDeclaredAnnotationsByType<T>(arg0: Internal.Class_<T>): T[];
        getAnnotation<T>(arg0: Internal.Class_<T>): T;
        isAnnotationPresent(arg0: Internal.Class_<Internal.Annotation_>): boolean;
        getDeclaredAnnotation<T>(arg0: Internal.Class_<T>): T;
        getAnnotations(): Internal.Annotation[];
        getDeclaredAnnotations(): Internal.Annotation[];
    }
    type AnnotatedElement_ = AnnotatedElement;
    class Frustum$Visibility extends Internal.Enum<Internal.Frustum$Visibility> {
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        static valueOf(name: string): Internal.Frustum$Visibility;
        static valueOf<T_>(arg0: Internal.Class_<T_>, arg1: string): T_;
        notifyAll(): void;
        static values(): Internal.Frustum$Visibility[];
        compareTo(arg0: Internal.Frustum$Visibility_): number;
        describeConstable(): Internal.Optional<Internal.Enum$EnumDesc<Internal.Frustum$Visibility>>;
        notify(): void;
        getDeclaringClass(): Internal.Class<Internal.Frustum$Visibility>;
        hashCode(): number;
        equals(arg0: any): boolean;
        name(): string;
        toString(): string;
        ordinal(): number;
        static readonly OUTSIDE : Internal.Frustum$Visibility;
        static readonly INTERSECT : Internal.Frustum$Visibility;
        static readonly INSIDE : Internal.Frustum$Visibility;
        get class(): Internal.Class<any>;
        get declaringClass(): Internal.Class<Internal.Frustum$Visibility>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    type Frustum$Visibility_ = "intersect" | "outside" | "inside" | Frustum$Visibility;
    interface Float2IntFunction extends Internal.Function<number, number>, Internal.DoubleToIntFunction {
        getOrDefault(arg0: any, arg1: number): number;
        getOrDefault(arg0: number, arg1: number): number;
        andThenShort(arg0: Internal.Int2ShortFunction_): Internal.Float2ShortFunction;
        composeByte(arg0: Internal.Byte2FloatFunction_): Internal.Byte2IntFunction;
        andThenInt(arg0: Internal.Int2IntFunction_): Internal.Float2IntFunction;
        composeReference<T_>(arg0: Internal.Reference2FloatFunction_<T_>): Internal.Reference2IntFunction<T_>;
        andThen<T_>(arg0: java_.util.function_.Function_<number, T_>): java_.util.function_.Function<number, T_>;
        put(arg0: number, arg1: number): number;
        remove(arg0: number): number;
        remove(arg0: any): number;
        defaultReturnValue(): number;
        defaultReturnValue(arg0: number): void;
        andThenDouble(arg0: Internal.Int2DoubleFunction_): Internal.Float2DoubleFunction;
        andThenObject<T_>(arg0: Internal.Int2ObjectFunction_<T_>): Internal.Float2ObjectFunction<T_>;
        get(arg0: any): number;
        get(arg0: number): number;
        andThenLong(arg0: Internal.Int2LongFunction_): Internal.Float2LongFunction;
        composeLong(arg0: Internal.Long2FloatFunction_): Internal.Long2IntFunction;
        andThenByte(arg0: Internal.Int2ByteFunction_): Internal.Float2ByteFunction;
        andThenFloat(arg0: Internal.Int2FloatFunction_): Internal.Float2FloatFunction;
        applyAsInt(arg0: number): number;
        apply(arg0: number): number;
        containsKey(arg0: any): boolean;
        containsKey(arg0: number): boolean;
        composeInt(arg0: Internal.Int2FloatFunction_): Internal.Int2IntFunction;
        clear(): void;
        composeFloat(arg0: Internal.Float2FloatFunction_): Internal.Float2IntFunction;
        andThenChar(arg0: Internal.Int2CharFunction_): Internal.Float2CharFunction;
        composeObject<T_>(arg0: Internal.Object2FloatFunction_<T_>): Internal.Object2IntFunction<T_>;
        size(): number;
        compose<T_>(arg0: java_.util.function_.Function_<T_, number>): java_.util.function_.Function<T_, number>;
        composeShort(arg0: Internal.Short2FloatFunction_): Internal.Short2IntFunction;
        andThenReference<T_>(arg0: Internal.Int2ReferenceFunction_<T_>): Internal.Float2ReferenceFunction<T_>;
        composeChar(arg0: Internal.Char2FloatFunction_): Internal.Char2IntFunction;
        composeDouble(arg0: Internal.Double2FloatFunction_): Internal.Double2IntFunction;
    }
    type Float2IntFunction_ = ((arg0: number) => number) | Float2IntFunction;
    /**
    */
    class ArmorItemBuilder$Leggings extends Internal.ArmorItemBuilder {
        barWidth(barWidth: Internal.ToIntFunction_<Internal.ItemStackJS_>): Internal.ItemBuilder;
        getClass(): Internal.Class<any>;
        maxStackSize(v: number): Internal.ItemBuilder;
        translationKey(key: string): Internal.BuilderBase<Internal.Item>;
        newID(pre: string, post: string): ResourceLocation;
        use(use: Internal.ItemBuilder$UseCallback_): Internal.ItemBuilder;
        maxDamage(v: number): Internal.ItemBuilder;
        textureJson(json: Internal.JsonObject_): Internal.ItemBuilder;
        tooltip(text: Internal.Component_): Internal.ItemBuilder;
        modifyTier(callback: Internal.Consumer_<Internal.MutableArmorTier_>): Internal.ArmorItemBuilder;
        type(type: string): Internal.BuilderBase<Internal.Item>;
        containerItem(id: string): Internal.ItemBuilder;
        subtypes(fn: java_.util.function_.Function_<Internal.ItemStackJS_, Internal.Collection_<Internal.ItemStackJS_>>): Internal.ItemBuilder;
        modelJson(json: Internal.JsonObject_): Internal.ItemBuilder;
        burnTime(v: number): Internal.ItemBuilder;
        useDuration(useDuration: Internal.ToIntFunction_<Internal.ItemStackJS_>): Internal.ItemBuilder;
        tag(tag: ResourceLocation_): Internal.BuilderBase<Internal.Item>;
        parentModel(m: string): Internal.ItemBuilder;
        generateDataJsons(generator: Internal.DataJsonGenerator_): void;
        group(g: string): Internal.ItemBuilder;
        static ofArmorMaterial(o: any): Internal.ArmorMaterial;
        /**
        */
        modifyAttribute(attribute: net.minecraft.world.entity.ai.attributes.Attribute_, identifier: string, d: number, operation: Internal.AttributeModifier$Operation_): Internal.ItemBuilder;
        getRegistryType(): Internal.RegistryObjectBuilderTypes<Internal.Item>;
        glow(v: boolean): Internal.ItemBuilder;
        useAnimation(animation: Internal.UseAnim_): Internal.ItemBuilder;
        rarity(v: Rarity_): Internal.ItemBuilder;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        clientRegistry(minecraft: Internal.Minecraft_): void;
        transformObject(obj: Internal.Item_): Internal.Item;
        color(callback: Internal.ItemBuilder$ItemColorJS_): Internal.ItemBuilder;
        color(index: number, c: Internal.Color_): Internal.ItemBuilder;
        displayName(name: string): Internal.BuilderBase<Internal.Item>;
        notifyAll(): void;
        barColor(barColor: java_.util.function_.Function_<Internal.ItemStackJS_, Internal.Color_>): Internal.ItemBuilder;
        notify(): void;
        createAdditionalObjects(): void;
        tier(t: Internal.ArmorMaterial_): Internal.ArmorItemBuilder;
        hashCode(): number;
        get(): Internal.Item;
        generateAssetJsons(generator: Internal.AssetJsonGenerator_): void;
        getTranslationKeyGroup(): string;
        texture(key: string, tex: string): Internal.ItemBuilder;
        texture(tex: string): Internal.ItemBuilder;
        generateLang(lang: Internal.Map_<string, string>): void;
        food(b: Internal.Consumer_<Internal.FoodBuilder_>): Internal.ItemBuilder;
        createObject(): Internal.Item;
        releaseUsing(releaseUsing: Internal.ItemBuilder$ReleaseUsingCallback_): Internal.ItemBuilder;
        unstackable(): Internal.ItemBuilder;
        addResourcePackLocations(path: string, list: Internal.List_<ResourceLocation_>, packType: Internal.PackType_): void;
        equals(arg0: any): boolean;
        toString(): string;
        finishUsing(finishUsing: Internal.ItemBuilder$FinishUsingCallback_): Internal.ItemBuilder;
        createItemProperties(): Internal.Item$Properties;
        armorTier : Internal.MutableArmorTier;
        static readonly TOOL_TIERS : {"gold":any,"diamond":any,"iron":any,"wood":any,"stone":any,"netherite":any};
        static readonly ARMOR_TIERS : {"gold":any,"chain":any,"diamond":any,"turtle":any,"iron":any,"leather":any,"netherite":any};
        readonly equipmentSlot : EquipmentSlot;
        readonly id : ResourceLocation;
        get registryType(): Internal.RegistryObjectBuilderTypes<Internal.Item>;
        get class(): Internal.Class<any>;
        get translationKeyGroup(): string;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    /**
    */
    type ArmorItemBuilder$Leggings_ = ArmorItemBuilder$Leggings;
    interface WidgetUIAccess {
        writeUpdateInfo(arg0: com.lowdragmc.lowdraglib.gui.widget.Widget_, arg1: number, arg2: Internal.Consumer_<Internal.FriendlyByteBuf_>): void;
        notifySizeChange(): void;
        attemptMergeStack(arg0: Internal.ItemStack_, arg1: boolean, arg2: boolean): boolean;
        notifyWidgetChange(): void;
        writeClientAction(arg0: com.lowdragmc.lowdraglib.gui.widget.Widget_, arg1: number, arg2: Internal.Consumer_<Internal.FriendlyByteBuf_>): void;
    }
    type WidgetUIAccess_ = WidgetUIAccess;
    class JobAttributes implements Internal.Cloneable {
        getClass(): Internal.Class<any>;
        setSidesToDefault(): void;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        getDefaultSelection(): Internal.JobAttributes$DefaultSelectionType;
        getDestination(): Internal.JobAttributes$DestinationType;
        getMaxPage(): number;
        notifyAll(): void;
        setMultipleDocumentHandling(arg0: Internal.JobAttributes$MultipleDocumentHandlingType_): void;
        setSides(arg0: Internal.JobAttributes$SidesType_): void;
        getPageRanges(): number[][];
        setDestination(arg0: Internal.JobAttributes$DestinationType_): void;
        notify(): void;
        getMultipleDocumentHandling(): Internal.JobAttributes$MultipleDocumentHandlingType;
        getDialog(): Internal.JobAttributes$DialogType;
        setDefaultSelection(arg0: Internal.JobAttributes$DefaultSelectionType_): void;
        setFileName(arg0: string): void;
        setMultipleDocumentHandlingToDefault(): void;
        hashCode(): number;
        setCopies(arg0: number): void;
        setMinPage(arg0: number): void;
        setPageRanges(arg0: number[][]): void;
        setMaxPage(arg0: number): void;
        getFileName(): string;
        getCopies(): number;
        set(arg0: Internal.JobAttributes_): void;
        setPrinter(arg0: string): void;
        getSides(): Internal.JobAttributes$SidesType;
        getFromPage(): number;
        getToPage(): number;
        setDialog(arg0: Internal.JobAttributes$DialogType_): void;
        setToPage(arg0: number): void;
        getPrinter(): string;
        equals(arg0: any): boolean;
        clone(): any;
        setCopiesToDefault(): void;
        toString(): string;
        setFromPage(arg0: number): void;
        getMinPage(): number;
        get fileName(): string;
        get defaultSelection(): Internal.JobAttributes$DefaultSelectionType;
        get printer(): string;
        get destination(): Internal.JobAttributes$DestinationType;
        get minPage(): number;
        get multipleDocumentHandling(): Internal.JobAttributes$MultipleDocumentHandlingType;
        get pageRanges(): number[][];
        get dialog(): Internal.JobAttributes$DialogType;
        get copies(): number;
        get fromPage(): number;
        get sides(): Internal.JobAttributes$SidesType;
        get class(): Internal.Class<any>;
        get maxPage(): number;
        get toPage(): number;
        set pageRanges(arg0: number[][]);
        set dialog(arg0: Internal.JobAttributes$DialogType_);
        set fileName(arg0: string);
        set copies(arg0: number);
        set defaultSelection(arg0: Internal.JobAttributes$DefaultSelectionType_);
        set fromPage(arg0: number);
        set printer(arg0: string);
        set destination(arg0: Internal.JobAttributes$DestinationType_);
        set minPage(arg0: number);
        set sides(arg0: Internal.JobAttributes$SidesType_);
        set multipleDocumentHandling(arg0: Internal.JobAttributes$MultipleDocumentHandlingType_);
        set maxPage(arg0: number);
        set toPage(arg0: number);
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    type JobAttributes_ = JobAttributes;
    class HierarchyEvent extends Internal.AWTEvent {
        getClass(): Internal.Class<any>;
        setSource(arg0: any): void;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        getChangedParent(): Internal.Container;
        getChanged(): java_.awt.Component;
        notifyAll(): void;
        getID(): number;
        notify(): void;
        paramString(): string;
        getChangeFlags(): number;
        hashCode(): number;
        getSource(): any;
        equals(arg0: any): boolean;
        toString(): string;
        getComponent(): java_.awt.Component;
        static readonly ADJUSTMENT_EVENT_MASK : 256;
        static readonly MOUSE_EVENT_MASK : 16;
        static readonly HIERARCHY_FIRST : 1400;
        static readonly HIERARCHY_CHANGED : 1400;
        static readonly COMPONENT_EVENT_MASK : 1;
        static readonly PAINT_EVENT_MASK : 8192;
        static readonly INPUT_METHOD_EVENT_MASK : 2048;
        static readonly HIERARCHY_BOUNDS_EVENT_MASK : 65536;
        static readonly FOCUS_EVENT_MASK : 4;
        static readonly INVOCATION_EVENT_MASK : 16384;
        static readonly KEY_EVENT_MASK : 8;
        static readonly RESERVED_ID_MAX : 1999;
        static readonly CONTAINER_EVENT_MASK : 2;
        static readonly WINDOW_EVENT_MASK : 64;
        static readonly MOUSE_WHEEL_EVENT_MASK : 131072;
        static readonly MOUSE_MOTION_EVENT_MASK : 32;
        static readonly ANCESTOR_RESIZED : 1402;
        static readonly HIERARCHY_LAST : 1402;
        static readonly WINDOW_FOCUS_EVENT_MASK : 524288;
        static readonly PARENT_CHANGED : 1;
        static readonly TEXT_EVENT_MASK : 1024;
        static readonly SHOWING_CHANGED : 4;
        static readonly ACTION_EVENT_MASK : 128;
        static readonly ITEM_EVENT_MASK : 512;
        static readonly HIERARCHY_EVENT_MASK : 32768;
        static readonly ANCESTOR_MOVED : 1401;
        static readonly WINDOW_STATE_EVENT_MASK : 262144;
        static readonly DISPLAYABILITY_CHANGED : 2;
        get component(): java_.awt.Component;
        get changedParent(): Internal.Container;
        get changeFlags(): number;
        get iD(): number;
        get source(): any;
        get class(): Internal.Class<any>;
        get changed(): java_.awt.Component;
        set source(arg0: any);
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    type HierarchyEvent_ = HierarchyEvent;
    interface AutoCloseable {
        close(): void;
    }
    type AutoCloseable_ = AutoCloseable;
    interface FrustumAdapter {
        sodium$createFrustum(): Internal.Frustum;
    }
    type FrustumAdapter_ = FrustumAdapter;
    interface WrappedJS {
    }
    type WrappedJS_ = WrappedJS;
    class LevelResource {
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        hashCode(): number;
        notifyAll(): void;
        equals(arg0: any): boolean;
        toString(): string;
        notify(): void;
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    type LevelResource_ = LevelResource;
    interface ItemBuilder$FinishUsingCallback {
        finishUsingItem(arg0: Internal.ItemStackJS_, arg1: Internal.LevelJS_, arg2: Internal.LivingEntityJS_): Internal.ItemStackJS;
    }
    type ItemBuilder$FinishUsingCallback_ = ((arg0: Internal.ItemStackJS, arg1: Internal.LevelJS, arg2: Internal.LivingEntityJS) => Internal.ItemStackJS) | ItemBuilder$FinishUsingCallback;
    interface BlockBuilderProvider {
        getBlockBuilderKJS(): Internal.BlockBuilder;
    }
    type BlockBuilderProvider_ = BlockBuilderProvider;
    abstract class ImmutableMap <K, V> implements Internal.Map<K, V>, Internal.Serializable {
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        getOrDefault(arg0: any, arg1: V): V;
        static ofEntries<K_, V_>(arg0: Internal.Map$Entry_<K_, V_>[]): Internal.ImmutableMap<K_, V_>;
        notifyAll(): void;
        computeIfAbsent(arg0: K, arg1: java_.util.function_.Function_<K, V>): V;
        values(): Internal.ImmutableCollection<V>;
        replace(arg0: K, arg1: V, arg2: V): boolean;
        replace(arg0: K, arg1: V): V;
        replaceAll(arg0: Internal.BiFunction_<K, V, V>): void;
        notify(): void;
        containsValue(arg0: any): boolean;
        put(arg0: K, arg1: V): V;
        remove(arg0: any, arg1: any): boolean;
        remove(arg0: any): V;
        compute(arg0: K, arg1: Internal.BiFunction_<K, V, V>): V;
        static toImmutableMap<T_, K_, V_>(arg0: java_.util.function_.Function_<T_, K_>, arg1: java_.util.function_.Function_<T_, V_>, arg2: Internal.BinaryOperator_<V_>): Internal.Collector<T_, any, Internal.ImmutableMap<K_, V_>>;
        static toImmutableMap<T_, K_, V_>(arg0: java_.util.function_.Function_<T_, K_>, arg1: java_.util.function_.Function_<T_, V_>): Internal.Collector<T_, any, Internal.ImmutableMap<K_, V_>>;
        hashCode(): number;
        putAll(arg0: Internal.Map_<K, V>): void;
        merge(arg0: K, arg1: V, arg2: Internal.BiFunction_<V, V, V>): V;
        static of<K_, V_>(arg0: K_, arg1: V_, arg2: K_, arg3: V_, arg4: K_, arg5: V_, arg6: K_, arg7: V_): Internal.ImmutableMap<K_, V_>;
        static of<K_, V_>(): Internal.ImmutableMap<K_, V_>;
        static of<K_, V_>(arg0: K_, arg1: V_, arg2: K_, arg3: V_): Internal.ImmutableMap<K_, V_>;
        static of<K_, V_>(arg0: K_, arg1: V_, arg2: K_, arg3: V_, arg4: K_, arg5: V_): Internal.ImmutableMap<K_, V_>;
        static of<K_, V_>(arg0: K_, arg1: V_, arg2: K_, arg3: V_, arg4: K_, arg5: V_, arg6: K_, arg7: V_, arg8: K_, arg9: V_, arg10: K_, arg11: V_, arg12: K_, arg13: V_): Internal.ImmutableMap<K_, V_>;
        static of<K_, V_>(arg0: K_, arg1: V_): Internal.ImmutableMap<K_, V_>;
        static of<K_, V_>(arg0: K_, arg1: V_, arg2: K_, arg3: V_, arg4: K_, arg5: V_, arg6: K_, arg7: V_, arg8: K_, arg9: V_, arg10: K_, arg11: V_, arg12: K_, arg13: V_, arg14: K_, arg15: V_): Internal.ImmutableMap<K_, V_>;
        static of<K_, V_>(arg0: K_, arg1: V_, arg2: K_, arg3: V_, arg4: K_, arg5: V_, arg6: K_, arg7: V_, arg8: K_, arg9: V_, arg10: K_, arg11: V_, arg12: K_, arg13: V_, arg14: K_, arg15: V_, arg16: K_, arg17: V_, arg18: K_, arg19: V_): Internal.ImmutableMap<K_, V_>;
        static of<K_, V_>(arg0: K_, arg1: V_, arg2: K_, arg3: V_, arg4: K_, arg5: V_, arg6: K_, arg7: V_, arg8: K_, arg9: V_, arg10: K_, arg11: V_): Internal.ImmutableMap<K_, V_>;
        static of<K_, V_>(arg0: K_, arg1: V_, arg2: K_, arg3: V_, arg4: K_, arg5: V_, arg6: K_, arg7: V_, arg8: K_, arg9: V_): Internal.ImmutableMap<K_, V_>;
        static of<K_, V_>(arg0: K_, arg1: V_, arg2: K_, arg3: V_, arg4: K_, arg5: V_, arg6: K_, arg7: V_, arg8: K_, arg9: V_, arg10: K_, arg11: V_, arg12: K_, arg13: V_, arg14: K_, arg15: V_, arg16: K_, arg17: V_): Internal.ImmutableMap<K_, V_>;
        get(arg0: any): V;
        static builder<K_, V_>(): Internal.ImmutableMap$Builder<K_, V_>;
        keySet(): Internal.ImmutableSet<K>;
        entrySet(): Internal.ImmutableSet<Internal.Map$Entry<K, V>>;
        forEach(arg0: Internal.BiConsumer_<K, V>): void;
        containsKey(arg0: any): boolean;
        isEmpty(): boolean;
        clear(): void;
        static copyOf<K_, V_>(arg0: Internal.Iterable_<Internal.Map$Entry_<K_, V_>>): Internal.ImmutableMap<K_, V_>;
        static copyOf<K_, V_>(arg0: Internal.Map_<K_, V_>): Internal.ImmutableMap<K_, V_>;
        static builderWithExpectedSize<K_, V_>(arg0: number): Internal.ImmutableMap$Builder<K_, V_>;
        asMultimap(): Internal.ImmutableSetMultimap<K, V>;
        computeIfPresent(arg0: K, arg1: Internal.BiFunction_<K, V, V>): V;
        size(): number;
        equals(arg0: any): boolean;
        toString(): string;
        putIfAbsent(arg0: K, arg1: V): V;
        get class(): Internal.Class<any>;
        get empty(): boolean;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    type ImmutableMap_<K, V> = ImmutableMap<K, V>;
    class TypeWrappers {
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        hashCode(): number;
        notifyAll(): void;
        equals(arg0: any): boolean;
        toString(): string;
        notify(): void;
        getWrapperFactory(target: Internal.Class_<any>, from: any): Internal.TypeWrapperFactory<any>;
        register<T>(target: Internal.Class_<T>, factory: Internal.TypeWrapperFactory_<T>): void;
        register<T>(target: Internal.Class_<T>, validator: Internal.Predicate_<any>, factory: Internal.TypeWrapperFactory_<T>): void;
        register<F, T>(id: string, from: Internal.Class_<F>, to: Internal.Class_<T>, factory: java_.util.function_.Function_<F, T>): void;
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    type TypeWrappers_ = TypeWrappers;
    interface IForgeRegistry <V> extends Internal.Iterable<V> {
        getKey(arg0: V): ResourceLocation;
        getCodec(): Internal.Codec<V>;
        getRegistryKey(): Internal.ResourceKey<Internal.Registry<V>>;
        getValues(): Internal.Collection<V>;
        spliterator(): Internal.Spliterator<V>;
        forEach(arg0: Internal.Consumer_<V>): void;
        registerAll(arg0: V[]): void;
        containsKey(arg0: ResourceLocation_): boolean;
        getDefaultKey(): ResourceLocation;
        isEmpty(): boolean;
        getRegistryName(): ResourceLocation;
        getRegistrySuperType(): Internal.Class<V>;
        getKeys(): Internal.Set<ResourceLocation>;
        getSlaveMap<T_>(arg0: ResourceLocation_, arg1: Internal.Class_<T_>): T_;
        containsValue(arg0: V): boolean;
        tags(): Internal.ITagManager<V>;
        getResourceKey(arg0: V): Internal.Optional<Internal.ResourceKey<V>>;
        getValue(arg0: ResourceLocation_): V;
        iterator(): Internal.Iterator<V>;
        getEntries(): Internal.Set<Internal.Map$Entry<Internal.ResourceKey<V>, V>>;
        getHolder(arg0: ResourceLocation_): Internal.Optional<Internal.Holder<V>>;
        getHolder(arg0: V): Internal.Optional<Internal.Holder<V>>;
        getHolder(arg0: Internal.ResourceKey_<V>): Internal.Optional<Internal.Holder<V>>;
        register(arg0: V): void;
    }
    type IForgeRegistry_<V> = IForgeRegistry<V>;
    class ScriptFileInfo {
        getPackMode(): string;
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        getProperty(s: string, def: string): string;
        hashCode(): number;
        notifyAll(): void;
        equals(arg0: any): boolean;
        getPriority(): number;
        toString(): string;
        isIgnored(): boolean;
        preload(source: Internal.ScriptSource_): Internal.Throwable;
        notify(): void;
        readonly file : string;
        readonly location : string;
        readonly id : ResourceLocation;
        readonly pack : Internal.ScriptPackInfo;
        get ignored(): boolean;
        get packMode(): string;
        get priority(): number;
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    type ScriptFileInfo_ = ScriptFileInfo;
    interface RandomGenerator {
        nextFloat(): number;
        nextFloat(arg0: number): number;
        nextFloat(arg0: number, arg1: number): number;
        isDeprecated(): boolean;
        nextInt(arg0: number): number;
        nextInt(arg0: number, arg1: number): number;
        nextInt(): number;
        nextLong(arg0: number, arg1: number): number;
        nextLong(): number;
        nextLong(arg0: number): number;
        nextGaussian(arg0: number, arg1: number): number;
        nextGaussian(): number;
        nextDouble(arg0: number): number;
        nextDouble(): number;
        nextDouble(arg0: number, arg1: number): number;
        nextBytes(arg0: number[]): void;
        longs(arg0: number, arg1: number, arg2: number): Internal.LongStream;
        longs(arg0: number, arg1: number): Internal.LongStream;
        longs(): Internal.LongStream;
        longs(arg0: number): Internal.LongStream;
        nextExponential(): number;
        doubles(): Internal.DoubleStream;
        doubles(arg0: number, arg1: number, arg2: number): Internal.DoubleStream;
        doubles(arg0: number, arg1: number): Internal.DoubleStream;
        doubles(arg0: number): Internal.DoubleStream;
        ints(arg0: number, arg1: number): Internal.IntStream;
        ints(): Internal.IntStream;
        ints(arg0: number): Internal.IntStream;
        ints(arg0: number, arg1: number, arg2: number): Internal.IntStream;
        nextBoolean(): boolean;
    }
    type RandomGenerator_ = RandomGenerator;
    class InetAddress implements Internal.Serializable {
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        isMCOrgLocal(): boolean;
        notifyAll(): void;
        notify(): void;
        isMCLinkLocal(): boolean;
        isLoopbackAddress(): boolean;
        isSiteLocalAddress(): boolean;
        isMulticastAddress(): boolean;
        hashCode(): number;
        static getByName(arg0: string): Internal.InetAddress;
        static getLoopbackAddress(): Internal.InetAddress;
        getAddress(): number[];
        getHostAddress(): string;
        isMCNodeLocal(): boolean;
        isReachable(arg0: Internal.NetworkInterface_, arg1: number, arg2: number): boolean;
        isReachable(arg0: number): boolean;
        isMCSiteLocal(): boolean;
        static getAllByName(arg0: string): Internal.InetAddress[];
        isMCGlobal(): boolean;
        getHostName(): string;
        getCanonicalHostName(): string;
        isAnyLocalAddress(): boolean;
        isLinkLocalAddress(): boolean;
        static getLocalHost(): Internal.InetAddress;
        equals(arg0: any): boolean;
        static getByAddress(arg0: number[]): Internal.InetAddress;
        static getByAddress(arg0: string, arg1: number[]): Internal.InetAddress;
        toString(): string;
        get linkLocalAddress(): boolean;
        get loopbackAddress(): Internal.InetAddress;
        get hostName(): string;
        get address(): number[];
        get canonicalHostName(): string;
        get mCOrgLocal(): boolean;
        get siteLocalAddress(): boolean;
        get mCNodeLocal(): boolean;
        get mCGlobal(): boolean;
        get mCLinkLocal(): boolean;
        get multicastAddress(): boolean;
        get localHost(): Internal.InetAddress;
        get hostAddress(): string;
        get class(): Internal.Class<any>;
        get mCSiteLocal(): boolean;
        get anyLocalAddress(): boolean;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    type InetAddress_ = InetAddress;
    class DataJsonGenerator extends Internal.JsonGenerator {
        getClass(): Internal.Class<any>;
        getAllJsons(): Internal.Map<ResourceLocation, Internal.JsonElement>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        hashCode(): number;
        notifyAll(): void;
        equals(arg0: any): boolean;
        json(id: ResourceLocation_, json: Internal.JsonElement_): void;
        toString(): string;
        notify(): void;
        get class(): Internal.Class<any>;
        get allJsons(): Internal.Map<ResourceLocation, Internal.JsonElement>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    type DataJsonGenerator_ = DataJsonGenerator;
    class IdFunctionObject extends Internal.BaseFunction {
        getClass(): Internal.Class<any>;
        isSealed(): boolean;
        setParentScope(m: Internal.Scriptable_): void;
        static redefineProperty(obj: Internal.Scriptable_, name: string, isConst: boolean): void;
        putConst(name: string, start: Internal.Scriptable_, value: any): void;
        static getTypedProperty<T_>(s: Internal.Scriptable_, name: string, type: Internal.Class_<T_>): T_;
        static getTypedProperty<T_>(s: Internal.Scriptable_, index: number, type: Internal.Class_<T_>): T_;
        getIds(): any[];
        static getArrayPrototype(scope: Internal.Scriptable_): Internal.Scriptable;
        construct(cx: Internal.Context_, scope: Internal.Scriptable_, args: any[]): Internal.Scriptable;
        getAllIds(): any[];
        put(key: Internal.Symbol_, start: Internal.Scriptable_, value: any): void;
        put(name: string, start: Internal.Scriptable_, value: any): void;
        put(index: number, start: Internal.Scriptable_, value: any): void;
        getArity(): number;
        static getDefaultValue(object: Internal.Scriptable_, typeHint: Internal.Class_<any>): any;
        getDefaultValue(typeHint: Internal.Class_<any>): any;
        defineOwnProperties(cx: Internal.Context_, props: Internal.ScriptableObject_): void;
        defineProperty(key: Internal.Symbol_, value: any, attributes: number): void;
        defineProperty(propertyName: string, clazz: Internal.Class_<any>, attributes: number): void;
        defineProperty(propertyName: string, delegateTo: any, getter: Internal.Method_, setter: Internal.Method_, attributes: number): void;
        defineProperty(propertyName: string, value: any, attributes: number): void;
        static defineProperty(destination: Internal.Scriptable_, propertyName: string, value: any, attributes: number): void;
        hasPrototypeMap(): boolean;
        setGetterOrSetter(name: string, index: number, getterOrSetter: Internal.Callable_, isSetter: boolean): void;
        avoidObjectDetection(): boolean;
        has(key: Internal.Symbol_, start: Internal.Scriptable_): boolean;
        has(name: string, start: Internal.Scriptable_): boolean;
        has(index: number, start: Internal.Scriptable_): boolean;
        getFunctionName(): string;
        getExternalArrayLength(): any;
        getAttributes(name: string): number;
        getAttributes(key: Internal.Symbol_): number;
        getAttributes(index: number): number;
        setImmunePrototypeProperty(value: any): void;
        hasInstance(instance: Internal.Scriptable_): boolean;
        hasTag(tag: any): boolean;
        getAssociatedValue(key: any): any;
        execIdCall(f: Internal.IdFunctionObject_, cx: Internal.Context_, scope: Internal.Scriptable_, thisObj: Internal.Scriptable_, args: any[]): any;
        static getPropertyIds(obj: Internal.Scriptable_): any[];
        static hasProperty(obj: Internal.Scriptable_, name: string): boolean;
        static hasProperty(obj: Internal.Scriptable_, key: Internal.Symbol_): boolean;
        static hasProperty(obj: Internal.Scriptable_, index: number): boolean;
        getExternalArrayData(): Internal.ExternalArrayData;
        size(): number;
        initPrototypeMethod(tag: any, id: number, propertyName: string, functionName: string, arity: number): Internal.IdFunctionObject;
        initPrototypeMethod(tag: any, id: number, key: Internal.Symbol_, functionName: string, arity: number): Internal.IdFunctionObject;
        initPrototypeMethod(tag: any, id: number, name: string, arity: number): Internal.IdFunctionObject;
        defineOwnProperty(cx: Internal.Context_, key: any, desc: Internal.ScriptableObject_): void;
        initPrototypeValue(id: number, name: string, value: any, attributes: number): void;
        initPrototypeValue(id: number, key: Internal.Symbol_, value: any, attributes: number): void;
        static getFunctionPrototype(scope: Internal.Scriptable_): Internal.Scriptable;
        getClassName(): string;
        getParentScope(): Internal.Scriptable;
        preventExtensions(): void;
        setExternalArrayData(array: Internal.ExternalArrayData_): void;
        static callMethod(cx: Internal.Context_, obj: Internal.Scriptable_, methodName: string, args: any[]): any;
        static callMethod(obj: Internal.Scriptable_, methodName: string, args: any[]): any;
        enumerationIteratorNext(cx: Internal.Context_, currentId: Internal.Consumer_<any>): boolean;
        getTypeOf(): string;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        addAsProperty(target: Internal.Scriptable_): void;
        static getTopScopeValue(scope: Internal.Scriptable_, key: any): any;
        initPrototypeConstructor(f: Internal.IdFunctionObject_): void;
        notifyAll(): void;
        methodId(): number;
        sealObject(): void;
        setAttributes(name: string, attributes: number): void;
        setAttributes(key: Internal.Symbol_, attributes: number): void;
        setAttributes(index: number, attributes: number): void;
        static putProperty(obj: Internal.Scriptable_, name: string, value: any): void;
        static putProperty(obj: Internal.Scriptable_, index: number, value: any): void;
        static putProperty(obj: Internal.Scriptable_, key: Internal.Symbol_, value: any): void;
        delete(key: Internal.Symbol_): void;
        delete(name: string): void;
        delete(index: number): void;
        notify(): void;
        associateValue(key: any, value: any): any;
        static deleteProperty(obj: Internal.Scriptable_, name: string): boolean;
        static deleteProperty(obj: Internal.Scriptable_, index: number): boolean;
        unknown(): Internal.RuntimeException;
        getPrototype(): Internal.Scriptable;
        static getObjectPrototype(scope: Internal.Scriptable_): Internal.Scriptable;
        isExtensible(): boolean;
        markAsConstructor(prototypeProperty: Internal.Scriptable_): void;
        exportAsScopeProperty(): void;
        hashCode(): number;
        isConst(name: string): boolean;
        get(name: string, start: Internal.Scriptable_): any;
        get(key: Internal.Symbol_, start: Internal.Scriptable_): any;
        get(index: number, start: Internal.Scriptable_): any;
        get(key: any): any;
        static putConstProperty(obj: Internal.Scriptable_, name: string, value: any): void;
        getGetterOrSetter(name: string, index: number, isSetter: boolean): any;
        static getTopLevelScope(obj: Internal.Scriptable_): Internal.Scriptable;
        static getProperty(obj: Internal.Scriptable_, name: string): any;
        static getProperty(obj: Internal.Scriptable_, key: Internal.Symbol_): any;
        static getProperty(obj: Internal.Scriptable_, index: number): any;
        static defineClass<T_>(scope: Internal.Scriptable_, clazz: Internal.Class_<T_>, sealed: boolean): void;
        static defineClass<T_>(scope: Internal.Scriptable_, clazz: Internal.Class_<T_>): void;
        static defineClass<T_>(scope: Internal.Scriptable_, clazz: Internal.Class_<T_>, sealed: boolean, mapInheritance: boolean): string;
        initFunction(name: string, scope: Internal.Scriptable_): void;
        activatePrototypeMap(maxPrototypeId: number): void;
        isEmpty(): boolean;
        defineFunctionProperties(names: string[], clazz: Internal.Class_<any>, attributes: number): void;
        getTag(): any;
        static getClassPrototype(scope: Internal.Scriptable_, className: string): Internal.Scriptable;
        createObject(cx: Internal.Context_, scope: Internal.Scriptable_): Internal.Scriptable;
        setPrototype(m: Internal.Scriptable_): void;
        exportAsJSClass(maxPrototypeId: number, scope: Internal.Scriptable_, sealed: boolean): Internal.IdFunctionObject;
        call(cx: Internal.Context_, scope: Internal.Scriptable_, thisObj: Internal.Scriptable_, args: any[]): any;
        defineConst(name: string, start: Internal.Scriptable_): void;
        equals(arg0: any): boolean;
        static defineConstProperty(destination: Internal.Scriptable_, propertyName: string): void;
        getLength(): number;
        toString(): string;
        enumerationIteratorHasNext(cx: Internal.Context_, currentId: Internal.Consumer_<any>): boolean;
        static getGeneratorFunctionPrototype(scope: Internal.Scriptable_): Internal.Scriptable;
        static readonly DONTENUM : 2;
        static readonly CONST : 13;
        static readonly NOT_FOUND : any;
        static readonly UNINITIALIZED_CONST : 8;
        static readonly EMPTY : 0;
        static readonly READONLY : 1;
        static readonly PERMANENT : 4;
        get functionName(): string;
        get sealed(): boolean;
        get externalArrayData(): Internal.ExternalArrayData;
        get length(): number;
        get className(): string;
        get prototype(): Internal.Scriptable;
        get empty(): boolean;
        get arity(): number;
        get parentScope(): Internal.Scriptable;
        get ids(): any[];
        get externalArrayLength(): any;
        get tag(): any;
        get class(): Internal.Class<any>;
        get allIds(): any[];
        get extensible(): boolean;
        get typeOf(): string;
        set immunePrototypeProperty(value: any);
        set externalArrayData(array: Internal.ExternalArrayData_);
        set parentScope(m: Internal.Scriptable_);
        set prototype(m: Internal.Scriptable_);
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    type IdFunctionObject_ = IdFunctionObject;
    class ServerLevel extends Internal.Level implements Internal.WorldGenLevel, Internal.DuneCache, Internal.ILevelEventRedirect {
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        getCapability<T_>(arg0: Internal.Capability_<T_>, arg1: Internal.Direction_): Internal.LazyOptional<T_>;
        getCapability<T_>(arg0: Internal.Capability_<T_>): Internal.LazyOptional<T_>;
        notifyAll(): void;
        addFreshBlockEntities(arg0: Internal.Collection_<Internal.BlockEntity_>): void;
        notify(): void;
        removePlayer(arg0: Internal.ServerPlayer_, arg1: boolean): void;
        markAndNotifyBlock(arg0: BlockPos_, arg1: Internal.LevelChunk_, arg2: Internal.BlockState_, arg3: Internal.BlockState_, arg4: number, arg5: number): void;
        getBiomeAt(): Internal.Long2ObjectOpenHashMap<any>;
        invalidateCaps(): void;
        hashCode(): number;
        increaseMaxEntityRadius(arg0: number): number;
        getExistingBlockEntity(arg0: BlockPos_): Internal.BlockEntity;
        removeEntityComplete(arg0: Internal.Entity_, arg1: boolean): void;
        close(): void;
        redirect$zod000$onTickLiquid(state: Internal.FluidState_, level: Internal.Level_, pos: BlockPos_): void;
        areCapsCompatible(arg0: Internal.CapabilityProvider_<Internal.Level_>): boolean;
        areCapsCompatible(arg0: Internal.CapabilityDispatcher_): boolean;
        getMaxEntityRadius(): number;
        removeEntity(arg0: Internal.Entity_): void;
        removeEntity(arg0: Internal.Entity_, arg1: boolean): void;
        getDensityAt(): Internal.Long2ObjectOpenHashMap<any>;
        asKJS(): any;
        reviveCaps(): void;
        redirect$zoc000$redirectTick(blockEntity: Internal.TickingBlockEntity_): void;
        equals(arg0: any): boolean;
        isAreaLoaded(arg0: BlockPos_, arg1: number): boolean;
        toString(): string;
        redirect$zod000$onTickBlock(state: Internal.BlockState_, level: Internal.ServerLevel_, pos: BlockPos_, random: Internal.Random_): void;
        setRedirected(arg0: boolean, arg1: Vec3_): void;
        restoringBlockSnapshots : boolean;
        capturedBlockSnapshots : Internal.ArrayList<Internal.BlockSnapshot>;
        captureBlockSnapshots : boolean;
        get densityAt(): Internal.Long2ObjectOpenHashMap<any>;
        get maxEntityRadius(): number;
        get class(): Internal.Class<any>;
        get biomeAt(): Internal.Long2ObjectOpenHashMap<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    type ServerLevel_ = ServerLevel;
    class ChunkRenderBounds {
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        hashCode(): number;
        notifyAll(): void;
        equals(arg0: any): boolean;
        toString(): string;
        notify(): void;
        readonly z1 : number;
        readonly y1 : number;
        readonly z2 : number;
        readonly x1 : number;
        readonly y2 : number;
        static readonly ALWAYS_FALSE : Internal.ChunkRenderBounds;
        readonly x2 : number;
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    type ChunkRenderBounds_ = ChunkRenderBounds;
    interface AsKJS {
        asKJS(): any;
    }
    type AsKJS_ = AsKJS;
    interface IExtensibleEnum {
        init(): void;
    }
    type IExtensibleEnum_ = IExtensibleEnum;
    class JsonNull extends Internal.JsonElement {
        getAsFloat(): number;
        getClass(): Internal.Class<any>;
        getAsByte(): number;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        getAsBigDecimal(): Internal.BigDecimal;
        notifyAll(): void;
        getAsNumber(): Internal.Number;
        getAsCharacter(): string;
        getAsString(): string;
        isJsonArray(): boolean;
        notify(): void;
        getAsInt(): number;
        isJsonPrimitive(): boolean;
        getAsLong(): number;
        isJsonObject(): boolean;
        hashCode(): number;
        getAsBigInteger(): Internal.BigInteger;
        getAsJsonObject(): Internal.JsonObject;
        getAsJsonNull(): Internal.JsonNull;
        isJsonNull(): boolean;
        getAsDouble(): number;
        deepCopy(): Internal.JsonNull;
        getAsJsonArray(): Internal.JsonArray;
        getAsJsonPrimitive(): Internal.JsonPrimitive;
        getAsBoolean(): boolean;
        equals(arg0: any): boolean;
        toString(): string;
        getAsShort(): number;
        static readonly INSTANCE : Internal.JsonNull;
        get asByte(): number;
        get asBigInteger(): Internal.BigInteger;
        get asJsonObject(): Internal.JsonObject;
        get asCharacter(): string;
        get jsonPrimitive(): boolean;
        get asNumber(): Internal.Number;
        get asBigDecimal(): Internal.BigDecimal;
        get jsonNull(): boolean;
        get asFloat(): number;
        get asLong(): number;
        get asInt(): number;
        get asJsonPrimitive(): Internal.JsonPrimitive;
        get asJsonNull(): Internal.JsonNull;
        get asShort(): number;
        get asDouble(): number;
        get asJsonArray(): Internal.JsonArray;
        get asString(): string;
        get jsonObject(): boolean;
        get class(): Internal.Class<any>;
        get jsonArray(): boolean;
        get asBoolean(): boolean;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    type JsonNull_ = JsonNull;
    class FallbackResourceManager implements Internal.ResourceManager, Internal.NamespaceResourceManagerAccessor {
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        hashCode(): number;
        notifyAll(): void;
        equals(arg0: any): boolean;
        toString(): string;
        notify(): void;
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    type FallbackResourceManager_ = FallbackResourceManager;
    interface PlayerKJS {
        setStagesKJS(arg0: Internal.Stages_): void;
        getStagesRawKJS(): Internal.Stages;
        getStagesKJS(): Internal.Stages;
    }
    type PlayerKJS_ = PlayerKJS;
    class AirBlock extends Internal.Block {
        rotate(arg0: Internal.BlockState_, arg1: Internal.LevelAccessor_, arg2: BlockPos_, arg3: Internal.Rotation_): Internal.BlockState;
        getClass(): Internal.Class<any>;
        getStateAtViewpoint(arg0: Internal.BlockState_, arg1: Internal.BlockGetter_, arg2: BlockPos_, arg3: Vec3_): Internal.BlockState;
        onBlockExploded(arg0: Internal.BlockState_, arg1: Internal.Level_, arg2: BlockPos_, arg3: Internal.Explosion_): void;
        getBedDirection(arg0: Internal.BlockState_, arg1: Internal.LevelReader_, arg2: BlockPos_): Internal.Direction;
        isBed(arg0: Internal.BlockState_, arg1: Internal.BlockGetter_, arg2: BlockPos_, arg3: Internal.Entity_): boolean;
        canHarvestBlock(arg0: Internal.BlockState_, arg1: Internal.BlockGetter_, arg2: BlockPos_, arg3: Internal.Player_): boolean;
        makesOpenTrapdoorAboveClimbable(arg0: Internal.BlockState_, arg1: Internal.LevelReader_, arg2: BlockPos_, arg3: Internal.BlockState_): boolean;
        isLadder(arg0: Internal.BlockState_, arg1: Internal.LevelReader_, arg2: BlockPos_, arg3: Internal.LivingEntity_): boolean;
        shouldDisplayFluidOverlay(arg0: Internal.BlockState_, arg1: Internal.BlockAndTintGetter_, arg2: BlockPos_, arg3: Internal.FluidState_): boolean;
        canStickTo(arg0: Internal.BlockState_, arg1: Internal.BlockState_): boolean;
        onNeighborChange(arg0: Internal.BlockState_, arg1: Internal.LevelReader_, arg2: BlockPos_, arg3: BlockPos_): void;
        getWeakChanges(arg0: Internal.BlockState_, arg1: Internal.LevelReader_, arg2: BlockPos_): boolean;
        canEntityDestroy(arg0: Internal.BlockState_, arg1: Internal.BlockGetter_, arg2: BlockPos_, arg3: Internal.Entity_): boolean;
        isBurning(arg0: Internal.BlockState_, arg1: Internal.BlockGetter_, arg2: BlockPos_): boolean;
        getFriction(arg0: Internal.BlockState_, arg1: Internal.LevelReader_, arg2: BlockPos_, arg3: Internal.Entity_): number;
        isValidSpawn(arg0: Internal.BlockState_, arg1: Internal.BlockGetter_, arg2: BlockPos_, arg3: Internal.SpawnPlacements$Type_, arg4: Internal.EntityType_<any>): boolean;
        isPortalFrame(arg0: Internal.BlockState_, arg1: Internal.BlockGetter_, arg2: BlockPos_): boolean;
        getExplosionResistance(arg0: Internal.BlockState_, arg1: Internal.BlockGetter_, arg2: BlockPos_, arg3: Internal.Explosion_): number;
        isScaffolding(arg0: Internal.BlockState_, arg1: Internal.LevelReader_, arg2: BlockPos_, arg3: Internal.LivingEntity_): boolean;
        canSustainPlant(arg0: Internal.BlockState_, arg1: Internal.BlockGetter_, arg2: BlockPos_, arg3: Internal.Direction_, arg4: Internal.IPlantable_): boolean;
        canDropFromExplosion(arg0: Internal.BlockState_, arg1: Internal.BlockGetter_, arg2: BlockPos_, arg3: Internal.Explosion_): boolean;
        isStickyBlock(arg0: Internal.BlockState_): boolean;
        isFertile(arg0: Internal.BlockState_, arg1: Internal.BlockGetter_, arg2: BlockPos_): boolean;
        getAiPathNodeType(arg0: Internal.BlockState_, arg1: Internal.BlockGetter_, arg2: BlockPos_, arg3: Internal.Mob_): Internal.BlockPathTypes;
        getBlockBuilderKJS(): Internal.BlockBuilder;
        isSlimeBlock(arg0: Internal.BlockState_): boolean;
        getRegistryType(): Internal.Class<Internal.Block>;
        getFireSpreadSpeed(arg0: Internal.BlockState_, arg1: Internal.BlockGetter_, arg2: BlockPos_, arg3: Internal.Direction_): number;
        getToolModifiedState(arg0: Internal.BlockState_, arg1: Internal.Level_, arg2: BlockPos_, arg3: Internal.Player_, arg4: Internal.ItemStack_, arg5: Internal.ToolAction_): Internal.BlockState;
        getToolModifiedState(arg0: Internal.BlockState_, arg1: Internal.UseOnContext_, arg2: Internal.ToolAction_, arg3: boolean): Internal.BlockState;
        getBeaconColorMultiplier(arg0: Internal.BlockState_, arg1: Internal.LevelReader_, arg2: BlockPos_, arg3: BlockPos_): number[];
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        getExpDrop(arg0: Internal.BlockState_, arg1: Internal.LevelReader_, arg2: BlockPos_, arg3: number, arg4: number): number;
        isConduitFrame(arg0: Internal.BlockState_, arg1: Internal.LevelReader_, arg2: BlockPos_, arg3: BlockPos_): boolean;
        notifyAll(): void;
        getLightEmission(arg0: Internal.BlockState_, arg1: Internal.BlockGetter_, arg2: BlockPos_): number;
        onDestroyedByPlayer(arg0: Internal.BlockState_, arg1: Internal.Level_, arg2: BlockPos_, arg3: Internal.Player_, arg4: boolean, arg5: Internal.FluidState_): boolean;
        getId(): string;
        shouldCheckWeakPower(arg0: Internal.BlockState_, arg1: Internal.LevelReader_, arg2: BlockPos_, arg3: Internal.Direction_): boolean;
        collisionExtendsVertically(arg0: Internal.BlockState_, arg1: Internal.BlockGetter_, arg2: BlockPos_, arg3: Internal.Entity_): boolean;
        notify(): void;
        supportsExternalFaceHiding(arg0: Internal.BlockState_): boolean;
        addLandingEffects(arg0: Internal.BlockState_, arg1: Internal.ServerLevel_, arg2: BlockPos_, arg3: Internal.BlockState_, arg4: Internal.LivingEntity_, arg5: number): boolean;
        getRenderPropertiesInternal(): any;
        getSoundType(arg0: Internal.BlockState_, arg1: Internal.LevelReader_, arg2: BlockPos_, arg3: Internal.Entity_): Internal.SoundType;
        hashCode(): number;
        addRunningEffects(arg0: Internal.BlockState_, arg1: Internal.Level_, arg2: BlockPos_, arg3: Internal.Entity_): boolean;
        hidesNeighborFace(arg0: Internal.BlockGetter_, arg1: BlockPos_, arg2: Internal.BlockState_, arg3: Internal.BlockState_, arg4: Internal.Direction_): boolean;
        initializeClient(arg0: Internal.Consumer_<Internal.IBlockRenderProperties_>): void;
        getCloneItemStack(arg0: Internal.BlockState_, arg1: Internal.HitResult_, arg2: Internal.BlockGetter_, arg3: BlockPos_, arg4: Internal.Player_): Internal.ItemStack;
        getBlockStatesKJS(): Internal.List<Internal.BlockState>;
        isFlammable(arg0: Internal.BlockState_, arg1: Internal.BlockGetter_, arg2: BlockPos_, arg3: Internal.Direction_): boolean;
        onCaughtFire(arg0: Internal.BlockState_, arg1: Internal.Level_, arg2: BlockPos_, arg3: Internal.Direction_, arg4: Internal.LivingEntity_): void;
        getEnchantPowerBonus(arg0: Internal.BlockState_, arg1: Internal.LevelReader_, arg2: BlockPos_): number;
        getRegistryName(): ResourceLocation;
        setBedOccupied(arg0: Internal.BlockState_, arg1: Internal.Level_, arg2: BlockPos_, arg3: Internal.LivingEntity_, arg4: boolean): void;
        setRegistryName(arg0: ResourceLocation_): Internal.Block;
        setRegistryName(arg0: string): Internal.Block;
        setRegistryName(arg0: string, arg1: string): Internal.Block;
        isFireSource(arg0: Internal.BlockState_, arg1: Internal.LevelReader_, arg2: BlockPos_, arg3: Internal.Direction_): boolean;
        getRespawnPosition(arg0: Internal.BlockState_, arg1: Internal.EntityType_<any>, arg2: Internal.LevelReader_, arg3: BlockPos_, arg4: number, arg5: Internal.LivingEntity_): Internal.Optional<Vec3>;
        equals(arg0: any): boolean;
        canConnectRedstone(arg0: Internal.BlockState_, arg1: Internal.BlockGetter_, arg2: BlockPos_, arg3: Internal.Direction_): boolean;
        setBlockBuilderKJS(b: Internal.BlockBuilder_): void;
        getTypeData(): Internal.CompoundTag;
        toString(): string;
        getFlammability(arg0: Internal.BlockState_, arg1: Internal.BlockGetter_, arg2: BlockPos_, arg3: Internal.Direction_): number;
        readonly delegate : Internal.IRegistryDelegate<Internal.Block>;
        get registryType(): Internal.Class<Internal.Block>;
        get blockBuilderKJS(): Internal.BlockBuilder;
        get renderPropertiesInternal(): any;
        get blockStatesKJS(): Internal.List<Internal.BlockState>;
        get id(): string;
        get registryName(): ResourceLocation;
        get typeData(): Internal.CompoundTag;
        get class(): Internal.Class<any>;
        set blockBuilderKJS(b: Internal.BlockBuilder_);
        set registryName(arg0: ResourceLocation_);
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    type AirBlock_ = AirBlock;
    interface IGuiItemStackGroup extends Internal.IGuiIngredientGroup<Internal.ItemStack> {
        init(arg0: number, arg1: boolean, arg2: number, arg3: number): void;
        init(arg0: number, arg1: boolean, arg2: Internal.IIngredientRenderer_<Internal.ItemStack_>, arg3: number, arg4: number, arg5: number, arg6: number, arg7: number, arg8: number): void;
        set(arg0: number, arg1: Internal.ItemStack_): void;
        set(arg0: number, arg1: Internal.List_<Internal.ItemStack_>): void;
        set(arg0: Internal.IIngredients_): void;
        getGuiIngredients(): Internal.Map<number, Internal.IGuiIngredient<Internal.ItemStack>>;
        addTooltipCallback(arg0: Internal.ITooltipCallback_<Internal.ItemStack_>): void;
        setOverrideDisplayFocus(arg0: Internal.IFocus_<Internal.ItemStack_>): void;
        setBackground(arg0: number, arg1: Internal.IDrawable_): void;
    }
    type IGuiItemStackGroup_ = IGuiItemStackGroup;
    interface LivingEntityKJS {
        foodEatenKJS(is: Internal.ItemStack_): void;
    }
    type LivingEntityKJS_ = LivingEntityKJS;
    class DragSourceContext implements Internal.DragSourceListener, Internal.DragSourceMotionListener, Internal.Serializable {
        removeDragSourceListener(arg0: Internal.DragSourceListener_): void;
        getClass(): Internal.Class<any>;
        getCursor(): Internal.Cursor;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        getTrigger(): Internal.DragGestureEvent;
        dragEnter(arg0: Internal.DragSourceDragEvent_): void;
        notifyAll(): void;
        dragDropEnd(arg0: Internal.DragSourceDropEvent_): void;
        dropActionChanged(arg0: Internal.DragSourceDragEvent_): void;
        transferablesFlavorsChanged(): void;
        notify(): void;
        addDragSourceListener(arg0: Internal.DragSourceListener_): void;
        getSourceActions(): number;
        getTransferable(): Internal.Transferable;
        dragMouseMoved(arg0: Internal.DragSourceDragEvent_): void;
        hashCode(): number;
        getDragSource(): Internal.DragSource;
        equals(arg0: any): boolean;
        toString(): string;
        setCursor(arg0: Internal.Cursor_): void;
        dragOver(arg0: Internal.DragSourceDragEvent_): void;
        getComponent(): java_.awt.Component;
        dragExit(arg0: Internal.DragSourceEvent_): void;
        get cursor(): Internal.Cursor;
        get sourceActions(): number;
        get component(): java_.awt.Component;
        get transferable(): Internal.Transferable;
        get trigger(): Internal.DragGestureEvent;
        get class(): Internal.Class<any>;
        get dragSource(): Internal.DragSource;
        set cursor(arg0: Internal.Cursor_);
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    type DragSourceContext_ = DragSourceContext;
    interface DamageSourceAccessor {
        callBypassArmor(): Internal.DamageSource;
        callBypassMagic(): Internal.DamageSource;
        callBypassInvul(): Internal.DamageSource;
    }
    type DamageSourceAccessor_ = DamageSourceAccessor;
    class ModuleDescriptor$Opens$Modifier extends Internal.Enum<Internal.ModuleDescriptor$Opens$Modifier> {
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        static valueOf(arg0: string): Internal.ModuleDescriptor$Opens$Modifier;
        static valueOf<T_>(arg0: Internal.Class_<T_>, arg1: string): T_;
        notifyAll(): void;
        static values(): Internal.ModuleDescriptor$Opens$Modifier[];
        compareTo(arg0: Internal.ModuleDescriptor$Opens$Modifier_): number;
        describeConstable(): Internal.Optional<Internal.Enum$EnumDesc<Internal.ModuleDescriptor$Opens$Modifier>>;
        notify(): void;
        getDeclaringClass(): Internal.Class<Internal.ModuleDescriptor$Opens$Modifier>;
        hashCode(): number;
        equals(arg0: any): boolean;
        name(): string;
        toString(): string;
        ordinal(): number;
        static readonly SYNTHETIC : Internal.ModuleDescriptor$Opens$Modifier;
        static readonly MANDATED : Internal.ModuleDescriptor$Opens$Modifier;
        get class(): Internal.Class<any>;
        get declaringClass(): Internal.Class<Internal.ModuleDescriptor$Opens$Modifier>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    type ModuleDescriptor$Opens$Modifier_ = "synthetic" | "mandated" | ModuleDescriptor$Opens$Modifier;
    class ModuleLayer {
        getClass(): Internal.Class<any>;
        static defineModulesWithManyLoaders(arg0: Internal.Configuration_, arg1: Internal.List_<Internal.ModuleLayer_>, arg2: Internal.ClassLoader_): Internal.ModuleLayer$Controller;
        defineModulesWithManyLoaders(arg0: Internal.Configuration_, arg1: Internal.ClassLoader_): Internal.ModuleLayer;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        configuration(): Internal.Configuration;
        notifyAll(): void;
        static defineModulesWithOneLoader(arg0: Internal.Configuration_, arg1: Internal.List_<Internal.ModuleLayer_>, arg2: Internal.ClassLoader_): Internal.ModuleLayer$Controller;
        defineModulesWithOneLoader(arg0: Internal.Configuration_, arg1: Internal.ClassLoader_): Internal.ModuleLayer;
        notify(): void;
        modules(): Internal.Set<Internal.Module>;
        defineModules(arg0: Internal.Configuration_, arg1: java_.util.function_.Function_<string, Internal.ClassLoader_>): Internal.ModuleLayer;
        static defineModules(arg0: Internal.Configuration_, arg1: Internal.List_<Internal.ModuleLayer_>, arg2: java_.util.function_.Function_<string, Internal.ClassLoader_>): Internal.ModuleLayer$Controller;
        static empty(): Internal.ModuleLayer;
        findModule(arg0: string): Internal.Optional<Internal.Module>;
        findLoader(arg0: string): Internal.ClassLoader;
        hashCode(): number;
        equals(arg0: any): boolean;
        toString(): string;
        static boot(): Internal.ModuleLayer;
        parents(): Internal.List<Internal.ModuleLayer>;
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    type ModuleLayer_ = ModuleLayer;
    abstract class AbstractByte2ObjectMap <V> extends Internal.AbstractByte2ObjectFunction<V> implements Internal.Byte2ObjectMap<V>, Internal.Serializable {
        getClass(): Internal.Class<any>;
        getOrDefault(arg0: number, arg1: V): V;
        getOrDefault(arg0: any, arg1: V): V;
        replace(arg0: number, arg1: V, arg2: V): boolean;
        replace(arg0: number, arg1: V): V;
        composeByte(arg0: Internal.Byte2ByteFunction_): Internal.Byte2ObjectFunction<V>;
        andThen<V_>(arg0: java_.util.function_.Function_<V, V_>): java_.util.function_.Function<number, V_>;
        composeReference<T_>(arg0: Internal.Reference2ByteFunction_<T_>): Internal.Reference2ObjectFunction<T_, V>;
        put(arg0: number, arg1: V): V;
        containsValue(arg0: any): boolean;
        compute(arg0: number, arg1: Internal.BiFunction_<number, V, V>): V;
        defaultReturnValue(arg0: V): void;
        defaultReturnValue(): V;
        andThenObject<T_>(arg0: Internal.Object2ObjectFunction_<V, T_>): Internal.Byte2ObjectFunction<T_>;
        merge(arg0: number, arg1: V, arg2: Internal.BiFunction_<V, V, V>): V;
        composeLong(arg0: Internal.Long2ByteFunction_): Internal.Long2ObjectFunction<V>;
        entrySet(): Internal.ObjectSet<Internal.Map$Entry<number, V>>;
        containsKey(arg0: number): boolean;
        containsKey(arg0: any): boolean;
        composeObject<T_>(arg0: Internal.Object2ByteFunction_<T_>): Internal.Object2ObjectFunction<T_, V>;
        size(): number;
        compose<T_>(arg0: java_.util.function_.Function_<T_, number>): java_.util.function_.Function<T_, V>;
        composeShort(arg0: Internal.Short2ByteFunction_): Internal.Short2ObjectFunction<V>;
        composeChar(arg0: Internal.Char2ByteFunction_): Internal.Char2ObjectFunction<V>;
        composeDouble(arg0: Internal.Double2ByteFunction_): Internal.Double2ObjectFunction<V>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        computeIfAbsent(arg0: number, arg1: Internal.Byte2ObjectFunction_<V>): V;
        computeIfAbsent(arg0: number, arg1: Internal.IntFunction_<V>): V;
        computeIfAbsent(arg0: number, arg1: java_.util.function_.Function_<number, V>): V;
        notifyAll(): void;
        values(): Internal.ObjectCollection<V>;
        andThenShort(arg0: Internal.Object2ShortFunction_<V>): Internal.Byte2ShortFunction;
        computeIfAbsentPartial(arg0: number, arg1: Internal.Byte2ObjectFunction_<V>): V;
        replaceAll(arg0: Internal.BiFunction_<number, V, V>): void;
        andThenInt(arg0: Internal.Object2IntFunction_<V>): Internal.Byte2IntFunction;
        remove(arg0: any): V;
        remove(arg0: number): V;
        remove(arg0: number, arg1: any): boolean;
        remove(arg0: any, arg1: any): boolean;
        notify(): void;
        byte2ObjectEntrySet(): Internal.ObjectSet<Internal.Byte2ObjectMap$Entry<V>>;
        andThenDouble(arg0: Internal.Object2DoubleFunction_<V>): Internal.Byte2DoubleFunction;
        hashCode(): number;
        get(arg0: any): V;
        get(arg0: number): V;
        putAll(arg0: Internal.Map_<number, V>): void;
        andThenLong(arg0: Internal.Object2LongFunction_<V>): Internal.Byte2LongFunction;
        keySet(): Internal.ByteSet;
        andThenByte(arg0: Internal.Object2ByteFunction_<V>): Internal.Byte2ByteFunction;
        andThenFloat(arg0: Internal.Object2FloatFunction_<V>): Internal.Byte2FloatFunction;
        apply(arg0: number): V;
        forEach(arg0: Internal.BiConsumer_<number, V>): void;
        composeInt(arg0: Internal.Int2ByteFunction_): Internal.Int2ObjectFunction<V>;
        clear(): void;
        isEmpty(): boolean;
        composeFloat(arg0: Internal.Float2ByteFunction_): Internal.Float2ObjectFunction<V>;
        andThenChar(arg0: Internal.Object2CharFunction_<V>): Internal.Byte2CharFunction;
        computeIfPresent(arg0: number, arg1: Internal.BiFunction_<number, V, V>): V;
        equals(arg0: any): boolean;
        andThenReference<T_>(arg0: Internal.Object2ReferenceFunction_<V, T_>): Internal.Byte2ReferenceFunction<T_>;
        toString(): string;
        putIfAbsent(arg0: number, arg1: V): V;
        get class(): Internal.Class<any>;
        get empty(): boolean;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    type AbstractByte2ObjectMap_<V> = AbstractByte2ObjectMap<V>;
    interface Multiset$Entry <E> {
        getElement(): E;
        hashCode(): number;
        equals(arg0: any): boolean;
        toString(): string;
        getCount(): number;
    }
    type Multiset$Entry_<E> = Multiset$Entry<E>;
    interface IForgeCommandSourceStack {
        getAdvancement(arg0: ResourceLocation_): Internal.Advancement;
        getRecipeManager(): Internal.RecipeManager;
        getUnsidedLevel(): Internal.Level;
        getScoreboard(): Internal.Scoreboard;
    }
    type IForgeCommandSourceStack_ = IForgeCommandSourceStack;
    interface SingleRedirectModifier <S> {
        apply(arg0: Internal.CommandContext_<S>): S;
    }
    type SingleRedirectModifier_<S> = ((arg0: Internal.CommandContext<S>) => S) | SingleRedirectModifier<S>;
    class PortalInfo {
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        hashCode(): number;
        notifyAll(): void;
        equals(arg0: any): boolean;
        toString(): string;
        notify(): void;
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    type PortalInfo_ = PortalInfo;
    class RegistryObjectBuilderTypes <T> {
        static add<T>(key: Internal.ResourceKey_<Internal.Registry_<T>>, baseClass: Internal.Class_<any>): Internal.RegistryObjectBuilderTypes<T>;
        getClass(): Internal.Class<any>;
        addType(type: string, builderType: Internal.Class_<Internal.BuilderBase_<T>>, factory: Internal.RegistryObjectBuilderTypes$BuilderFactory_<T>, isDefault: boolean): void;
        addType(type: string, builderType: Internal.Class_<Internal.BuilderBase_<T>>, factory: Internal.RegistryObjectBuilderTypes$BuilderFactory_<T>): void;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        hashCode(): number;
        notifyAll(): void;
        equals(arg0: any): boolean;
        toString(): string;
        bypassServerOnly(): Internal.RegistryObjectBuilderTypes<T>;
        getCurrent(): Internal.BuilderBase<T>;
        addBuilder(builder: Internal.BuilderBase_<T>): void;
        notify(): void;
        getDefaultType(): Internal.RegistryObjectBuilderTypes$BuilderType<T>;
        static readonly BLOCK_ENTITY_TYPE : Internal.RegistryObjectBuilderTypes<Internal.BlockEntityType<any>>;
        static readonly CUSTOM_STAT : Internal.RegistryObjectBuilderTypes<ResourceLocation>;
        static readonly ENCHANTMENT : Internal.RegistryObjectBuilderTypes<Internal.Enchantment>;
        static readonly POINT_OF_INTEREST_TYPE : Internal.RegistryObjectBuilderTypes<Internal.PoiType>;
        readonly types : Internal.Map<string, Internal.RegistryObjectBuilderTypes$BuilderType<T>>;
        static readonly MOTIVE : Internal.RegistryObjectBuilderTypes<Internal.Motive>;
        static readonly VILLAGER_TYPE : Internal.RegistryObjectBuilderTypes<Internal.VillagerType>;
        static readonly ALL_BUILDERS : Internal.List<Internal.BuilderBase<any>>;
        static readonly PARTICLE_TYPE : Internal.RegistryObjectBuilderTypes<Internal.ParticleType<any>>;
        readonly objects : Internal.Map<ResourceLocation, Internal.BuilderBase<T>>;
        static readonly BLOCK : Internal.RegistryObjectBuilderTypes<Internal.Block>;
        static readonly ENTITY_TYPE : Internal.RegistryObjectBuilderTypes<Internal.EntityType<any>>;
        readonly registryKey : Internal.ResourceKey<Internal.Registry<T>>;
        static readonly ITEM : Internal.RegistryObjectBuilderTypes<Internal.Item>;
        readonly objectBaseClass : Internal.Class<T>;
        static readonly VILLAGER_PROFESSION : Internal.RegistryObjectBuilderTypes<Internal.VillagerProfession>;
        current : Internal.BuilderBase<T>;
        static readonly FLUID : Internal.RegistryObjectBuilderTypes<Internal.Fluid>;
        static readonly SOUND_EVENT : Internal.RegistryObjectBuilderTypes<Internal.SoundEvent>;
        static readonly POTION : Internal.RegistryObjectBuilderTypes<Internal.Potion>;
        readonly deferredRegister : Internal.DeferredRegister<T>;
        static readonly MOB_EFFECT : Internal.RegistryObjectBuilderTypes<Internal.MobEffect>;
        static readonly MAP : {};
        get class(): Internal.Class<any>;
        get defaultType(): Internal.RegistryObjectBuilderTypes$BuilderType<T>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    type RegistryObjectBuilderTypes_<T> = RegistryObjectBuilderTypes<T>;
    class FluidState extends Internal.StateHolder<Internal.Fluid, Internal.FluidState> implements Internal.IForgeFluidState {
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        getExplosionResistance(arg0: Internal.BlockGetter_, arg1: BlockPos_, arg2: Internal.Explosion_): number;
        hashCode(): number;
        notifyAll(): void;
        equals(arg0: any): boolean;
        toString(): string;
        isEntityInside(arg0: Internal.LevelReader_, arg1: BlockPos_, arg2: Internal.Entity_, arg3: number, arg4: Internal.HolderSet_<Internal.Fluid_>, arg5: boolean): boolean;
        notify(): void;
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    type FluidState_ = FluidState;
    abstract class CapabilityProxy <K> {
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        getCapability<C>(arg0: Internal.Capability_<C>): C;
        getLatestPeriodID(): number;
        notifyAll(): void;
        handleRecipe(arg0: Internal.IO_, arg1: com.lowdragmc.multiblocked.api.recipe.Recipe_, arg2: Internal.List_<any>): Internal.List<K>;
        notify(): void;
        updateChangedState(arg0: number): void;
        searchingRecipe(arg0: Internal.IO_, arg1: com.lowdragmc.multiblocked.api.recipe.Recipe_, arg2: Internal.List_<any>): Internal.List<K>;
        copyContent(arg0: any): K;
        hashCode(): number;
        getTileEntity(): Internal.BlockEntity;
        equals(arg0: any): boolean;
        toString(): string;
        postWorking(arg0: Internal.ICapabilityProxyHolder_, arg1: Internal.IO_, arg2: com.lowdragmc.multiblocked.api.recipe.Recipe_): void;
        preWorking(arg0: Internal.ICapabilityProxyHolder_, arg1: Internal.IO_, arg2: com.lowdragmc.multiblocked.api.recipe.Recipe_): void;
        readonly capability : Internal.MultiblockCapability<K>;
        slots : Internal.Set<string>;
        facing : Internal.Direction;
        get latestPeriodID(): number;
        get class(): Internal.Class<any>;
        get tileEntity(): Internal.BlockEntity;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    type CapabilityProxy_<K> = CapabilityProxy<K>;
    interface CompletionStage <T> {
        exceptionallyAsync(arg0: java_.util.function_.Function_<Internal.Throwable_, T>): Internal.CompletionStage<T>;
        exceptionallyAsync(arg0: java_.util.function_.Function_<Internal.Throwable_, T>, arg1: Internal.Executor_): Internal.CompletionStage<T>;
        thenRunAsync(arg0: Internal.Runnable_, arg1: Internal.Executor_): Internal.CompletionStage<void>;
        thenRunAsync(arg0: Internal.Runnable_): Internal.CompletionStage<void>;
        runAfterBothAsync(arg0: Internal.CompletionStage_<any>, arg1: Internal.Runnable_): Internal.CompletionStage<void>;
        runAfterBothAsync(arg0: Internal.CompletionStage_<any>, arg1: Internal.Runnable_, arg2: Internal.Executor_): Internal.CompletionStage<void>;
        applyToEitherAsync<U>(arg0: Internal.CompletionStage_<T>, arg1: java_.util.function_.Function_<T, U>, arg2: Internal.Executor_): Internal.CompletionStage<U>;
        applyToEitherAsync<U>(arg0: Internal.CompletionStage_<T>, arg1: java_.util.function_.Function_<T, U>): Internal.CompletionStage<U>;
        acceptEitherAsync(arg0: Internal.CompletionStage_<T>, arg1: Internal.Consumer_<T>): Internal.CompletionStage<void>;
        acceptEitherAsync(arg0: Internal.CompletionStage_<T>, arg1: Internal.Consumer_<T>, arg2: Internal.Executor_): Internal.CompletionStage<void>;
        runAfterEitherAsync(arg0: Internal.CompletionStage_<any>, arg1: Internal.Runnable_): Internal.CompletionStage<void>;
        runAfterEitherAsync(arg0: Internal.CompletionStage_<any>, arg1: Internal.Runnable_, arg2: Internal.Executor_): Internal.CompletionStage<void>;
        acceptEither(arg0: Internal.CompletionStage_<T>, arg1: Internal.Consumer_<T>): Internal.CompletionStage<void>;
        thenAcceptBoth<U>(arg0: Internal.CompletionStage_<U>, arg1: Internal.BiConsumer_<T, U>): Internal.CompletionStage<void>;
        exceptionallyCompose(arg0: java_.util.function_.Function_<Internal.Throwable_, Internal.CompletionStage_<T>>): Internal.CompletionStage<T>;
        applyToEither<U>(arg0: Internal.CompletionStage_<T>, arg1: java_.util.function_.Function_<T, U>): Internal.CompletionStage<U>;
        runAfterEither(arg0: Internal.CompletionStage_<any>, arg1: Internal.Runnable_): Internal.CompletionStage<void>;
        thenApply<U>(arg0: java_.util.function_.Function_<T, U>): Internal.CompletionStage<U>;
        thenComposeAsync<U>(arg0: java_.util.function_.Function_<T, Internal.CompletionStage_<U>>): Internal.CompletionStage<U>;
        thenComposeAsync<U>(arg0: java_.util.function_.Function_<T, Internal.CompletionStage_<U>>, arg1: Internal.Executor_): Internal.CompletionStage<U>;
        thenAccept(arg0: Internal.Consumer_<T>): Internal.CompletionStage<void>;
        thenRun(arg0: Internal.Runnable_): Internal.CompletionStage<void>;
        runAfterBoth(arg0: Internal.CompletionStage_<any>, arg1: Internal.Runnable_): Internal.CompletionStage<void>;
        exceptionally(arg0: java_.util.function_.Function_<Internal.Throwable_, T>): Internal.CompletionStage<T>;
        handleAsync<U>(arg0: Internal.BiFunction_<T, Internal.Throwable_, U>): Internal.CompletionStage<U>;
        handleAsync<U>(arg0: Internal.BiFunction_<T, Internal.Throwable_, U>, arg1: Internal.Executor_): Internal.CompletionStage<U>;
        handle<U>(arg0: Internal.BiFunction_<T, Internal.Throwable_, U>): Internal.CompletionStage<U>;
        thenCompose<U>(arg0: java_.util.function_.Function_<T, Internal.CompletionStage_<U>>): Internal.CompletionStage<U>;
        whenComplete(arg0: Internal.BiConsumer_<T, Internal.Throwable_>): Internal.CompletionStage<T>;
        thenCombineAsync<U, V>(arg0: Internal.CompletionStage_<U>, arg1: Internal.BiFunction_<T, U, V>): Internal.CompletionStage<V>;
        thenCombineAsync<U, V>(arg0: Internal.CompletionStage_<U>, arg1: Internal.BiFunction_<T, U, V>, arg2: Internal.Executor_): Internal.CompletionStage<V>;
        thenAcceptBothAsync<U>(arg0: Internal.CompletionStage_<U>, arg1: Internal.BiConsumer_<T, U>, arg2: Internal.Executor_): Internal.CompletionStage<void>;
        thenAcceptBothAsync<U>(arg0: Internal.CompletionStage_<U>, arg1: Internal.BiConsumer_<T, U>): Internal.CompletionStage<void>;
        exceptionallyComposeAsync(arg0: java_.util.function_.Function_<Internal.Throwable_, Internal.CompletionStage_<T>>, arg1: Internal.Executor_): Internal.CompletionStage<T>;
        exceptionallyComposeAsync(arg0: java_.util.function_.Function_<Internal.Throwable_, Internal.CompletionStage_<T>>): Internal.CompletionStage<T>;
        thenCombine<U, V>(arg0: Internal.CompletionStage_<U>, arg1: Internal.BiFunction_<T, U, V>): Internal.CompletionStage<V>;
        whenCompleteAsync(arg0: Internal.BiConsumer_<T, Internal.Throwable_>): Internal.CompletionStage<T>;
        whenCompleteAsync(arg0: Internal.BiConsumer_<T, Internal.Throwable_>, arg1: Internal.Executor_): Internal.CompletionStage<T>;
        thenApplyAsync<U>(arg0: java_.util.function_.Function_<T, U>, arg1: Internal.Executor_): Internal.CompletionStage<U>;
        thenApplyAsync<U>(arg0: java_.util.function_.Function_<T, U>): Internal.CompletionStage<U>;
        thenAcceptAsync(arg0: Internal.Consumer_<T>): Internal.CompletionStage<void>;
        thenAcceptAsync(arg0: Internal.Consumer_<T>, arg1: Internal.Executor_): Internal.CompletionStage<void>;
        toCompletableFuture(): Internal.CompletableFuture<T>;
    }
    type CompletionStage_<T> = CompletionStage<T>;
    interface IAsyncThreadUpdate {
        asyncThreadLogic(arg0: number): void;
    }
    type IAsyncThreadUpdate_ = IAsyncThreadUpdate;
    class Dist extends Internal.Enum<Internal.Dist> {
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        static valueOf(arg0: string): Internal.Dist;
        static valueOf<T_>(arg0: Internal.Class_<T_>, arg1: string): T_;
        notifyAll(): void;
        static values(): Internal.Dist[];
        isClient(): boolean;
        compareTo(arg0: Internal.Dist_): number;
        describeConstable(): Internal.Optional<Internal.Enum$EnumDesc<Internal.Dist>>;
        notify(): void;
        getDeclaringClass(): Internal.Class<Internal.Dist>;
        isDedicatedServer(): boolean;
        hashCode(): number;
        equals(arg0: any): boolean;
        name(): string;
        toString(): string;
        ordinal(): number;
        static readonly DEDICATED_SERVER : Internal.Dist;
        static readonly CLIENT : Internal.Dist;
        get dedicatedServer(): boolean;
        get client(): boolean;
        get class(): Internal.Class<any>;
        get declaringClass(): Internal.Class<Internal.Dist>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    type Dist_ = "dedicated_server" | "client" | Dist;
    class ToolAction {
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        hashCode(): number;
        notifyAll(): void;
        equals(arg0: any): boolean;
        static get(arg0: string): Internal.ToolAction;
        name(): string;
        static getActions(): Internal.Collection<Internal.ToolAction>;
        toString(): string;
        notify(): void;
        get class(): Internal.Class<any>;
        get actions(): Internal.Collection<Internal.ToolAction>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    type ToolAction_ = ToolAction;
    interface BufferVertexFormat {
        getStride(): number;
    }
    type BufferVertexFormat_ = BufferVertexFormat;
    class MenuBar extends Internal.MenuComponent implements Internal.MenuContainer, Internal.Accessible {
        setName(arg0: string): void;
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        getName(): string;
        notifyAll(): void;
        shortcuts(): Internal.Enumeration<Internal.MenuShortcut>;
        notify(): void;
        remove(arg0: number): void;
        remove(arg0: Internal.MenuComponent_): void;
        getShortcutMenuItem(arg0: Internal.MenuShortcut_): Internal.MenuItem;
        hashCode(): number;
        getMenu(arg0: number): Internal.Menu;
        getMenuCount(): number;
        setFont(arg0: Internal.Font_): void;
        add(arg0: Internal.Menu_): Internal.Menu;
        getParent(): Internal.MenuContainer;
        dispatchEvent(arg0: Internal.AWTEvent_): void;
        deleteShortcut(arg0: Internal.MenuShortcut_): void;
        countMenus(): number;
        getAccessibleContext(): Internal.AccessibleContext;
        postEvent(arg0: java_.awt.Event_): boolean;
        getHelpMenu(): Internal.Menu;
        addNotify(): void;
        equals(arg0: any): boolean;
        removeNotify(): void;
        getFont(): Internal.Font;
        toString(): string;
        setHelpMenu(arg0: Internal.Menu_): void;
        get accessibleContext(): Internal.AccessibleContext;
        get parent(): Internal.MenuContainer;
        get menuCount(): number;
        get name(): string;
        get helpMenu(): Internal.Menu;
        get class(): Internal.Class<any>;
        get font(): Internal.Font;
        set name(arg0: string);
        set helpMenu(arg0: Internal.Menu_);
        set font(arg0: Internal.Font_);
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    type MenuBar_ = MenuBar;
    /**
    */
    class ItemStackJS implements Internal.IngredientJS, Internal.NBTSerializable, Internal.ChangeListener<net.minecraft.nbt.Tag>, Internal.SpecialEquality {
        getItemIds(): Internal.Set<string>;
        getClass(): Internal.Class<any>;
        getNbt(): Internal.CompoundTag;
        isBlock(): boolean;
        getName(): Internal.Text;
        getStacks(): Internal.Set<Internal.ItemStackJS>;
        getVanillaItems(): Internal.Set<Internal.Item>;
        static findGroup(id: string): Internal.CreativeModeTab;
        getItem(): Internal.Item;
        hasEnchantment(enchantment: Internal.Enchantment_, level: number): boolean;
        getTags(): Internal.Collection<ResourceLocation>;
        getItemGroup(): string;
        setChance(c: number): void;
        static getList(): Internal.List<Internal.ItemStackJS>;
        getFirst(): Internal.ItemStackJS;
        withChance(c: number): Internal.ItemStackJS;
        withName(displayName: Internal.Component_): Internal.ItemStackJS;
        getCount(): number;
        setCount(count: number): void;
        testVanillaItem(item: Internal.Item_): boolean;
        hasTag(tag: ResourceLocation_): boolean;
        test(other: Internal.ItemStackJS_): boolean;
        hasChance(): boolean;
        asIngredientStack(): Internal.IngredientStackJS;
        static getRawItem(o: any): Internal.Item;
        getNbtString(): string;
        createVanillaIngredient(): Internal.Ingredient;
        isNBTEqual(other: Internal.ItemStack_): boolean;
        isNBTEqual(other: Internal.ItemStackJS_): boolean;
        toJson(): Internal.JsonElement;
        withCount(c: number): Internal.ItemStackJS;
        static getListJS(): Internal.ListJS;
        specialEquals(o: any, shallow: boolean): boolean;
        anyStackMatches(ingredient: Internal.IngredientJS_): boolean;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        hasNBT(): boolean;
        areItemsEqual(other: Internal.ItemStack_): boolean;
        areItemsEqual(other: Internal.ItemStackJS_): boolean;
        getChance(): number;
        getMod(): string;
        notifyAll(): void;
        isInvalidRecipeIngredient(): boolean;
        getId(): string;
        notify(): void;
        weakNBT(): Internal.IngredientJS;
        static clearListCache(): void;
        not(): Internal.IngredientJS;
        toNBT(): Internal.CompoundTag;
        getHarvestSpeed(block: Internal.BlockContainerJS_): number;
        getHarvestSpeed(): number;
        hashCode(): number;
        toRawResultJson(): Internal.JsonElement;
        static of(o: any): Internal.ItemStackJS;
        getItemStack(): Internal.ItemStack;
        copy(): Internal.ItemStackJS;
        withNBT(nbt: Internal.CompoundTag_): Internal.ItemStackJS;
        toResultJson(): Internal.JsonElement;
        onChanged(o: net.minecraft.nbt.Tag_): void;
        static getTypeList(): Internal.ListJS;
        isEmpty(): boolean;
        strongEquals(o: any): boolean;
        getVanillaPredicate(): Internal.Predicate<Internal.ItemStack>;
        filter(filter: Internal.IngredientJS_): Internal.IngredientJS;
        getEnchantments(): Internal.MapJS;
        getFluidStack(): Internal.FluidStackJS;
        removeNBT(): Internal.ItemStackJS;
        static resultFromRecipeJson(json: Internal.JsonElement_): Internal.ItemStackJS;
        unwrapStackIngredient(): Internal.List<Internal.IngredientJS>;
        testVanilla(other: Internal.ItemStack_): boolean;
        enchant(enchantments: Internal.MapJS_): Internal.ItemStackJS;
        enchant(enchantment: Internal.Enchantment_, level: number): Internal.ItemStackJS;
        equals(o: any): boolean;
        x(c: number): Internal.IngredientJS;
        ignoreNBT(): Internal.IngredientJS;
        getTypeData(): Internal.CompoundTag;
        toString(): string;
        removeChance(): void;
        setNbt(tag: Internal.CompoundTag_): void;
        static readonly EMPTY : Internal.ItemStackJS;
        get nbt(): Internal.CompoundTag;
        get itemStack(): Internal.ItemStack;
        get mod(): string;
        get itemIds(): Internal.Set<string>;
        get vanillaItems(): Internal.Set<Internal.Item>;
        get empty(): boolean;
        get harvestSpeed(): number;
        get typeList(): Internal.ListJS;
        get nbtString(): string;
        get block(): boolean;
        get id(): string;
        get class(): Internal.Class<any>;
        get invalidRecipeIngredient(): boolean;
        get itemGroup(): string;
        get item(): Internal.Item;
        get chance(): number;
        get stacks(): Internal.Set<Internal.ItemStackJS>;
        get count(): number;
        get list(): Internal.List<Internal.ItemStackJS>;
        get enchantments(): Internal.MapJS;
        get typeData(): Internal.CompoundTag;
        get listJS(): Internal.ListJS;
        get tags(): Internal.Collection<ResourceLocation>;
        get name(): Internal.Text;
        get fluidStack(): Internal.FluidStackJS;
        get first(): Internal.ItemStackJS;
        get vanillaPredicate(): Internal.Predicate<Internal.ItemStack>;
        set nbt(tag: Internal.CompoundTag_);
        set chance(c: number);
        set count(count: number);
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    /**
    */
    type ItemStackJS_ = `${string}:${string}` | ItemStackJS;
    interface ILevelEventRedirect {
        setRedirected(arg0: boolean, arg1: Vec3_): void;
    }
    type ILevelEventRedirect_ = ILevelEventRedirect;
    class TextStyle extends Internal.Enum<Internal.TextStyle> {
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        static valueOf(arg0: string): Internal.TextStyle;
        static valueOf<T_>(arg0: Internal.Class_<T_>, arg1: string): T_;
        notifyAll(): void;
        static values(): Internal.TextStyle[];
        compareTo(arg0: Internal.TextStyle_): number;
        describeConstable(): Internal.Optional<Internal.Enum$EnumDesc<Internal.TextStyle>>;
        notify(): void;
        getDeclaringClass(): Internal.Class<Internal.TextStyle>;
        asNormal(): Internal.TextStyle;
        hashCode(): number;
        equals(arg0: any): boolean;
        isStandalone(): boolean;
        name(): string;
        toString(): string;
        asStandalone(): Internal.TextStyle;
        ordinal(): number;
        static readonly SHORT_STANDALONE : Internal.TextStyle;
        static readonly NARROW_STANDALONE : Internal.TextStyle;
        static readonly FULL_STANDALONE : Internal.TextStyle;
        static readonly FULL : Internal.TextStyle;
        static readonly SHORT : Internal.TextStyle;
        static readonly NARROW : Internal.TextStyle;
        get standalone(): boolean;
        get class(): Internal.Class<any>;
        get declaringClass(): Internal.Class<Internal.TextStyle>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    type TextStyle_ = "short_standalone" | "narrow_standalone" | "short" | "narrow" | "full_standalone" | "full" | TextStyle;
    interface AccessorRenderType {
    }
    type AccessorRenderType_ = AccessorRenderType;
    class GlyphJustificationInfo {
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        hashCode(): number;
        notifyAll(): void;
        equals(arg0: any): boolean;
        toString(): string;
        notify(): void;
        readonly growRightLimit : number;
        static readonly PRIORITY_WHITESPACE : 1;
        readonly shrinkLeftLimit : number;
        readonly weight : number;
        readonly shrinkRightLimit : number;
        readonly shrinkAbsorb : boolean;
        readonly growPriority : number;
        static readonly PRIORITY_KASHIDA : 0;
        readonly growAbsorb : boolean;
        static readonly PRIORITY_NONE : 3;
        readonly growLeftLimit : number;
        static readonly PRIORITY_INTERCHAR : 2;
        readonly shrinkPriority : number;
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    type GlyphJustificationInfo_ = GlyphJustificationInfo;
    interface Transparency {
        getTransparency(): number;
    }
    type Transparency_ = Transparency;
    class PageAttributes$ColorType extends Internal.AttributeValue {
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        notifyAll(): void;
        equals(arg0: any): boolean;
        notify(): void;
        static readonly MONOCHROME : Internal.PageAttributes$ColorType;
        static readonly COLOR : Internal.PageAttributes$ColorType;
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    type PageAttributes$ColorType_ = PageAttributes$ColorType;
    class LootContextParam <T> {
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        hashCode(): number;
        notifyAll(): void;
        equals(arg0: any): boolean;
        toString(): string;
        notify(): void;
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    type LootContextParam_<T> = LootContextParam<T>;
    class ConfiguredWorldCarver <WC> extends Internal.Record {
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        hashCode(): number;
        notifyAll(): void;
        equals(arg0: any): boolean;
        toString(): string;
        notify(): void;
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    type ConfiguredWorldCarver_<WC> = ConfiguredWorldCarver<WC>;
    class DynamicPatternEvent extends Internal.EventJS {
        cancel(): void;
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        isCancelled(): boolean;
        post(t: Internal.ScriptType_, id: string, sub: string): boolean;
        post(t: Internal.ScriptType_, id: string): boolean;
        hashCode(): number;
        notifyAll(): void;
        equals(arg0: any): boolean;
        setPattern(arg0: Internal.BlockPattern_): void;
        toString(): string;
        getController(): Internal.ControllerTileEntity;
        notify(): void;
        canCancel(): boolean;
        pattern : Internal.BlockPattern;
        static readonly ID : "mbd.dynamic_pattern";
        get controller(): Internal.ControllerTileEntity;
        get cancelled(): boolean;
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    type DynamicPatternEvent_ = DynamicPatternEvent;
    interface ToNumberStrategy {
        readNumber(arg0: Internal.JsonReader_): Internal.Number;
    }
    type ToNumberStrategy_ = ToNumberStrategy;
    abstract class ImmutableMultisetGwtSerializationDependencies <E> extends Internal.ImmutableCollection<E> {
        add(arg0: E): boolean;
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        spliterator(): Internal.Spliterator<E>;
        forEach(arg0: Internal.Consumer_<E>): void;
        notifyAll(): void;
        containsAll(arg0: Internal.Collection_<any>): boolean;
        isEmpty(): boolean;
        clear(): void;
        notify(): void;
        asList(): Internal.ImmutableList<E>;
        remove(arg0: any): boolean;
        removeIf(arg0: Internal.Predicate_<E>): boolean;
        removeAll(arg0: Internal.Collection_<any>): boolean;
        contains(arg0: any): boolean;
        iterator(): Internal.UnmodifiableIterator<E>;
        size(): number;
        stream(): Internal.Stream<E>;
        addAll(arg0: Internal.Collection_<E>): boolean;
        hashCode(): number;
        equals(arg0: any): boolean;
        toArray(): any[];
        toArray<T_>(arg0: T_[]): T_[];
        toArray<T_>(arg0: Internal.IntFunction_<T_[]>): T_[];
        parallelStream(): Internal.Stream<E>;
        toString(): string;
        retainAll(arg0: Internal.Collection_<any>): boolean;
        get class(): Internal.Class<any>;
        get empty(): boolean;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    type ImmutableMultisetGwtSerializationDependencies_<E> = ImmutableMultisetGwtSerializationDependencies<E>;
    interface PrimitiveIterator <T, T_CONS> extends Internal.Iterator<T> {
        next(): T;
        hasNext(): boolean;
        forEachRemaining(arg0: T_CONS): void;
        forEachRemaining(arg0: Internal.Consumer_<T>): void;
        remove(): void;
    }
    type PrimitiveIterator_<T, T_CONS> = PrimitiveIterator<T, T_CONS>;
    class PopupMenu extends Internal.Menu {
        setName(arg0: string): void;
        getListeners<T_>(arg0: Internal.Class_<T_>): T_[];
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        getName(): string;
        getLabel(): string;
        notifyAll(): void;
        getItemCount(): number;
        show(arg0: java_.awt.Component_, arg1: number, arg2: number): void;
        getItem(arg0: number): Internal.MenuItem;
        insert(arg0: Internal.MenuItem_, arg1: number): void;
        insert(arg0: string, arg1: number): void;
        isTearOff(): boolean;
        getShortcut(): Internal.MenuShortcut;
        notify(): void;
        remove(arg0: number): void;
        remove(arg0: Internal.MenuComponent_): void;
        paramString(): string;
        removeAll(): void;
        removeActionListener(arg0: Internal.ActionListener_): void;
        addSeparator(): void;
        hashCode(): number;
        enable(arg0: boolean): void;
        enable(): void;
        setFont(arg0: Internal.Font_): void;
        setShortcut(arg0: Internal.MenuShortcut_): void;
        add(arg0: Internal.MenuItem_): Internal.MenuItem;
        add(arg0: string): void;
        getParent(): Internal.MenuContainer;
        dispatchEvent(arg0: Internal.AWTEvent_): void;
        deleteShortcut(): void;
        addActionListener(arg0: Internal.ActionListener_): void;
        countItems(): number;
        setActionCommand(arg0: string): void;
        getAccessibleContext(): Internal.AccessibleContext;
        postEvent(arg0: java_.awt.Event_): boolean;
        setEnabled(arg0: boolean): void;
        addNotify(): void;
        disable(): void;
        equals(arg0: any): boolean;
        isEnabled(): boolean;
        getActionListeners(): Internal.ActionListener[];
        setLabel(arg0: string): void;
        removeNotify(): void;
        getFont(): Internal.Font;
        toString(): string;
        getActionCommand(): string;
        insertSeparator(arg0: number): void;
        get accessibleContext(): Internal.AccessibleContext;
        get parent(): Internal.MenuContainer;
        get actionCommand(): string;
        get shortcut(): Internal.MenuShortcut;
        get actionListeners(): Internal.ActionListener[];
        get tearOff(): boolean;
        get name(): string;
        get label(): string;
        get class(): Internal.Class<any>;
        get enabled(): boolean;
        get itemCount(): number;
        get font(): Internal.Font;
        set actionCommand(arg0: string);
        set shortcut(arg0: Internal.MenuShortcut_);
        set name(arg0: string);
        set label(arg0: string);
        set enabled(arg0: boolean);
        set font(arg0: Internal.Font_);
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    type PopupMenu_ = PopupMenu;
    interface PreparableReloadListener {
    }
    type PreparableReloadListener_ = PreparableReloadListener;
    /**
    * Fired when ticking on client side.
    */
    class ClientTickEventJS extends Internal.ClientEventJS {
        cancel(): void;
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        isCancelled(): boolean;
        getPlayer(): Internal.ClientPlayerJS;
        notifyAll(): void;
        getEntity(): Internal.EntityJS;
        notify(): void;
        getLevel(): Internal.ClientLevelJS;
        post(id: string): boolean;
        post(id: string, sub: string): boolean;
        post(t: Internal.ScriptType_, id: string, sub: string): boolean;
        post(t: Internal.ScriptType_, id: string): boolean;
        hashCode(): number;
        equals(arg0: any): boolean;
        toString(): string;
        canCancel(): boolean;
        get level(): Internal.ClientLevelJS;
        get cancelled(): boolean;
        get class(): Internal.Class<any>;
        get entity(): Internal.EntityJS;
        get player(): Internal.ClientPlayerJS;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    /**
    * Fired when ticking on client side.
    */
    type ClientTickEventJS_ = ClientTickEventJS;
    class Field extends Internal.AccessibleObject implements Internal.Member {
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        setByte(arg0: any, arg1: number): void;
        getByte(arg0: any): number;
        getName(): string;
        isAnnotationPresent(arg0: Internal.Class_<Internal.Annotation_>): boolean;
        notifyAll(): void;
        isSynthetic(): boolean;
        getDouble(arg0: any): number;
        setShort(arg0: any, arg1: number): void;
        getFloat(arg0: any): number;
        notify(): void;
        getDeclaredAnnotations(): Internal.Annotation[];
        setDouble(arg0: any, arg1: number): void;
        setChar(arg0: any, arg1: string): void;
        getDeclaringClass(): Internal.Class<any>;
        getAnnotationsByType<T_>(arg0: Internal.Class_<T_>): T_[];
        hashCode(): number;
        canAccess(arg0: any): boolean;
        toGenericString(): string;
        get(arg0: any): any;
        getBoolean(arg0: any): boolean;
        getGenericType(): java_.lang.reflect.Type;
        getModifiers(): number;
        getAnnotatedType(): Internal.AnnotatedType;
        trySetAccessible(): boolean;
        setFloat(arg0: any, arg1: number): void;
        isAccessible(): boolean;
        set(arg0: any, arg1: any): void;
        setAccessible(arg0: boolean): void;
        static setAccessible(arg0: Internal.AccessibleObject_[], arg1: boolean): void;
        getShort(arg0: any): number;
        getAnnotations(): Internal.Annotation[];
        setInt(arg0: any, arg1: number): void;
        getLong(arg0: any): number;
        getInt(arg0: any): number;
        getChar(arg0: any): string;
        setLong(arg0: any, arg1: number): void;
        getDeclaredAnnotationsByType<T_>(arg0: Internal.Class_<T_>): T_[];
        getType(): Internal.Class<any>;
        getAnnotation<T_>(arg0: Internal.Class_<T_>): T_;
        equals(arg0: any): boolean;
        getDeclaredAnnotation<T_>(arg0: Internal.Class_<T_>): T_;
        toString(): string;
        isEnumConstant(): boolean;
        setBoolean(arg0: any, arg1: boolean): void;
        static readonly PUBLIC : 0;
        static readonly DECLARED : 1;
        get synthetic(): boolean;
        get declaredAnnotations(): Internal.Annotation[];
        get accessible(): boolean;
        get annotatedType(): Internal.AnnotatedType;
        get enumConstant(): boolean;
        get name(): string;
        get annotations(): Internal.Annotation[];
        get genericType(): java_.lang.reflect.Type;
        get modifiers(): number;
        get type(): Internal.Class<any>;
        get class(): Internal.Class<any>;
        get declaringClass(): Internal.Class<any>;
        set accessible(arg0: boolean);
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    type Field_ = Field;
    class ItemArmorTierEventJS extends Internal.StartupEventJS {
        cancel(): void;
        add(id: string, parent: string, tier: Internal.Consumer_<Internal.MutableArmorTier_>): void;
        add(id: string, tier: Internal.Consumer_<Internal.MutableArmorTier_>): void;
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        isCancelled(): boolean;
        post(id: string): boolean;
        post(id: string, sub: string): boolean;
        post(t: Internal.ScriptType_, id: string, sub: string): boolean;
        post(t: Internal.ScriptType_, id: string): boolean;
        hashCode(): number;
        notifyAll(): void;
        equals(arg0: any): boolean;
        toString(): string;
        notify(): void;
        canCancel(): boolean;
        get cancelled(): boolean;
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    type ItemArmorTierEventJS_ = ItemArmorTierEventJS;
    class ModuleDescriptor$Version implements Internal.Comparable<Internal.ModuleDescriptor$Version> {
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        hashCode(): number;
        notifyAll(): void;
        equals(arg0: any): boolean;
        toString(): string;
        static parse(arg0: string): Internal.ModuleDescriptor$Version;
        compareTo(arg0: Internal.ModuleDescriptor$Version_): number;
        notify(): void;
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    type ModuleDescriptor$Version_ = ModuleDescriptor$Version;
    abstract class AbstractMultimap <K, V> implements Internal.Multimap<K, V> {
        getClass(): Internal.Class<any>;
        containsEntry(arg0: any, arg1: any): boolean;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        containsKey(arg0: any): boolean;
        forEach(arg0: Internal.BiConsumer_<K, V>): void;
        asMap(): Internal.Map<K, Internal.Collection<V>>;
        keys(): Internal.Multiset<K>;
        notifyAll(): void;
        values(): Internal.Collection<V>;
        clear(): void;
        isEmpty(): boolean;
        replaceValues(arg0: K, arg1: Internal.Iterable_<V>): Internal.Collection<V>;
        notify(): void;
        containsValue(arg0: any): boolean;
        put(arg0: K, arg1: V): boolean;
        remove(arg0: any, arg1: any): boolean;
        removeAll(arg0: any): Internal.Collection<V>;
        entries(): Internal.Collection<Internal.Map$Entry<K, V>>;
        size(): number;
        hashCode(): number;
        get(arg0: K): Internal.Collection<V>;
        putAll(arg0: K, arg1: Internal.Iterable_<V>): boolean;
        putAll(arg0: Internal.Multimap_<K, V>): boolean;
        equals(arg0: any): boolean;
        toString(): string;
        keySet(): Internal.Set<K>;
        get class(): Internal.Class<any>;
        get empty(): boolean;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    type AbstractMultimap_<K, V> = AbstractMultimap<K, V>;
    class ConfigGroup {
        getClass(): Internal.Class<any>;
        addEnum<E>(id: string, value: E, setter: Internal.Consumer_<E>, nameMap: Internal.NameMap_<E>, def: E): Internal.EnumConfig<E>;
        addEnum<E>(id: string, value: E, setter: Internal.Consumer_<E>, nameMap: Internal.NameMap_<E>): Internal.EnumConfig<E>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        getName(): Internal.Component;
        notifyAll(): void;
        save(accepted: boolean): void;
        notify(): void;
        getTooltip(): Internal.Component;
        hashCode(): number;
        getPath(): string;
        addList<E, CV>(id: string, c: Internal.List_<E>, type: CV, def: E): Internal.ListConfig<E, CV>;
        getGroups(): Internal.Collection<Internal.ConfigGroup>;
        addString(id: string, value: string, setter: Internal.Consumer_<string>, def: string): Internal.StringConfig;
        addString(id: string, value: string, setter: Internal.Consumer_<string>, def: string, pattern: Internal.Pattern_): Internal.StringConfig;
        add<T, CV>(id: string, type: CV, value: T, callback: Internal.Consumer_<T>, defaultValue: T): CV;
        getValues(): Internal.Collection<Internal.ConfigValue>;
        addBool(id: string, value: boolean, setter: Internal.Consumer_<boolean>, def: boolean): Internal.BooleanConfig;
        addItemStack(id: string, value: Internal.ItemStack_, setter: Internal.Consumer_<Internal.ItemStack_>, def: Internal.ItemStack_, singleItemOnly: boolean, allowEmpty: boolean): Internal.ItemStackConfig;
        getNameKey(): string;
        addTristate(id: string, value: Internal.Tristate_, setter: Internal.Consumer_<Internal.Tristate_>, def: Internal.Tristate_): Internal.EnumConfig<Internal.Tristate>;
        addTristate(id: string, value: Internal.Tristate_, setter: Internal.Consumer_<Internal.Tristate_>): Internal.EnumConfig<Internal.Tristate>;
        setNameKey(key: string): Internal.ConfigGroup;
        equals(arg0: any): boolean;
        getGroup(id: string): Internal.ConfigGroup;
        toString(): string;
        addInt(id: string, value: number, setter: Internal.Consumer_<number>, def: number, min: number, max: number): Internal.IntConfig;
        addLong(id: string, value: number, setter: Internal.Consumer_<number>, def: number, min: number, max: number): Internal.LongConfig;
        addDouble(id: string, value: number, setter: Internal.Consumer_<number>, def: number, min: number, max: number): Internal.DoubleConfig;
        parent : Internal.ConfigGroup;
        readonly id : string;
        savedCallback : Internal.ConfigCallback;
        get path(): string;
        get nameKey(): string;
        get values(): Internal.Collection<Internal.ConfigValue>;
        get name(): Internal.Component;
        get tooltip(): Internal.Component;
        get groups(): Internal.Collection<Internal.ConfigGroup>;
        get class(): Internal.Class<any>;
        set nameKey(key: string);
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    type ConfigGroup_ = ConfigGroup;
    interface ItemKJS {
        setFoodPropertiesKJS(arg0: Internal.FoodProperties_): void;
        setFireResistantKJS(arg0: boolean): void;
        setMaxDamageKJS(arg0: number): void;
        setItemBuilderKJS(arg0: Internal.ItemBuilder_): void;
        getTypeDataKJS(): Internal.CompoundTag;
        setCraftingRemainderKJS(arg0: Internal.Item_): void;
        setBurnTimeKJS(arg0: number): void;
        setRarityKJS(arg0: Rarity_): void;
        getItemBuilderKJS(): Internal.ItemBuilder;
        setMaxStackSizeKJS(arg0: number): void;
    }
    type ItemKJS_ = ItemKJS;
    interface Short2BooleanFunction extends Internal.Function<number, boolean>, java_.util.function_.IntPredicate {
        getOrDefault(arg0: any, arg1: boolean): boolean;
        getOrDefault(arg0: number, arg1: boolean): boolean;
        andThenShort(arg0: Internal.Boolean2ShortFunction_): Internal.Short2ShortFunction;
        composeByte(arg0: Internal.Byte2ShortFunction_): Internal.Byte2BooleanFunction;
        andThenInt(arg0: Internal.Boolean2IntFunction_): Internal.Short2IntFunction;
        composeReference<T_>(arg0: Internal.Reference2ShortFunction_<T_>): Internal.Reference2BooleanFunction<T_>;
        andThen<T_>(arg0: java_.util.function_.Function_<boolean, T_>): java_.util.function_.Function<number, T_>;
        put(arg0: number, arg1: boolean): boolean;
        remove(arg0: number): boolean;
        remove(arg0: any): boolean;
        defaultReturnValue(): boolean;
        defaultReturnValue(arg0: boolean): void;
        andThenDouble(arg0: Internal.Boolean2DoubleFunction_): Internal.Short2DoubleFunction;
        andThenObject<T_>(arg0: Internal.Boolean2ObjectFunction_<T_>): Internal.Short2ObjectFunction<T_>;
        and(arg0: java_.util.function_.IntPredicate_): java_.util.function_.IntPredicate;
        get(arg0: any): boolean;
        get(arg0: number): boolean;
        andThenLong(arg0: Internal.Boolean2LongFunction_): Internal.Short2LongFunction;
        composeLong(arg0: Internal.Long2ShortFunction_): Internal.Long2BooleanFunction;
        andThenByte(arg0: Internal.Boolean2ByteFunction_): Internal.Short2ByteFunction;
        andThenFloat(arg0: Internal.Boolean2FloatFunction_): Internal.Short2FloatFunction;
        or(arg0: java_.util.function_.IntPredicate_): java_.util.function_.IntPredicate;
        test(arg0: number): boolean;
        apply(arg0: number): boolean;
        containsKey(arg0: number): boolean;
        containsKey(arg0: any): boolean;
        composeInt(arg0: Internal.Int2ShortFunction_): Internal.Int2BooleanFunction;
        clear(): void;
        composeFloat(arg0: Internal.Float2ShortFunction_): Internal.Float2BooleanFunction;
        andThenChar(arg0: Internal.Boolean2CharFunction_): Internal.Short2CharFunction;
        composeObject<T_>(arg0: Internal.Object2ShortFunction_<T_>): Internal.Object2BooleanFunction<T_>;
        size(): number;
        compose<T_>(arg0: java_.util.function_.Function_<T_, number>): java_.util.function_.Function<T_, boolean>;
        negate(): java_.util.function_.IntPredicate;
        composeShort(arg0: Internal.Short2ShortFunction_): Internal.Short2BooleanFunction;
        andThenReference<T_>(arg0: Internal.Boolean2ReferenceFunction_<T_>): Internal.Short2ReferenceFunction<T_>;
        composeChar(arg0: Internal.Char2ShortFunction_): Internal.Char2BooleanFunction;
        composeDouble(arg0: Internal.Double2ShortFunction_): Internal.Double2BooleanFunction;
    }
    type Short2BooleanFunction_ = ((arg0: number) => boolean) | Short2BooleanFunction;
    class CoderResult {
        static malformedForLength(arg0: number): Internal.CoderResult;
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        isMalformed(): boolean;
        isOverflow(): boolean;
        notifyAll(): void;
        isUnmappable(): boolean;
        length(): number;
        throwException(): void;
        notify(): void;
        isError(): boolean;
        static unmappableForLength(arg0: number): Internal.CoderResult;
        hashCode(): number;
        equals(arg0: any): boolean;
        isUnderflow(): boolean;
        toString(): string;
        static readonly OVERFLOW : Internal.CoderResult;
        static readonly UNDERFLOW : Internal.CoderResult;
        get underflow(): boolean;
        get overflow(): boolean;
        get unmappable(): boolean;
        get error(): boolean;
        get class(): Internal.Class<any>;
        get malformed(): boolean;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    type CoderResult_ = CoderResult;
    class LinkedHashMap <K, V> extends Internal.HashMap<K, V> implements Internal.Map<K, V> {
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        getOrDefault(arg0: any, arg1: V): V;
        notifyAll(): void;
        computeIfAbsent(arg0: K, arg1: java_.util.function_.Function_<K, V>): V;
        values(): Internal.Collection<V>;
        replace(arg0: K, arg1: V): V;
        replace(arg0: K, arg1: V, arg2: V): boolean;
        replaceAll(arg0: Internal.BiFunction_<K, V, V>): void;
        notify(): void;
        put(arg0: K, arg1: V): V;
        remove(arg0: any, arg1: any): boolean;
        remove(arg0: any): V;
        containsValue(arg0: any): boolean;
        compute(arg0: K, arg1: Internal.BiFunction_<K, V, V>): V;
        hashCode(): number;
        putAll(arg0: Internal.Map_<K, V>): void;
        merge(arg0: K, arg1: V, arg2: Internal.BiFunction_<V, V, V>): V;
        get(arg0: any): V;
        keySet(): Internal.Set<K>;
        entrySet(): Internal.Set<Internal.Map$Entry<K, V>>;
        containsKey(arg0: any): boolean;
        forEach(arg0: Internal.BiConsumer_<K, V>): void;
        isEmpty(): boolean;
        clear(): void;
        computeIfPresent(arg0: K, arg1: Internal.BiFunction_<K, V, V>): V;
        size(): number;
        equals(arg0: any): boolean;
        clone(): any;
        toString(): string;
        putIfAbsent(arg0: K, arg1: V): V;
        get class(): Internal.Class<any>;
        get empty(): boolean;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    type LinkedHashMap_<K, V> = LinkedHashMap<K, V>;
    interface Applicative <F, Mu> extends Internal.Functor<F, Mu> {
        point<A_>(arg0: A_): Internal.App<Mu, A_>;
        map<T_, R_>(arg0: java_.util.function_.Function_<T_, R_>, arg1: Internal.App_<Mu, T_>): Internal.App<Mu, R_>;
        group<T1_, T2_, T3_, T4_, T5_, T6_, T7_, T8_, T9_, T10_, T11_>(arg0: Internal.App_<Mu, T1_>, arg1: Internal.App_<Mu, T2_>, arg2: Internal.App_<Mu, T3_>, arg3: Internal.App_<Mu, T4_>, arg4: Internal.App_<Mu, T5_>, arg5: Internal.App_<Mu, T6_>, arg6: Internal.App_<Mu, T7_>, arg7: Internal.App_<Mu, T8_>, arg8: Internal.App_<Mu, T9_>, arg9: Internal.App_<Mu, T10_>, arg10: Internal.App_<Mu, T11_>): Internal.Products$P11<Mu, T1_, T2_, T3_, T4_, T5_, T6_, T7_, T8_, T9_, T10_, T11_>;
        group<T1_, T2_, T3_, T4_, T5_, T6_, T7_, T8_, T9_, T10_>(arg0: Internal.App_<Mu, T1_>, arg1: Internal.App_<Mu, T2_>, arg2: Internal.App_<Mu, T3_>, arg3: Internal.App_<Mu, T4_>, arg4: Internal.App_<Mu, T5_>, arg5: Internal.App_<Mu, T6_>, arg6: Internal.App_<Mu, T7_>, arg7: Internal.App_<Mu, T8_>, arg8: Internal.App_<Mu, T9_>, arg9: Internal.App_<Mu, T10_>): Internal.Products$P10<Mu, T1_, T2_, T3_, T4_, T5_, T6_, T7_, T8_, T9_, T10_>;
        group<T1_, T2_, T3_, T4_, T5_, T6_, T7_, T8_, T9_>(arg0: Internal.App_<Mu, T1_>, arg1: Internal.App_<Mu, T2_>, arg2: Internal.App_<Mu, T3_>, arg3: Internal.App_<Mu, T4_>, arg4: Internal.App_<Mu, T5_>, arg5: Internal.App_<Mu, T6_>, arg6: Internal.App_<Mu, T7_>, arg7: Internal.App_<Mu, T8_>, arg8: Internal.App_<Mu, T9_>): Internal.Products$P9<Mu, T1_, T2_, T3_, T4_, T5_, T6_, T7_, T8_, T9_>;
        group<T1_, T2_, T3_, T4_, T5_, T6_, T7_, T8_, T9_, T10_, T11_, T12_, T13_, T14_, T15_, T16_>(arg0: Internal.App_<Mu, T1_>, arg1: Internal.App_<Mu, T2_>, arg2: Internal.App_<Mu, T3_>, arg3: Internal.App_<Mu, T4_>, arg4: Internal.App_<Mu, T5_>, arg5: Internal.App_<Mu, T6_>, arg6: Internal.App_<Mu, T7_>, arg7: Internal.App_<Mu, T8_>, arg8: Internal.App_<Mu, T9_>, arg9: Internal.App_<Mu, T10_>, arg10: Internal.App_<Mu, T11_>, arg11: Internal.App_<Mu, T12_>, arg12: Internal.App_<Mu, T13_>, arg13: Internal.App_<Mu, T14_>, arg14: Internal.App_<Mu, T15_>, arg15: Internal.App_<Mu, T16_>): Internal.Products$P16<Mu, T1_, T2_, T3_, T4_, T5_, T6_, T7_, T8_, T9_, T10_, T11_, T12_, T13_, T14_, T15_, T16_>;
        group<T1_, T2_, T3_, T4_, T5_, T6_, T7_, T8_, T9_, T10_, T11_, T12_, T13_, T14_, T15_>(arg0: Internal.App_<Mu, T1_>, arg1: Internal.App_<Mu, T2_>, arg2: Internal.App_<Mu, T3_>, arg3: Internal.App_<Mu, T4_>, arg4: Internal.App_<Mu, T5_>, arg5: Internal.App_<Mu, T6_>, arg6: Internal.App_<Mu, T7_>, arg7: Internal.App_<Mu, T8_>, arg8: Internal.App_<Mu, T9_>, arg9: Internal.App_<Mu, T10_>, arg10: Internal.App_<Mu, T11_>, arg11: Internal.App_<Mu, T12_>, arg12: Internal.App_<Mu, T13_>, arg13: Internal.App_<Mu, T14_>, arg14: Internal.App_<Mu, T15_>): Internal.Products$P15<Mu, T1_, T2_, T3_, T4_, T5_, T6_, T7_, T8_, T9_, T10_, T11_, T12_, T13_, T14_, T15_>;
        group<T1_, T2_, T3_, T4_, T5_, T6_, T7_, T8_, T9_, T10_, T11_, T12_, T13_, T14_>(arg0: Internal.App_<Mu, T1_>, arg1: Internal.App_<Mu, T2_>, arg2: Internal.App_<Mu, T3_>, arg3: Internal.App_<Mu, T4_>, arg4: Internal.App_<Mu, T5_>, arg5: Internal.App_<Mu, T6_>, arg6: Internal.App_<Mu, T7_>, arg7: Internal.App_<Mu, T8_>, arg8: Internal.App_<Mu, T9_>, arg9: Internal.App_<Mu, T10_>, arg10: Internal.App_<Mu, T11_>, arg11: Internal.App_<Mu, T12_>, arg12: Internal.App_<Mu, T13_>, arg13: Internal.App_<Mu, T14_>): Internal.Products$P14<Mu, T1_, T2_, T3_, T4_, T5_, T6_, T7_, T8_, T9_, T10_, T11_, T12_, T13_, T14_>;
        group<T1_, T2_, T3_, T4_, T5_, T6_, T7_, T8_, T9_, T10_, T11_, T12_, T13_>(arg0: Internal.App_<Mu, T1_>, arg1: Internal.App_<Mu, T2_>, arg2: Internal.App_<Mu, T3_>, arg3: Internal.App_<Mu, T4_>, arg4: Internal.App_<Mu, T5_>, arg5: Internal.App_<Mu, T6_>, arg6: Internal.App_<Mu, T7_>, arg7: Internal.App_<Mu, T8_>, arg8: Internal.App_<Mu, T9_>, arg9: Internal.App_<Mu, T10_>, arg10: Internal.App_<Mu, T11_>, arg11: Internal.App_<Mu, T12_>, arg12: Internal.App_<Mu, T13_>): Internal.Products$P13<Mu, T1_, T2_, T3_, T4_, T5_, T6_, T7_, T8_, T9_, T10_, T11_, T12_, T13_>;
        group<T1_, T2_, T3_, T4_, T5_, T6_, T7_, T8_, T9_, T10_, T11_, T12_>(arg0: Internal.App_<Mu, T1_>, arg1: Internal.App_<Mu, T2_>, arg2: Internal.App_<Mu, T3_>, arg3: Internal.App_<Mu, T4_>, arg4: Internal.App_<Mu, T5_>, arg5: Internal.App_<Mu, T6_>, arg6: Internal.App_<Mu, T7_>, arg7: Internal.App_<Mu, T8_>, arg8: Internal.App_<Mu, T9_>, arg9: Internal.App_<Mu, T10_>, arg10: Internal.App_<Mu, T11_>, arg11: Internal.App_<Mu, T12_>): Internal.Products$P12<Mu, T1_, T2_, T3_, T4_, T5_, T6_, T7_, T8_, T9_, T10_, T11_, T12_>;
        group<T1_, T2_, T3_>(arg0: Internal.App_<Mu, T1_>, arg1: Internal.App_<Mu, T2_>, arg2: Internal.App_<Mu, T3_>): Internal.Products$P3<Mu, T1_, T2_, T3_>;
        group<T1_, T2_>(arg0: Internal.App_<Mu, T1_>, arg1: Internal.App_<Mu, T2_>): Internal.Products$P2<Mu, T1_, T2_>;
        group<T1_>(arg0: Internal.App_<Mu, T1_>): Internal.Products$P1<Mu, T1_>;
        group<T1_, T2_, T3_, T4_, T5_, T6_, T7_, T8_>(arg0: Internal.App_<Mu, T1_>, arg1: Internal.App_<Mu, T2_>, arg2: Internal.App_<Mu, T3_>, arg3: Internal.App_<Mu, T4_>, arg4: Internal.App_<Mu, T5_>, arg5: Internal.App_<Mu, T6_>, arg6: Internal.App_<Mu, T7_>, arg7: Internal.App_<Mu, T8_>): Internal.Products$P8<Mu, T1_, T2_, T3_, T4_, T5_, T6_, T7_, T8_>;
        group<T1_, T2_, T3_, T4_, T5_, T6_, T7_>(arg0: Internal.App_<Mu, T1_>, arg1: Internal.App_<Mu, T2_>, arg2: Internal.App_<Mu, T3_>, arg3: Internal.App_<Mu, T4_>, arg4: Internal.App_<Mu, T5_>, arg5: Internal.App_<Mu, T6_>, arg6: Internal.App_<Mu, T7_>): Internal.Products$P7<Mu, T1_, T2_, T3_, T4_, T5_, T6_, T7_>;
        group<T1_, T2_, T3_, T4_, T5_, T6_>(arg0: Internal.App_<Mu, T1_>, arg1: Internal.App_<Mu, T2_>, arg2: Internal.App_<Mu, T3_>, arg3: Internal.App_<Mu, T4_>, arg4: Internal.App_<Mu, T5_>, arg5: Internal.App_<Mu, T6_>): Internal.Products$P6<Mu, T1_, T2_, T3_, T4_, T5_, T6_>;
        group<T1_, T2_, T3_, T4_, T5_>(arg0: Internal.App_<Mu, T1_>, arg1: Internal.App_<Mu, T2_>, arg2: Internal.App_<Mu, T3_>, arg3: Internal.App_<Mu, T4_>, arg4: Internal.App_<Mu, T5_>): Internal.Products$P5<Mu, T1_, T2_, T3_, T4_, T5_>;
        group<T1_, T2_, T3_, T4_>(arg0: Internal.App_<Mu, T1_>, arg1: Internal.App_<Mu, T2_>, arg2: Internal.App_<Mu, T3_>, arg3: Internal.App_<Mu, T4_>): Internal.Products$P4<Mu, T1_, T2_, T3_, T4_>;
        apply2<A_, B_, R_>(arg0: Internal.BiFunction_<A_, B_, R_>, arg1: Internal.App_<Mu, A_>, arg2: Internal.App_<Mu, B_>): Internal.App<Mu, R_>;
        apply3<T1_, T2_, T3_, R_>(arg0: Internal.Function3_<T1_, T2_, T3_, R_>, arg1: Internal.App_<Mu, T1_>, arg2: Internal.App_<Mu, T2_>, arg3: Internal.App_<Mu, T3_>): Internal.App<Mu, R_>;
        ap2<A_, B_, R_>(arg0: Internal.App_<Mu, Internal.BiFunction_<A_, B_, R_>>, arg1: Internal.App_<Mu, A_>, arg2: Internal.App_<Mu, B_>): Internal.App<Mu, R_>;
        ap11<T1_, T2_, T3_, T4_, T5_, T6_, T7_, T8_, T9_, T10_, T11_, R_>(arg0: Internal.App_<Mu, Internal.Function11_<T1_, T2_, T3_, T4_, T5_, T6_, T7_, T8_, T9_, T10_, T11_, R_>>, arg1: Internal.App_<Mu, T1_>, arg2: Internal.App_<Mu, T2_>, arg3: Internal.App_<Mu, T3_>, arg4: Internal.App_<Mu, T4_>, arg5: Internal.App_<Mu, T5_>, arg6: Internal.App_<Mu, T6_>, arg7: Internal.App_<Mu, T7_>, arg8: Internal.App_<Mu, T8_>, arg9: Internal.App_<Mu, T9_>, arg10: Internal.App_<Mu, T10_>, arg11: Internal.App_<Mu, T11_>): Internal.App<Mu, R_>;
        apply4<T1_, T2_, T3_, T4_, R_>(arg0: Internal.Function4_<T1_, T2_, T3_, T4_, R_>, arg1: Internal.App_<Mu, T1_>, arg2: Internal.App_<Mu, T2_>, arg3: Internal.App_<Mu, T3_>, arg4: Internal.App_<Mu, T4_>): Internal.App<Mu, R_>;
        ap10<T1_, T2_, T3_, T4_, T5_, T6_, T7_, T8_, T9_, T10_, R_>(arg0: Internal.App_<Mu, Internal.Function10_<T1_, T2_, T3_, T4_, T5_, T6_, T7_, T8_, T9_, T10_, R_>>, arg1: Internal.App_<Mu, T1_>, arg2: Internal.App_<Mu, T2_>, arg3: Internal.App_<Mu, T3_>, arg4: Internal.App_<Mu, T4_>, arg5: Internal.App_<Mu, T5_>, arg6: Internal.App_<Mu, T6_>, arg7: Internal.App_<Mu, T7_>, arg8: Internal.App_<Mu, T8_>, arg9: Internal.App_<Mu, T9_>, arg10: Internal.App_<Mu, T10_>): Internal.App<Mu, R_>;
        apply5<T1_, T2_, T3_, T4_, T5_, R_>(arg0: Internal.Function5_<T1_, T2_, T3_, T4_, T5_, R_>, arg1: Internal.App_<Mu, T1_>, arg2: Internal.App_<Mu, T2_>, arg3: Internal.App_<Mu, T3_>, arg4: Internal.App_<Mu, T4_>, arg5: Internal.App_<Mu, T5_>): Internal.App<Mu, R_>;
        ap4<T1_, T2_, T3_, T4_, R_>(arg0: Internal.App_<Mu, Internal.Function4_<T1_, T2_, T3_, T4_, R_>>, arg1: Internal.App_<Mu, T1_>, arg2: Internal.App_<Mu, T2_>, arg3: Internal.App_<Mu, T3_>, arg4: Internal.App_<Mu, T4_>): Internal.App<Mu, R_>;
        lift2<A_, B_, R_>(arg0: Internal.App_<Mu, Internal.BiFunction_<A_, B_, R_>>): Internal.BiFunction<Internal.App<Mu, A_>, Internal.App<Mu, B_>, Internal.App<Mu, R_>>;
        ap3<T1_, T2_, T3_, R_>(arg0: Internal.App_<Mu, Internal.Function3_<T1_, T2_, T3_, R_>>, arg1: Internal.App_<Mu, T1_>, arg2: Internal.App_<Mu, T2_>, arg3: Internal.App_<Mu, T3_>): Internal.App<Mu, R_>;
        lift1<A_, R_>(arg0: Internal.App_<Mu, java_.util.function_.Function_<A_, R_>>): java_.util.function_.Function<Internal.App<Mu, A_>, Internal.App<Mu, R_>>;
        ap6<T1_, T2_, T3_, T4_, T5_, T6_, R_>(arg0: Internal.App_<Mu, Internal.Function6_<T1_, T2_, T3_, T4_, T5_, T6_, R_>>, arg1: Internal.App_<Mu, T1_>, arg2: Internal.App_<Mu, T2_>, arg3: Internal.App_<Mu, T3_>, arg4: Internal.App_<Mu, T4_>, arg5: Internal.App_<Mu, T5_>, arg6: Internal.App_<Mu, T6_>): Internal.App<Mu, R_>;
        ap5<T1_, T2_, T3_, T4_, T5_, R_>(arg0: Internal.App_<Mu, Internal.Function5_<T1_, T2_, T3_, T4_, T5_, R_>>, arg1: Internal.App_<Mu, T1_>, arg2: Internal.App_<Mu, T2_>, arg3: Internal.App_<Mu, T3_>, arg4: Internal.App_<Mu, T4_>, arg5: Internal.App_<Mu, T5_>): Internal.App<Mu, R_>;
        ap8<T1_, T2_, T3_, T4_, T5_, T6_, T7_, T8_, R_>(arg0: Internal.App_<Mu, Internal.Function8_<T1_, T2_, T3_, T4_, T5_, T6_, T7_, T8_, R_>>, arg1: Internal.App_<Mu, T1_>, arg2: Internal.App_<Mu, T2_>, arg3: Internal.App_<Mu, T3_>, arg4: Internal.App_<Mu, T4_>, arg5: Internal.App_<Mu, T5_>, arg6: Internal.App_<Mu, T6_>, arg7: Internal.App_<Mu, T7_>, arg8: Internal.App_<Mu, T8_>): Internal.App<Mu, R_>;
        lift6<T1_, T2_, T3_, T4_, T5_, T6_, R_>(arg0: Internal.App_<Mu, Internal.Function6_<T1_, T2_, T3_, T4_, T5_, T6_, R_>>): Internal.Function6<Internal.App<Mu, T1_>, Internal.App<Mu, T2_>, Internal.App<Mu, T3_>, Internal.App<Mu, T4_>, Internal.App<Mu, T5_>, Internal.App<Mu, T6_>, Internal.App<Mu, R_>>;
        ap7<T1_, T2_, T3_, T4_, T5_, T6_, T7_, R_>(arg0: Internal.App_<Mu, Internal.Function7_<T1_, T2_, T3_, T4_, T5_, T6_, T7_, R_>>, arg1: Internal.App_<Mu, T1_>, arg2: Internal.App_<Mu, T2_>, arg3: Internal.App_<Mu, T3_>, arg4: Internal.App_<Mu, T4_>, arg5: Internal.App_<Mu, T5_>, arg6: Internal.App_<Mu, T6_>, arg7: Internal.App_<Mu, T7_>): Internal.App<Mu, R_>;
        lift5<T1_, T2_, T3_, T4_, T5_, R_>(arg0: Internal.App_<Mu, Internal.Function5_<T1_, T2_, T3_, T4_, T5_, R_>>): Internal.Function5<Internal.App<Mu, T1_>, Internal.App<Mu, T2_>, Internal.App<Mu, T3_>, Internal.App<Mu, T4_>, Internal.App<Mu, T5_>, Internal.App<Mu, R_>>;
        lift4<T1_, T2_, T3_, T4_, R_>(arg0: Internal.App_<Mu, Internal.Function4_<T1_, T2_, T3_, T4_, R_>>): Internal.Function4<Internal.App<Mu, T1_>, Internal.App<Mu, T2_>, Internal.App<Mu, T3_>, Internal.App<Mu, T4_>, Internal.App<Mu, R_>>;
        ap9<T1_, T2_, T3_, T4_, T5_, T6_, T7_, T8_, T9_, R_>(arg0: Internal.App_<Mu, Internal.Function9_<T1_, T2_, T3_, T4_, T5_, T6_, T7_, T8_, T9_, R_>>, arg1: Internal.App_<Mu, T1_>, arg2: Internal.App_<Mu, T2_>, arg3: Internal.App_<Mu, T3_>, arg4: Internal.App_<Mu, T4_>, arg5: Internal.App_<Mu, T5_>, arg6: Internal.App_<Mu, T6_>, arg7: Internal.App_<Mu, T7_>, arg8: Internal.App_<Mu, T8_>, arg9: Internal.App_<Mu, T9_>): Internal.App<Mu, R_>;
        lift3<T1_, T2_, T3_, R_>(arg0: Internal.App_<Mu, Internal.Function3_<T1_, T2_, T3_, R_>>): Internal.Function3<Internal.App<Mu, T1_>, Internal.App<Mu, T2_>, Internal.App<Mu, T3_>, Internal.App<Mu, R_>>;
        apply6<T1_, T2_, T3_, T4_, T5_, T6_, R_>(arg0: Internal.Function6_<T1_, T2_, T3_, T4_, T5_, T6_, R_>, arg1: Internal.App_<Mu, T1_>, arg2: Internal.App_<Mu, T2_>, arg3: Internal.App_<Mu, T3_>, arg4: Internal.App_<Mu, T4_>, arg5: Internal.App_<Mu, T5_>, arg6: Internal.App_<Mu, T6_>): Internal.App<Mu, R_>;
        apply7<T1_, T2_, T3_, T4_, T5_, T6_, T7_, R_>(arg0: Internal.Function7_<T1_, T2_, T3_, T4_, T5_, T6_, T7_, R_>, arg1: Internal.App_<Mu, T1_>, arg2: Internal.App_<Mu, T2_>, arg3: Internal.App_<Mu, T3_>, arg4: Internal.App_<Mu, T4_>, arg5: Internal.App_<Mu, T5_>, arg6: Internal.App_<Mu, T6_>, arg7: Internal.App_<Mu, T7_>): Internal.App<Mu, R_>;
        lift9<T1_, T2_, T3_, T4_, T5_, T6_, T7_, T8_, T9_, R_>(arg0: Internal.App_<Mu, Internal.Function9_<T1_, T2_, T3_, T4_, T5_, T6_, T7_, T8_, T9_, R_>>): Internal.Function9<Internal.App<Mu, T1_>, Internal.App<Mu, T2_>, Internal.App<Mu, T3_>, Internal.App<Mu, T4_>, Internal.App<Mu, T5_>, Internal.App<Mu, T6_>, Internal.App<Mu, T7_>, Internal.App<Mu, T8_>, Internal.App<Mu, T9_>, Internal.App<Mu, R_>>;
        apply8<T1_, T2_, T3_, T4_, T5_, T6_, T7_, T8_, R_>(arg0: Internal.Function8_<T1_, T2_, T3_, T4_, T5_, T6_, T7_, T8_, R_>, arg1: Internal.App_<Mu, T1_>, arg2: Internal.App_<Mu, T2_>, arg3: Internal.App_<Mu, T3_>, arg4: Internal.App_<Mu, T4_>, arg5: Internal.App_<Mu, T5_>, arg6: Internal.App_<Mu, T6_>, arg7: Internal.App_<Mu, T7_>, arg8: Internal.App_<Mu, T8_>): Internal.App<Mu, R_>;
        lift8<T1_, T2_, T3_, T4_, T5_, T6_, T7_, T8_, R_>(arg0: Internal.App_<Mu, Internal.Function8_<T1_, T2_, T3_, T4_, T5_, T6_, T7_, T8_, R_>>): Internal.Function8<Internal.App<Mu, T1_>, Internal.App<Mu, T2_>, Internal.App<Mu, T3_>, Internal.App<Mu, T4_>, Internal.App<Mu, T5_>, Internal.App<Mu, T6_>, Internal.App<Mu, T7_>, Internal.App<Mu, T8_>, Internal.App<Mu, R_>>;
        apply9<T1_, T2_, T3_, T4_, T5_, T6_, T7_, T8_, T9_, R_>(arg0: Internal.Function9_<T1_, T2_, T3_, T4_, T5_, T6_, T7_, T8_, T9_, R_>, arg1: Internal.App_<Mu, T1_>, arg2: Internal.App_<Mu, T2_>, arg3: Internal.App_<Mu, T3_>, arg4: Internal.App_<Mu, T4_>, arg5: Internal.App_<Mu, T5_>, arg6: Internal.App_<Mu, T6_>, arg7: Internal.App_<Mu, T7_>, arg8: Internal.App_<Mu, T8_>, arg9: Internal.App_<Mu, T9_>): Internal.App<Mu, R_>;
        lift7<T1_, T2_, T3_, T4_, T5_, T6_, T7_, R_>(arg0: Internal.App_<Mu, Internal.Function7_<T1_, T2_, T3_, T4_, T5_, T6_, T7_, R_>>): Internal.Function7<Internal.App<Mu, T1_>, Internal.App<Mu, T2_>, Internal.App<Mu, T3_>, Internal.App<Mu, T4_>, Internal.App<Mu, T5_>, Internal.App<Mu, T6_>, Internal.App<Mu, T7_>, Internal.App<Mu, R_>>;
        ap<A_, R_>(arg0: Internal.App_<Mu, java_.util.function_.Function_<A_, R_>>, arg1: Internal.App_<Mu, A_>): Internal.App<Mu, R_>;
        ap<A_, R_>(arg0: java_.util.function_.Function_<A_, R_>, arg1: Internal.App_<Mu, A_>): Internal.App<Mu, R_>;
        ap16<T1_, T2_, T3_, T4_, T5_, T6_, T7_, T8_, T9_, T10_, T11_, T12_, T13_, T14_, T15_, T16_, R_>(arg0: Internal.App_<Mu, Internal.Function16_<T1_, T2_, T3_, T4_, T5_, T6_, T7_, T8_, T9_, T10_, T11_, T12_, T13_, T14_, T15_, T16_, R_>>, arg1: Internal.App_<Mu, T1_>, arg2: Internal.App_<Mu, T2_>, arg3: Internal.App_<Mu, T3_>, arg4: Internal.App_<Mu, T4_>, arg5: Internal.App_<Mu, T5_>, arg6: Internal.App_<Mu, T6_>, arg7: Internal.App_<Mu, T7_>, arg8: Internal.App_<Mu, T8_>, arg9: Internal.App_<Mu, T9_>, arg10: Internal.App_<Mu, T10_>, arg11: Internal.App_<Mu, T11_>, arg12: Internal.App_<Mu, T12_>, arg13: Internal.App_<Mu, T13_>, arg14: Internal.App_<Mu, T14_>, arg15: Internal.App_<Mu, T15_>, arg16: Internal.App_<Mu, T16_>): Internal.App<Mu, R_>;
        ap13<T1_, T2_, T3_, T4_, T5_, T6_, T7_, T8_, T9_, T10_, T11_, T12_, T13_, R_>(arg0: Internal.App_<Mu, Internal.Function13_<T1_, T2_, T3_, T4_, T5_, T6_, T7_, T8_, T9_, T10_, T11_, T12_, T13_, R_>>, arg1: Internal.App_<Mu, T1_>, arg2: Internal.App_<Mu, T2_>, arg3: Internal.App_<Mu, T3_>, arg4: Internal.App_<Mu, T4_>, arg5: Internal.App_<Mu, T5_>, arg6: Internal.App_<Mu, T6_>, arg7: Internal.App_<Mu, T7_>, arg8: Internal.App_<Mu, T8_>, arg9: Internal.App_<Mu, T9_>, arg10: Internal.App_<Mu, T10_>, arg11: Internal.App_<Mu, T11_>, arg12: Internal.App_<Mu, T12_>, arg13: Internal.App_<Mu, T13_>): Internal.App<Mu, R_>;
        ap12<T1_, T2_, T3_, T4_, T5_, T6_, T7_, T8_, T9_, T10_, T11_, T12_, R_>(arg0: Internal.App_<Mu, Internal.Function12_<T1_, T2_, T3_, T4_, T5_, T6_, T7_, T8_, T9_, T10_, T11_, T12_, R_>>, arg1: Internal.App_<Mu, T1_>, arg2: Internal.App_<Mu, T2_>, arg3: Internal.App_<Mu, T3_>, arg4: Internal.App_<Mu, T4_>, arg5: Internal.App_<Mu, T5_>, arg6: Internal.App_<Mu, T6_>, arg7: Internal.App_<Mu, T7_>, arg8: Internal.App_<Mu, T8_>, arg9: Internal.App_<Mu, T9_>, arg10: Internal.App_<Mu, T10_>, arg11: Internal.App_<Mu, T11_>, arg12: Internal.App_<Mu, T12_>): Internal.App<Mu, R_>;
        ap15<T1_, T2_, T3_, T4_, T5_, T6_, T7_, T8_, T9_, T10_, T11_, T12_, T13_, T14_, T15_, R_>(arg0: Internal.App_<Mu, Internal.Function15_<T1_, T2_, T3_, T4_, T5_, T6_, T7_, T8_, T9_, T10_, T11_, T12_, T13_, T14_, T15_, R_>>, arg1: Internal.App_<Mu, T1_>, arg2: Internal.App_<Mu, T2_>, arg3: Internal.App_<Mu, T3_>, arg4: Internal.App_<Mu, T4_>, arg5: Internal.App_<Mu, T5_>, arg6: Internal.App_<Mu, T6_>, arg7: Internal.App_<Mu, T7_>, arg8: Internal.App_<Mu, T8_>, arg9: Internal.App_<Mu, T9_>, arg10: Internal.App_<Mu, T10_>, arg11: Internal.App_<Mu, T11_>, arg12: Internal.App_<Mu, T12_>, arg13: Internal.App_<Mu, T13_>, arg14: Internal.App_<Mu, T14_>, arg15: Internal.App_<Mu, T15_>): Internal.App<Mu, R_>;
        ap14<T1_, T2_, T3_, T4_, T5_, T6_, T7_, T8_, T9_, T10_, T11_, T12_, T13_, T14_, R_>(arg0: Internal.App_<Mu, Internal.Function14_<T1_, T2_, T3_, T4_, T5_, T6_, T7_, T8_, T9_, T10_, T11_, T12_, T13_, T14_, R_>>, arg1: Internal.App_<Mu, T1_>, arg2: Internal.App_<Mu, T2_>, arg3: Internal.App_<Mu, T3_>, arg4: Internal.App_<Mu, T4_>, arg5: Internal.App_<Mu, T5_>, arg6: Internal.App_<Mu, T6_>, arg7: Internal.App_<Mu, T7_>, arg8: Internal.App_<Mu, T8_>, arg9: Internal.App_<Mu, T9_>, arg10: Internal.App_<Mu, T10_>, arg11: Internal.App_<Mu, T11_>, arg12: Internal.App_<Mu, T12_>, arg13: Internal.App_<Mu, T13_>, arg14: Internal.App_<Mu, T14_>): Internal.App<Mu, R_>;
    }
    type Applicative_<F, Mu> = Applicative<F, Mu>;
    interface Float2ObjectFunction <V> extends Internal.Function<number, V>, Internal.DoubleFunction<V> {
        getOrDefault(arg0: number, arg1: V): V;
        getOrDefault(arg0: any, arg1: V): V;
        andThenShort(arg0: Internal.Object2ShortFunction_<V>): Internal.Float2ShortFunction;
        composeByte(arg0: Internal.Byte2FloatFunction_): Internal.Byte2ObjectFunction<V>;
        andThenInt(arg0: Internal.Object2IntFunction_<V>): Internal.Float2IntFunction;
        andThen<V_>(arg0: java_.util.function_.Function_<V, V_>): java_.util.function_.Function<number, V_>;
        composeReference<T_>(arg0: Internal.Reference2FloatFunction_<T_>): Internal.Reference2ObjectFunction<T_, V>;
        put(arg0: number, arg1: V): V;
        remove(arg0: any): V;
        remove(arg0: number): V;
        defaultReturnValue(arg0: V): void;
        defaultReturnValue(): V;
        andThenDouble(arg0: Internal.Object2DoubleFunction_<V>): Internal.Float2DoubleFunction;
        andThenObject<T_>(arg0: Internal.Object2ObjectFunction_<V, T_>): Internal.Float2ObjectFunction<T_>;
        get(arg0: any): V;
        get(arg0: number): V;
        andThenLong(arg0: Internal.Object2LongFunction_<V>): Internal.Float2LongFunction;
        composeLong(arg0: Internal.Long2FloatFunction_): Internal.Long2ObjectFunction<V>;
        andThenByte(arg0: Internal.Object2ByteFunction_<V>): Internal.Float2ByteFunction;
        andThenFloat(arg0: Internal.Object2FloatFunction_<V>): Internal.Float2FloatFunction;
        apply(arg0: number): V;
        containsKey(arg0: any): boolean;
        containsKey(arg0: number): boolean;
        composeInt(arg0: Internal.Int2FloatFunction_): Internal.Int2ObjectFunction<V>;
        clear(): void;
        composeFloat(arg0: Internal.Float2FloatFunction_): Internal.Float2ObjectFunction<V>;
        andThenChar(arg0: Internal.Object2CharFunction_<V>): Internal.Float2CharFunction;
        composeObject<T_>(arg0: Internal.Object2FloatFunction_<T_>): Internal.Object2ObjectFunction<T_, V>;
        size(): number;
        compose<T_>(arg0: java_.util.function_.Function_<T_, number>): java_.util.function_.Function<T_, V>;
        composeShort(arg0: Internal.Short2FloatFunction_): Internal.Short2ObjectFunction<V>;
        andThenReference<T_>(arg0: Internal.Object2ReferenceFunction_<V, T_>): Internal.Float2ReferenceFunction<T_>;
        composeChar(arg0: Internal.Char2FloatFunction_): Internal.Char2ObjectFunction<V>;
        composeDouble(arg0: Internal.Double2FloatFunction_): Internal.Double2ObjectFunction<V>;
    }
    type Float2ObjectFunction_<V> = ((arg0: number) => V) | Float2ObjectFunction<V>;
    class ScrollBar$Plane extends Internal.Enum<Internal.ScrollBar$Plane> {
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        static valueOf(name: string): Internal.ScrollBar$Plane;
        static valueOf<T_>(arg0: Internal.Class_<T_>, arg1: string): T_;
        notifyAll(): void;
        static values(): Internal.ScrollBar$Plane[];
        compareTo(arg0: Internal.ScrollBar$Plane_): number;
        describeConstable(): Internal.Optional<Internal.Enum$EnumDesc<Internal.ScrollBar$Plane>>;
        notify(): void;
        getDeclaringClass(): Internal.Class<Internal.ScrollBar$Plane>;
        hashCode(): number;
        equals(arg0: any): boolean;
        name(): string;
        toString(): string;
        ordinal(): number;
        static readonly VERTICAL : Internal.ScrollBar$Plane;
        readonly isVertical : boolean;
        static readonly HORIZONTAL : Internal.ScrollBar$Plane;
        get class(): Internal.Class<any>;
        get declaringClass(): Internal.Class<Internal.ScrollBar$Plane>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    type ScrollBar$Plane_ = "horizontal" | "vertical" | ScrollBar$Plane;
    class ArsNouveauEnchantingApparatusRecipeJS extends Internal.RecipeJS {
        parseResultItemList(o: any): Internal.List<Internal.ItemStackJS>;
        getClass(): Internal.Class<any>;
        ingredientAction(filter: Internal.IngredientActionFilter_, action: Internal.IngredientAction_): Internal.RecipeJS;
        convertReplacedInput(index: number, oldIngredient: Internal.IngredientJS_, newIngredient: Internal.IngredientJS_): Internal.IngredientJS;
        getUniqueId(): string;
        replaceOutput(i: Internal.IngredientJS_, with_: Internal.ItemStackJS_, exact: boolean): boolean;
        replaceOutput(i: Internal.IngredientJS_, with_: Internal.ItemStackJS_, exact: boolean, func: Internal.BiFunction_<Internal.ItemStackJS_, Internal.ItemStackJS_, Internal.ItemStackJS_>): boolean;
        parseIngredientItemList(o: any): Internal.List<Internal.IngredientJS>;
        merge(data: any): Internal.RecipeJS;
        getPath(): string;
        create(args: Internal.ListJS_): void;
        parseIngredientItemStackList(o: any): Internal.List<Internal.IngredientStackJS>;
        id(_id: ResourceLocation_): Internal.RecipeJS;
        parseIngredientItem(o: any, key: string): Internal.IngredientJS;
        parseIngredientItem(o: any): Internal.IngredientJS;
        group(g: string): Internal.RecipeJS;
        getOriginalRecipeResult(): Internal.ItemStackJS;
        getOriginalRecipeIngredients(): Internal.List<Internal.IngredientJS>;
        getInputIndex(ingredient: Internal.IngredientJS_, exact: boolean): number;
        setGroup(g: string): void;
        serialize(): void;
        replaceInput(i: Internal.IngredientJS_, with_: Internal.IngredientJS_, exact: boolean, func: Internal.BiFunction_<Internal.IngredientJS_, Internal.IngredientJS_, Internal.IngredientJS_>): boolean;
        replaceInput(i: Internal.IngredientJS_, with_: Internal.IngredientJS_, exact: boolean): boolean;
        getType(): string;
        getGroup(): string;
        hasOutput(ingredient: Internal.IngredientJS_, exact: boolean): boolean;
        keepIngredient(filter: Internal.IngredientActionFilter_): Internal.RecipeJS;
        customIngredientAction(filter: Internal.IngredientActionFilter_, id: string): Internal.RecipeJS;
        modifyResult(callback: Internal.ModifyRecipeResultCallback_): Internal.RecipeJS;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        getMod(): string;
        notifyAll(): void;
        convertReplacedOutput(index: number, oldStack: Internal.ItemStackJS_, newStack: Internal.ItemStackJS_): Internal.ItemStackJS;
        save(): void;
        damageIngredient(filter: Internal.IngredientActionFilter_): Internal.RecipeJS;
        damageIngredient(filter: Internal.IngredientActionFilter_, damage: number): Internal.RecipeJS;
        getId(): string;
        dontAdd(): void;
        notify(): void;
        serializeJson(): void;
        createRecipe(): Internal.Recipe<any>;
        getFromToString(): string;
        hashCode(): number;
        deserializeJson(): void;
        getOrCreateId(): ResourceLocation;
        deserialize(): void;
        serializeNBTAsJson(): boolean;
        getOutputIndex(ingredient: Internal.IngredientJS_, exact: boolean): number;
        serializeIngredientStack(in_: Internal.IngredientStackJS_): Internal.JsonElement;
        resultFromRecipeJson(json: Internal.JsonObject_): Internal.ItemStackJS;
        stage(s: string): Internal.RecipeJS;
        equals(arg0: any): boolean;
        serializeItemStack(stack: Internal.ItemStackJS_): Internal.JsonElement;
        toString(): string;
        hasInput(ingredient: Internal.IngredientJS_, exact: boolean): boolean;
        parseResultItem(o: any): Internal.ItemStackJS;
        replaceIngredient(filter: Internal.IngredientActionFilter_, item: Internal.ItemStackJS_): Internal.RecipeJS;
        static currentRecipe : Internal.RecipeJS;
        originalJson : Internal.JsonObject;
        serializeOutputs : boolean;
        originalRecipe : Internal.Recipe<any>;
        readonly inputItems : Internal.List<((arg0: Internal.ItemStackJS) => boolean)>;
        static itemErrors : false;
        json : Internal.JsonObject;
        readonly outputItems : Internal.List<Internal.ItemStackJS>;
        type : Internal.RecipeTypeJS;
        serializeInputs : boolean;
        get path(): string;
        get originalRecipeIngredients(): Internal.List<Internal.IngredientJS>;
        get mod(): string;
        get originalRecipeResult(): Internal.ItemStackJS;
        get orCreateId(): ResourceLocation;
        get class(): Internal.Class<any>;
        get fromToString(): string;
        get uniqueId(): string;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    type ArsNouveauEnchantingApparatusRecipeJS_ = ArsNouveauEnchantingApparatusRecipeJS;
    interface FormattedCharSequence {
    }
    type FormattedCharSequence_ = FormattedCharSequence;
    interface ITag <V> extends Internal.Iterable<V> {
        getKey(): Internal.TagKey<V>;
        iterator(): Internal.Iterator<V>;
        contains(arg0: V): boolean;
        size(): number;
        spliterator(): Internal.Spliterator<V>;
        isBound(): boolean;
        stream(): Internal.Stream<V>;
        forEach(arg0: Internal.Consumer_<V>): void;
        getRandomElement(arg0: Internal.Random_): Internal.Optional<V>;
        isEmpty(): boolean;
    }
    type ITag_<V> = ITag<V>;
    interface Set <E> extends Internal.Collection<E> {
        add(arg0: E): boolean;
        spliterator(): Internal.Spliterator<E>;
        forEach(arg0: Internal.Consumer_<E>): void;
        containsAll(arg0: Internal.Collection_<any>): boolean;
        isEmpty(): boolean;
        clear(): void;
        remove(arg0: any): boolean;
        removeIf(arg0: Internal.Predicate_<E>): boolean;
        removeAll(arg0: Internal.Collection_<any>): boolean;
        contains(arg0: any): boolean;
        iterator(): Internal.Iterator<E>;
        size(): number;
        stream(): Internal.Stream<E>;
        addAll(arg0: Internal.Collection_<E>): boolean;
        hashCode(): number;
        equals(arg0: any): boolean;
        toArray<T_>(arg0: T_[]): T_[];
        toArray(): any[];
        toArray<T_>(arg0: Internal.IntFunction_<T_[]>): T_[];
        parallelStream(): Internal.Stream<E>;
        retainAll(arg0: Internal.Collection_<any>): boolean;
    }
    type Set_<E> = Set<E>;
}
declare namespace net.minecraft.client.gui {
    class Font implements Internal.IAntiqueTextProvider {
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        setAntiqueInk(arg0: boolean): void;
        hashCode(): number;
        notifyAll(): void;
        equals(arg0: any): boolean;
        toString(): string;
        notify(): void;
        hasAntiqueInk(): boolean;
        get class(): Internal.Class<any>;
        set antiqueInk(arg0: boolean);
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    type Font_ = Font;
}
declare namespace java_.util.function_ {
    interface Function <T, R> {
        compose<V>(arg0: java_.util.function_.Function_<V, T>): java_.util.function_.Function<V, R>;
        apply(arg0: T): R;
        andThen<V>(arg0: java_.util.function_.Function_<R, V>): java_.util.function_.Function<T, V>;
    }
    type Function_<T, R> = ((arg0: T) => R) | Function<T, R>;
    interface IntConsumer {
        andThen(arg0: java_.util.function_.IntConsumer_): java_.util.function_.IntConsumer;
        accept(arg0: number): void;
    }
    type IntConsumer_ = ((arg0: number) => void) | IntConsumer;
    interface DoubleConsumer {
        andThen(arg0: java_.util.function_.DoubleConsumer_): java_.util.function_.DoubleConsumer;
        accept(arg0: number): void;
    }
    type DoubleConsumer_ = ((arg0: number) => void) | DoubleConsumer;
    interface DoublePredicate {
        or(arg0: java_.util.function_.DoublePredicate_): java_.util.function_.DoublePredicate;
        test(arg0: number): boolean;
        and(arg0: java_.util.function_.DoublePredicate_): java_.util.function_.DoublePredicate;
        negate(): java_.util.function_.DoublePredicate;
    }
    type DoublePredicate_ = ((arg0: number) => boolean) | DoublePredicate;
    interface LongConsumer {
        andThen(arg0: java_.util.function_.LongConsumer_): java_.util.function_.LongConsumer;
        accept(arg0: number): void;
    }
    type LongConsumer_ = ((arg0: number) => void) | LongConsumer;
    interface IntPredicate {
        or(arg0: java_.util.function_.IntPredicate_): java_.util.function_.IntPredicate;
        test(arg0: number): boolean;
        and(arg0: java_.util.function_.IntPredicate_): java_.util.function_.IntPredicate;
        negate(): java_.util.function_.IntPredicate;
    }
    type IntPredicate_ = ((arg0: number) => boolean) | IntPredicate;
}
declare namespace net.blay09.mods.balm.mixin {
    interface AbstractContainerScreenAccessor {
        callIsHovering(arg0: Internal.Slot_, arg1: number, arg2: number): boolean;
        getHoveredSlot(): Internal.Slot;
        callRenderSlot(arg0: Internal.PoseStack_, arg1: Internal.Slot_): void;
        getImageWidth(): number;
        getTopPos(): number;
        getLeftPos(): number;
        getImageHeight(): number;
    }
    type AbstractContainerScreenAccessor_ = AbstractContainerScreenAccessor;
}
declare namespace vazkii.botania.mixin.client {
    interface AccessorMinecraft {
        getItemColors(): Internal.ItemColors;
    }
    type AccessorMinecraft_ = AccessorMinecraft;
}
declare namespace io.netty.util.concurrent {
    interface ScheduledFuture <V> extends io.netty.util.concurrent.Future<V>, Internal.ScheduledFuture<V> {
        cancel(arg0: boolean): boolean;
        isCancelled(): boolean;
        getDelay(arg0: Internal.TimeUnit_): number;
        removeListeners(arg0: Internal.GenericFutureListener_<io.netty.util.concurrent.Future_<V>>[]): io.netty.util.concurrent.Future<V>;
        getNow(): V;
        cause(): Internal.Throwable;
        awaitUninterruptibly(): io.netty.util.concurrent.Future<V>;
        awaitUninterruptibly(arg0: number, arg1: Internal.TimeUnit_): boolean;
        awaitUninterruptibly(arg0: number): boolean;
        compareTo(arg0: Internal.Delayed_): number;
        removeListener(arg0: Internal.GenericFutureListener_<io.netty.util.concurrent.Future_<V>>): io.netty.util.concurrent.Future<V>;
        isDone(): boolean;
        sync(): io.netty.util.concurrent.Future<V>;
        syncUninterruptibly(): io.netty.util.concurrent.Future<V>;
        get(arg0: number, arg1: Internal.TimeUnit_): V;
        get(): V;
        isCancellable(): boolean;
        await(arg0: number, arg1: Internal.TimeUnit_): boolean;
        await(arg0: number): boolean;
        await(): io.netty.util.concurrent.Future<V>;
        addListeners(arg0: Internal.GenericFutureListener_<io.netty.util.concurrent.Future_<V>>[]): io.netty.util.concurrent.Future<V>;
        isSuccess(): boolean;
        addListener(arg0: Internal.GenericFutureListener_<io.netty.util.concurrent.Future_<V>>): io.netty.util.concurrent.Future<V>;
    }
    type ScheduledFuture_<V> = ScheduledFuture<V>;
    interface Future <V> extends Internal.Future<V> {
        cancel(arg0: boolean): boolean;
        isCancelled(): boolean;
        removeListeners(arg0: Internal.GenericFutureListener_<io.netty.util.concurrent.Future_<V>>[]): io.netty.util.concurrent.Future<V>;
        getNow(): V;
        cause(): Internal.Throwable;
        awaitUninterruptibly(): io.netty.util.concurrent.Future<V>;
        awaitUninterruptibly(arg0: number, arg1: Internal.TimeUnit_): boolean;
        awaitUninterruptibly(arg0: number): boolean;
        removeListener(arg0: Internal.GenericFutureListener_<io.netty.util.concurrent.Future_<V>>): io.netty.util.concurrent.Future<V>;
        isDone(): boolean;
        sync(): io.netty.util.concurrent.Future<V>;
        syncUninterruptibly(): io.netty.util.concurrent.Future<V>;
        get(arg0: number, arg1: Internal.TimeUnit_): V;
        get(): V;
        isCancellable(): boolean;
        await(arg0: number, arg1: Internal.TimeUnit_): boolean;
        await(arg0: number): boolean;
        await(): io.netty.util.concurrent.Future<V>;
        addListeners(arg0: Internal.GenericFutureListener_<io.netty.util.concurrent.Future_<V>>[]): io.netty.util.concurrent.Future<V>;
        isSuccess(): boolean;
        addListener(arg0: Internal.GenericFutureListener_<io.netty.util.concurrent.Future_<V>>): io.netty.util.concurrent.Future<V>;
    }
    type Future_<V> = Future<V>;
}
declare namespace java_.awt {
    class Color implements Internal.Paint, Internal.Serializable {
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        notifyAll(): void;
        static decode(arg0: string): java_.awt.Color;
        createContext(arg0: Internal.ColorModel_, arg1: Internal.Rectangle_, arg2: Internal.Rectangle2D_, arg3: Internal.AffineTransform_, arg4: Internal.RenderingHints_): Internal.PaintContext;
        notify(): void;
        getAlpha(): number;
        getColorComponents(arg0: Internal.ColorSpace_, arg1: number[]): number[];
        getColorComponents(arg0: number[]): number[];
        getRed(): number;
        darker(): java_.awt.Color;
        getRGBComponents(arg0: number[]): number[];
        hashCode(): number;
        getComponents(arg0: Internal.ColorSpace_, arg1: number[]): number[];
        getComponents(arg0: number[]): number[];
        static RGBtoHSB(arg0: number, arg1: number, arg2: number, arg3: number[]): number[];
        static getHSBColor(arg0: number, arg1: number, arg2: number): java_.awt.Color;
        getRGB(): number;
        brighter(): java_.awt.Color;
        static getColor(arg0: string, arg1: java_.awt.Color_): java_.awt.Color;
        static getColor(arg0: string, arg1: number): java_.awt.Color;
        static getColor(arg0: string): java_.awt.Color;
        static HSBtoRGB(arg0: number, arg1: number, arg2: number): number;
        getBlue(): number;
        getColorSpace(): Internal.ColorSpace;
        getTransparency(): number;
        getRGBColorComponents(arg0: number[]): number[];
        getGreen(): number;
        equals(arg0: any): boolean;
        toString(): string;
        static readonly lightGray : java_.awt.Color;
        static readonly magenta : java_.awt.Color;
        static readonly GRAY : java_.awt.Color;
        static readonly pink : java_.awt.Color;
        static readonly BLUE : java_.awt.Color;
        static readonly yellow : java_.awt.Color;
        static readonly cyan : java_.awt.Color;
        static readonly red : java_.awt.Color;
        static readonly gray : java_.awt.Color;
        static readonly PINK : java_.awt.Color;
        static readonly white : java_.awt.Color;
        static readonly TRANSLUCENT : 3;
        static readonly BLACK : java_.awt.Color;
        static readonly ORANGE : java_.awt.Color;
        static readonly WHITE : java_.awt.Color;
        static readonly green : java_.awt.Color;
        static readonly black : java_.awt.Color;
        static readonly BITMASK : 2;
        static readonly GREEN : java_.awt.Color;
        static readonly RED : java_.awt.Color;
        static readonly orange : java_.awt.Color;
        static readonly LIGHT_GRAY : java_.awt.Color;
        static readonly blue : java_.awt.Color;
        static readonly OPAQUE : 1;
        static readonly darkGray : java_.awt.Color;
        static readonly MAGENTA : java_.awt.Color;
        static readonly YELLOW : java_.awt.Color;
        static readonly DARK_GRAY : java_.awt.Color;
        static readonly CYAN : java_.awt.Color;
        get colorSpace(): Internal.ColorSpace;
        get alpha(): number;
        get transparency(): number;
        get rGB(): number;
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    type Color_ = Color;
    class Event implements Internal.Serializable {
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        controlDown(): boolean;
        shiftDown(): boolean;
        hashCode(): number;
        notifyAll(): void;
        equals(arg0: any): boolean;
        metaDown(): boolean;
        toString(): string;
        notify(): void;
        translate(arg0: number, arg1: number): void;
        static readonly DOWN : 1005;
        static readonly PRINT_SCREEN : 1020;
        static readonly BACK_SPACE : 8;
        when : number;
        static readonly MOUSE_UP : 502;
        static readonly SCROLL_ABSOLUTE : 605;
        static readonly KEY_RELEASE : 402;
        static readonly MOUSE_DRAG : 506;
        static readonly UP : 1004;
        static readonly SCROLL_PAGE_UP : 603;
        id : number;
        static readonly LIST_DESELECT : 702;
        static readonly LOAD_FILE : 1002;
        static readonly MOUSE_EXIT : 505;
        static readonly LEFT : 1006;
        static readonly F1 : 1008;
        static readonly MOUSE_DOWN : 501;
        static readonly F2 : 1009;
        static readonly F3 : 1010;
        static readonly F4 : 1011;
        static readonly F5 : 1012;
        static readonly F6 : 1013;
        static readonly SAVE_FILE : 1003;
        static readonly F7 : 1014;
        static readonly F8 : 1015;
        static readonly F9 : 1016;
        static readonly NUM_LOCK : 1023;
        static readonly MOUSE_ENTER : 504;
        static readonly SCROLL_END : 607;
        static readonly END : 1001;
        static readonly INSERT : 1025;
        static readonly WINDOW_DEICONIFY : 204;
        static readonly GOT_FOCUS : 1004;
        static readonly WINDOW_DESTROY : 201;
        static readonly SCROLL_BEGIN : 606;
        static readonly CAPS_LOCK : 1022;
        static readonly SCROLL_LINE_DOWN : 602;
        static readonly WINDOW_EXPOSE : 202;
        clickCount : number;
        static readonly SHIFT_MASK : 1;
        static readonly KEY_ACTION : 403;
        static readonly ENTER : 10;
        static readonly LOST_FOCUS : 1005;
        modifiers : number;
        static readonly PAUSE : 1024;
        static readonly KEY_PRESS : 401;
        static readonly DELETE : 127;
        static readonly LIST_SELECT : 701;
        arg : any;
        static readonly CTRL_MASK : 2;
        static readonly ALT_MASK : 8;
        static readonly RIGHT : 1007;
        static readonly WINDOW_MOVED : 205;
        key : number;
        evt : java_.awt.Event;
        static readonly PGDN : 1003;
        static readonly F10 : 1017;
        static readonly WINDOW_ICONIFY : 203;
        static readonly F12 : 1019;
        static readonly SCROLL_LINE_UP : 601;
        static readonly F11 : 1018;
        static readonly ESCAPE : 27;
        target : any;
        static readonly MOUSE_MOVE : 503;
        static readonly SCROLL_LOCK : 1021;
        static readonly TAB : 9;
        static readonly PGUP : 1002;
        static readonly SCROLL_PAGE_DOWN : 604;
        static readonly ACTION_EVENT : 1001;
        x : number;
        y : number;
        static readonly KEY_ACTION_RELEASE : 404;
        static readonly META_MASK : 4;
        static readonly HOME : 1000;
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    type Event_ = Event;
    abstract class Component implements Internal.ImageObserver, Internal.MenuContainer, Internal.Serializable {
        getHierarchyBoundsListeners(): Internal.HierarchyBoundsListener[];
        requestFocusInWindow(): boolean;
        requestFocusInWindow(arg0: Internal.FocusEvent$Cause_): boolean;
        getLocation(arg0: Internal.Point_): Internal.Point;
        getLocation(): Internal.Point;
        isOpaque(): boolean;
        paint(arg0: Internal.Graphics_): void;
        getInputMethodListeners(): Internal.InputMethodListener[];
        mouseDown(arg0: java_.awt.Event_, arg1: number, arg2: number): boolean;
        getInputMethodRequests(): Internal.InputMethodRequests;
        getBounds(): Internal.Rectangle;
        getBounds(arg0: Internal.Rectangle_): Internal.Rectangle;
        setPreferredSize(arg0: Internal.Dimension_): void;
        addHierarchyBoundsListener(arg0: Internal.HierarchyBoundsListener_): void;
        enable(arg0: boolean): void;
        enable(): void;
        getMinimumSize(): Internal.Dimension;
        getMousePosition(): Internal.Point;
        getAlignmentY(): number;
        action(arg0: java_.awt.Event_, arg1: any): boolean;
        getAlignmentX(): number;
        firePropertyChange(arg0: string, arg1: number, arg2: number): void;
        firePropertyChange(arg0: string, arg1: string, arg2: string): void;
        dispatchEvent(arg0: Internal.AWTEvent_): void;
        addMouseMotionListener(arg0: Internal.MouseMotionListener_): void;
        getComponentOrientation(): Internal.ComponentOrientation;
        setFocusable(arg0: boolean): void;
        getTreeLock(): any;
        isBackgroundSet(): boolean;
        addHierarchyListener(arg0: Internal.HierarchyListener_): void;
        reshape(arg0: number, arg1: number, arg2: number, arg3: number): void;
        postEvent(arg0: java_.awt.Event_): boolean;
        setEnabled(arg0: boolean): void;
        isLightweight(): boolean;
        contains(arg0: Internal.Point_): boolean;
        contains(arg0: number, arg1: number): boolean;
        size(): Internal.Dimension;
        minimumSize(): Internal.Dimension;
        enableInputMethods(arg0: boolean): void;
        mouseUp(arg0: java_.awt.Event_, arg1: number, arg2: number): boolean;
        isEnabled(): boolean;
        bounds(): Internal.Rectangle;
        addComponentListener(arg0: Internal.ComponentListener_): void;
        repaint(arg0: number, arg1: number, arg2: number, arg3: number): void;
        repaint(arg0: number): void;
        repaint(): void;
        repaint(arg0: number, arg1: number, arg2: number, arg3: number, arg4: number): void;
        getMouseMotionListeners(): Internal.MouseMotionListener[];
        setMinimumSize(arg0: Internal.Dimension_): void;
        transferFocus(): void;
        getListeners<T_>(arg0: Internal.Class_<T_>): T_[];
        setName(arg0: string): void;
        removeInputMethodListener(arg0: Internal.InputMethodListener_): void;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        getMaximumSize(): Internal.Dimension;
        removeHierarchyListener(arg0: Internal.HierarchyListener_): void;
        getLocationOnScreen(): Internal.Point;
        keyUp(arg0: java_.awt.Event_, arg1: number): boolean;
        getWidth(): number;
        notify(): void;
        getFontMetrics(arg0: Internal.Font_): Internal.FontMetrics;
        getHeight(): number;
        paintAll(arg0: Internal.Graphics_): void;
        setFocusTraversalKeys(arg0: number, arg1: Internal.Set_<Internal.AWTKeyStroke_>): void;
        getIgnoreRepaint(): boolean;
        getBaselineResizeBehavior(): Internal.Component$BaselineResizeBehavior;
        removeMouseWheelListener(arg0: Internal.MouseWheelListener_): void;
        hasFocus(): boolean;
        isPreferredSizeSet(): boolean;
        applyComponentOrientation(arg0: Internal.ComponentOrientation_): void;
        validate(): void;
        isDoubleBuffered(): boolean;
        getParent(): Internal.Container;
        getColorModel(): Internal.ColorModel;
        getPropertyChangeListeners(arg0: string): Internal.PropertyChangeListener[];
        getPropertyChangeListeners(): Internal.PropertyChangeListener[];
        isMinimumSizeSet(): boolean;
        setComponentOrientation(arg0: Internal.ComponentOrientation_): void;
        isValid(): boolean;
        getFocusTraversalKeysEnabled(): boolean;
        setBounds(arg0: Internal.Rectangle_): void;
        setBounds(arg0: number, arg1: number, arg2: number, arg3: number): void;
        hide(): void;
        getPreferredSize(): Internal.Dimension;
        addNotify(): void;
        disable(): void;
        equals(arg0: any): boolean;
        prepareImage(arg0: Internal.Image_, arg1: Internal.ImageObserver_): boolean;
        prepareImage(arg0: Internal.Image_, arg1: number, arg2: number, arg3: Internal.ImageObserver_): boolean;
        addInputMethodListener(arg0: Internal.InputMethodListener_): void;
        getFocusCycleRootAncestor(): Internal.Container;
        toString(): string;
        isFocusable(): boolean;
        getClass(): Internal.Class<any>;
        getName(): string;
        isFocusTraversable(): boolean;
        setMixingCutoutShape(arg0: Internal.Shape_): void;
        inside(arg0: number, arg1: number): boolean;
        nextFocus(): void;
        mouseExit(arg0: java_.awt.Event_, arg1: number, arg2: number): boolean;
        getFocusTraversalKeys(arg0: number): Internal.Set<Internal.AWTKeyStroke>;
        getInputContext(): Internal.InputContext;
        getHierarchyListeners(): Internal.HierarchyListener[];
        isCursorSet(): boolean;
        isShowing(): boolean;
        mouseEnter(arg0: java_.awt.Event_, arg1: number, arg2: number): boolean;
        mouseDrag(arg0: java_.awt.Event_, arg1: number, arg2: number): boolean;
        getMouseWheelListeners(): Internal.MouseWheelListener[];
        preferredSize(): Internal.Dimension;
        getMouseListeners(): Internal.MouseListener[];
        setFont(arg0: Internal.Font_): void;
        removeMouseMotionListener(arg0: Internal.MouseMotionListener_): void;
        doLayout(): void;
        setVisible(arg0: boolean): void;
        add(arg0: Internal.PopupMenu_): void;
        removeKeyListener(arg0: Internal.KeyListener_): void;
        isVisible(): boolean;
        removePropertyChangeListener(arg0: string, arg1: Internal.PropertyChangeListener_): void;
        removePropertyChangeListener(arg0: Internal.PropertyChangeListener_): void;
        setDropTarget(arg0: Internal.DropTarget_): void;
        list(arg0: Internal.PrintStream_, arg1: number): void;
        list(arg0: Internal.PrintStream_): void;
        list(): void;
        list(arg0: Internal.PrintWriter_): void;
        list(arg0: Internal.PrintWriter_, arg1: number): void;
        deliverEvent(arg0: java_.awt.Event_): void;
        getForeground(): java_.awt.Color;
        revalidate(): void;
        removeNotify(): void;
        setCursor(arg0: Internal.Cursor_): void;
        getFont(): Internal.Font;
        isDisplayable(): boolean;
        getGraphicsConfiguration(): Internal.GraphicsConfiguration;
        setLocale(arg0: Internal.Locale_): void;
        removeComponentListener(arg0: Internal.ComponentListener_): void;
        gotFocus(arg0: java_.awt.Event_, arg1: any): boolean;
        requestFocus(): void;
        requestFocus(arg0: Internal.FocusEvent$Cause_): void;
        locate(arg0: number, arg1: number): java_.awt.Component;
        handleEvent(arg0: java_.awt.Event_): boolean;
        addFocusListener(arg0: Internal.FocusListener_): void;
        notifyAll(): void;
        isForegroundSet(): boolean;
        show(): void;
        show(arg0: boolean): void;
        getComponentAt(arg0: Internal.Point_): java_.awt.Component;
        getComponentAt(arg0: number, arg1: number): java_.awt.Component;
        update(arg0: Internal.Graphics_): void;
        setMaximumSize(arg0: Internal.Dimension_): void;
        isFocusCycleRoot(arg0: Internal.Container_): boolean;
        setFocusTraversalKeysEnabled(arg0: boolean): void;
        setBackground(arg0: java_.awt.Color_): void;
        printAll(arg0: Internal.Graphics_): void;
        remove(arg0: Internal.MenuComponent_): void;
        imageUpdate(arg0: Internal.Image_, arg1: number, arg2: number, arg3: number, arg4: number, arg5: number): boolean;
        addMouseWheelListener(arg0: Internal.MouseWheelListener_): void;
        getToolkit(): Internal.Toolkit;
        transferFocusUpCycle(): void;
        checkImage(arg0: Internal.Image_, arg1: Internal.ImageObserver_): number;
        checkImage(arg0: Internal.Image_, arg1: number, arg2: number, arg3: Internal.ImageObserver_): number;
        isFontSet(): boolean;
        setSize(arg0: number, arg1: number): void;
        setSize(arg0: Internal.Dimension_): void;
        addKeyListener(arg0: Internal.KeyListener_): void;
        setLocation(arg0: number, arg1: number): void;
        setLocation(arg0: Internal.Point_): void;
        hashCode(): number;
        getComponentListeners(): Internal.ComponentListener[];
        getGraphics(): Internal.Graphics;
        addPropertyChangeListener(arg0: Internal.PropertyChangeListener_): void;
        addPropertyChangeListener(arg0: string, arg1: Internal.PropertyChangeListener_): void;
        isMaximumSizeSet(): boolean;
        removeFocusListener(arg0: Internal.FocusListener_): void;
        setIgnoreRepaint(arg0: boolean): void;
        transferFocusBackward(): void;
        getCursor(): Internal.Cursor;
        move(arg0: number, arg1: number): void;
        createImage(arg0: number, arg1: number): Internal.Image;
        createImage(arg0: Internal.ImageProducer_): Internal.Image;
        mouseMove(arg0: java_.awt.Event_, arg1: number, arg2: number): boolean;
        areFocusTraversalKeysSet(arg0: number): boolean;
        getKeyListeners(): Internal.KeyListener[];
        setForeground(arg0: java_.awt.Color_): void;
        invalidate(): void;
        getAccessibleContext(): Internal.AccessibleContext;
        layout(): void;
        isFocusOwner(): boolean;
        getX(): number;
        getBaseline(arg0: number, arg1: number): number;
        getSize(arg0: Internal.Dimension_): Internal.Dimension;
        getSize(): Internal.Dimension;
        print(arg0: Internal.Graphics_): void;
        getY(): number;
        removeHierarchyBoundsListener(arg0: Internal.HierarchyBoundsListener_): void;
        getFocusListeners(): Internal.FocusListener[];
        createVolatileImage(arg0: number, arg1: number, arg2: Internal.ImageCapabilities_): Internal.VolatileImage;
        createVolatileImage(arg0: number, arg1: number): Internal.VolatileImage;
        resize(arg0: Internal.Dimension_): void;
        resize(arg0: number, arg1: number): void;
        lostFocus(arg0: java_.awt.Event_, arg1: any): boolean;
        location(): Internal.Point;
        removeMouseListener(arg0: Internal.MouseListener_): void;
        keyDown(arg0: java_.awt.Event_, arg1: number): boolean;
        getDropTarget(): Internal.DropTarget;
        getBackground(): java_.awt.Color;
        getLocale(): Internal.Locale;
        addMouseListener(arg0: Internal.MouseListener_): void;
        static readonly ABORT : 128;
        static readonly CENTER_ALIGNMENT : 0.5;
        static readonly PROPERTIES : 4;
        static readonly SOMEBITS : 8;
        static readonly BOTTOM_ALIGNMENT : 1.0;
        static readonly WIDTH : 1;
        static readonly HEIGHT : 2;
        static readonly FRAMEBITS : 16;
        static readonly LEFT_ALIGNMENT : 0.0;
        static readonly ALLBITS : 32;
        static readonly RIGHT_ALIGNMENT : 1.0;
        static readonly TOP_ALIGNMENT : 0.0;
        static readonly ERROR : 64;
        get parent(): Internal.Container;
        get inputContext(): Internal.InputContext;
        get graphicsConfiguration(): Internal.GraphicsConfiguration;
        get dropTarget(): Internal.DropTarget;
        get foreground(): java_.awt.Color;
        get graphics(): Internal.Graphics;
        get baselineResizeBehavior(): Internal.Component$BaselineResizeBehavior;
        get foregroundSet(): boolean;
        get mouseWheelListeners(): Internal.MouseWheelListener[];
        get propertyChangeListeners(): Internal.PropertyChangeListener[];
        get doubleBuffered(): boolean;
        get height(): number;
        get visible(): boolean;
        get displayable(): boolean;
        get focusable(): boolean;
        get maximumSizeSet(): boolean;
        get mousePosition(): Internal.Point;
        get focusTraversalKeysEnabled(): boolean;
        get focusOwner(): boolean;
        get toolkit(): Internal.Toolkit;
        get focusCycleRootAncestor(): Internal.Container;
        get background(): java_.awt.Color;
        get name(): string;
        get focusTraversable(): boolean;
        get maximumSize(): Internal.Dimension;
        get hierarchyListeners(): Internal.HierarchyListener[];
        get minimumSizeSet(): boolean;
        get cursor(): Internal.Cursor;
        get accessibleContext(): Internal.AccessibleContext;
        get alignmentX(): number;
        get alignmentY(): number;
        get componentOrientation(): Internal.ComponentOrientation;
        get locale(): Internal.Locale;
        get ignoreRepaint(): boolean;
        get enabled(): boolean;
        get lightweight(): boolean;
        get valid(): boolean;
        get componentListeners(): Internal.ComponentListener[];
        get locationOnScreen(): Internal.Point;
        get colorModel(): Internal.ColorModel;
        get cursorSet(): boolean;
        get class(): Internal.Class<any>;
        get keyListeners(): Internal.KeyListener[];
        get inputMethodListeners(): Internal.InputMethodListener[];
        get opaque(): boolean;
        get mouseListeners(): Internal.MouseListener[];
        get hierarchyBoundsListeners(): Internal.HierarchyBoundsListener[];
        get inputMethodRequests(): Internal.InputMethodRequests;
        get preferredSizeSet(): boolean;
        get treeLock(): any;
        get backgroundSet(): boolean;
        get focusListeners(): Internal.FocusListener[];
        get width(): number;
        get x(): number;
        get y(): number;
        get fontSet(): boolean;
        get showing(): boolean;
        get mouseMotionListeners(): Internal.MouseMotionListener[];
        get font(): Internal.Font;
        set cursor(arg0: Internal.Cursor_);
        set visible(arg0: boolean);
        set componentOrientation(arg0: Internal.ComponentOrientation_);
        set dropTarget(arg0: Internal.DropTarget_);
        set focusable(arg0: boolean);
        set foreground(arg0: java_.awt.Color_);
        set locale(arg0: Internal.Locale_);
        set ignoreRepaint(arg0: boolean);
        set enabled(arg0: boolean);
        set focusTraversalKeysEnabled(arg0: boolean);
        set mixingCutoutShape(arg0: Internal.Shape_);
        set background(arg0: java_.awt.Color_);
        set name(arg0: string);
        set maximumSize(arg0: Internal.Dimension_);
        set font(arg0: Internal.Font_);
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    type Component_ = Component;
    class Window extends Internal.Container implements Internal.Accessible {
        requestFocusInWindow(): boolean;
        requestFocusInWindow(arg0: Internal.FocusEvent$Cause_): boolean;
        getLocation(arg0: Internal.Point_): Internal.Point;
        getLocation(): Internal.Point;
        isOpaque(): boolean;
        setModalExclusionType(arg0: Internal.Dialog$ModalExclusionType_): void;
        paint(arg0: Internal.Graphics_): void;
        removeWindowListener(arg0: Internal.WindowListener_): void;
        getInputMethodListeners(): Internal.InputMethodListener[];
        setLayout(arg0: Internal.LayoutManager_): void;
        mouseDown(arg0: java_.awt.Event_, arg1: number, arg2: number): boolean;
        getOwner(): java_.awt.Window;
        getInputMethodRequests(): Internal.InputMethodRequests;
        addHierarchyBoundsListener(arg0: Internal.HierarchyBoundsListener_): void;
        removeAll(): void;
        getMinimumSize(): Internal.Dimension;
        getAlignmentY(): number;
        getWindowStateListeners(): Internal.WindowStateListener[];
        getAlignmentX(): number;
        dispatchEvent(arg0: Internal.AWTEvent_): void;
        setFocusableWindowState(arg0: boolean): void;
        getMostRecentFocusOwner(): java_.awt.Component;
        reshape(arg0: number, arg1: number, arg2: number, arg3: number): void;
        pack(): void;
        postEvent(arg0: java_.awt.Event_): boolean;
        toBack(): void;
        createBufferStrategy(arg0: number, arg1: Internal.BufferCapabilities_): void;
        createBufferStrategy(arg0: number): void;
        contains(arg0: Internal.Point_): boolean;
        contains(arg0: number, arg1: number): boolean;
        size(): Internal.Dimension;
        getType(): Internal.Window$Type;
        enableInputMethods(arg0: boolean): void;
        mouseUp(arg0: java_.awt.Event_, arg1: number, arg2: number): boolean;
        removeContainerListener(arg0: Internal.ContainerListener_): void;
        addComponentListener(arg0: Internal.ComponentListener_): void;
        setName(arg0: string): void;
        removeInputMethodListener(arg0: Internal.InputMethodListener_): void;
        removeHierarchyListener(arg0: Internal.HierarchyListener_): void;
        removeWindowFocusListener(arg0: Internal.WindowFocusListener_): void;
        getFontMetrics(arg0: Internal.Font_): Internal.FontMetrics;
        getHeight(): number;
        getIgnoreRepaint(): boolean;
        getBaselineResizeBehavior(): Internal.Component$BaselineResizeBehavior;
        removeMouseWheelListener(arg0: Internal.MouseWheelListener_): void;
        applyComponentOrientation(arg0: Internal.ComponentOrientation_): void;
        isAlwaysOnTopSupported(): boolean;
        validate(): void;
        getParent(): Internal.Container;
        isMinimumSizeSet(): boolean;
        getWindowFocusListeners(): Internal.WindowFocusListener[];
        setComponentOrientation(arg0: Internal.ComponentOrientation_): void;
        setBounds(arg0: number, arg1: number, arg2: number, arg3: number): void;
        setBounds(arg0: Internal.Rectangle_): void;
        static getWindows(): java_.awt.Window[];
        isValidateRoot(): boolean;
        addNotify(): void;
        addInputMethodListener(arg0: Internal.InputMethodListener_): void;
        toString(): string;
        getFocusCycleRootAncestor(): Internal.Container;
        setFocusTraversalPolicyProvider(arg0: boolean): void;
        addWindowFocusListener(arg0: Internal.WindowFocusListener_): void;
        getName(): string;
        countComponents(): number;
        isFocusTraversable(): boolean;
        inside(arg0: number, arg1: number): boolean;
        nextFocus(): void;
        getFocusTraversalKeys(arg0: number): Internal.Set<Internal.AWTKeyStroke>;
        getInputContext(): Internal.InputContext;
        isCursorSet(): boolean;
        getMouseWheelListeners(): Internal.MouseWheelListener[];
        getComponents(): java_.awt.Component[];
        removeMouseMotionListener(arg0: Internal.MouseMotionListener_): void;
        doLayout(): void;
        isLocationByPlatform(): boolean;
        add(arg0: java_.awt.Component_): java_.awt.Component;
        add(arg0: string, arg1: java_.awt.Component_): java_.awt.Component;
        add(arg0: java_.awt.Component_, arg1: any): void;
        add(arg0: java_.awt.Component_, arg1: number): java_.awt.Component;
        add(arg0: java_.awt.Component_, arg1: any, arg2: number): void;
        add(arg0: Internal.PopupMenu_): void;
        setVisible(arg0: boolean): void;
        removeKeyListener(arg0: Internal.KeyListener_): void;
        setFocusCycleRoot(arg0: boolean): void;
        isVisible(): boolean;
        removePropertyChangeListener(arg0: string, arg1: Internal.PropertyChangeListener_): void;
        removePropertyChangeListener(arg0: Internal.PropertyChangeListener_): void;
        setDropTarget(arg0: Internal.DropTarget_): void;
        list(arg0: Internal.PrintWriter_, arg1: number): void;
        list(arg0: Internal.PrintStream_, arg1: number): void;
        list(arg0: Internal.PrintStream_): void;
        list(): void;
        list(arg0: Internal.PrintWriter_): void;
        isFocused(): boolean;
        revalidate(): void;
        removeWindowStateListener(arg0: Internal.WindowStateListener_): void;
        removeNotify(): void;
        getWarningString(): string;
        static getOwnerlessWindows(): java_.awt.Window[];
        gotFocus(arg0: java_.awt.Event_, arg1: any): boolean;
        handleEvent(arg0: java_.awt.Event_): boolean;
        notifyAll(): void;
        isForegroundSet(): boolean;
        show(): void;
        show(arg0: boolean): void;
        update(arg0: Internal.Graphics_): void;
        getShape(): Internal.Shape;
        isFocusTraversalPolicySet(): boolean;
        setMaximumSize(arg0: Internal.Dimension_): void;
        remove(arg0: java_.awt.Component_): void;
        remove(arg0: number): void;
        remove(arg0: Internal.MenuComponent_): void;
        imageUpdate(arg0: Internal.Image_, arg1: number, arg2: number, arg3: number, arg4: number, arg5: number): boolean;
        addMouseWheelListener(arg0: Internal.MouseWheelListener_): void;
        checkImage(arg0: Internal.Image_, arg1: Internal.ImageObserver_): number;
        checkImage(arg0: Internal.Image_, arg1: number, arg2: number, arg3: Internal.ImageObserver_): number;
        getLayout(): Internal.LayoutManager;
        addKeyListener(arg0: Internal.KeyListener_): void;
        getContainerListeners(): Internal.ContainerListener[];
        hashCode(): number;
        getComponentListeners(): Internal.ComponentListener[];
        isMaximumSizeSet(): boolean;
        addPropertyChangeListener(arg0: string, arg1: Internal.PropertyChangeListener_): void;
        addPropertyChangeListener(arg0: Internal.PropertyChangeListener_): void;
        getWindowListeners(): Internal.WindowListener[];
        getCursor(): Internal.Cursor;
        createImage(arg0: number, arg1: number): Internal.Image;
        createImage(arg0: Internal.ImageProducer_): Internal.Image;
        mouseMove(arg0: java_.awt.Event_, arg1: number, arg2: number): boolean;
        areFocusTraversalKeysSet(arg0: number): boolean;
        getKeyListeners(): Internal.KeyListener[];
        setType(arg0: Internal.Window$Type_): void;
        layout(): void;
        getBaseline(arg0: number, arg1: number): number;
        print(arg0: Internal.Graphics_): void;
        paintComponents(arg0: Internal.Graphics_): void;
        getFocusListeners(): Internal.FocusListener[];
        createVolatileImage(arg0: number, arg1: number, arg2: Internal.ImageCapabilities_): Internal.VolatileImage;
        createVolatileImage(arg0: number, arg1: number): Internal.VolatileImage;
        resize(arg0: Internal.Dimension_): void;
        resize(arg0: number, arg1: number): void;
        isAutoRequestFocus(): boolean;
        lostFocus(arg0: java_.awt.Event_, arg1: any): boolean;
        location(): Internal.Point;
        keyDown(arg0: java_.awt.Event_, arg1: number): boolean;
        getDropTarget(): Internal.DropTarget;
        getLocale(): Internal.Locale;
        setOpacity(arg0: number): void;
        getHierarchyBoundsListeners(): Internal.HierarchyBoundsListener[];
        getBounds(): Internal.Rectangle;
        getBounds(arg0: Internal.Rectangle_): Internal.Rectangle;
        setPreferredSize(arg0: Internal.Dimension_): void;
        enable(arg0: boolean): void;
        enable(): void;
        getMousePosition(arg0: boolean): Internal.Point;
        getMousePosition(): Internal.Point;
        action(arg0: java_.awt.Event_, arg1: any): boolean;
        setIconImages(arg0: Internal.List_<Internal.Image_>): void;
        addContainerListener(arg0: Internal.ContainerListener_): void;
        setComponentZOrder(arg0: java_.awt.Component_, arg1: number): void;
        firePropertyChange(arg0: string, arg1: number, arg2: number): void;
        firePropertyChange(arg0: string, arg1: string, arg2: string): void;
        addMouseMotionListener(arg0: Internal.MouseMotionListener_): void;
        getComponentOrientation(): Internal.ComponentOrientation;
        setFocusable(arg0: boolean): void;
        getTreeLock(): any;
        isBackgroundSet(): boolean;
        addHierarchyListener(arg0: Internal.HierarchyListener_): void;
        findComponentAt(arg0: number, arg1: number): java_.awt.Component;
        findComponentAt(arg0: Internal.Point_): java_.awt.Component;
        setLocationByPlatform(arg0: boolean): void;
        setEnabled(arg0: boolean): void;
        isLightweight(): boolean;
        isEnabled(): boolean;
        minimumSize(): Internal.Dimension;
        bounds(): Internal.Rectangle;
        repaint(arg0: number, arg1: number, arg2: number, arg3: number): void;
        repaint(arg0: number): void;
        repaint(): void;
        repaint(arg0: number, arg1: number, arg2: number, arg3: number, arg4: number): void;
        getMouseMotionListeners(): Internal.MouseMotionListener[];
        getModalExclusionType(): Internal.Dialog$ModalExclusionType;
        setMinimumSize(arg0: Internal.Dimension_): void;
        transferFocus(): void;
        printComponents(arg0: Internal.Graphics_): void;
        getListeners<T_>(arg0: Internal.Class_<T_>): T_[];
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        getMaximumSize(): Internal.Dimension;
        getLocationOnScreen(): Internal.Point;
        keyUp(arg0: java_.awt.Event_, arg1: number): boolean;
        getWidth(): number;
        notify(): void;
        setFocusTraversalPolicy(arg0: Internal.FocusTraversalPolicy_): void;
        addWindowListener(arg0: Internal.WindowListener_): void;
        paintAll(arg0: Internal.Graphics_): void;
        setFocusTraversalKeys(arg0: number, arg1: Internal.Set_<Internal.AWTKeyStroke_>): void;
        hasFocus(): boolean;
        isPreferredSizeSet(): boolean;
        addWindowStateListener(arg0: Internal.WindowStateListener_): void;
        getIconImages(): Internal.List<Internal.Image>;
        getFocusableWindowState(): boolean;
        isDoubleBuffered(): boolean;
        getColorModel(): Internal.ColorModel;
        getPropertyChangeListeners(arg0: string): Internal.PropertyChangeListener[];
        getPropertyChangeListeners(): Internal.PropertyChangeListener[];
        isValid(): boolean;
        getInsets(): Internal.Insets;
        getFocusTraversalKeysEnabled(): boolean;
        hide(): void;
        getPreferredSize(): Internal.Dimension;
        disable(): void;
        equals(arg0: any): boolean;
        prepareImage(arg0: Internal.Image_, arg1: Internal.ImageObserver_): boolean;
        prepareImage(arg0: Internal.Image_, arg1: number, arg2: number, arg3: Internal.ImageObserver_): boolean;
        isFocusableWindow(): boolean;
        isFocusable(): boolean;
        setLocationRelativeTo(arg0: java_.awt.Component_): void;
        getClass(): Internal.Class<any>;
        insets(): Internal.Insets;
        setIconImage(arg0: Internal.Image_): void;
        setMixingCutoutShape(arg0: Internal.Shape_): void;
        isActive(): boolean;
        mouseExit(arg0: java_.awt.Event_, arg1: number, arg2: number): boolean;
        getHierarchyListeners(): Internal.HierarchyListener[];
        getOpacity(): number;
        isShowing(): boolean;
        mouseEnter(arg0: java_.awt.Event_, arg1: number, arg2: number): boolean;
        mouseDrag(arg0: java_.awt.Event_, arg1: number, arg2: number): boolean;
        preferredSize(): Internal.Dimension;
        getMouseListeners(): Internal.MouseListener[];
        setFont(arg0: Internal.Font_): void;
        setAutoRequestFocus(arg0: boolean): void;
        toFront(): void;
        deliverEvent(arg0: java_.awt.Event_): void;
        getForeground(): java_.awt.Color;
        isAncestorOf(arg0: java_.awt.Component_): boolean;
        getComponentCount(): number;
        getFont(): Internal.Font;
        setCursor(arg0: Internal.Cursor_): void;
        dispose(): void;
        isDisplayable(): boolean;
        getGraphicsConfiguration(): Internal.GraphicsConfiguration;
        getComponent(arg0: number): java_.awt.Component;
        setLocale(arg0: Internal.Locale_): void;
        removeComponentListener(arg0: Internal.ComponentListener_): void;
        requestFocus(): void;
        requestFocus(arg0: Internal.FocusEvent$Cause_): void;
        locate(arg0: number, arg1: number): java_.awt.Component;
        addFocusListener(arg0: Internal.FocusListener_): void;
        getComponentAt(arg0: Internal.Point_): java_.awt.Component;
        getComponentAt(arg0: number, arg1: number): java_.awt.Component;
        isAlwaysOnTop(): boolean;
        isFocusCycleRoot(): boolean;
        isFocusCycleRoot(arg0: Internal.Container_): boolean;
        setFocusTraversalKeysEnabled(arg0: boolean): void;
        getComponentZOrder(arg0: java_.awt.Component_): number;
        setBackground(arg0: java_.awt.Color_): void;
        printAll(arg0: Internal.Graphics_): void;
        getToolkit(): Internal.Toolkit;
        transferFocusUpCycle(): void;
        isFontSet(): boolean;
        setSize(arg0: number, arg1: number): void;
        setSize(arg0: Internal.Dimension_): void;
        isFocusTraversalPolicyProvider(): boolean;
        setLocation(arg0: Internal.Point_): void;
        setLocation(arg0: number, arg1: number): void;
        getGraphics(): Internal.Graphics;
        removeFocusListener(arg0: Internal.FocusListener_): void;
        setIgnoreRepaint(arg0: boolean): void;
        transferFocusBackward(): void;
        getOwnedWindows(): java_.awt.Window[];
        move(arg0: number, arg1: number): void;
        transferFocusDownCycle(): void;
        applyResourceBundle(arg0: string): void;
        applyResourceBundle(arg0: Internal.ResourceBundle_): void;
        setForeground(arg0: java_.awt.Color_): void;
        invalidate(): void;
        getBufferStrategy(): Internal.BufferStrategy;
        getAccessibleContext(): Internal.AccessibleContext;
        setShape(arg0: Internal.Shape_): void;
        isFocusOwner(): boolean;
        getX(): number;
        getSize(arg0: Internal.Dimension_): Internal.Dimension;
        getSize(): Internal.Dimension;
        getY(): number;
        removeHierarchyBoundsListener(arg0: Internal.HierarchyBoundsListener_): void;
        getFocusTraversalPolicy(): Internal.FocusTraversalPolicy;
        setAlwaysOnTop(arg0: boolean): void;
        getFocusOwner(): java_.awt.Component;
        removeMouseListener(arg0: Internal.MouseListener_): void;
        getBackground(): java_.awt.Color;
        addMouseListener(arg0: Internal.MouseListener_): void;
        static readonly ABORT : 128;
        static readonly CENTER_ALIGNMENT : 0.5;
        static readonly PROPERTIES : 4;
        static readonly SOMEBITS : 8;
        static readonly BOTTOM_ALIGNMENT : 1.0;
        static readonly WIDTH : 1;
        static readonly HEIGHT : 2;
        static readonly FRAMEBITS : 16;
        static readonly LEFT_ALIGNMENT : 0.0;
        static readonly ALLBITS : 32;
        static readonly RIGHT_ALIGNMENT : 1.0;
        static readonly TOP_ALIGNMENT : 0.0;
        static readonly ERROR : 64;
        get parent(): Internal.Container;
        get warningString(): string;
        get inputContext(): Internal.InputContext;
        get dropTarget(): Internal.DropTarget;
        get modalExclusionType(): Internal.Dialog$ModalExclusionType;
        get graphicsConfiguration(): Internal.GraphicsConfiguration;
        get windowFocusListeners(): Internal.WindowFocusListener[];
        get foreground(): java_.awt.Color;
        get graphics(): Internal.Graphics;
        get type(): Internal.Window$Type;
        get baselineResizeBehavior(): Internal.Component$BaselineResizeBehavior;
        get foregroundSet(): boolean;
        get mouseWheelListeners(): Internal.MouseWheelListener[];
        get propertyChangeListeners(): Internal.PropertyChangeListener[];
        get doubleBuffered(): boolean;
        get height(): number;
        get ownedWindows(): java_.awt.Window[];
        get visible(): boolean;
        get shape(): Internal.Shape;
        get displayable(): boolean;
        get active(): boolean;
        get maximumSizeSet(): boolean;
        get autoRequestFocus(): boolean;
        get focusable(): boolean;
        get mousePosition(): Internal.Point;
        get focusTraversalPolicySet(): boolean;
        get focusTraversalKeysEnabled(): boolean;
        get focusOwner(): java_.awt.Component;
        get componentCount(): number;
        get iconImages(): Internal.List<Internal.Image>;
        get focusTraversalPolicy(): Internal.FocusTraversalPolicy;
        get toolkit(): Internal.Toolkit;
        get focusCycleRootAncestor(): Internal.Container;
        get focusCycleRoot(): boolean;
        get background(): java_.awt.Color;
        get name(): string;
        get focusTraversable(): boolean;
        get focused(): boolean;
        get focusableWindow(): boolean;
        get focusTraversalPolicyProvider(): boolean;
        get maximumSize(): Internal.Dimension;
        get containerListeners(): Internal.ContainerListener[];
        get alwaysOnTopSupported(): boolean;
        get hierarchyListeners(): Internal.HierarchyListener[];
        get minimumSizeSet(): boolean;
        get cursor(): Internal.Cursor;
        get accessibleContext(): Internal.AccessibleContext;
        get alignmentX(): number;
        get alignmentY(): number;
        get components(): java_.awt.Component[];
        get mostRecentFocusOwner(): java_.awt.Component;
        get componentOrientation(): Internal.ComponentOrientation;
        get alwaysOnTop(): boolean;
        get locale(): Internal.Locale;
        get ignoreRepaint(): boolean;
        get ownerlessWindows(): java_.awt.Window[];
        get enabled(): boolean;
        get lightweight(): boolean;
        get valid(): boolean;
        get componentListeners(): Internal.ComponentListener[];
        get focusableWindowState(): boolean;
        get locationOnScreen(): Internal.Point;
        get cursorSet(): boolean;
        get locationByPlatform(): boolean;
        get colorModel(): Internal.ColorModel;
        get windowStateListeners(): Internal.WindowStateListener[];
        get class(): Internal.Class<any>;
        get bufferStrategy(): Internal.BufferStrategy;
        get keyListeners(): Internal.KeyListener[];
        get owner(): java_.awt.Window;
        get inputMethodListeners(): Internal.InputMethodListener[];
        get opaque(): boolean;
        get validateRoot(): boolean;
        get mouseListeners(): Internal.MouseListener[];
        get inputMethodRequests(): Internal.InputMethodRequests;
        get hierarchyBoundsListeners(): Internal.HierarchyBoundsListener[];
        get preferredSizeSet(): boolean;
        get windows(): java_.awt.Window[];
        get windowListeners(): Internal.WindowListener[];
        get treeLock(): any;
        get focusListeners(): Internal.FocusListener[];
        get backgroundSet(): boolean;
        get width(): number;
        get x(): number;
        get y(): number;
        get fontSet(): boolean;
        get opacity(): number;
        get showing(): boolean;
        get mouseMotionListeners(): Internal.MouseMotionListener[];
        get font(): Internal.Font;
        set cursor(arg0: Internal.Cursor_);
        set iconImage(arg0: Internal.Image_);
        set locationRelativeTo(arg0: java_.awt.Component_);
        set alwaysOnTop(arg0: boolean);
        set componentOrientation(arg0: Internal.ComponentOrientation_);
        set dropTarget(arg0: Internal.DropTarget_);
        set modalExclusionType(arg0: Internal.Dialog$ModalExclusionType_);
        set foreground(arg0: java_.awt.Color_);
        set locale(arg0: Internal.Locale_);
        set type(arg0: Internal.Window$Type_);
        set ignoreRepaint(arg0: boolean);
        set enabled(arg0: boolean);
        set focusableWindowState(arg0: boolean);
        set locationByPlatform(arg0: boolean);
        set visible(arg0: boolean);
        set shape(arg0: Internal.Shape_);
        set autoRequestFocus(arg0: boolean);
        set focusable(arg0: boolean);
        set focusTraversalKeysEnabled(arg0: boolean);
        set mixingCutoutShape(arg0: Internal.Shape_);
        set focusTraversalPolicy(arg0: Internal.FocusTraversalPolicy_);
        set iconImages(arg0: Internal.List_<Internal.Image_>);
        set background(arg0: java_.awt.Color_);
        set focusCycleRoot(arg0: boolean);
        set focusTraversalPolicyProvider(arg0: boolean);
        set name(arg0: string);
        set maximumSize(arg0: Internal.Dimension_);
        set opacity(arg0: number);
        set font(arg0: Internal.Font_);
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    type Window_ = Window;
}
declare namespace net.minecraft.world {
    interface Container extends Internal.Clearable {
    }
    type Container_ = Container;
}
declare namespace net.minecraft.nbt {
    interface Tag {
        toString(): string;
    }
    type Tag_ = Tag;
}
declare namespace snownee.kiwi.mixin {
    interface RecipeManagerAccess {
        getContext(): Internal.ICondition$IContext;
    }
    type RecipeManagerAccess_ = RecipeManagerAccess;
}
declare namespace io.netty.channel {
    interface Channel extends Internal.AttributeMap, Internal.ChannelOutboundInvoker, Internal.Comparable<io.netty.channel.Channel> {
        disconnect(): Internal.ChannelFuture;
        disconnect(arg0: Internal.ChannelPromise_): Internal.ChannelFuture;
        parent(): io.netty.channel.Channel;
        metadata(): Internal.ChannelMetadata;
        newProgressivePromise(): Internal.ChannelProgressivePromise;
        eventLoop(): Internal.EventLoop;
        compareTo(arg0: io.netty.channel.Channel_): number;
        isWritable(): boolean;
        isActive(): boolean;
        unsafe(): Internal.Channel$Unsafe;
        writeAndFlush(arg0: any, arg1: Internal.ChannelPromise_): Internal.ChannelFuture;
        writeAndFlush(arg0: any): Internal.ChannelFuture;
        bind(arg0: Internal.SocketAddress_): Internal.ChannelFuture;
        bind(arg0: Internal.SocketAddress_, arg1: Internal.ChannelPromise_): Internal.ChannelFuture;
        flush(): io.netty.channel.Channel;
        flush(): Internal.ChannelOutboundInvoker;
        bytesBeforeWritable(): number;
        id(): Internal.ChannelId;
        attr<T_>(arg0: Internal.AttributeKey_<T_>): io.netty.util.Attribute<T_>;
        close(arg0: Internal.ChannelPromise_): Internal.ChannelFuture;
        close(): Internal.ChannelFuture;
        write(arg0: any): Internal.ChannelFuture;
        write(arg0: any, arg1: Internal.ChannelPromise_): Internal.ChannelFuture;
        connect(arg0: Internal.SocketAddress_, arg1: Internal.SocketAddress_, arg2: Internal.ChannelPromise_): Internal.ChannelFuture;
        connect(arg0: Internal.SocketAddress_, arg1: Internal.ChannelPromise_): Internal.ChannelFuture;
        connect(arg0: Internal.SocketAddress_): Internal.ChannelFuture;
        connect(arg0: Internal.SocketAddress_, arg1: Internal.SocketAddress_): Internal.ChannelFuture;
        remoteAddress(): Internal.SocketAddress;
        newPromise(): Internal.ChannelPromise;
        read(): io.netty.channel.Channel;
        read(): Internal.ChannelOutboundInvoker;
        bytesBeforeUnwritable(): number;
        deregister(arg0: Internal.ChannelPromise_): Internal.ChannelFuture;
        deregister(): Internal.ChannelFuture;
        newFailedFuture(arg0: Internal.Throwable_): Internal.ChannelFuture;
        hasAttr<T_>(arg0: Internal.AttributeKey_<T_>): boolean;
        pipeline(): Internal.ChannelPipeline;
        isOpen(): boolean;
        voidPromise(): Internal.ChannelPromise;
        newSucceededFuture(): Internal.ChannelFuture;
        closeFuture(): Internal.ChannelFuture;
        localAddress(): Internal.SocketAddress;
        isRegistered(): boolean;
        alloc(): Internal.ByteBufAllocator;
        config(): Internal.ChannelConfig;
    }
    type Channel_ = Channel;
}
declare namespace net.minecraft.client.renderer.culling {
    class Frustum implements Internal.FrustumAdapter {
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        hashCode(): number;
        handler$zgo000$init(modelViewMatrix: Internal.Matrix4f_, projectionMatrix: Internal.Matrix4f_, ci: Internal.CallbackInfo_): void;
        notifyAll(): void;
        equals(arg0: any): boolean;
        toString(): string;
        notify(): void;
        sodium$createFrustum(): Internal.Frustum;
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    type Frustum_ = Frustum;
}
declare namespace java_.lang.reflect {
    interface Type {
        getTypeName(): string;
    }
    type Type_ = Type;
}
declare namespace net.minecraft.world.level.block.state.properties {
    abstract class Property <T> {
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        hashCode(): number;
        notifyAll(): void;
        equals(arg0: any): boolean;
        toString(): string;
        notify(): void;
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    type Property_<T> = Property<T>;
}
declare namespace dev.ftb.mods.ftblibrary.ui {
    class Widget implements Internal.IScreenWrapper {
        static isMouseButtonDown(button: Internal.MouseButton_): boolean;
        closeGui(openPrevScreen: boolean): void;
        closeGui(): void;
        getClass(): Internal.Class<any>;
        setY(v: number): void;
        collidesWith(x: number, y: number, w: number, h: number): boolean;
        setX(v: number): void;
        shouldDraw(): boolean;
        acceptGhostIngredient(ingredient: any): void;
        isGhostIngredientTarget(ingredient: any): boolean;
        run(): void;
        getGui(): Internal.BaseScreen;
        mousePressed(button: Internal.MouseButton_): boolean;
        setPos(x: number, y: number): void;
        getTitle(): Internal.Component;
        static getClipboardString(): string;
        static isCtrlKeyDown(): boolean;
        updateMouseOver(mouseX: number, mouseY: number): void;
        getScreen(): Internal.Window;
        getMouseY(): number;
        onClosed(): void;
        isMouseOver(): boolean;
        keyPressed(key: dev.ftb.mods.ftblibrary.ui.input.Key_): boolean;
        getMouseX(): number;
        openGui(): void;
        setPosAndSize(x: number, y: number, w: number, h: number): dev.ftb.mods.ftblibrary.ui.Widget;
        tick(): void;
        setHeight(v: number): void;
        addMouseOverText(list: Internal.TooltipList_): void;
        playClickSound(): void;
        handleClick(click: string): boolean;
        handleClick(scheme: string, path: string): boolean;
        isEnabled(): boolean;
        charTyped(c: string, modifiers: Internal.KeyModifiers_): boolean;
        mouseDoubleClicked(button: Internal.MouseButton_): boolean;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        mouseScrolled(scroll: number): boolean;
        notifyAll(): void;
        shouldAddMouseOverText(): boolean;
        openAfter(runnable: Internal.Runnable_): Internal.Runnable;
        closeContextMenu(): void;
        notify(): void;
        mouseReleased(button: Internal.MouseButton_): void;
        setSize(w: number, h: number): void;
        hashCode(): number;
        getPartialTicks(): number;
        openGuiLater(): void;
        static isKeyDown(key: number): boolean;
        keyReleased(key: dev.ftb.mods.ftblibrary.ui.input.Key_): void;
        static setClipboardString(string: string): void;
        static isShiftKeyDown(): boolean;
        getCursor(): Internal.CursorType;
        getWidgetType(): Internal.WidgetType;
        draw(matrixStack: Internal.PoseStack_, theme: Internal.Theme_, x: number, y: number, w: number, h: number): void;
        checkMouseOver(mouseX: number, mouseY: number): boolean;
        setWidth(v: number): void;
        openContextMenu(panel: Internal.Panel_): void;
        getX(): number;
        getY(): number;
        equals(arg0: any): boolean;
        toString(): string;
        getIngredientUnderMouse(): any;
        posX : number;
        parent : Internal.Panel;
        posY : number;
        width : number;
        height : number;
        get mouseX(): number;
        get cursor(): Internal.CursorType;
        get ingredientUnderMouse(): any;
        get clipboardString(): string;
        get mouseY(): number;
        get shiftKeyDown(): boolean;
        get mouseOver(): boolean;
        get screen(): Internal.Window;
        get title(): Internal.Component;
        get enabled(): boolean;
        get widgetType(): Internal.WidgetType;
        get ctrlKeyDown(): boolean;
        get x(): number;
        get y(): number;
        get gui(): Internal.BaseScreen;
        get class(): Internal.Class<any>;
        get partialTicks(): number;
        set clipboardString(string: string);
        set x(v: number);
        set y(v: number);
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    type Widget_ = Widget;
}
declare namespace com.lowdragmc.lowdraglib.gui.widget {
    class Widget {
        getClass(): Internal.Class<any>;
        mouseWheelMove(arg0: number, arg1: number, arg2: number): boolean;
        mouseDragged(arg0: number, arg1: number, arg2: number, arg3: number, arg4: number): boolean;
        drawInForeground(arg0: Internal.PoseStack_, arg1: number, arg2: number, arg3: number): void;
        readUpdateInfo(arg0: number, arg1: Internal.FriendlyByteBuf_): void;
        toRectangleBox(): Internal.Rect2i;
        isActive(): boolean;
        getGui(): Internal.ModularUI;
        updateScreen(): void;
        mouseMoved(arg0: number, arg1: number): void;
        setVisible(arg0: boolean): void;
        static isMouseOver(arg0: number, arg1: number, arg2: number, arg3: number, arg4: number, arg5: number): boolean;
        addSelfPosition(arg0: number, arg1: number): Internal.Position;
        isParent(arg0: Internal.WidgetGroup_): boolean;
        keyPressed(arg0: number, arg1: number, arg2: number): boolean;
        setHoverTexture(arg0: Internal.IGuiTexture_[]): com.lowdragmc.lowdraglib.gui.widget.Widget;
        isMouseOverElement(arg0: number, arg1: number): boolean;
        isVisible(): boolean;
        getSelfPosition(): Internal.Position;
        setClientSideWidget(): com.lowdragmc.lowdraglib.gui.widget.Widget;
        handleClientAction(arg0: number, arg1: Internal.FriendlyByteBuf_): void;
        mouseClicked(arg0: number, arg1: number, arg2: number): boolean;
        charTyped(arg0: string, arg1: number): boolean;
        readInitialData(arg0: Internal.FriendlyByteBuf_): void;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        notifyAll(): void;
        isInitialized(): boolean;
        setBackground(arg0: Internal.IGuiTexture_[]): com.lowdragmc.lowdraglib.gui.widget.Widget;
        notify(): void;
        mouseReleased(arg0: number, arg1: number, arg2: number): boolean;
        setSize(arg0: Internal.Size_): void;
        initWidget(): void;
        hashCode(): number;
        getNativeWidgets(): Internal.List<Internal.SlotWidget>;
        keyReleased(arg0: number, arg1: number, arg2: number): boolean;
        detectAndSendChanges(): void;
        getParent(): Internal.WidgetGroup;
        setSelfPosition(arg0: Internal.Position_): void;
        isRemote(): boolean;
        setFocus(arg0: boolean): void;
        setUiAccess(arg0: Internal.WidgetUIAccess_): void;
        drawInBackground(arg0: Internal.PoseStack_, arg1: number, arg2: number, arg3: number): void;
        getParentPosition(): Internal.Position;
        getSize(): Internal.Size;
        setActive(arg0: boolean): void;
        getPosition(): Internal.Position;
        isFocus(): boolean;
        equals(arg0: any): boolean;
        onFocusChanged(arg0: com.lowdragmc.lowdraglib.gui.widget.Widget_, arg1: com.lowdragmc.lowdraglib.gui.widget.Widget_): void;
        setHoverTooltips(arg0: Internal.List_<Internal.Component_>): com.lowdragmc.lowdraglib.gui.widget.Widget;
        setHoverTooltips(arg0: string[]): com.lowdragmc.lowdraglib.gui.widget.Widget;
        setHoverTooltips(arg0: Internal.Component_[]): com.lowdragmc.lowdraglib.gui.widget.Widget;
        writeInitialData(arg0: Internal.FriendlyByteBuf_): void;
        toString(): string;
        setParentPosition(arg0: Internal.Position_): void;
        setGui(arg0: Internal.ModularUI_): void;
        get selfPosition(): Internal.Position;
        get parent(): Internal.WidgetGroup;
        get visible(): boolean;
        get nativeWidgets(): Internal.List<Internal.SlotWidget>;
        get active(): boolean;
        get focus(): boolean;
        get remote(): boolean;
        get parentPosition(): Internal.Position;
        get size(): Internal.Size;
        get initialized(): boolean;
        get gui(): Internal.ModularUI;
        get position(): Internal.Position;
        get class(): Internal.Class<any>;
        set selfPosition(arg0: Internal.Position_);
        set parentPosition(arg0: Internal.Position_);
        set visible(arg0: boolean);
        set size(arg0: Internal.Size_);
        set hoverTexture(arg0: Internal.IGuiTexture_[]);
        set background(arg0: Internal.IGuiTexture_[]);
        set active(arg0: boolean);
        set focus(arg0: boolean);
        set gui(arg0: Internal.ModularUI_);
        set hoverTooltips(arg0: Internal.List_<Internal.Component_>);
        set uiAccess(arg0: Internal.WidgetUIAccess_);
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    type Widget_ = Widget;
}
declare namespace com.lowdragmc.multiblocked.api.recipe {
    class Recipe {
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        checkConditions(arg0: Internal.RecipeLogic_): boolean;
        matchTickRecipe(arg0: Internal.ICapabilityProxyHolder_): boolean;
        notifyAll(): void;
        handleRecipe(arg0: Internal.IO_, arg1: Internal.ICapabilityProxyHolder_, arg2: Internal.ImmutableMap_<Internal.MultiblockCapability_<any>, Internal.ImmutableList_<Internal.Content_>>): boolean;
        notify(): void;
        matchRecipe(arg0: Internal.ICapabilityProxyHolder_): boolean;
        getInputContents(arg0: Internal.MultiblockCapability_<any>): Internal.List<Internal.Content>;
        hashCode(): number;
        equals(arg0: any): boolean;
        handleTickRecipeIO(arg0: Internal.IO_, arg1: Internal.ICapabilityProxyHolder_): boolean;
        toString(): string;
        handleRecipeIO(arg0: Internal.IO_, arg1: Internal.ICapabilityProxyHolder_): boolean;
        postWorking(arg0: Internal.ICapabilityProxyHolder_): void;
        preWorking(arg0: Internal.ICapabilityProxyHolder_): void;
        hasTick(): boolean;
        getData(): Internal.CompoundTag;
        getOutputContents(arg0: Internal.MultiblockCapability_<any>): Internal.List<Internal.Content>;
        readonly outputs : Internal.ImmutableMap<Internal.MultiblockCapability<any>, Internal.ImmutableList<Internal.Content>>;
        readonly duration : number;
        readonly uid : string;
        readonly data : Internal.CompoundTag;
        readonly inputs : Internal.ImmutableMap<Internal.MultiblockCapability<any>, Internal.ImmutableList<Internal.Content>>;
        readonly tickInputs : Internal.ImmutableMap<Internal.MultiblockCapability<any>, Internal.ImmutableList<Internal.Content>>;
        readonly tickOutputs : Internal.ImmutableMap<Internal.MultiblockCapability<any>, Internal.ImmutableList<Internal.Content>>;
        readonly text : Internal.Component;
        readonly conditions : Internal.ImmutableList<Internal.RecipeCondition>;
        static readonly EMPTY : {};
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    type Recipe_ = Recipe;
}
declare namespace mezz.jei.api.recipe {
    class RecipeType <T> {
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        getUid(): ResourceLocation;
        hashCode(): number;
        notifyAll(): void;
        equals(arg0: any): boolean;
        static create<T>(arg0: string, arg1: string, arg2: Internal.Class_<T>): mezz.jei.api.recipe.RecipeType<T>;
        toString(): string;
        getRecipeClass(): Internal.Class<T>;
        notify(): void;
        get uid(): ResourceLocation;
        get recipeClass(): Internal.Class<T>;
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    type RecipeType_<T> = RecipeType<T>;
}
declare namespace io.netty.util {
    interface Attribute <T> {
        set(arg0: T): void;
        compareAndSet(arg0: T, arg1: T): boolean;
        setIfAbsent(arg0: T): T;
        get(): T;
        getAndSet(arg0: T): T;
        getAndRemove(): T;
        key(): Internal.AttributeKey<T>;
        remove(): void;
    }
    type Attribute_<T> = Attribute<T>;
}
declare namespace net.minecraftforge.fluids {
    class FluidStack {
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        getRawFluid(): Internal.Fluid;
        notifyAll(): void;
        getOrCreateChildTag(arg0: string): Internal.CompoundTag;
        notify(): void;
        getChildTag(arg0: string): Internal.CompoundTag;
        containsFluid(arg0: net.minecraftforge.fluids.FluidStack_): boolean;
        static readFromPacket(arg0: Internal.FriendlyByteBuf_): net.minecraftforge.fluids.FluidStack;
        hashCode(): number;
        setTag(arg0: Internal.CompoundTag_): void;
        copy(): net.minecraftforge.fluids.FluidStack;
        setAmount(arg0: number): void;
        isFluidEqual(arg0: net.minecraftforge.fluids.FluidStack_): boolean;
        isFluidEqual(arg0: Internal.ItemStack_): boolean;
        writeToNBT(arg0: Internal.CompoundTag_): Internal.CompoundTag;
        getAmount(): number;
        isFluidStackIdentical(arg0: net.minecraftforge.fluids.FluidStack_): boolean;
        removeChildTag(arg0: string): void;
        grow(arg0: number): void;
        hasTag(): boolean;
        static loadFluidStackFromNBT(arg0: Internal.CompoundTag_): net.minecraftforge.fluids.FluidStack;
        shrink(arg0: number): void;
        getTranslationKey(): string;
        isEmpty(): boolean;
        getTag(): Internal.CompoundTag;
        getOrCreateTag(): Internal.CompoundTag;
        writeToPacket(arg0: Internal.FriendlyByteBuf_): void;
        getDisplayName(): Internal.Component;
        equals(arg0: any): boolean;
        getFluid(): Internal.Fluid;
        toString(): string;
        static areFluidStackTagsEqual(arg0: net.minecraftforge.fluids.FluidStack_, arg1: net.minecraftforge.fluids.FluidStack_): boolean;
        static readonly CODEC : Internal.Codec<net.minecraftforge.fluids.FluidStack>;
        static readonly EMPTY : net.minecraftforge.fluids.FluidStack;
        get orCreateTag(): Internal.CompoundTag;
        get rawFluid(): Internal.Fluid;
        get amount(): number;
        get translationKey(): string;
        get displayName(): Internal.Component;
        get fluid(): Internal.Fluid;
        get tag(): Internal.CompoundTag;
        get class(): Internal.Class<any>;
        get empty(): boolean;
        set amount(arg0: number);
        set tag(arg0: Internal.CompoundTag_);
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    type FluidStack_ = FluidStack;
}
declare namespace dev.ftb.mods.ftblibrary.ui.input {
    class Key {
        getClass(): Internal.Class<any>;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        deselectAll(): boolean;
        cut(): boolean;
        notifyAll(): void;
        is(k: number): boolean;
        paste(): boolean;
        notify(): void;
        selectAll(): boolean;
        getInputMapping(): Internal.InputConstants$Key;
        backspace(): boolean;
        esc(): boolean;
        hashCode(): number;
        equals(arg0: any): boolean;
        toString(): string;
        enter(): boolean;
        copy(): boolean;
        escOrInventory(): boolean;
        readonly keyCode : number;
        readonly modifiers : Internal.KeyModifiers;
        readonly scanCode : number;
        get inputMapping(): Internal.InputConstants$Key;
        get class(): Internal.Class<any>;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    type Key_ = Key;
}
declare namespace org.apache.commons.lang3.tuple {
    abstract class Pair <L, R> implements Internal.Map$Entry<L, R>, Internal.Comparable<org.apache.commons.lang3.tuple.Pair<L, R>>, Internal.Serializable {
        getClass(): Internal.Class<any>;
        getKey(): L;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        notifyAll(): void;
        compareTo(arg0: org.apache.commons.lang3.tuple.Pair_<L, R>): number;
        notify(): void;
        getValue(): R;
        getRight(): R;
        hashCode(): number;
        setValue(arg0: R): R;
        static of<L_, R_>(arg0: Internal.Map$Entry_<L_, R_>): org.apache.commons.lang3.tuple.Pair<L_, R_>;
        static of<L_, R_>(arg0: L_, arg1: R_): org.apache.commons.lang3.tuple.Pair<L_, R_>;
        equals(arg0: any): boolean;
        toString(arg0: string): string;
        toString(): string;
        static emptyArray<L_, R_>(): org.apache.commons.lang3.tuple.Pair<L_, R_>[];
        getLeft(): L;
        static readonly EMPTY_ARRAY : org.apache.commons.lang3.tuple.Pair<any, any>[];
        get left(): L;
        get right(): R;
        get class(): Internal.Class<any>;
        get value(): R;
        get key(): L;
        set value(arg0: R);
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    type Pair_<L, R> = Pair<L, R>;
}
declare namespace dev.latvian.mods.rhino.util.unit {
    abstract class Unit {
        getClass(): Internal.Class<any>;
        sub(with_: dev.latvian.mods.rhino.util.unit.Unit_): dev.latvian.mods.rhino.util.unit.Unit;
        wait(arg0: number, arg1: number): void;
        wait(): void;
        wait(arg0: number): void;
        mod(with_: dev.latvian.mods.rhino.util.unit.Unit_): dev.latvian.mods.rhino.util.unit.Unit;
        mul(with_: dev.latvian.mods.rhino.util.unit.Unit_): dev.latvian.mods.rhino.util.unit.Unit;
        log(): dev.latvian.mods.rhino.util.unit.Unit;
        log1p(): dev.latvian.mods.rhino.util.unit.Unit;
        log10(): dev.latvian.mods.rhino.util.unit.Unit;
        cos(): dev.latvian.mods.rhino.util.unit.Unit;
        notifyAll(): void;
        deg(): dev.latvian.mods.rhino.util.unit.Unit;
        lt(with_: dev.latvian.mods.rhino.util.unit.Unit_): dev.latvian.mods.rhino.util.unit.Unit;
        atan(): dev.latvian.mods.rhino.util.unit.Unit;
        notify(): void;
        getAsInt(): number;
        div(with_: dev.latvian.mods.rhino.util.unit.Unit_): dev.latvian.mods.rhino.util.unit.Unit;
        neg(): dev.latvian.mods.rhino.util.unit.Unit;
        not(): dev.latvian.mods.rhino.util.unit.Unit;
        shiftLeft(with_: dev.latvian.mods.rhino.util.unit.Unit_): dev.latvian.mods.rhino.util.unit.Unit;
        min(with_: dev.latvian.mods.rhino.util.unit.Unit_): dev.latvian.mods.rhino.util.unit.Unit;
        rad(): dev.latvian.mods.rhino.util.unit.Unit;
        sqrt(): dev.latvian.mods.rhino.util.unit.Unit;
        hashCode(): number;
        and(with_: dev.latvian.mods.rhino.util.unit.Unit_): dev.latvian.mods.rhino.util.unit.Unit;
        get(): number;
        gte(with_: dev.latvian.mods.rhino.util.unit.Unit_): dev.latvian.mods.rhino.util.unit.Unit;
        pow(with_: dev.latvian.mods.rhino.util.unit.Unit_): dev.latvian.mods.rhino.util.unit.Unit;
        sin(): dev.latvian.mods.rhino.util.unit.Unit;
        xor(with_: dev.latvian.mods.rhino.util.unit.Unit_): dev.latvian.mods.rhino.util.unit.Unit;
        neq(with_: dev.latvian.mods.rhino.util.unit.Unit_): dev.latvian.mods.rhino.util.unit.Unit;
        lte(with_: dev.latvian.mods.rhino.util.unit.Unit_): dev.latvian.mods.rhino.util.unit.Unit;
        floor(): dev.latvian.mods.rhino.util.unit.Unit;
        isFixed(): boolean;
        sq(): dev.latvian.mods.rhino.util.unit.Unit;
        atan2(with_: dev.latvian.mods.rhino.util.unit.Unit_): dev.latvian.mods.rhino.util.unit.Unit;
        tan(): dev.latvian.mods.rhino.util.unit.Unit;
        add(with_: dev.latvian.mods.rhino.util.unit.Unit_): dev.latvian.mods.rhino.util.unit.Unit;
        or(with_: dev.latvian.mods.rhino.util.unit.Unit_): dev.latvian.mods.rhino.util.unit.Unit;
        max(with_: dev.latvian.mods.rhino.util.unit.Unit_): dev.latvian.mods.rhino.util.unit.Unit;
        toBool(): dev.latvian.mods.rhino.util.unit.Unit;
        ceil(): dev.latvian.mods.rhino.util.unit.Unit;
        eq(with_: dev.latvian.mods.rhino.util.unit.Unit_): dev.latvian.mods.rhino.util.unit.Unit;
        gt(with_: dev.latvian.mods.rhino.util.unit.Unit_): dev.latvian.mods.rhino.util.unit.Unit;
        shiftRight(with_: dev.latvian.mods.rhino.util.unit.Unit_): dev.latvian.mods.rhino.util.unit.Unit;
        abs(): dev.latvian.mods.rhino.util.unit.Unit;
        getAsBoolean(): boolean;
        equals(arg0: any): boolean;
        toString(): string;
        append(arg0: Internal.StringBuilder_): void;
        get asInt(): number;
        get fixed(): boolean;
        get class(): Internal.Class<any>;
        get asBoolean(): boolean;
        /**
        * Internal constructor, this means that it's not valid and you will get an error if you use it.
        */
        protected constructor();
    }
    type Unit_ = Unit;
}
declare namespace net.coderbot.iris.mixin.rendertype {
    interface RenderTypeAccessor {
        shouldSortOnUpload(): boolean;
    }
    type RenderTypeAccessor_ = RenderTypeAccessor;
    interface RenderStateShardAccessor {
        getName(): string;
    }
    type RenderStateShardAccessor_ = RenderStateShardAccessor;
}
declare namespace net.darkhax.bookshelf.mixin.entity {
    interface AccessorLivingEntity {
        bookshelf$getDrinkingSound(arg0: Internal.ItemStack_): Internal.SoundEvent;
        bookshelf$getHurtSound(arg0: Internal.DamageSource_): Internal.SoundEvent;
        bookshelf$makePoofParticles(): void;
        bookshelf$getDeathSound(): Internal.SoundEvent;
        bookshelf$getFallDamageSound(arg0: number): Internal.SoundEvent;
    }
    type AccessorLivingEntity_ = AccessorLivingEntity;
}
declare namespace java_.util.concurrent {
    interface Callable <V> {
        call(): V;
    }
    type Callable_<V> = (() => V) | Callable<V>;
}
declare namespace it.unimi.dsi.fastutil.longs {
    interface LongPredicate extends Internal.Predicate<number>, Internal.LongPredicate {
        or(arg0: Internal.Predicate_<number>): Internal.Predicate<number>;
        or(arg0: Internal.LongPredicate_): it.unimi.dsi.fastutil.longs.LongPredicate;
        or(arg0: it.unimi.dsi.fastutil.longs.LongPredicate_): it.unimi.dsi.fastutil.longs.LongPredicate;
        test(arg0: number): boolean;
        and(arg0: Internal.LongPredicate_): it.unimi.dsi.fastutil.longs.LongPredicate;
        and(arg0: it.unimi.dsi.fastutil.longs.LongPredicate_): it.unimi.dsi.fastutil.longs.LongPredicate;
        and(arg0: Internal.Predicate_<number>): Internal.Predicate<number>;
        negate(): it.unimi.dsi.fastutil.longs.LongPredicate;
    }
    type LongPredicate_ = ((arg0: number) => boolean) | LongPredicate;
}
declare namespace dev.latvian.mods.rhino {
    interface Function extends Internal.Scriptable, Internal.Callable {
        enumerationIteratorNext(cx: Internal.Context_, currentId: Internal.Consumer_<any>): boolean;
        hasInstance(arg0: Internal.Scriptable_): boolean;
        setParentScope(arg0: Internal.Scriptable_): void;
        getIds(): any[];
        construct(arg0: Internal.Context_, arg1: Internal.Scriptable_, arg2: any[]): Internal.Scriptable;
        getAllIds(): any[];
        delete(arg0: string): void;
        delete(arg0: number): void;
        put(arg0: number, arg1: Internal.Scriptable_, arg2: any): void;
        put(arg0: string, arg1: Internal.Scriptable_, arg2: any): void;
        getDefaultValue(arg0: Internal.Class_<any>): any;
        setPrototype(arg0: Internal.Scriptable_): void;
        getPrototype(): Internal.Scriptable;
        call(arg0: Internal.Context_, arg1: Internal.Scriptable_, arg2: Internal.Scriptable_, arg3: any[]): any;
        get(arg0: number, arg1: Internal.Scriptable_): any;
        get(arg0: string, arg1: Internal.Scriptable_): any;
        enumerationIteratorHasNext(cx: Internal.Context_, currentId: Internal.Consumer_<any>): boolean;
        has(arg0: number, arg1: Internal.Scriptable_): boolean;
        has(arg0: string, arg1: Internal.Scriptable_): boolean;
        getClassName(): string;
        getParentScope(): Internal.Scriptable;
    }
    type Function_ = Function;
}
declare namespace net.minecraft.core {
    interface Position {
    }
    type Position_ = Position;
}
declare namespace vectorwing.farmersdelight.common.mixin.accessor {
    interface RecipeManagerAccessor {
        getRecipeMap<C, T>(arg0: Internal.RecipeType_<T>): Internal.Map<ResourceLocation, Internal.Recipe<C>>;
    }
    type RecipeManagerAccessor_ = RecipeManagerAccessor;
}
declare namespace it.unimi.dsi.fastutil.doubles {
    interface DoubleBinaryOperator extends Internal.BinaryOperator<number>, Internal.DoubleBinaryOperator {
        applyAsDouble(arg0: number, arg1: number): number;
        apply(arg0: number, arg1: number): number;
        andThen<V_>(arg0: java_.util.function_.Function_<number, V_>): Internal.BiFunction<number, number, V_>;
    }
    type DoubleBinaryOperator_ = ((arg0: number, arg1: number) => number) | DoubleBinaryOperator;
}
declare namespace Document {
    class ArsNouveauRecipes {
        enchanting_apparatus(output: Internal.ItemStackJS_, reagent: Internal.IngredientJS_, inputs: Internal.IngredientJS_[]): Internal.ArsNouveauEnchantingApparatusRecipeJS;
        enchantment(enchantment: string, level: number, inputs: Internal.IngredientJS_[]): Internal.ArsNouveauEnchantmentRecipeJS;
        enchantment(enchantment: string, level: number, inputs: Internal.IngredientJS_[], mana: number): Internal.ArsNouveauEnchantmentRecipeJS;
        glyph_recipe(output: Internal.ItemStackJS_, input: Internal.ItemStackJS_, tier: string): Internal.ArsNouveauEnchantmentRecipeJS;
    }
    class RecipeHolder {
        /**
        * All recipes from Minecraft.
        */
        readonly minecraft: Document.MinecraftRecipes;
        readonly ars_nouveau: Document.ArsNouveauRecipes;
        readonly botania: Document.BotaniaRecipes;
        readonly cucumber: Document.CucumberRecipes;
    }
    class CucumberRecipes {
        shaped_no_mirror(output: Internal.ItemStackJS_, pattern: string[], items: Internal.Map_<string, Internal.IngredientJS_>): Internal.ShapedRecipeJS;
    }
    class BotaniaRecipes {
        runic_altar(output: Internal.ItemStackJS_, inputs: Internal.IngredientJS_[]): Internal.BotaniaRunicAltarRecipeJS;
        runic_altar(output: Internal.ItemStackJS_, inputs: Internal.IngredientJS_[], mana: number): Internal.BotaniaRunicAltarRecipeJS;
    }
    class MinecraftRecipes {
        /**
        * Adds a smelting recipe to Minecraft.
        *
        * This is used by Furnaces.
        */
        smelting(output: Internal.ItemStackJS_, input: Internal.IngredientJS_): Internal.CookingRecipeJS;
        /**
        * Adds a smelting recipe to Minecraft.
        *
        * This is used by Smokers.
        */
        smoking(output: Internal.ItemStackJS_, input: Internal.IngredientJS_): Internal.CookingRecipeJS;
        /**
        * Adds a smelting recipe to Minecraft.
        *
        * This is used by Blast Furnaces.
        */
        blasting(output: Internal.ItemStackJS_, input: Internal.IngredientJS_): Internal.CookingRecipeJS;
        /**
        * Adds a shaped crafting recipe.
        */
        crafting_shaped(output: Internal.ItemStackJS_, pattern: Internal.IngredientJS_[][]): Internal.ShapedRecipeJS;
        /**
        * Adds a shaped crafting recipe.
        */
        crafting_shaped(output: Internal.ItemStackJS_, pattern: string[], items: { [string]: Internal.IngredientJS_ }): Internal.ShapedRecipeJS;
        /**
        * Adds a shapeless crafting recipe.
        */
        crafting_shapeless(output: Internal.ItemStackJS_, inputs: Internal.IngredientJS_[]): Internal.ShapelessRecipeJS;
        /**
        * Adds a smelting recipe to Minecraft.
        *
        * This is used by Campfire.
        */
        campfire_cooking(output: Internal.ItemStackJS_, input: Internal.IngredientJS_): Internal.CookingRecipeJS;
        /**
        * Adds a stonecutting recipe.
        */
        stonecutting(output: Internal.ItemStackJS_, inputs: Internal.IngredientJS_): Internal.StonecuttingRecipeJS;
        /**
        * Adds a smithing recipe.
        */
        smithing(output: Internal.ItemStackJS_, base: Internal.IngredientJS_, addition: Internal.IngredientJS_): Internal.SmithingRecipeJS;
    }
}
declare namespace Type {
}
declare namespace TSDoc {
}
